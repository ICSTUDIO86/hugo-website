/*!
 * IC Studio è§†å¥å·¥å…· - ä¸“ä¸šçº§è§†å¥æ—‹å¾‹ç”Ÿæˆå™¨
 * Professional Music Sight-Reading Tool - Final Version
 * 
 * Copyright Â© 2026. All rights reserved. Igor Chen - icstudio.club
 * 
 * Author: Igor Chen
 * Website: https://icstudio.club
 * Email: icstudio@fastmail.com
 * 
 * Features:
 * - ä¸¥æ ¼éµå¾ªéŸ³ä¹ç†è®ºï¼Œä½¿ç”¨OSMDä¸“ä¸šæ¸²æŸ“
 * - ç»ä¸è°ƒç”¨VexFlow APIï¼Œå®Œå…¨åŸºäºæœ‰æ•ˆMusicXML
 * - ä¸“ä¸šçº§äº”çº¿è°±æ¸²æŸ“ä¸éŸ³ä¹ç†è®ºå·¥å…·
 * - Apple-inspired minimalist design
 * 
 * This software provides advanced sight-reading melody generation
 * with professional music theory compliance and modern UI design.
 */

// ====== å…¨å±€å˜é‡ ======
let osmd = null;
let melodyHistory = [];
let currentHistoryIndex = -1;
let currentDisplayedClef = null; // è·Ÿè¸ªå½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹çš„è°±å·
let lastRenderedMelodyData = null; // æœ€è¿‘ä¸€æ¬¡æ¸²æŸ“çš„æ—‹å¾‹æ•°æ®ï¼Œä¾›æ˜¾ç¤ºè¾…åŠ©è®°è°±ä½¿ç”¨

// ====== éŸ³é¢‘æ’­æ”¾ç³»ç»Ÿ ======
let audioContext = null;
let masterGain = null;
let lowPassFilter = null;
let isAudioInitialized = false;
const AUDIO_BOOST = 4;

/**
 * åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿï¼ŒåŒ…å«ä½é€šæ»¤æ³¢å™¨æ¥é™ä½é«˜é¢‘
 */
function initializeAudio() {
    if (isAudioInitialized) return;

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // åˆ›å»ºä¸»éŸ³é‡æ§åˆ¶
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.3 * AUDIO_BOOST; // è®¾ç½®åˆé€‚çš„éŸ³é‡

        // ğŸ”¥ åˆ›å»ºä½é€šæ»¤æ³¢å™¨æ¥é™ä½é«˜é¢‘ï¼Œè®©éŸ³è‰²æ›´æ¸©å’Œ
        lowPassFilter = audioContext.createBiquadFilter();
        lowPassFilter.type = 'lowpass';
        lowPassFilter.frequency.value = 2000; // æˆªæ­¢é¢‘ç‡2000Hzï¼Œè¿‡æ»¤æ‰åˆºè€³çš„é«˜é¢‘
        lowPassFilter.Q.value = 1; // æ»¤æ³¢å™¨è´¨é‡å› å­

        // è¿æ¥éŸ³é¢‘å¤„ç†é“¾ï¼šoscillator -> lowpass filter -> master gain -> destination
        lowPassFilter.connect(masterGain);
        masterGain.connect(audioContext.destination);

        isAudioInitialized = true;
        console.log('ğŸµ éŸ³é¢‘ç³»ç»Ÿå·²åˆå§‹åŒ–ï¼ŒåŒ…å«ä½é€šæ»¤æ³¢å™¨ï¼ˆæˆªæ­¢é¢‘ç‡: 2000Hzï¼‰');
    } catch (error) {
        console.error('âŒ éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
    }
}

/**
 * MIDIéŸ³ç¬¦å·è½¬æ¢ä¸ºé¢‘ç‡
 */
function midiToFrequency(midiNote) {
    return 440 * Math.pow(2, (midiNote - 69) / 12);
}

/**
 * æ’­æ”¾å•ä¸ªéŸ³ç¬¦ï¼Œä½¿ç”¨ä½é€šæ»¤æ³¢å™¨é™ä½é«˜é¢‘
 */
function playNote(midiNote, duration = 0.5) {
    if (!isAudioInitialized) {
        initializeAudio();
    }

    if (!audioContext) return;

    try {
        const frequency = midiToFrequency(midiNote);
        const oscillator = audioContext.createOscillator();
        const noteGain = audioContext.createGain();

        // è®¾ç½®æŒ¯è¡å™¨ä¸ºæŸ”å’Œçš„æ­£å¼¦æ³¢
        oscillator.type = 'sine';
        oscillator.frequency.value = frequency;

        // è®¾ç½®éŸ³ç¬¦éŸ³é‡åŒ…ç»œï¼šå¿«é€Ÿæ”»å‡»ï¼Œæ…¢è¡°å‡
        const now = audioContext.currentTime;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(0.8, now + 0.05); // å¿«é€Ÿæ”»å‡»
        noteGain.gain.exponentialRampToValueAtTime(0.01, now + duration); // æ…¢è¡°å‡

        // ğŸ”¥ å…³é”®ï¼šé€šè¿‡ä½é€šæ»¤æ³¢å™¨æ¥è¿‡æ»¤é«˜é¢‘
        oscillator.connect(noteGain);
        noteGain.connect(lowPassFilter); // è¿æ¥åˆ°ä½é€šæ»¤æ³¢å™¨

        oscillator.start(now);
        oscillator.stop(now + duration);

        console.log(`ğŸµ æ’­æ”¾éŸ³ç¬¦: MIDI ${midiNote} (${frequency.toFixed(1)}Hz) - ç»è¿‡ä½é€šæ»¤æ³¢`);
    } catch (error) {
        console.error('âŒ æ’­æ”¾éŸ³ç¬¦å¤±è´¥:', error);
    }
}

/**
 * æ’­æ”¾æ—‹å¾‹
 */
async function playMelody() {
    if (!melodyHistory.length || currentHistoryIndex === -1) {
        alert('è¯·å…ˆç”Ÿæˆä¸€æ®µæ—‹å¾‹ï¼');
        return;
    }

    console.log('ğŸµ å¼€å§‹æ’­æ”¾æ—‹å¾‹...');

    // ç¡®ä¿éŸ³é¢‘ç³»ç»Ÿå·²åˆå§‹åŒ–
    if (!isAudioInitialized) {
        initializeAudio();
    }

    // æ¢å¤AudioContextï¼ˆæŸäº›æµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½å¯åŠ¨ï¼‰
    if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }

    const currentMelody = melodyHistory[currentHistoryIndex];
    if (!currentMelody || !currentMelody.melody) {
        alert('æ—‹å¾‹æ•°æ®æ— æ•ˆï¼');
        return;
    }

    const durationToBeats = (note) => {
        if (!note) return 0;
        if (typeof note.beats === 'number' && Number.isFinite(note.beats) && note.beats > 0) {
            return note.beats;
        }

        const token = typeof note.duration === 'string' ? note.duration : '';
        const beatMap = {
            'whole': 4,
            'half': 2,
            'half.': 3,
            'quarter': 1,
            'quarter.': 1.5,
            'eighth': 0.5,
            'eighth.': 0.75,
            '16th': 0.25,
            '32nd': 0.125
        };
        return beatMap[token] || 1;
    };

    const extractPlaybackEvents = (melodyData) => {
        if (!melodyData || !Array.isArray(melodyData.melody)) return [];
        if (melodyData.melody.length > 0 && melodyData.melody[0] && Array.isArray(melodyData.melody[0].notes)) {
            return melodyData.melody.flatMap(measure => Array.isArray(measure?.notes) ? measure.notes : []);
        }
        return melodyData.melody;
    };

    const events = extractPlaybackEvents(currentMelody);
    const playableEvents = events.filter(Boolean);
    if (playableEvents.length === 0) {
        console.warn('âš ï¸ å½“å‰æ—‹å¾‹æ— å¯æ’­æ”¾éŸ³ç¬¦');
        return;
    }

    const msPerBeat = 600; // ä¸ç°æœ‰èŠ‚å¥ä¿æŒä¸€è‡´ï¼ˆçº¦100 BPMï¼‰
    let noteIndex = 0;

    function playNextNote() {
        if (noteIndex >= playableEvents.length) {
            console.log('ğŸµ æ—‹å¾‹æ’­æ”¾å®Œæˆ');
            return;
        }

        const event = playableEvents[noteIndex];
        const beats = durationToBeats(event);
        const eventMs = Math.max(80, beats * msPerBeat);

        if (event.type === 'note' && typeof event.midi === 'number') {
            // Acciaccatura: å…ˆå¿«é€Ÿæ’­æ”¾graceï¼Œå†è½åœ¨ä¸»éŸ³ï¼Œæ•´ä½“æ—¶å€¼ä¸å˜
            if (event.graceNote && typeof event.graceNote.midi === 'number') {
                const graceMs = Math.min(90, Math.max(45, eventMs * 0.18));
                const leadMs = Math.max(20, Math.floor(graceMs * 0.8));
                playNote(event.graceNote.midi, Math.max(0.04, graceMs / 1000));
                setTimeout(() => {
                    const mainSec = Math.max(0.06, (eventMs - leadMs) / 1000 * 0.92);
                    playNote(event.midi, mainSec);
                }, leadMs);
            } else {
                playNote(event.midi, Math.max(0.06, eventMs / 1000 * 0.85));
            }
        }
        noteIndex++;
        setTimeout(playNextNote, eventMs);
    }

    playNextNote();
}

/**
 * æµ‹è¯•æ’­æ”¾åŠŸèƒ½
 */
function directPlayTest() {
    console.log('ğŸµ æµ‹è¯•æ’­æ”¾åŠŸèƒ½...');

    // æ’­æ”¾ä¸€ä¸ªæµ‹è¯•éŸ³ç¬¦
    playNote(60, 1.0); // ä¸­å¤®Cï¼ŒæŒç»­1ç§’

    // å¦‚æœæœ‰æ—‹å¾‹å°±æ’­æ”¾æ—‹å¾‹
    if (melodyHistory.length > 0 && currentHistoryIndex !== -1) {
        setTimeout(() => playMelody(), 1500);
    }
}

/**
 * ç©ºçš„èŠ‚æ‹å™¨å‡½æ•°ï¼ˆå ä½ï¼‰
 */
function toggleMetronome() {
    console.log('ğŸµ èŠ‚æ‹å™¨åŠŸèƒ½å¾…å®ç°');
}

/**
 * è°ƒæ•´éŸ³é¢‘æ»¤æ³¢å™¨å‚æ•°
 */
function adjustAudioFilter(cutoffFreq = 2000, volume = 0.3) {
    if (!isAudioInitialized) return;

    if (lowPassFilter) {
        lowPassFilter.frequency.value = cutoffFreq;
        console.log(`ğŸ›ï¸ ä½é€šæ»¤æ³¢å™¨æˆªæ­¢é¢‘ç‡å·²è°ƒæ•´ä¸º: ${cutoffFreq}Hz`);
    }

    if (masterGain) {
        masterGain.gain.value = volume * AUDIO_BOOST;
        console.log(`ğŸ”Š ä¸»éŸ³é‡å·²è°ƒæ•´ä¸º: ${(volume * AUDIO_BOOST * 100).toFixed(0)}%`);
    }
}

/**
 * é¢„è®¾éŸ³è‰²è®¾ç½®
 */
function setAudioPreset(preset) {
    switch (preset) {
        case 'warm': // æ¸©æš–éŸ³è‰²
            adjustAudioFilter(1500, 0.25);
            console.log('ğŸµ å·²è®¾ç½®ä¸ºæ¸©æš–éŸ³è‰²ï¼ˆä½é€š1500Hzï¼‰');
            break;
        case 'bright': // æ˜äº®éŸ³è‰²
            adjustAudioFilter(3000, 0.3);
            console.log('ğŸµ å·²è®¾ç½®ä¸ºæ˜äº®éŸ³è‰²ï¼ˆä½é€š3000Hzï¼‰');
            break;
        case 'soft': // æŸ”å’ŒéŸ³è‰²
            adjustAudioFilter(1200, 0.2);
            console.log('ğŸµ å·²è®¾ç½®ä¸ºæŸ”å’ŒéŸ³è‰²ï¼ˆä½é€š1200Hzï¼‰');
            break;
        default:
            adjustAudioFilter(2000, 0.3);
            console.log('ğŸµ å·²è®¾ç½®ä¸ºé»˜è®¤éŸ³è‰²ï¼ˆä½é€š2000Hzï¼‰');
    }
}

// ====== ç”¨æˆ·è‡ªå®šä¹‰è®¾ç½® ======
let userSettings = {
    // ä¸ºæ¯ä¸ªè°±å·åˆ†åˆ«ä¿å­˜éŸ³åŸŸè®¾ç½®
    clefRanges: {
        treble: { 
            customRange: null, // åªæœ‰ç”¨æˆ·æ‰‹åŠ¨è®¾ç½®æ—¶æ‰æœ‰å€¼
            hasCustomRange: false 
        },
        alto: { 
            customRange: null,
            hasCustomRange: false 
        },
        bass: { 
            customRange: null,
            hasCustomRange: false 
        }
    },
    // ä¿æŒå‘åå…¼å®¹çš„å…¨å±€éŸ³åŸŸï¼ˆå·²å¼ƒç”¨ï¼Œä»…ä¾›æ—§ä»£ç å‚è€ƒï¼‰
    customRange: { min: 60, max: 79 }, // é»˜è®¤C5-C6 (åœ¨æ–°æ‰©å±•èŒƒå›´å†…)
    hasCustomRange: false, // æ ‡è®°ç”¨æˆ·æ˜¯å¦æ‰‹åŠ¨è®¾ç½®äº†éŸ³åŸŸï¼ˆå·²å¼ƒç”¨ï¼‰
    allowedRhythms: ['half', 'quarter', 'eighth'], // é»˜è®¤å…è®¸çš„èŠ‚å¥ï¼ˆäºŒåˆ†éŸ³ç¬¦ã€å››åˆ†éŸ³ç¬¦ã€å…«åˆ†éŸ³ç¬¦ï¼‰
    allowDottedNotes: true, // æ˜¯å¦å…è®¸é™„ç‚¹éŸ³ç¬¦
    accidentalRate: 0, // ä¸´æ—¶è®°å·æ¦‚ç‡ (0-100%)
    maxJump: 12, // æœ€å¤§éŸ³ç¨‹è·³åŠ¨ (åŠéŸ³æ•°)
    
    // ğŸ”¥ æ–°å¢ï¼šå¤šé€‰è®¾ç½®é¡¹
    allowedKeys: ['C'], // å…è®¸çš„è°ƒå·ï¼Œé»˜è®¤Cå¤§è°ƒ
    allowedTimeSignatures: ['4/4'], // å…è®¸çš„æ‹å·ï¼Œé»˜è®¤4/4æ‹
    allowedIntervals: [12], // å…è®¸çš„æœ€å¤§éŸ³ç¨‹è·¨åº¦ï¼Œé»˜è®¤å®Œå…¨å…«åº¦
    allowedClefs: ['treble'], // å…è®¸çš„è°±å·ï¼Œé»˜è®¤é«˜éŸ³è°±å·
    customTimeSignature: null, // è‡ªå®šä¹‰æ‹å·ï¼ˆä»…æ—‹å¾‹å·¥å…·ä½¿ç”¨ï¼‰
    
    // èŠ‚å¥é¢‘ç‡è®¾ç½®
    rhythmFrequencies: {
        dotted: 20,
        whole: 10,
        half: 30,
        quarter: 50,
        eighth: 40,
        '16th': 20,
        triplet: 35,
        duplet: 30,
        quadruplet: 25
    },
    
    // Articulation & Ornaments è®¾ç½®
    articulations: {
        enabled: false, // æ˜¯å¦å¯ç”¨articulation
        basic: [], // åŸºæœ¬æ¼”å¥æ³• ['staccato', 'accent', 'acciaccatura'] (å·²ç§»é™¤: tenuto, marcato, fermata)
        ornaments: [], // è£…é¥°éŸ³ (å·²å®Œå…¨ç§»é™¤)
        guitar: [], // å‰ä»–æŠ€å·§ ['hammer-on', 'pull-off', 'glissando', 'slide-in', 'slide-out'] (å·²ç§»é™¤: bend, vibrato, harmonic)
        strings: [], // å¼¦ä¹æŠ€å·§ (å·²å®Œå…¨ç§»é™¤)  
        bass: [], // è´æ–¯æŠ€å·§ (å·²å®Œå…¨ç§»é™¤)
        frequencies: {
            staccato: 20,
            accent: 15,
            acciaccatura: 10,
            slur: 15,  // ç»Ÿä¸€çš„å‡»å‹¾å¼¦(slur)é¢‘ç‡æ§åˆ¶
            slide: 10  // ç»Ÿä¸€çš„Slideé¢‘ç‡æ§åˆ¶ï¼ˆglissando/slide-in/slide-outï¼‰
        }
    }
};

const BUILTIN_TIME_SIGNATURES = ['2/4', '3/4', '4/4', '6/8'];

function parseTimeSignatureString(ts) {
    if (typeof ts !== 'string') return null;
    const parts = ts.split('/');
    if (parts.length !== 2) return null;
    const beats = parseInt(parts[0], 10);
    const beatType = parseInt(parts[1], 10);
    if (!Number.isFinite(beats) || !Number.isFinite(beatType)) return null;
    return { beats, beatType };
}

function isBuiltInTimeSignature(ts) {
    return BUILTIN_TIME_SIGNATURES.includes(ts);
}

function isCompoundTimeSignature(ts) {
    const parsed = parseTimeSignatureString(ts);
    if (!parsed) return false;
    if (parsed.beatType !== 8) return false;
    if (parsed.beats % 3 !== 0) return false;
    return parsed.beats > 3;
}

function getBeamingReferenceTimeSignature(ts) {
    if (isBuiltInTimeSignature(ts)) return ts;
    return isCompoundTimeSignature(ts) ? '6/8' : '4/4';
}

function getCustomBeatGrouping(timeSignature, measureIndex) {
    if (!timeSignature || isBuiltInTimeSignature(timeSignature)) return null;
    const parsed = parseTimeSignatureString(timeSignature);
    if (!parsed) return null;
    const { beats, beatType } = parsed;
    const unit = beatType === 8 ? 0.5 : beatType === 16 ? 0.25 : beatType === 2 ? 2 : 1;
    let groups = [];

    if (beats === 5) {
        groups = (measureIndex % 2 === 0) ? [3, 2] : [2, 3];
    } else if (beats === 7) {
        groups = (measureIndex % 2 === 0) ? [3, 2, 2] : [2, 2, 3];
    } else if (beats === 8) {
        groups = (measureIndex % 2 === 0) ? [3, 3, 2] : [2, 3, 3];
    } else if (isCompoundTimeSignature(timeSignature)) {
        const fullGroups = Math.floor(beats / 3);
        groups = new Array(fullGroups).fill(3);
        const remainder = beats % 3;
        if (remainder) groups.push(remainder);
    } else {
        let remaining = beats;
        while (remaining > 0) {
            if (remaining === 5) {
                groups.push(3, 2);
                break;
            }
            if (remaining === 7) {
                groups.push(3, 2, 2);
                break;
            }
            if (remaining === 3) {
                groups.push(3);
                break;
            }
            if (remaining === 2) {
                groups.push(2);
                break;
            }
            groups.push(2);
            remaining -= 2;
        }
    }

    const starts = [0];
    let acc = 0;
    for (let i = 0; i < groups.length - 1; i++) {
        acc += groups[i] * unit;
        starts.push(acc);
    }

    return { starts, totalBeats: beats * (4 / beatType) };
}


/**
 * æ£€æŸ¥æ˜¯å¦åº”è¯¥æ ¹æ®ç”¨æˆ·é¢‘ç‡è®¾ç½®ç”Ÿæˆç‰¹å®šæ–¹å‘çš„slur
 * è¿™æ˜¯æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶sluræ–¹å‘è€Œä¸æ˜¯articulationç±»å‹
 */
/**
 * ğŸ¸ ç»Ÿä¸€çš„å‡»å‹¾å¼¦(slur)é¢‘ç‡æ§åˆ¶å‡½æ•°
 * ä½¿ç”¨å•ä¸€é¢‘ç‡æ§åˆ¶æ‰€æœ‰äºŒåº¦éŸ³ç¨‹çš„slurç”Ÿæˆ
 */
function shouldGenerateDirectionalSlur(interval, randomGenerator = null) {
    // åªå¯¹äºŒåº¦éŸ³ç¨‹(Â±1æˆ–Â±2åŠéŸ³)ç”Ÿæˆslur
    if (Math.abs(interval) !== 1 && Math.abs(interval) !== 2) {
        return false;
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ç”¨äº†guitaræŠ€å·§
    const hammerCheckbox = document.getElementById('gtr-hammer');
    const pullCheckbox = document.getElementById('gtr-pull');
    const hammerChecked = hammerCheckbox ? hammerCheckbox.checked : false;
    const pullChecked = pullCheckbox ? pullCheckbox.checked : false;
    
    // å¦‚æœç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•guitaræŠ€å·§ï¼Œåˆ™ä¸ç”Ÿæˆslur
    if (!hammerChecked && !pullChecked) return false;
    
    // è·å–ç»Ÿä¸€çš„sluré¢‘ç‡è®¾ç½® - ä½¿ç”¨æ–°çš„é¢‘ç‡æ˜ å°„ç³»ç»Ÿ
    const slurFreq = getUserFrequency('articulation', 'slur');
    
    // å¦‚æœé¢‘ç‡ä¸º0%ï¼Œå®Œå…¨ä¸ç”Ÿæˆ
    if (slurFreq === 0) {
        console.log(`ğŸš« å‡»å‹¾å¼¦é¢‘ç‡ä¸º 0%ï¼Œå®Œå…¨é˜»æ­¢ (éŸ³ç¨‹${interval > 0 ? '+' : ''}${interval})`);
        return false;
    }
    
    // ğŸ”¥ ä½¿ç”¨ä¼ å…¥çš„éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨Math.random
    const randomValue = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    const shouldGenerate = randomValue * 100 < slurFreq;
    
    // å¢åŠ è°ƒè¯•ä¿¡æ¯è¾“å‡ºé¢‘ç‡ä»¥ä¾¿è§‚å¯Ÿ
    if (slurFreq <= 10 || slurFreq >= 90 || Math.random() < 0.1) {
        console.log(`ğŸ¸ å‡»å‹¾å¼¦æ§åˆ¶ ${slurFreq}%: ${shouldGenerate ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'} (éŸ³ç¨‹${interval > 0 ? '+' : ''}${interval})`);
    }
    
    return shouldGenerate;
}

const SLIDE_ARTICULATION_TYPES = ['glissando', 'slide-in', 'slide-out'];
const TWO_NOTE_TECHNIQUE_TYPES = ['hammer-on', 'pull-off', 'glissando'];
const MAX_SLIDES_PER_MELODY = 2;
const SLIDE_UNLIMITED_THRESHOLD = 60;
const MIN_SLIDE_NOTE_BEATS = 0.5; // ä¸å…è®¸åœ¨æ¯”å…«åˆ†éŸ³ç¬¦æ›´å¿«ï¼ˆå¦‚16åˆ†ï¼‰çš„ä½ç½®å‡ºç°slide
// é»˜è®¤æƒé‡ï¼šä¸‰ç§slideå°½é‡æ¥è¿‘ï¼Œæ™®é€šslideè½»å¾®åé«˜
const DEFAULT_SLIDE_TYPE_WEIGHTS = Object.freeze({
    glissando: 0.45,
    'slide-in': 0.275,
    'slide-out': 0.275
});
const DIRECTIONAL_SLIDE_CHANCE_SCALE = 0.8; // æå‡æ–¹å‘æ»‘éŸ³çš„å¯è§æ€§ï¼Œä½¿ä¸‰è€…æ›´æ¥è¿‘å‡è¡¡
const SLIDE_OUT_CHANCE_BIAS = 0.72; // ç»“å°¾ä½å¤©ç„¶æ›´å®¹æ˜“å‘½ä¸­ï¼Œé¢å¤–å‹ä½ slide-out
const CUSTOM_SLIDE_ANCHOR_OFFSET_X = 0; // ä½¿ç”¨éŸ³å¤´ä¸­å¿ƒç‚¹ä½œä¸ºé”šç‚¹ï¼Œæ— éœ€é¢å¤–æ°´å¹³ä¿®æ­£
const CUSTOM_SLIDE_ANCHOR_OFFSET_Y = 0; // ä½¿ç”¨éŸ³å¤´ä¸­å¿ƒç‚¹ä½œä¸ºé”šç‚¹ï¼Œæ— éœ€é¢å¤–å‚ç›´ä¿®æ­£
const CUSTOM_SLIDE_NOTE_GAP_PX = 2.2; // æ‰€æœ‰slideçº¿æ®µä¸éŸ³å¤´ä¹‹é—´ä¿ç•™è½»å¾®é—´éš™
const CUSTOM_SLIDE_IN_OUT_LENGTH_PX = 30; // slide-in/outæ¯”æ™®é€šslideæ›´é•¿ï¼Œä¾¿äºè§†è§‰åŒºåˆ†
const CUSTOM_SLIDE_IN_OUT_DIAGONAL_OFFSET_PX = CUSTOM_SLIDE_IN_OUT_LENGTH_PX / Math.SQRT2; // 45Â°æ—¶x/yåˆ†é‡ç›¸ç­‰

function isSlideArticulationType(type) {
    return SLIDE_ARTICULATION_TYPES.includes(type);
}

function isTwoNoteTechniqueType(type) {
    return TWO_NOTE_TECHNIQUE_TYPES.includes(type);
}

function getNoteBeatsForSlide(note, fallbackFn = null) {
    if (!note) return null;
    if (typeof note.beats === 'number' && Number.isFinite(note.beats)) {
        return note.beats;
    }
    const duration = typeof note.duration === 'string' ? note.duration : '';
    if (fallbackFn && duration) {
        const fallbackBeats = fallbackFn(duration);
        if (typeof fallbackBeats === 'number' && Number.isFinite(fallbackBeats)) {
            return fallbackBeats;
        }
    }
    return null;
}

function isSlideDurationAllowed(note, fallbackFn = null) {
    const beats = getNoteBeatsForSlide(note, fallbackFn);
    return typeof beats === 'number' && beats >= MIN_SLIDE_NOTE_BEATS;
}

function mapSlideFrequencyToExpectedSlides(slideFrequency) {
    const normalized = normalizeFrequencyPercentage(slideFrequency, 10);
    // ç›®æ ‡ï¼š
    // 10% -> å¹³å‡æ¯æ¡0.5ä¸ªslideï¼ˆçº¦æ¯ä¸¤æ¡å‡ºç°1ä¸ªï¼‰
    // é«˜é¢‘ç‡æ—¶æå‡å•æ¡æ—‹å¾‹å†…slideæ•°é‡ï¼ˆ>=60%æ—¶è¿›å…¥ä¸é™æ•°é‡æ¨¡å¼ï¼‰
    return Math.max(0, normalized / 20);
}

function sampleSlideBudget(expectedSlides, randomGenerator = null) {
    const boundedExpected = Math.max(0, Math.min(MAX_SLIDES_PER_MELODY, expectedSlides));
    const whole = Math.floor(boundedExpected);
    const fraction = boundedExpected - whole;
    const randomValue = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    const sampled = whole + (randomValue < fraction ? 1 : 0);
    return Math.max(0, Math.min(MAX_SLIDES_PER_MELODY, sampled));
}

function getEnabledSlideTypes() {
    const selected = userSettings?.articulations?.guitar;
    if (!Array.isArray(selected)) return [];
    return SLIDE_ARTICULATION_TYPES.filter(type => selected.includes(type));
}

function createSlideAssignmentState(randomGenerator = null) {
    const enabledTypes = getEnabledSlideTypes();
    const slideFrequency = getUserFrequency('articulation', 'slide');
    const expectedSlides = mapSlideFrequencyToExpectedSlides(slideFrequency);
    const hasSlideEnabled = enabledTypes.length > 0 && slideFrequency > 0;
    const isUnlimited = hasSlideEnabled && slideFrequency >= SLIDE_UNLIMITED_THRESHOLD;
    const slideBudget = !hasSlideEnabled
        ? 0
        : (isUnlimited ? Number.POSITIVE_INFINITY : sampleSlideBudget(expectedSlides, randomGenerator));

    return {
        enabledTypes,
        slideFrequency,
        expectedSlides,
        slideBudget,
        isUnlimited,
        consumedCount: 0,
        consumedTypes: []
    };
}

function getSlideInOutChance(slideFrequency, isLongNote, slideType = 'slide-in') {
    const normalized = normalizeFrequencyPercentage(slideFrequency, 10);
    if (normalized <= 0) return 0;

    const ratio = normalized / 100;
    const curvedRatio = Math.pow(ratio, 1.35);
    const minChance = slideType === 'slide-out' ? 0.1 : 0.09;
    const maxChance = slideType === 'slide-out' ? 0.96 : 0.94;
    const baseChance = minChance + (maxChance - minChance) * curvedRatio;
    const longNoteBoost = isLongNote ? 0.06 : 0;
    const typeBias = slideType === 'slide-out' ? SLIDE_OUT_CHANCE_BIAS : 1;
    const directionalChance = (baseChance + longNoteBoost) * DIRECTIONAL_SLIDE_CHANCE_SCALE * typeBias;
    return Math.max(0, Math.min(1, directionalChance));
}

function getDefaultSlideTypeWeight(type) {
    return DEFAULT_SLIDE_TYPE_WEIGHTS[type] || 0;
}

function chooseWeightedSlideType(candidates, randomGenerator = null) {
    if (!Array.isArray(candidates) || candidates.length === 0) return null;

    const weighted = candidates
        .map(candidate => {
            const chance = Math.max(0, Math.min(1, Number(candidate.chance) || 0));
            const weight = getDefaultSlideTypeWeight(candidate.type);
            return {
                ...candidate,
                chance,
                weight,
                score: chance * weight
            };
        })
        .filter(item => item.score > 0);

    if (!weighted.length) return null;

    const totalScore = weighted.reduce((sum, item) => sum + item.score, 0);
    const triggerChance = Math.max(0, Math.min(1, totalScore));
    const triggerRoll = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    if (triggerRoll >= triggerChance) {
        return null;
    }

    let cursor = (randomGenerator ? randomGenerator.nextFloat() : Math.random()) * totalScore;

    for (const item of weighted) {
        cursor -= item.score;
        if (cursor <= 0) {
            return item;
        }
    }

    return weighted[weighted.length - 1];
}

function canAssignSlideWithState(state, requestedType) {
    if (!state || !isSlideArticulationType(requestedType)) return false;
    if ((state.slideBudget || 0) <= 0) return false;
    if (!state.isUnlimited && (state.consumedCount || 0) >= state.slideBudget) return false;
    return Array.isArray(state.enabledTypes) && state.enabledTypes.includes(requestedType);
}

function consumeSlideWithState(state, requestedType) {
    if (!canAssignSlideWithState(state, requestedType)) {
        return false;
    }
    state.consumedCount = (state.consumedCount || 0) + 1;
    if (!Array.isArray(state.consumedTypes)) {
        state.consumedTypes = [];
    }
    state.consumedTypes.push(requestedType);
    return true;
}

/**
 * ğŸ§ª ç®€å•æµ‹è¯•æ–°çš„é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
 */
function testNewFrequencyControl() {
    console.log('ğŸ§ª === æ–°é¢‘ç‡æ§åˆ¶ç³»ç»Ÿæµ‹è¯•å¼€å§‹ ===');
    
    const hammerSlider = document.getElementById('freq-hammer');
    const pullSlider = document.getElementById('freq-pull');
    const hammerCheckbox = document.getElementById('gtr-hammer');
    const pullCheckbox = document.getElementById('gtr-pull');
    
    if (!hammerSlider || !pullSlider || !hammerCheckbox || !pullCheckbox) {
        console.log('âŒ æµ‹è¯•å¤±è´¥: UIå…ƒç´ ä¸å®Œæ•´');
        return;
    }
    
    console.log('âœ… UIå…ƒç´ æ£€æŸ¥é€šè¿‡');
    console.log(`ğŸ“Š å½“å‰è®¾ç½®: hammer=${userSettings?.articulations?.frequencies?.hammer}%, pull=${userSettings?.articulations?.frequencies?.pull}%`);
    console.log(`â˜‘ï¸ å¤é€‰æ¡†çŠ¶æ€: hammer=${hammerCheckbox.checked}, pull=${pullCheckbox.checked}`);
    
    // æµ‹è¯•ä¸åŒé¢‘ç‡å€¼
    const testFreqs = [0, 25, 50, 75, 100];
    testFreqs.forEach(freq => {
        const oldHammer = userSettings.articulations.frequencies.hammer;
        const oldPull = userSettings.articulations.frequencies.pull;
        
        userSettings.articulations.frequencies.hammer = freq;
        userSettings.articulations.frequencies.pull = freq;
        
        // æµ‹è¯•10æ¬¡ï¼Œçœ‹æ¦‚ç‡æ˜¯å¦æ¥è¿‘é¢„æœŸ
        let hammerHits = 0, pullHits = 0;
        for (let i = 0; i < 100; i++) {
            if (shouldGenerateDirectionalSlur(1)) hammerHits++;
            if (shouldGenerateDirectionalSlur(-1)) pullHits++;
        }
        
        console.log(`ğŸ¯ é¢‘ç‡${freq}%æµ‹è¯•: hammerå‘½ä¸­${hammerHits}%, pullå‘½ä¸­${pullHits}%`);
        
        // æ¢å¤åŸå€¼
        userSettings.articulations.frequencies.hammer = oldHammer;
        userSettings.articulations.frequencies.pull = oldPull;
    });
    
    console.log('ğŸ§ª === æµ‹è¯•å®Œæˆ ===');
}

/**
 * ğŸµ æµ‹è¯•é™„ç‚¹éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
 */
function testDottedNoteFrequencyControl() {
    console.log('ğŸµ === é™„ç‚¹éŸ³ç¬¦é¢‘ç‡æ§åˆ¶æµ‹è¯•å¼€å§‹ ===');
    
    // æ£€æŸ¥UIå…ƒç´ 
    const dottedQuarterSlider = document.getElementById('freq-dotted-quarter');
    const dottedHalfSlider = document.getElementById('freq-dotted-half');
    const dottedQuarterCheckbox = document.getElementById('rhythm-dotted-quarter');
    const dottedHalfCheckbox = document.getElementById('rhythm-dotted-half');
    
    console.log('ğŸ“‹ UIçŠ¶æ€æ£€æŸ¥:');
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦æ»‘å—: ${!!dottedQuarterSlider}`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ»‘å—: ${!!dottedHalfSlider}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!dottedQuarterCheckbox} (å‹¾é€‰: ${dottedQuarterCheckbox?.checked})`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!dottedHalfCheckbox} (å‹¾é€‰: ${dottedHalfCheckbox?.checked})`);
    
    if (!userSettings || !userSettings.rhythmFrequencies) {
        console.log('âŒ userSettingsæˆ–rhythmFrequenciesä¸å­˜åœ¨');
        return;
    }
    
    console.log('ğŸ“Š å½“å‰é¢‘ç‡è®¾ç½®:');
    console.log(`  - dotted-quarter: ${userSettings.rhythmFrequencies['dotted-quarter']}%`);
    console.log(`  - dotted-half: ${userSettings.rhythmFrequencies['dotted-half']}%`);
    
    // æµ‹è¯•èŠ‚å¥æƒé‡æ˜ å°„
    const testMelodyGen = new IntelligentMelodyGenerator(1, 'C', '6/8', 'treble', 12345);
    
    console.log('ğŸ”„ æµ‹è¯•èŠ‚å¥æƒé‡æ˜ å°„:');
    
    // æ¨¡æ‹Ÿä¸åŒé¢‘ç‡è®¾ç½®ä¸‹çš„æƒé‡è®¡ç®—
    const testFreqs = [0, 25, 50, 100];
    testFreqs.forEach(freq => {
        console.log(`\nğŸ¯ æµ‹è¯•é¢‘ç‡ ${freq}%:`);
        
        // ä¿å­˜åŸå§‹è®¾ç½®
        const originalQuarter = userSettings.rhythmFrequencies['dotted-quarter'];
        const originalHalf = userSettings.rhythmFrequencies['dotted-half'];
        
        // ä¸´æ—¶è®¾ç½®æ–°é¢‘ç‡
        userSettings.rhythmFrequencies['dotted-quarter'] = freq;
        userSettings.rhythmFrequencies['dotted-half'] = freq;
        
        try {
            // æµ‹è¯• quarter. æƒé‡è®¡ç®—
            const quarterWeight = testMelodyGen.calculateDurationWeight(['quarter.'], 'quarter.', 1.5, 1.5);
            console.log(`  quarter. æƒé‡: ${quarterWeight}`);
            
            // æµ‹è¯• half. æƒé‡è®¡ç®—  
            const halfWeight = testMelodyGen.calculateDurationWeight(['half.'], 'half.', 3.0, 3.0);
            console.log(`  half. æƒé‡: ${halfWeight}`);
        } catch (error) {
            console.log(`  æµ‹è¯•å‡ºé”™: ${error.message}`);
        }
        
        // æ¢å¤åŸå§‹è®¾ç½®
        userSettings.rhythmFrequencies['dotted-quarter'] = originalQuarter;
        userSettings.rhythmFrequencies['dotted-half'] = originalHalf;
    });
    
    console.log('ğŸµ === é™„ç‚¹éŸ³ç¬¦é¢‘ç‡æ§åˆ¶æµ‹è¯•å®Œæˆ ===');
}

/**
 * ğŸ¸ æµ‹è¯•æ–°çš„å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
 */
function testSlurFrequencyControl() {
    console.log('ğŸ¸ === å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶æµ‹è¯•å¼€å§‹ ===');
    
    // æ£€æŸ¥UIå…ƒç´ 
    const slurSlider = document.getElementById('freq-slur');
    const slurValueDisplay = document.getElementById('freq-slur-value');
    const hammerCheckbox = document.getElementById('gtr-hammer');
    const pullCheckbox = document.getElementById('gtr-pull');
    
    console.log('ğŸ“‹ UIçŠ¶æ€æ£€æŸ¥:');
    console.log(`  - å‡»å‹¾å¼¦æ»‘å—: ${!!slurSlider} (å€¼: ${slurSlider?.value})`);
    console.log(`  - å‡»å‹¾å¼¦æ˜¾ç¤º: ${!!slurValueDisplay} (æ–‡æœ¬: ${slurValueDisplay?.textContent})`);
    console.log(`  - Hammer-onå¤é€‰æ¡†: ${!!hammerCheckbox} (å‹¾é€‰: ${hammerCheckbox?.checked})`);
    console.log(`  - Pull-offå¤é€‰æ¡†: ${!!pullCheckbox} (å‹¾é€‰: ${pullCheckbox?.checked})`);
    
    if (!userSettings || !userSettings.articulations || !userSettings.articulations.frequencies) {
        console.log('âŒ userSettingsç»“æ„ä¸å®Œæ•´');
        return;
    }
    
    console.log('ğŸ“Š å½“å‰é¢‘ç‡è®¾ç½®:');
    console.log(`  - sluré¢‘ç‡: ${userSettings.articulations.frequencies.slur}%`);
    
    // æµ‹è¯•ä¸åŒé¢‘ç‡ä¸‹çš„ç”Ÿæˆæ¦‚ç‡
    console.log('\nğŸ¯ æ¦‚ç‡æµ‹è¯•:');
    const testFreqs = [0, 25, 50, 75, 100];
    
    testFreqs.forEach(freq => {
        // ä¸´æ—¶è®¾ç½®é¢‘ç‡
        const originalFreq = userSettings.articulations.frequencies.slur;
        userSettings.articulations.frequencies.slur = freq;
        
        // æµ‹è¯•100æ¬¡ï¼Œç»Ÿè®¡ç”Ÿæˆæ¬¡æ•°
        let upwardCount = 0, downwardCount = 0;
        const testCount = 100;
        
        for (let i = 0; i < testCount; i++) {
            if (shouldGenerateDirectionalSlur(1)) upwardCount++;  // ä¸Šè¡ŒäºŒåº¦
            if (shouldGenerateDirectionalSlur(-1)) downwardCount++; // ä¸‹è¡ŒäºŒåº¦
        }
        
        console.log(`  é¢‘ç‡${freq}%: ä¸Šè¡ŒäºŒåº¦å‘½ä¸­${upwardCount}%, ä¸‹è¡ŒäºŒåº¦å‘½ä¸­${downwardCount}%`);
        
        // æ¢å¤åŸé¢‘ç‡
        userSettings.articulations.frequencies.slur = originalFreq;
    });
    
    // æµ‹è¯•éŸ³ç¨‹èŒƒå›´
    console.log('\nğŸµ éŸ³ç¨‹èŒƒå›´æµ‹è¯•:');
    const intervals = [-3, -2, -1, 0, 1, 2, 3];
    intervals.forEach(interval => {
        const result = shouldGenerateDirectionalSlur(interval);
        console.log(`  éŸ³ç¨‹${interval > 0 ? '+' : ''}${interval}: ${result ? 'âœ…å¯èƒ½ç”Ÿæˆ' : 'âŒä¸ç”Ÿæˆ'}`);
    });
    
    console.log('\nğŸ¯ é¢‘ç‡å½±å“æµ‹è¯• (0%å’Œ100%):');
    // æµ‹è¯•0%é¢‘ç‡
    userSettings.articulations.frequencies.slur = 0;
    const zeroTest = shouldGenerateDirectionalSlur(1);
    console.log(`  0%é¢‘ç‡æµ‹è¯•: ${zeroTest ? 'âŒå¼‚å¸¸-ä»ç”Ÿæˆ' : 'âœ…æ­£ç¡®-ä¸ç”Ÿæˆ'}`);
    
    // æµ‹è¯•100%é¢‘ç‡(å¤šæ¬¡æµ‹è¯•)
    userSettings.articulations.frequencies.slur = 100;
    let hundredCount = 0;
    for (let i = 0; i < 10; i++) {
        if (shouldGenerateDirectionalSlur(1)) hundredCount++;
    }
    console.log(`  100%é¢‘ç‡æµ‹è¯•(10æ¬¡): å‘½ä¸­${hundredCount}/10æ¬¡ ${hundredCount >= 8 ? 'âœ…æ­£å¸¸' : 'âŒå¼‚å¸¸'}`);
    
    console.log('ğŸ¸ === å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶æµ‹è¯•å®Œæˆ ===');
}

/**
 * ğŸ§ª æµ‹è¯•é™„ç‚¹éŸ³ç¬¦é€‰æ‹©çš„ä¸¥æ ¼æ€§
 */
function testStrictDottedNoteSelection() {
    console.log('ğŸ§ª === é™„ç‚¹éŸ³ç¬¦ä¸¥æ ¼é€‰æ‹©æµ‹è¯•å¼€å§‹ ===');
    
    // æ£€æŸ¥UIå…ƒç´ 
    const dottedQuarterCheckbox = document.getElementById('rhythm-dotted-quarter');
    const dottedHalfCheckbox = document.getElementById('rhythm-dotted-half');
    const quarterCheckbox = document.getElementById('rhythm-quarter');
    const halfCheckbox = document.getElementById('rhythm-half');
    
    console.log('ğŸ“‹ UIçŠ¶æ€æ£€æŸ¥:');
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!dottedQuarterCheckbox} (å‹¾é€‰: ${dottedQuarterCheckbox?.checked})`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!dottedHalfCheckbox} (å‹¾é€‰: ${dottedHalfCheckbox?.checked})`);
    console.log(`  - å››åˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!quarterCheckbox} (å‹¾é€‰: ${quarterCheckbox?.checked})`);
    console.log(`  - äºŒåˆ†éŸ³ç¬¦å¤é€‰æ¡†: ${!!halfCheckbox} (å‹¾é€‰: ${halfCheckbox?.checked})`);
    
    if (!userSettings) {
        console.log('âŒ userSettingsä¸å­˜åœ¨');
        return;
    }
    
    console.log('\nğŸ“Š å½“å‰èŠ‚å¥è®¾ç½®:');
    console.log(`  - allowedRhythms: [${userSettings.allowedRhythms?.join(', ') || 'undefined'}]`);
    
    // æµ‹è¯•åªé€‰æ‹©é™„ç‚¹éŸ³ç¬¦çš„æƒ…å†µ
    console.log('\nğŸ¯ æµ‹è¯•åœºæ™¯: åªé€‰æ‹©é™„ç‚¹å››åˆ†éŸ³ç¬¦');
    
    // æ¨¡æ‹Ÿç”¨æˆ·è®¾ç½®
    const originalRhythms = userSettings.allowedRhythms;
    userSettings.allowedRhythms = ['dotted-quarter'];
    
    try {
        // åˆ›å»ºæµ‹è¯•ç”Ÿæˆå™¨
        const testGen = new IntelligentMelodyGenerator(1, 'C', '6/8', 'treble', 12345);
        
        console.log('ğŸ” ç”Ÿæˆå™¨å…è®¸çš„èŠ‚å¥:');
        console.log(`  - allowedDurations: [${testGen.rules.allowedDurations.join(', ')}]`);
        
        // æ£€æŸ¥æ˜¯å¦åªåŒ…å«ç”¨æˆ·é€‰æ‹©çš„èŠ‚å¥ï¼ˆè½¬æ¢åçš„æ ¼å¼ï¼‰
        const expectedRhythms = ['quarter.'];  // dotted-quarter åº”è¯¥è½¬æ¢ä¸º quarter.
        const hasOnlyExpected = testGen.rules.allowedDurations.every(r => expectedRhythms.includes(r));
        const hasUnexpected = testGen.rules.allowedDurations.some(r => !expectedRhythms.includes(r));
        
        console.log(`âœ… åªåŒ…å«é¢„æœŸèŠ‚å¥: ${hasOnlyExpected ? 'æ˜¯' : 'å¦'}`);
        console.log(`âŒ åŒ…å«æ„å¤–èŠ‚å¥: ${hasUnexpected ? 'æ˜¯' : 'å¦'}`);
        
        if (hasUnexpected) {
            const unexpected = testGen.rules.allowedDurations.filter(r => !expectedRhythms.includes(r));
            console.log(`ğŸš« æ„å¤–çš„èŠ‚å¥ç±»å‹: [${unexpected.join(', ')}]`);
        }
        
    } catch (error) {
        console.log(`æµ‹è¯•å‡ºé”™: ${error.message}`);
    }
    
    // æ¢å¤åŸå§‹è®¾ç½®
    userSettings.allowedRhythms = originalRhythms;
    
    console.log('ğŸ§ª === é™„ç‚¹éŸ³ç¬¦ä¸¥æ ¼é€‰æ‹©æµ‹è¯•å®Œæˆ ===');
}

/**
 * ğŸ” è°ƒè¯•å·¥å…·å‡½æ•°ï¼šæµ‹è¯•é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
 * ç”¨æ³•ï¼šåœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ testFrequencyControl()
 */
function testFrequencyControl() {
    console.log(`\nğŸ§ª === é¢‘ç‡æ§åˆ¶ç³»ç»Ÿç»¼åˆæµ‹è¯• ===`);
    
    // 1. æ£€æŸ¥UIå…ƒç´ 
    const hammerSlider = document.getElementById('freq-hammer');
    const pullSlider = document.getElementById('freq-pull');
    const hammerDisplay = document.getElementById('freq-hammer-value');
    const pullDisplay = document.getElementById('freq-pull-value');
    
    console.log(`ğŸ“‹ UIå…ƒç´ æ£€æŸ¥:`);
    console.log(`  - hammeræ‘‡æ†å­˜åœ¨: ${!!hammerSlider} ${hammerSlider ? `(å€¼: ${hammerSlider.value})` : ''}`);
    console.log(`  - pullæ‘‡æ†å­˜åœ¨: ${!!pullSlider} ${pullSlider ? `(å€¼: ${pullSlider.value})` : ''}`);
    console.log(`  - hammeræ˜¾ç¤ºå­˜åœ¨: ${!!hammerDisplay} ${hammerDisplay ? `(æ–‡æœ¬: ${hammerDisplay.textContent})` : ''}`);
    console.log(`  - pullæ˜¾ç¤ºå­˜åœ¨: ${!!pullDisplay} ${pullDisplay ? `(æ–‡æœ¬: ${pullDisplay.textContent})` : ''}`);
    
    // 2. æ£€æŸ¥userSettingsçŠ¶æ€
    console.log(`\nğŸ“Š userSettingsæ£€æŸ¥:`);
    console.log(`  - userSettingså­˜åœ¨: ${!!userSettings}`);
    console.log(`  - articulationså­˜åœ¨: ${!!userSettings?.articulations}`);
    console.log(`  - frequencieså­˜åœ¨: ${!!userSettings?.articulations?.frequencies}`);
    
    if (userSettings?.articulations?.frequencies) {
        console.log(`  - hammeré¢‘ç‡: ${userSettings.articulations.frequencies.hammer}%`);
        console.log(`  - pullé¢‘ç‡: ${userSettings.articulations.frequencies.pull}%`);
    }
    
    // 3. æ£€æŸ¥å¤é€‰æ¡†çŠ¶æ€
    const hammerCheckboxTest = document.getElementById('gtr-hammer');
    const pullCheckboxTest = document.getElementById('gtr-pull');
    console.log(`\nğŸ›ï¸ å¤é€‰æ¡†çŠ¶æ€æ£€æŸ¥:`);
    console.log(`  - hammer-onå¤é€‰æ¡†: ${hammerCheckboxTest ? (hammerCheckboxTest.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰') : 'âŒä¸å­˜åœ¨'}`);
    console.log(`  - pull-offå¤é€‰æ¡†: ${pullCheckboxTest ? (pullCheckboxTest.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰') : 'âŒä¸å­˜åœ¨'}`);
    
    // 4. æµ‹è¯•shouldGenerateDirectionalSlurå‡½æ•°
    console.log(`\nğŸ¯ shouldGenerateDirectionalSluræµ‹è¯•:`);
    const testIntervals = [1, 2, -1, -2, 3, -3];
    testIntervals.forEach(interval => {
        console.log(`\nğŸ” æµ‹è¯•éŸ³ç¨‹ ${interval}:`);
        const result = shouldGenerateDirectionalSlur(interval);
        console.log(`  ç»“æœ: ${result ? 'âœ…å…è®¸ç”Ÿæˆ' : 'âŒé˜»æ­¢ç”Ÿæˆ'}`);
    });
    
    // 5. æ¨¡æ‹Ÿé¢‘ç‡æ§åˆ¶æµ‹è¯•
    if (userSettings?.articulations?.frequencies) {
        console.log(`\nğŸ”§ æ¨¡æ‹Ÿé¢‘ç‡æµ‹è¯•:`);
        
        // ä¸´æ—¶ä¿å­˜åŸå§‹å€¼
        const originalHammer = userSettings.articulations.frequencies.hammer;
        const originalPull = userSettings.articulations.frequencies.pull;
        
        // æµ‹è¯•0%é¢‘ç‡
        console.log(`  è®¾ç½®é¢‘ç‡ä¸º0%æµ‹è¯•:`);
        userSettings.articulations.frequencies.hammer = 0;
        userSettings.articulations.frequencies.pull = 0;
        
        testIntervals.forEach(interval => {
            if (interval === 1 || interval === 2 || interval === -1 || interval === -2) {
                const result = shouldGenerateDirectionalSlur(interval);
                console.log(`    éŸ³ç¨‹${interval}: ${result ? 'âš ï¸ä»ç„¶ç”Ÿæˆï¼ˆå¼‚å¸¸ï¼‰' : 'âœ…æ­£ç¡®é˜»æ­¢'}`);
            }
        });
        
        // æ¢å¤åŸå§‹å€¼
        userSettings.articulations.frequencies.hammer = originalHammer;
        userSettings.articulations.frequencies.pull = originalPull;
        console.log(`  å·²æ¢å¤åŸå§‹é¢‘ç‡è®¾ç½®`);
    }
    
    // 6. ç»™å‡ºè¯¦ç»†çš„æµ‹è¯•æŒ‡å—
    const hammerCheckboxGuide = document.getElementById('gtr-hammer');
    const pullCheckboxGuide = document.getElementById('gtr-pull');
    const hammerChecked = hammerCheckboxGuide?.checked;
    const pullChecked = pullCheckboxGuide?.checked;
    
    console.log(`\nğŸ“‹ === å®Œæ•´æµ‹è¯•æŒ‡å— ===`);
    
    console.log(`\nğŸ”§ å½“å‰çŠ¶æ€æ£€æŸ¥:`);
    console.log(`  - Hammer-onå¤é€‰æ¡†å·²å‹¾é€‰: ${hammerChecked ? 'âœ…' : 'âŒ éœ€è¦å‹¾é€‰'}`);
    console.log(`  - Pull-offå¤é€‰æ¡†å·²å‹¾é€‰: ${pullChecked ? 'âœ…' : 'âŒ éœ€è¦å‹¾é€‰'}`);
    console.log(`  - å½“å‰è°±å·: ${document.getElementById('clef')?.value || 'unknown'}`);
    
    if (!hammerChecked || !pullChecked) {
        console.log(`\nâš ï¸ å…³é”®é—®é¢˜å‘ç°ï¼š`);
        console.log(`  å¤é€‰æ¡†æœªå‹¾é€‰ï¼è¿™ä¼šé˜»æ­¢æ‰€æœ‰hammer-on/pull-offçš„ç”Ÿæˆ`);
        console.log(`  é¢‘ç‡æ§åˆ¶åªæœ‰åœ¨å‹¾é€‰å¯¹åº”å¤é€‰æ¡†åæ‰æœ‰æ•ˆ`);
    }
    
    console.log(`\nğŸ§ª å®Œæ•´æµ‹è¯•æ­¥éª¤:`);
    console.log(`  1. ã€è®¾ç½®Articulationã€‘`);
    console.log(`     - ç‚¹å‡»"Articulation & Ornaments"æŒ‰é’®`);
    console.log(`     - å‹¾é€‰"Hammer-on (H)"å’Œ"Pull-off (P)"`);
    console.log(`     - ç‚¹å‡»"é«˜çº§è®¾ç½®"å±•å¼€é¢‘ç‡æ§åˆ¶é¢æ¿`);
    
    console.log(`  2. ã€è°ƒèŠ‚é¢‘ç‡ã€‘`);
    console.log(`     - å°†"Hammer-on"æ‘‡æ†æ‹–åˆ°æœ€å·¦è¾¹(0%)`);
    console.log(`     - å°†"Pull-off"æ‘‡æ†æ‹–åˆ°æœ€å·¦è¾¹(0%)`);
    console.log(`     - æ£€æŸ¥æ˜¾ç¤ºæ˜¯å¦ä¸º"0%"`);
    
    console.log(`  3. ã€ä¿å­˜è®¾ç½®ã€‘`);
    console.log(`     - ç‚¹å‡»"ä¿å­˜"æŒ‰é’®å…³é—­è®¾ç½®é¢æ¿`);
    console.log(`     - åº”è¯¥çœ‹åˆ°"âœ… æ¼”å¥æ³•é¢‘ç‡è®¾ç½®"æ¶ˆæ¯`);
    
    console.log(`  4. ã€é€‰æ‹©åˆé€‚çš„é…ç½®ã€‘`);
    console.log(`     - ç¡®ä¿é€‰æ‹©"é«˜éŸ³è°±å·(Treble Clef)"`);
    console.log(`     - é€‰æ‹©è¾ƒå°çš„éŸ³åŸŸèŒƒå›´å¢åŠ äºŒåº¦éŸ³ç¨‹æ¦‚ç‡`);
    
    console.log(`  5. ã€ç”Ÿæˆå’ŒéªŒè¯ã€‘`);
    console.log(`     - ç‚¹å‡»"ç”Ÿæˆæ–°æ—‹å¾‹"å¤šæ¬¡(3-5æ¬¡)`);
    console.log(`     - è§‚å¯Ÿæ§åˆ¶å°è¾“å‡ºæ˜¯å¦æ˜¾ç¤º:`);
    console.log(`       "ğŸš« ä¸Šè¡ŒäºŒåº¦slurè¢«é˜»æ­¢ï¼šhammer-oné¢‘ç‡ä¸º0%"`);
    console.log(`       "ğŸš« ä¸‹è¡ŒäºŒåº¦slurè¢«é˜»æ­¢ï¼špull-offé¢‘ç‡ä¸º0%"`);
    console.log(`     - æ£€æŸ¥ä¹è°±ä¸­æ˜¯å¦å®Œå…¨æ²¡æœ‰slurè¿çº¿`);
    
    console.log(`\nâœ… å¦‚æœæµ‹è¯•æˆåŠŸ:`);
    console.log(`  - å°†æ‘‡æ†è°ƒå›100%ï¼Œåº”è¯¥é‡æ–°å‡ºç°hammer-on/pull-off`);
    console.log(`  - è°ƒåˆ°50%ï¼Œåº”è¯¥å‡å°‘å‡ºç°é¢‘ç‡`);
    
    console.log(`\nâš ï¸ å¸¸è§é—®é¢˜æ’é™¤:`);
    console.log(`  - é—®é¢˜ï¼šæ²¡æœ‰æ§åˆ¶å°è¾“å‡º â†’ æ£€æŸ¥æ˜¯å¦å‹¾é€‰äº†å¤é€‰æ¡†`);
    console.log(`  - é—®é¢˜ï¼šä»æœ‰slurå‡ºç° â†’ æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†"ä¿å­˜"æŒ‰é’®`);
    console.log(`  - é—®é¢˜ï¼šæ ¹æœ¬æ²¡æœ‰slur â†’ æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†é«˜éŸ³è°±å·`);
    console.log(`  - é—®é¢˜ï¼šå¾ˆå°‘æœ‰äºŒåº¦éŸ³ç¨‹ â†’ å‡å°éŸ³åŸŸèŒƒå›´ï¼Œå¢åŠ äºŒåº¦æ¦‚ç‡`);
    
    console.log(`\nğŸ§ª === æµ‹è¯•ç»“æŸ ===\n`);
    
    return {
        uiElements: {
            hammerSlider: !!hammerSlider,
            pullSlider: !!pullSlider,
            hammerDisplay: !!hammerDisplay,
            pullDisplay: !!pullDisplay
        },
        checkboxes: {
            hammerChecked: hammerCheckbox?.checked,
            pullChecked: pullCheckbox?.checked
        },
        frequencies: userSettings?.articulations?.frequencies,
        sliderValues: {
            hammer: hammerSlider?.value,
            pull: pullSlider?.value
        }
    };
}

// å°†æµ‹è¯•å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œæ–¹ä¾¿åœ¨æ§åˆ¶å°è°ƒç”¨
window.testFrequencyControl = testFrequencyControl;

/**
 * ğŸ” 6/8æ‹é™„ç‚¹éŸ³ç¬¦ç»¼åˆæµ‹è¯•å‡½æ•°
 * ç”¨æ³•ï¼šåœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ test68DottedNotes()
 */
function test68DottedNotes() {
    console.log(`\nğŸ§ª === 6/8æ‹é™„ç‚¹éŸ³ç¬¦ç»¼åˆæµ‹è¯• ===`);
    
    // 1. æ£€æŸ¥UIçŠ¶æ€
    console.log(`\nğŸ“‹ UIçŠ¶æ€æ£€æŸ¥:`);
    const dottedHalfCheckbox = document.getElementById('rhythm-dotted-half');
    const dottedQuarterCheckbox = document.getElementById('rhythm-dotted-quarter');
    const timeSignatureSelect = document.getElementById('timeSignature');
    
    console.log(`  - æ‹å·è®¾ç½®: ${timeSignatureSelect?.value || 'unknown'}`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å¤é€‰æ¡†å­˜åœ¨: ${!!dottedHalfCheckbox}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦å¤é€‰æ¡†å­˜åœ¨: ${!!dottedQuarterCheckbox}`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å·²å‹¾é€‰: ${dottedHalfCheckbox?.checked || false}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦å·²å‹¾é€‰: ${dottedQuarterCheckbox?.checked || false}`);
    
    // 2. æ£€æŸ¥é¢‘ç‡æ§åˆ¶
    console.log(`\nğŸ›ï¸ é¢‘ç‡æ§åˆ¶æ£€æŸ¥:`);
    const dottedHalfSlider = document.getElementById('freq-dotted-half');
    const dottedQuarterSlider = document.getElementById('freq-dotted-quarter');
    
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡æ‘‡æ†å­˜åœ¨: ${!!dottedHalfSlider}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡æ‘‡æ†å­˜åœ¨: ${!!dottedQuarterSlider}`);
    if (dottedHalfSlider) {
        console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®: ${dottedHalfSlider.value}%`);
    }
    if (dottedQuarterSlider) {
        console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®: ${dottedQuarterSlider.value}%`);
    }
    
    // 3. æ£€æŸ¥userSettingsçŠ¶æ€
    console.log(`\nâš™ï¸ ç”¨æˆ·è®¾ç½®æ£€æŸ¥:`);
    console.log(`  - userSettingså­˜åœ¨: ${!!userSettings}`);
    console.log(`  - allowedRhythms: [${userSettings?.allowedRhythms?.join(', ') || 'undefined'}]`);
    console.log(`  - rhythmFrequencieså­˜åœ¨: ${!!userSettings?.rhythmFrequencies}`);
    if (userSettings?.rhythmFrequencies) {
        console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡: ${userSettings.rhythmFrequencies['dotted-half']}%`);
        console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡: ${userSettings.rhythmFrequencies['dotted-quarter']}%`);
    }
    
    // 4. æµ‹è¯•6/8æ‹èŠ‚å¥è½¬æ¢
    console.log(`\nğŸ”„ èŠ‚å¥è½¬æ¢æµ‹è¯•:`);
    if (userSettings?.allowedRhythms) {
        const testGenerator = new IntelligentMelodyGenerator(1, 'C', '6/8', 'treble', 12345);
        console.log(`  - è½¬æ¢å‰ç”¨æˆ·èŠ‚å¥: [${userSettings.allowedRhythms.join(', ')}]`);
        console.log(`  - è½¬æ¢åç”Ÿæˆå™¨èŠ‚å¥: [${testGenerator.rules.allowedDurations.join(', ')}]`);
        console.log(`  - åŒ…å«half.: ${testGenerator.rules.allowedDurations.includes('half.') ? 'âœ…' : 'âŒ'}`);
        console.log(`  - åŒ…å«quarter.: ${testGenerator.rules.allowedDurations.includes('quarter.') ? 'âœ…' : 'âŒ'}`);
    }
    
    // 5. ç»™å‡ºè¯Šæ–­å»ºè®®
    console.log(`\nğŸ’¡ è¯Šæ–­ç»“æœå’Œå»ºè®®:`);
    
    if (timeSignatureSelect?.value !== '6/8') {
        console.log(`  âš ï¸ å½“å‰æ‹å·ä¸æ˜¯6/8ï¼Œè¯·å…ˆåˆ‡æ¢åˆ°6/8æ‹`);
    }
    
    if (!dottedHalfCheckbox?.checked && !dottedQuarterCheckbox?.checked) {
        console.log(`  âš ï¸ æœªå‹¾é€‰é™„ç‚¹éŸ³ç¬¦ï¼Œè¯·åœ¨èŠ‚å¥è®¾ç½®ä¸­å‹¾é€‰é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å’Œ/æˆ–é™„ç‚¹å››åˆ†éŸ³ç¬¦`);
    }
    
    if (dottedHalfSlider && dottedHalfSlider.value === '0') {
        console.log(`  âš ï¸ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œè¯·è°ƒæ•´åˆ°é€‚å½“å€¼ï¼ˆå»ºè®®50-100%ï¼‰`);
    }
    
    console.log(`\nâœ… å¦‚æœä»¥ä¸Šæ£€æŸ¥éƒ½æ­£å¸¸ï¼Œç°åœ¨é™„ç‚¹éŸ³ç¬¦åº”è¯¥èƒ½æ­£å¸¸ç”Ÿæˆäº†ï¼`);
    console.log(`ğŸ§ª === æµ‹è¯•ç»“æŸ ===\n`);
}

window.test68DottedNotes = test68DottedNotes;

/**
 * ğŸ” æµ‹è¯•ç”Ÿæˆæ—‹å¾‹æ—¶é™„ç‚¹éŸ³ç¬¦çŠ¶æ€ä¿æŒ
 * ç”¨æ³•ï¼šåœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ testDottedNotesPersistence()
 */
function testDottedNotesPersistence() {
    console.log(`\nğŸ§ª === é™„ç‚¹éŸ³ç¬¦çŠ¶æ€ä¿æŒæµ‹è¯• ===`);
    
    // 1. æ£€æŸ¥å½“å‰è®¾ç½®
    const dottedHalfCheckbox = document.getElementById('rhythm-dotted-half');
    const dottedQuarterCheckbox = document.getElementById('rhythm-dotted-quarter');
    const timeSignatureSelect = document.getElementById('timeSignature');
    
    console.log(`\nğŸ“‹ æµ‹è¯•å‰çŠ¶æ€:`);
    console.log(`  - æ‹å·: ${timeSignatureSelect?.value}`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦: ${dottedHalfCheckbox?.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰'}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦: ${dottedQuarterCheckbox?.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰'}`);
    
    // 2. æ¨¡æ‹ŸupdateRhythmSettingsRealTimeè°ƒç”¨
    console.log(`\nğŸ”„ æ¨¡æ‹ŸupdateRhythmSettingsRealTimeè°ƒç”¨:`);
    const originalConsoleLog = console.log;
    let capturedLogs = [];
    console.log = function(...args) {
        capturedLogs.push(args.join(' '));
        originalConsoleLog.apply(console, args);
    };
    
    try {
        updateRhythmSettingsRealTime();
    } catch (error) {
        console.error('âŒ updateRhythmSettingsRealTimeè°ƒç”¨å‡ºé”™:', error);
    } finally {
        console.log = originalConsoleLog;
    }
    
    // 3. æ£€æŸ¥è°ƒç”¨åçŠ¶æ€
    console.log(`\nğŸ“‹ è°ƒç”¨åçŠ¶æ€:`);
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦: ${dottedHalfCheckbox?.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰'}`);
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦: ${dottedQuarterCheckbox?.checked ? 'âœ…å‹¾é€‰' : 'âŒæœªå‹¾é€‰'}`);
    console.log(`  - userSettings.allowedRhythms: [${userSettings?.allowedRhythms?.join(', ') || 'undefined'}]`);
    
    // 4. æ£€æŸ¥æ˜¯å¦æœ‰çŠ¶æ€å˜åŒ–
    const dottedHalfAfter = dottedHalfCheckbox?.checked;
    const dottedQuarterAfter = dottedQuarterCheckbox?.checked;
    
    console.log(`\nğŸ’¡ æµ‹è¯•ç»“æœ:`);
    if (dottedHalfAfter && dottedQuarterAfter) {
        console.log(`  âœ… é™„ç‚¹éŸ³ç¬¦çŠ¶æ€ä¿æŒè‰¯å¥½`);
    } else {
        console.log(`  âš ï¸ é™„ç‚¹éŸ³ç¬¦çŠ¶æ€å¯èƒ½æœ‰é—®é¢˜`);
        console.log(`  å»ºè®®æ£€æŸ¥updateRhythmOptionsForTimeSignatureå‡½æ•°`);
    }
    
    // 5. æ˜¾ç¤ºç›¸å…³çš„æ•è·æ—¥å¿—
    console.log(`\nğŸ“ ç›¸å…³æ—¥å¿—:`);
    const relevantLogs = capturedLogs.filter(log => 
        log.includes('dotted') || log.includes('é™„ç‚¹') || log.includes('rhythm-')
    );
    relevantLogs.forEach(log => console.log(`  ${log}`));
    
    console.log(`\nğŸ§ª === æµ‹è¯•ç»“æŸ ===\n`);
}

window.testDottedNotesPersistence = testDottedNotesPersistence;

/**
 * ğŸ” ä¸“é—¨æµ‹è¯•hammer-on/pull-offé¢‘ç‡æ§åˆ¶çš„å®Œæ•´æµç¨‹
 * ç”¨æ³•ï¼šåœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ testHammerPullFrequencyControl()
 */
function testHammerPullFrequencyControl() {
    console.log(`\nğŸ§ª === Hammer-on/Pull-offé¢‘ç‡æ§åˆ¶å®Œæ•´æµ‹è¯• ===`);
    
    // 1. æ£€æŸ¥UIå…ƒç´ 
    const hammerSlider = document.getElementById('freq-hammer');
    const pullSlider = document.getElementById('freq-pull');
    const hammerCheckbox = document.getElementById('gtr-hammer');
    const pullCheckbox = document.getElementById('gtr-pull');
    const clefSelect = document.getElementById('clef');
    
    console.log(`\nğŸ“‹ UIçŠ¶æ€æ£€æŸ¥:`);
    console.log(`  - Hammeræ‘‡æ†å­˜åœ¨: ${!!hammerSlider} ${hammerSlider ? `(å€¼: ${hammerSlider.value}%)` : ''}`);
    console.log(`  - Pullæ‘‡æ†å­˜åœ¨: ${!!pullSlider} ${pullSlider ? `(å€¼: ${pullSlider.value}%)` : ''}`);
    console.log(`  - Hammerå¤é€‰æ¡†å‹¾é€‰: ${hammerCheckbox?.checked ? 'âœ…' : 'âŒ'}`);
    console.log(`  - Pullå¤é€‰æ¡†å‹¾é€‰: ${pullCheckbox?.checked ? 'âœ…' : 'âŒ'}`);
    console.log(`  - å½“å‰è°±å·: ${clefSelect?.value || 'unknown'}`);
    
    if (clefSelect?.value !== 'treble') {
        console.log(`  âš ï¸ è­¦å‘Š: å½“å‰ä¸æ˜¯é«˜éŸ³è°±å·ï¼Œå‰ä»–æŠ€å·§ä»…åœ¨é«˜éŸ³è°±å·ä¸‹å·¥ä½œ`);
    }
    
    // 2. æ£€æŸ¥userSettings
    console.log(`\nâš™ï¸ ç”¨æˆ·è®¾ç½®æ£€æŸ¥:`);
    console.log(`  - userSettingså­˜åœ¨: ${!!userSettings}`);
    console.log(`  - guitarè®¾ç½®: [${userSettings?.articulations?.guitar?.join(', ') || 'none'}]`);
    console.log(`  - é¢‘ç‡è®¾ç½®å­˜åœ¨: ${!!userSettings?.articulations?.frequencies}`);
    if (userSettings?.articulations?.frequencies) {
        console.log(`  - Hammeré¢‘ç‡: ${userSettings.articulations.frequencies.hammer}%`);
        console.log(`  - Pullé¢‘ç‡: ${userSettings.articulations.frequencies.pull}%`);
    }
    
    // 3. æµ‹è¯•shouldGenerateDirectionalSlurå‡½æ•°
    console.log(`\nğŸ¯ å‡½æ•°æµ‹è¯•:`);
    
    // æµ‹è¯•ä¸Šè¡ŒéŸ³ç¨‹(hammer-on)
    console.log(`  ä¸Šè¡ŒéŸ³ç¨‹æµ‹è¯• (hammer-on):`);
    for (const interval of [1, 2]) {
        const result = shouldGenerateDirectionalSlur(interval);
        console.log(`    éŸ³ç¨‹+${interval}: ${result ? 'âœ…å…è®¸' : 'âŒé˜»æ­¢'}`);
    }
    
    // æµ‹è¯•ä¸‹è¡ŒéŸ³ç¨‹(pull-off)
    console.log(`  ä¸‹è¡ŒéŸ³ç¨‹æµ‹è¯• (pull-off):`);
    for (const interval of [-1, -2]) {
        const result = shouldGenerateDirectionalSlur(interval);
        console.log(`    éŸ³ç¨‹${interval}: ${result ? 'âœ…å…è®¸' : 'âŒé˜»æ­¢'}`);
    }
    
    // 4. æ¨¡æ‹Ÿæ‘‡æ†è°ƒæ•´åˆ°0%çš„æµ‹è¯•
    console.log(`\nğŸ”§ é›¶é¢‘ç‡æµ‹è¯•:`);
    if (hammerSlider && pullSlider) {
        // ä¿å­˜åŸå§‹å€¼
        const originalHammer = hammerSlider.value;
        const originalPull = pullSlider.value;
        
        // è®¾ç½®ä¸º0%
        hammerSlider.value = 0;
        pullSlider.value = 0;
        
        // è§¦å‘äº‹ä»¶
        hammerSlider.dispatchEvent(new Event('input'));
        pullSlider.dispatchEvent(new Event('input'));
        
        console.log(`  è®¾ç½®æ‘‡æ†ä¸º0%å:`);
        console.log(`    Hammeré¢‘ç‡: ${userSettings?.articulations?.frequencies?.hammer}%`);
        console.log(`    Pullé¢‘ç‡: ${userSettings?.articulations?.frequencies?.pull}%`);
        
        // æµ‹è¯•å‡½æ•°å“åº”
        const hammerBlocked = !shouldGenerateDirectionalSlur(1);
        const pullBlocked = !shouldGenerateDirectionalSlur(-1);
        
        console.log(`    éŸ³ç¨‹+1è¢«é˜»æ­¢: ${hammerBlocked ? 'âœ…æ­£ç¡®' : 'âŒé”™è¯¯'}`);
        console.log(`    éŸ³ç¨‹-1è¢«é˜»æ­¢: ${pullBlocked ? 'âœ…æ­£ç¡®' : 'âŒé”™è¯¯'}`);
        
        // æ¢å¤åŸå§‹å€¼
        hammerSlider.value = originalHammer;
        pullSlider.value = originalPull;
        hammerSlider.dispatchEvent(new Event('input'));
        pullSlider.dispatchEvent(new Event('input'));
        
        console.log(`  å·²æ¢å¤åŸå§‹è®¾ç½®`);
    }
    
    // 5. ç»™å‡ºè¯Šæ–­ç»“æœ
    console.log(`\nğŸ’¡ è¯Šæ–­ç»“æœ:`);
    
    const requiredConditions = [
        { name: 'é«˜éŸ³è°±å·', passed: clefSelect?.value === 'treble' },
        { name: 'Hammer-onå¤é€‰æ¡†å‹¾é€‰', passed: hammerCheckbox?.checked },
        { name: 'Pull-offå¤é€‰æ¡†å‹¾é€‰', passed: pullCheckbox?.checked },
        { name: 'æ‘‡æ†å…ƒç´ å­˜åœ¨', passed: !!hammerSlider && !!pullSlider },
        { name: 'é¢‘ç‡è®¾ç½®å­˜åœ¨', passed: !!userSettings?.articulations?.frequencies }
    ];
    
    requiredConditions.forEach(condition => {
        console.log(`  ${condition.name}: ${condition.passed ? 'âœ…' : 'âŒ'}`);
    });
    
    const allPassed = requiredConditions.every(c => c.passed);
    
    if (allPassed) {
        console.log(`\nâœ… æ‰€æœ‰æ¡ä»¶æ»¡è¶³ï¼é¢‘ç‡æ§åˆ¶åº”è¯¥æ­£å¸¸å·¥ä½œã€‚`);
        console.log(`ğŸ“ æµ‹è¯•æ­¥éª¤ï¼š`);
        console.log(`  1. å°†æ‘‡æ†è°ƒåˆ°0%`);
        console.log(`  2. ç”Ÿæˆæ—‹å¾‹å¤šæ¬¡`);
        console.log(`  3. è§‚å¯Ÿæ§åˆ¶å°è¾“å‡ºåº”è¯¥æ˜¾ç¤º"é¢‘ç‡æ§åˆ¶é˜»æ­¢"ä¿¡æ¯`);
        console.log(`  4. ä¹è°±ä¸­ä¸åº”å‡ºç°hammer-on/pull-offè¿éŸ³çº¿`);
    } else {
        console.log(`\nâš ï¸ å‘ç°é—®é¢˜ï¼è¯·å…ˆè§£å†³ä»¥ä¸Šæ ‡è®°ä¸ºâŒçš„æ¡ä»¶ã€‚`);
    }
    
    console.log(`\nğŸ§ª === æµ‹è¯•ç»“æŸ ===\n`);
}

window.testHammerPullFrequencyControl = testHammerPullFrequencyControl;
window.testNewFrequencyControl = testNewFrequencyControl;
window.testDottedNoteFrequencyControl = testDottedNoteFrequencyControl;
window.testSlurFrequencyControl = testSlurFrequencyControl;
window.testStrictDottedNoteSelection = testStrictDottedNoteSelection;

/**
 * ğŸ”§ ç®€åŒ–çš„å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶æµ‹è¯•
 */
function testSlurFrequencySimple() {
    console.log('ğŸ¸ === å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶ç®€åŒ–æµ‹è¯• ===');
    
    // æ£€æŸ¥UIå…ƒç´ 
    const slurSlider = document.getElementById('freq-slur');
    const slurValueDisplay = document.getElementById('freq-slur-value');
    
    console.log('ğŸ“‹ UIçŠ¶æ€:');
    console.log(`  - å‡»å‹¾å¼¦æ»‘å—å­˜åœ¨: ${!!slurSlider}`);
    console.log(`  - å½“å‰æ»‘å—å€¼: ${slurSlider?.value}`);
    console.log(`  - æ˜¾ç¤ºå€¼: ${slurValueDisplay?.textContent}`);
    console.log(`  - userSettingsä¸­çš„å€¼: ${userSettings?.articulations?.frequencies?.slur}`);
    
    if (!slurSlider) {
        console.log('âŒ æ»‘å—ä¸å­˜åœ¨ï¼Œæµ‹è¯•ç»“æŸ');
        return;
    }
    
    // æµ‹è¯•æ»‘å—æ›´æ–°åŠŸèƒ½
    console.log('\nğŸ”§ æµ‹è¯•æ»‘å—æ›´æ–°:');
    const testValues = [0, 25, 50, 100];
    
    testValues.forEach(value => {
        console.log(`\nè®¾ç½®é¢‘ç‡ä¸º ${value}%:`);
        
        slurSlider.value = value;
        slurSlider.dispatchEvent(new Event('input'));
        
        console.log(`  - æ»‘å—å€¼: ${slurSlider.value}`);
        console.log(`  - æ˜¾ç¤ºå€¼: ${slurValueDisplay?.textContent}`);
        console.log(`  - userSettingså€¼: ${userSettings?.articulations?.frequencies?.slur}`);
        
        // æµ‹è¯•å‡½æ•°å“åº”
        const testResult1 = shouldGenerateDirectionalSlur(1);
        const testResult2 = shouldGenerateDirectionalSlur(-1);
        console.log(`  - éŸ³ç¨‹+1æµ‹è¯•: ${testResult1 ? 'âœ…ä¼šç”Ÿæˆ' : 'âŒä¸ç”Ÿæˆ'}`);
        console.log(`  - éŸ³ç¨‹-1æµ‹è¯•: ${testResult2 ? 'âœ…ä¼šç”Ÿæˆ' : 'âŒä¸ç”Ÿæˆ'}`);
    });
    
    // æ¢å¤é»˜è®¤å€¼
    slurSlider.value = 15;
    slurSlider.dispatchEvent(new Event('input'));
    
    console.log('\nğŸ¸ === æµ‹è¯•å®Œæˆ ===');
}

window.testSlurFrequencySimple = testSlurFrequencySimple;

// ====== æ­£ç¡®çš„éŸ³ä¹ç†è®ºç³»ç»Ÿ ======

// æ ‡å‡†éŸ³é˜¶å®šä¹‰ï¼ˆæ‰‹åŠ¨å®šä¹‰ï¼Œç¡®ä¿æ­£ç¡®ï¼‰
const KEY_SCALES = {
    // å¤§è°ƒéŸ³é˜¶
    'C': [0, 2, 4, 5, 7, 9, 11],    // Cå¤§è°ƒ: C D E F G A B
    'G': [7, 9, 11, 0, 2, 4, 6],    // Gå¤§è°ƒ: G A B C D E F#
    'D': [2, 4, 6, 7, 9, 11, 1],    // Då¤§è°ƒ: D E F# G A B C#
    'A': [9, 11, 1, 2, 4, 6, 8],    // Aå¤§è°ƒ: A B C# D E F# G#
    'E': [4, 6, 8, 9, 11, 1, 3],    // Eå¤§è°ƒ: E F# G# A B C# D#
    'B': [11, 1, 3, 4, 6, 8, 10],   // Bå¤§è°ƒ: B C# D# E F# G# A#
    'F#': [6, 8, 10, 11, 1, 3, 5],  // F#å¤§è°ƒ: F# G# A# B C# D# E#(F)
    'F': [5, 7, 9, 10, 0, 2, 4],    // Få¤§è°ƒ: F G A Bb C D E
    'Bb': [10, 0, 2, 3, 5, 7, 9],   // Bbå¤§è°ƒ: Bb C D Eb F G A
    'Eb': [3, 5, 7, 8, 10, 0, 2],   // Ebå¤§è°ƒ: Eb F G Ab Bb C D
    'Ab': [8, 10, 0, 1, 3, 5, 7],   // Abå¤§è°ƒ: Ab Bb C Db Eb F G
    'Db': [1, 3, 5, 6, 8, 10, 0],   // Dbå¤§è°ƒ: Db Eb F Gb Ab Bb C
    'Gb': [6, 8, 10, 11, 1, 3, 5],  // Gbå¤§è°ƒ: Gb Ab Bb Cb(B) Db Eb F
    
    // å°è°ƒéŸ³é˜¶ï¼ˆè‡ªç„¶å°è°ƒï¼‰
    'Am': [9, 11, 0, 2, 4, 5, 7],   // Aå°è°ƒ: A B C D E F G
    'Em': [4, 6, 7, 9, 11, 0, 2],   // Eå°è°ƒ: E F# G A B C D
    'Bm': [11, 1, 2, 4, 6, 7, 9],   // Bå°è°ƒ: B C# D E F# G A
    'F#m': [6, 8, 9, 11, 1, 2, 4],  // F#å°è°ƒ: F# G# A B C# D E
    'C#m': [1, 3, 4, 6, 8, 9, 11],  // C#å°è°ƒ: C# D# E F# G# A B
    'G#m': [8, 10, 11, 1, 3, 4, 6], // G#å°è°ƒ: G# A# B C# D# E F#
    'D#m': [3, 5, 6, 8, 10, 11, 1], // D#å°è°ƒ: D# E# F# G# A# B C#
    'A#m': [10, 0, 1, 3, 5, 6, 8],  // A#å°è°ƒ: A# B# C# D# E# F# G#
    'Dm': [2, 4, 5, 7, 9, 10, 0],   // Då°è°ƒ: D E F G A Bb C
    'Gm': [7, 9, 10, 0, 2, 3, 5],   // Gå°è°ƒ: G A Bb C D Eb F
    'Cm': [0, 2, 3, 5, 7, 8, 10],   // Cå°è°ƒ: C D Eb F G Ab Bb
    'Fm': [5, 7, 8, 10, 0, 1, 3],   // Få°è°ƒ: F G Ab Bb C Db Eb
    'Bbm': [10, 0, 1, 3, 5, 6, 8],  // Bbå°è°ƒ: Bb C Db Eb F Gb Ab
    'Ebm': [3, 5, 6, 8, 10, 11, 1], // Ebå°è°ƒ: Eb F Gb Ab Bb Cb(B) Db
};

// è°ƒå·çš„å‡é™å·å®šä¹‰ï¼ˆç”¨äºæ£€æµ‹ä¸´æ—¶è®°å·å†²çªï¼‰
const KEY_SIGNATURES = {
    // å¤§è°ƒ
    'C': { sharps: [], flats: [], tonic: 0 },
    'G': { sharps: [6], flats: [], tonic: 7 },     // F#
    'D': { sharps: [6, 1], flats: [], tonic: 2 },  // F#, C#
    'A': { sharps: [6, 1, 8], flats: [], tonic: 9 }, // F#, C#, G#
    'E': { sharps: [6, 1, 8, 3], flats: [], tonic: 4 }, // F#, C#, G#, D#
    'B': { sharps: [6, 1, 8, 3, 10], flats: [], tonic: 11 }, // F#, C#, G#, D#, A#
    'F#': { sharps: [6, 1, 8, 3, 10, 5], flats: [], tonic: 6 }, // F#, C#, G#, D#, A#, E#
    'F': { sharps: [], flats: [10], tonic: 5 },     // Bb
    'Bb': { sharps: [], flats: [10, 3], tonic: 10 }, // Bb, Eb
    'Eb': { sharps: [], flats: [10, 3, 8], tonic: 3 }, // Bb, Eb, Ab
    'Ab': { sharps: [], flats: [10, 3, 8, 1], tonic: 8 }, // Bb, Eb, Ab, Db
    'Db': { sharps: [], flats: [10, 3, 8, 1, 6], tonic: 1 }, // Bb, Eb, Ab, Db, Gb
    'Gb': { sharps: [], flats: [10, 3, 8, 1, 6, 11], tonic: 6 }, // Bb, Eb, Ab, Db, Gb, Cb
    
    // å°è°ƒï¼ˆç»§æ‰¿ç›¸å¯¹å¤§è°ƒçš„è°ƒå·ï¼‰
    'Am': { sharps: [], flats: [], tonic: 9, mode: 'minor' },
    'Em': { sharps: [6], flats: [], tonic: 4, mode: 'minor' },
    'Bm': { sharps: [6, 1], flats: [], tonic: 11, mode: 'minor' },
    'F#m': { sharps: [6, 1, 8], flats: [], tonic: 6, mode: 'minor' },
    'C#m': { sharps: [6, 1, 8, 3], flats: [], tonic: 1, mode: 'minor' },
    'G#m': { sharps: [6, 1, 8, 3, 10], flats: [], tonic: 8, mode: 'minor' },
    'D#m': { sharps: [6, 1, 8, 3, 10, 5], flats: [], tonic: 3, mode: 'minor' },
    'A#m': { sharps: [6, 1, 8, 3, 10, 5, 0], flats: [], tonic: 10, mode: 'minor' },
    'Dm': { sharps: [], flats: [10], tonic: 2, mode: 'minor' },
    'Gm': { sharps: [], flats: [10, 3], tonic: 7, mode: 'minor' },
    'Cm': { sharps: [], flats: [10, 3, 8], tonic: 0, mode: 'minor' },
    'Fm': { sharps: [], flats: [10, 3, 8, 1], tonic: 5, mode: 'minor' },
    'Bbm': { sharps: [], flats: [10, 3, 8, 1, 6], tonic: 10, mode: 'minor' },
    'Ebm': { sharps: [], flats: [10, 3, 8, 1, 6, 11], tonic: 3, mode: 'minor' },
};

// ğŸµ ä¸“ä¸šè®°è°±è§„åˆ™ï¼šæ­£ç¡®çš„éŸ³åæ‹¼å†™æ˜ å°„è¡¨
const PROFESSIONAL_NOTATION_RULES = {
    // è®°è°±è§„åˆ™1ï¼šæ­£ç¡®ä½¿ç”¨éŸ³åï¼ˆEnharmonic spellingï¼‰
    getCorrectSpelling: function(pitchClass, keySignature) {
        const keyInfo = KEY_SIGNATURES[keySignature];
        if (!keyInfo) return this.defaultSpelling[pitchClass];
        
        // å°è°ƒçš„ç‰¹æ®Šå¤„ç† - ä½¿ç”¨ä¸“é—¨çš„å°è°ƒæ‹¼å†™è¡¨
        if (keyInfo.mode === 'minor' && typeof MINOR_KEY_SPELLING !== 'undefined') {
            const minorSpelling = MINOR_KEY_SPELLING[keySignature];
            if (minorSpelling && minorSpelling[pitchClass]) {
                return minorSpelling[pitchClass];
            }
        }
        
        // Special handling for B# in C# major
        if (pitchClass === 0) {
            if (keySignature === 'C#' || keySignature === 'C#m' || 
                keySignature === 'A#m') {
                return 'B#';
            }
        }
        
        // Special handling for E# in sharp keys
        if (pitchClass === 5) {
            if (keySignature === 'C#' || keySignature === 'C#m' || 
                keySignature === 'F#' || keySignature === 'F#m') {
                return 'E#';
            }
        }
        
        // Special handling for Cb in specific flat keys
        if (pitchClass === 11) {
            if (keySignature === 'Gb' || keySignature === 'Ebm') {
                return 'Cb';
            }
        }
        
        // æ ¹æ®è°ƒå·ç¡®å®šæ­£ç¡®çš„éŸ³åæ‹¼å†™
        const isSharpKey = keyInfo.sharps.length > 0;
        const isFlatKey = keyInfo.flats.length > 0;
        
        if (isSharpKey) {
            return this.sharpKeySpelling[pitchClass];
        } else if (isFlatKey) {
            return this.flatKeySpelling[pitchClass];
        } else {
            return this.defaultSpelling[pitchClass];
        }
    },
    
    // å‡å·è°ƒçš„æ‹¼å†™è§„èŒƒ
    sharpKeySpelling: {
        0: 'C', 1: 'C#', 2: 'D', 3: 'D#', 4: 'E', 5: 'E#', 
        6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'A#', 11: 'B'
    },
    
    // é™å·è°ƒçš„æŠ¼å†™è§„èŒƒ
    flatKeySpelling: {
        0: 'C', 1: 'Db', 2: 'D', 3: 'Eb', 4: 'E', 5: 'F', 
        6: 'Gb', 7: 'G', 8: 'Ab', 9: 'A', 10: 'Bb', 11: 'B'
    },
    
    // é»˜è®¤æ‹¼å†™ï¼ˆCå¤§è°ƒ/Amå°è°ƒï¼‰
    // Aå°è°ƒåº”è¯¥ä½¿ç”¨G#è€Œä¸æ˜¯Abï¼ˆä½œä¸ºå’Œå£°å°è°ƒçš„å¯¼éŸ³ï¼‰
    defaultSpelling: {
        0: 'C', 1: 'C#', 2: 'D', 3: 'Eb', 4: 'E', 5: 'F', 
        6: 'F#', 7: 'G', 8: 'G#', 9: 'A', 10: 'Bb', 11: 'B'
    }
};

// ğŸµ ä¸“ä¸šè®°è°±è§„åˆ™ï¼šå’Œå¼¦æ‹¼å†™è§„èŒƒï¼ˆç¡®ä¿ä¸‰åº¦å †å ï¼‰
const CHORD_SPELLING_RULES = {
    // æ£€æŸ¥å’Œå¼¦æ‹¼å†™æ˜¯å¦ç¬¦åˆä¸‰åº¦å †å è§„èŒƒ
    validateChordSpelling: function(chordNotes, rootNote) {
        // ç¡®ä¿å’Œå¼¦å†…éŸ³ç¬¦æŒ‰ä¸‰åº¦å †å æ’åˆ—ï¼Œé¿å…ç­‰å“å¼‚åé”™è¯¯
        // ä¾‹å¦‚ï¼šCm åº”è¯¥æ˜¯ C-Eb-Gï¼Œä¸èƒ½å†™æˆ C-D#-G
        return true; // ç®€åŒ–å®ç°ï¼Œå®é™…å¯ä»¥æ›´å¤æ‚
    },
    
    // è·å–æ­£ç¡®çš„ä¸‰å’Œå¼¦æ‹¼å†™
    getTriadSpelling: function(root, quality, keySignature) {
        const rootPc = root % 12;
        const intervals = quality === 'major' ? [0, 4, 7] : [0, 3, 7]; // å¤§ä¸‰åº¦æˆ–å°ä¸‰åº¦
        
        return intervals.map(interval => {
            const notePc = (rootPc + interval) % 12;
            return PROFESSIONAL_NOTATION_RULES.getCorrectSpelling(notePc, keySignature);
        });
    }
};

// ğŸµ ä¸“ä¸šè®°è°±è§„åˆ™ï¼šèŠ‚å¥æ‹¼å†™è§„èŒƒ
// ç¬¦å¹²è¿æ¥ï¼ˆç¬¦æ§“ï¼‰è§„åˆ™ - è¯¦ç»†ç‰ˆæœ¬
const BEAMING_RULES = {
    
    /**
     * ç¬¦æ§“è¿æ¥æ ¸å¿ƒè§„åˆ™
     * åŸºäºå›½é™…éŸ³ä¹è®°è°±æ³•æ ‡å‡†å’Œä¸­æ–‡éŸ³ä¹ç†è®º
     */
    
    // 1. åŸºç¡€è¿æ¥è§„åˆ™
    basicRules: {
        // å¯ä»¥è¿æ¥ç¬¦æ§“çš„éŸ³ç¬¦ç±»å‹ï¼ˆåŒ…æ‹¬å››åˆ†éŸ³ç¬¦åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼‰
        beamableNotes: ['quarter', 'quarter.', 'eighth', 'eighth.', '16th', '16th.', '32nd', '64th'],
        
        // æœ€å°‘è¿æ¥æ•°é‡ï¼šè¿ç»­ä¸¤ä¸ªæˆ–ä»¥ä¸Šçš„æœ‰ç¬¦å°¾éŸ³ç¬¦å¯ä»¥è¿æ¥
        minimumGroupSize: 2,
        
        // ç¬¦æ§“ç±»å‹å¯¹åº”
        beamLevels: {
            'quarter': 1,   // å››åˆ†éŸ³ç¬¦ï¼š1æ¡ç¬¦æ§“ï¼ˆåœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼‰
            'quarter.': 1,  // é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼š1æ¡ç¬¦æ§“
            'eighth': 1,    // å…«åˆ†éŸ³ç¬¦ï¼š1æ¡ç¬¦æ§“
            'eighth.': 1,   // é™„ç‚¹å…«åˆ†éŸ³ç¬¦ï¼š1æ¡ç¬¦æ§“ï¼ˆä¸å…«åˆ†éŸ³ç¬¦ç›¸åŒï¼‰
            '16th': 2,      // åå…­åˆ†éŸ³ç¬¦ï¼š2æ¡ç¬¦æ§“
            '16th.': 2,     // é™„ç‚¹åå…­åˆ†éŸ³ç¬¦ï¼š2æ¡ç¬¦æ§“
            '32nd': 3,      // ä¸‰åäºŒåˆ†éŸ³ç¬¦ï¼š3æ¡ç¬¦æ§“
            '64th': 4       // å…­åå››åˆ†éŸ³ç¬¦ï¼š4æ¡ç¬¦æ§“
        }
    },
    
    // 2. æ‹å·ç›¸å…³è¿æ¥è§„åˆ™
    timeSignatureRules: {
        '4/4': {
            // 4/4æ‹ï¼šæŒ‰æ‹åˆ†ç»„ï¼Œä¸è·¨è¶Šå°èŠ‚ä¸­å¿ƒçº¿
            primaryBoundaries: [0, 2],      // å¼ºæ‹è¾¹ç•Œï¼ˆç¬¬1ã€3æ‹ï¼‰
            secondaryBoundaries: [1, 3],    // æ¬¡å¼ºæ‹è¾¹ç•Œï¼ˆç¬¬2ã€4æ‹ï¼‰
            subdivisionBoundaries: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5], // é»˜è®¤åŠæ‹è¾¹ç•Œï¼ˆå…«åˆ†éŸ³ç¬¦ç»†åˆ†ï¼‰
            
            rules: [
                "ä¸èƒ½è·¨è¶Šå°èŠ‚ä¸­å¿ƒçº¿ï¼ˆç¬¬2æ‹æœ«å°¾åˆ°ç¬¬3æ‹å¼€å§‹ï¼‰",
                "ä¼˜å…ˆæŒ‰æ‹åˆ†ç»„ï¼šç¬¬1æ‹å†…ã€ç¬¬2æ‹å†…ã€ç¬¬3æ‹å†…ã€ç¬¬4æ‹å†…",
                "å…è®¸è¿æ¥ï¼šç¬¬1-2æ‹ã€ç¬¬3-4æ‹",
                "åå…­åˆ†éŸ³ç¬¦ä»¥ä¸‹ï¼šä¸¥æ ¼æŒ‰æ‹åˆ†ç»„"
            ]
        },
        
        '3/4': {
            // 3/4æ‹ï¼šç®€å•ä¸‰æ‹å­ - å…«åˆ†éŸ³ç¬¦ä¸¤ä¸ªä¸¤ä¸ªè¿æ¥ï¼ˆä½“ç°å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰
            primaryBoundaries: [0, 1, 2],      // ä¸‰ä¸ªå››åˆ†éŸ³ç¬¦æ‹çš„è¾¹ç•Œ
            secondaryBoundaries: [],           // å…«åˆ†éŸ³ç¬¦é€šå¸¸ä¸ä½œä¸ºåˆ†ç»„è¾¹ç•Œ
            subdivisionBoundaries: [0, 0.5, 1, 1.5, 2, 2.5], // åå…­åˆ†éŸ³ç¬¦è¾¹ç•Œ
            beamingPattern: "two-by-two",      // å…«åˆ†éŸ³ç¬¦ä¸¤ä¸ªä¸¤ä¸ªè¿æ¥
            
            rules: [
                "å…«åˆ†éŸ³ç¬¦ä¸¤ä¸ªä¸¤ä¸ªè¿æ¥ï¼ˆä½“ç°å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰",
                "ä¾‹å¦‚ï¼šâ™ªâ™ª â™ªâ™ª â™ªâ™ª (æ¯ç»„ä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦)",
                "ä¸è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹è¾¹ç•Œè¿æ¥",
                "åå…­åˆ†éŸ³ç¬¦å¯åœ¨å››åˆ†éŸ³ç¬¦æ‹å†…è¿æ¥"
            ]
        },
        
        '6/8': {
            // 6/8æ‹ï¼šå¤åˆäºŒæ‹å­ - å…«åˆ†éŸ³ç¬¦ä¸‰ä¸ªä¸‰ä¸ªè¿æ¥ï¼ˆä½“ç°é™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰
            primaryBoundaries: [0, 1.5],       // ä¸¤ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹çš„è¾¹ç•Œ
            secondaryBoundaries: [],           // å…«åˆ†éŸ³ç¬¦å­æ‹ä¸ä½œä¸ºä¸»è¦åˆ†ç»„è¾¹ç•Œ  
            subdivisionBoundaries: [0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75], // åå…­åˆ†éŸ³ç¬¦è¾¹ç•Œ
            beamingPattern: "three-by-three",  // å…«åˆ†éŸ³ç¬¦ä¸‰ä¸ªä¸‰ä¸ªè¿æ¥
            
            rules: [
                "å…«åˆ†éŸ³ç¬¦ä¸‰ä¸ªä¸‰ä¸ªè¿æ¥ï¼ˆä½“ç°é™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰", 
                "ä¾‹å¦‚ï¼šâ™ªâ™ªâ™ª â™ªâ™ªâ™ª (æ¯ç»„ä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦)",
                "ä¸è·¨è¶Šé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ç‚¹è¾¹ç•Œï¼ˆ1.5æ‹ï¼‰è¿æ¥",
                "åå…­åˆ†éŸ³ç¬¦å¯åœ¨å…«åˆ†éŸ³ç¬¦å­æ‹å†…è¿æ¥"
            ]
        },
        
        '2/4': {
            primaryBoundaries: [0, 1],    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½ç½®0å’Œä½ç½®1éƒ½æ˜¯ä¸å¯è·¨è¶Šçš„ä¸»è¦è¾¹ç•Œ
            secondaryBoundaries: [],      // æ²¡æœ‰æ¬¡è¦è¾¹ç•Œ
            subdivisionBoundaries: [0, 0.5, 1, 1.5],

            rules: [
                "ä¸¥æ ¼æŒ‰æ‹åˆ†ç»„ï¼šç¬¬1æ‹å†…(0-1)ã€ç¬¬2æ‹å†…(1-2)",
                "ç»å¯¹ä¸å…è®¸è·¨è¶Šä½ç½®1ï¼ˆç¬¬äºŒæ‹å¼€å§‹ï¼‰çš„ç¬¦å¹²è¿çº¿",
                "äºŒåˆ†éŸ³ç¬¦ä¾‹å¤–ï¼šå•ä¸€éŸ³ç¬¦spanningæ•´ä¸ªå°èŠ‚æ˜¯å…è®¸çš„",
                "åå…­åˆ†éŸ³ç¬¦ä¸¥æ ¼æŒ‰æ‹åˆ†ç»„"
            ]
        },
        
        '6/8': {
            primaryBoundaries: [0, 3],      // å¤æ‹å­çš„ä¸¤ä¸ªä¸»è¦æ‹ç‚¹
            secondaryBoundaries: [1.5, 4.5],
            subdivisionBoundaries: [0, 1.5, 3, 4.5],
            
            rules: [
                "æŒ‰å¤æ‹å­åˆ†ç»„ï¼šå‰ä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦ä¸€ç»„ï¼Œåä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦ä¸€ç»„",
                "ä¸è·¨è¶Šç¬¬3æ‹å’Œç¬¬4æ‹ä¹‹é—´çš„è¾¹ç•Œ",
                "æ¯ä¸ªä¸‰æ‹ç»„å†…çš„å…«åˆ†éŸ³ç¬¦å¯ä»¥è¿æ¥"
            ]
        }
    },
    
    // 3. æ··åˆéŸ³å€¼è¿æ¥è§„åˆ™
    mixedValueRules: {
        principle: "ä¸»ç¬¦æ§“è¿æ¥æ‰€æœ‰éŸ³ç¬¦ï¼Œæ¬¡ç¬¦æ§“åªè¿æ¥éœ€è¦çš„éŸ³ç¬¦",
        
        examples: {
            "å…«åˆ†+åå…­åˆ†": {
                description: "å…«åˆ†éŸ³ç¬¦ä¸åå…­åˆ†éŸ³ç¬¦æ··åˆæ—¶",
                rule: "ä¸»ç¬¦æ§“ï¼ˆç¬¬1æ¡ï¼‰è¿æ¥æ‰€æœ‰éŸ³ç¬¦ï¼Œæ¬¡ç¬¦æ§“ï¼ˆç¬¬2æ¡ï¼‰åªè¿æ¥åå…­åˆ†éŸ³ç¬¦",
                visual: "â™«=â™¬â™¬ (ä¸€æ¡ä¸»æ§“ï¼Œåå…­åˆ†éŸ³ç¬¦é—´æœ‰ç¬¬äºŒæ¡æ§“)"
            },
            
            "é™„ç‚¹å…«åˆ†+åå…­åˆ†": {
                description: "é™„ç‚¹å…«åˆ†éŸ³ç¬¦ä¸åå…­åˆ†éŸ³ç¬¦åœ¨åŒä¸€æ‹ç‚¹å†…æ—¶",
                rule: "ä¸»ç¬¦æ§“ï¼ˆç¬¬1æ¡ï¼‰è¿æ¥ä¸¤ä¸ªéŸ³ç¬¦ï¼Œæ¬¡ç¬¦æ§“ï¼ˆç¬¬2æ¡ï¼‰åªè¿æ¥åå…­åˆ†éŸ³ç¬¦",
                visual: "â™«.â™¬ (ä¸€æ¡ä¸»æ§“è¿æ¥ï¼Œåå…­åˆ†éŸ³ç¬¦æœ‰ç¬¬äºŒæ¡æ§“)",
                condition: "å¿…é¡»åœ¨åŒä¸€ä¸ªå››åˆ†éŸ³ç¬¦æ‹ç‚¹å†…"
            },
            
            "åå…­åˆ†+ä¸‰åäºŒåˆ†": {
                description: "åå…­åˆ†éŸ³ç¬¦ä¸ä¸‰åäºŒåˆ†éŸ³ç¬¦æ··åˆæ—¶",
                rule: "ç¬¬1ã€2æ¡ç¬¦æ§“è¿æ¥æ‰€æœ‰éŸ³ç¬¦ï¼Œç¬¬3æ¡ç¬¦æ§“åªè¿æ¥ä¸‰åäºŒåˆ†éŸ³ç¬¦",
                visual: "â™¬â™¬=â™­â™­ (ä¸¤æ¡ä¸»æ§“ï¼Œä¸‰åäºŒåˆ†éŸ³ç¬¦é—´æœ‰ç¬¬ä¸‰æ¡æ§“)"
            }
        }
    },
    
    // 4. ç¬¦å¹²æ–¹å‘è§„åˆ™
    stemDirectionRules: {
        principle: "ä»¥è¿æ¥ç»„ä¸­è·ç¦»äº”çº¿è°±ä¸­çº¿æœ€è¿œçš„éŸ³ç¬¦å†³å®šæ•´ç»„ç¬¦å¹²æ–¹å‘",
        
        rules: [
            "ä¸­çº¿ä»¥ä¸Šï¼ˆåŒ…æ‹¬ä¸­çº¿ï¼‰ï¼šç¬¦å¹²å‘ä¸‹",
            "ä¸­çº¿ä»¥ä¸‹ï¼šç¬¦å¹²å‘ä¸Š",
            "æ··åˆé«˜ä½éŸ³æ—¶ï¼šä»¥è·ä¸­çº¿æœ€è¿œçš„éŸ³ç¬¦ä¸ºå‡†",
            "ç›¸ç­‰è·ç¦»æ—¶ï¼šä¼˜å…ˆå‘ä¸Š"
        ],
        
        implementation: {
            middleLine: { step: 'B', octave: 4 }, // é«˜éŸ³è°±å·ä¸­çº¿ä¸ºB4
            
            calculateDirection: function(notes) {
                let maxDistance = 0;
                let direction = 'up';
                
                for (const note of notes) {
                    const distance = this.getDistanceFromMiddleLine(note.step, note.octave);
                    if (Math.abs(distance) > maxDistance) {
                        maxDistance = Math.abs(distance);
                        direction = distance > 0 ? 'down' : 'up';
                    }
                }
                
                return direction;
            },
            
            getDistanceFromMiddleLine: function(step, octave) {
                const steps = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                const noteValue = octave * 7 + steps.indexOf(step);
                const middleValue = 4 * 7 + 6; // B4
                return noteValue - middleValue;
            }
        }
    },
    
    // 5. ç‰¹æ®Šæƒ…å†µè§„åˆ™
    specialCases: {
        triplets: {
            rule: "ä¸‰è¿éŸ³æœ‰è‡ªå·±çš„è¿æ¥é€»è¾‘ï¼Œä¸ä¸æ™®é€šéŸ³ç¬¦æ··åˆè¿æ¥",
            beaming: "ä¸‰è¿éŸ³å†…éƒ¨å¯ä»¥è¿æ¥ï¼Œä½†ä¸è·¨è¶Šä¸‰è¿éŸ³è¾¹ç•Œ"
        },
        
        rests: {
            rule: "ä¼‘æ­¢ç¬¦ä¸­æ–­ç¬¦æ§“è¿æ¥",
            behavior: "ä¼‘æ­¢ç¬¦å‰åçš„éŸ³ç¬¦ä¸èƒ½è¿æ¥"
        },
        
        ties: {
            rule: "è¿éŸ³çº¿ä¸å½±å“ç¬¦æ§“è¿æ¥",
            behavior: "è¢«è¿éŸ³çº¿è¿æ¥çš„éŸ³ç¬¦å¯ä»¥æ­£å¸¸å‚ä¸ç¬¦æ§“è¿æ¥"
        },
        
        crossStaff: {
            rule: "è·¨è°±è¡¨éŸ³ç¬¦ä¸è¿æ¥ç¬¦æ§“",
            behavior: "å·¦æ‰‹å’Œå³æ‰‹çš„éŸ³ç¬¦ä¸èƒ½ç”¨ç¬¦æ§“è¿æ¥"
        }
    },
    
    // 6. åˆ†ç»„ä¼˜å…ˆçº§
    groupingPriorities: {
        level1: "èŠ‚æ‹å•ä½å†…åˆ†ç»„ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰",
        level2: "åŠæ‹å•ä½å†…åˆ†ç»„",
        level3: "ç›¸é‚»æ‹å­é—´åˆ†ç»„ï¼ˆä»…ç‰¹å®šæƒ…å†µï¼‰",
        level4: "æ•´å°èŠ‚åˆ†ç»„ï¼ˆä»…ç‰¹å®šç®€å•æƒ…å†µï¼‰"
    },
    
    // 7. å®ç”¨åˆ¤æ–­å‡½æ•°
    shouldConnectWithBeam: function(notes, startIndex, endIndex, timeSignature, currentPosition) {
        // æ£€æŸ¥åŸºç¡€æ¡ä»¶
        if (endIndex - startIndex < 1) return false; // è‡³å°‘2ä¸ªéŸ³ç¬¦
        
        const groupNotes = notes.slice(startIndex, endIndex + 1);
        
        // æ£€æŸ¥æ‰€æœ‰éŸ³ç¬¦æ˜¯å¦å¯è¿æ¥
        if (!groupNotes.every(note => {
            if (!note) {
                console.error(`âš ï¸ ç©ºéŸ³ç¬¦åœ¨beamingæ£€æŸ¥ä¸­`);
                return false;
            }
            if (!note.type) {
                console.error(`âš ï¸ éŸ³ç¬¦ç¼ºå°‘typeå±æ€§: ${JSON.stringify(note)}`);
                return false;
            }
            if (!note.duration) {
                console.error(`âš ï¸ éŸ³ç¬¦ç¼ºå°‘durationå±æ€§: ${JSON.stringify(note)}`);
                return false;
            }
            if (!Array.isArray(this.basicRules.beamableNotes)) {
                console.error(`âš ï¸ beamableNotesä¸æ˜¯æ•°ç»„: ${JSON.stringify(this.basicRules.beamableNotes)}`);
                return false;
            }
            
            return note.type === 'note' && 
                   this.basicRules.beamableNotes.includes(note.duration) &&
                   !note.isTriplet; // ä¸‰è¿éŸ³å•ç‹¬å¤„ç†
        })) {
            return false;
        }
        
        // æ£€æŸ¥æ‹å·è¾¹ç•Œï¼ˆä½¿ç”¨åŠ¨æ€ç»†åˆ†è¾¹ç•Œï¼‰
        const allowedRhythms = userSettings?.allowedRhythms || [];
        return !this.crossesCriticalBoundary(groupNotes, currentPosition, timeSignature, null, allowedRhythms);
    },
    
    crossesCriticalBoundary: function(notes, startPosition, timeSignature, currentBeatLevel = null, allowedRhythms = null) {
        const rules = this.timeSignatureRules[timeSignature];
        if (!rules) return false;

        // ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šå•ä¸€éŸ³ç¬¦ä¸å—beamè¾¹ç•Œé™åˆ¶ï¼ˆç‰¹åˆ«æ˜¯äºŒåˆ†éŸ³ç¬¦çš„ä¾‹å¤–æƒ…å†µï¼‰
        if (notes.length === 1) {
            const singleNote = notes[0];
            // äºŒåˆ†éŸ³ç¬¦ã€å…¨éŸ³ç¬¦ç­‰é•¿æ—¶å€¼éŸ³ç¬¦æ˜¯å•ä¸€éŸ³ç¬¦ï¼Œä¸æ¶‰åŠbeamè¿çº¿
            if (singleNote.duration === 'half' || singleNote.duration === 'whole' ||
                singleNote.duration === 'half.' || singleNote.beats >= 2) {
                console.log(`    âœ… å•ä¸€éŸ³ç¬¦(${singleNote.duration}, ${singleNote.beats}æ‹)ä¸å—beamè¾¹ç•Œé™åˆ¶ - ä¾‹å¤–æƒ…å†µ`);
                return false; // ä¸è·¨è¶Šè¾¹ç•Œï¼Œå…è®¸
            }
        }

        // ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šåªæœ‰å¯è¿æ¥beamçš„éŸ³ç¬¦æ‰æ£€æŸ¥è¾¹ç•Œ
        const hasBeamableNotes = notes.some(note =>
            this.basicRules.beamableNotes.includes(note.duration) && !note.isTriplet
        );

        if (!hasBeamableNotes) {
            console.log(`    âœ… éŸ³ç¬¦ç»„ä¸åŒ…å«å¯è¿beamçš„éŸ³ç¬¦ï¼Œè·³è¿‡è¾¹ç•Œæ£€æŸ¥`);
            return false; // ä¸éœ€è¦æ£€æŸ¥è¾¹ç•Œ
        }

        let position = startPosition;
        const beatsPerMeasure = parseInt(timeSignature.split('/')[0]);

        // ğŸµ ä½¿ç”¨åŠ¨æ€ç»†åˆ†è¾¹ç•Œï¼ˆæ ¹æ®é™„ç‚¹éŸ³ç¬¦è°ƒæ•´ï¼‰
        let dynamicSubdivisions;
        if (typeof BEAMING_RULES.getDynamicSubdivisionBoundaries === 'function') {
            dynamicSubdivisions = BEAMING_RULES.getDynamicSubdivisionBoundaries(timeSignature, allowedRhythms);
        } else {
            console.warn('âš ï¸ getDynamicSubdivisionBoundarieså‡½æ•°ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤ç»†åˆ†');
            // æ ¹æ®æ‹å·æä¾›é»˜è®¤ç»†åˆ†
            if (timeSignature === '4/4') {
                dynamicSubdivisions = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]; // å…«åˆ†éŸ³ç¬¦ç»†åˆ†
            } else if (timeSignature === '3/4') {
                dynamicSubdivisions = [0, 0.5, 1, 1.5, 2, 2.5]; // å…«åˆ†éŸ³ç¬¦ç»†åˆ†
            } else if (timeSignature === '2/4') {
                dynamicSubdivisions = [0, 0.5, 1, 1.5]; // å…«åˆ†éŸ³ç¬¦ç»†åˆ†
            } else if (timeSignature === '6/8') {
                dynamicSubdivisions = [0, 0.5, 1, 1.5, 2, 2.5]; // å…«åˆ†éŸ³ç¬¦ç»†åˆ†
            } else {
                dynamicSubdivisions = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]; // é»˜è®¤4/4æ‹ç»†åˆ†
            }
        }

        // æ ¹æ®å½“å‰æ‹ç‚¹æ˜¾ç¤ºå±‚çº§ç¡®å®šå…³é”®è¾¹ç•Œ
        let criticalBoundaries = rules.primaryBoundaries; // é»˜è®¤ä½¿ç”¨ä¸»è¦è¾¹ç•Œ
        
        // ğŸ¼ ç‰¹æ®Šå¤„ç†ï¼š2/4æ‹å’Œ3/4æ‹å¿…é¡»åœ¨æ¯ä¸ªå››åˆ†éŸ³ç¬¦æ‹ç‚¹å¤„åˆ†å‰²beamï¼Œé˜²æ­¢è·¨æ‹è¿æ¥
        if (timeSignature === '2/4') {
            criticalBoundaries = [0, 1]; // å¼ºåˆ¶ä½¿ç”¨å››åˆ†éŸ³ç¬¦è¾¹ç•Œï¼Œç»å¯¹ä¸å…è®¸è·¨è¶Šä½ç½®1
            console.log(`    ğŸµ 2/4æ‹beaming: å¼ºåˆ¶ä½¿ç”¨å››åˆ†éŸ³ç¬¦è¾¹ç•Œ [0, 1] - ä¸¥ç¦è·¨è¶Šç¬¬äºŒæ‹`);
        } else if (timeSignature === '3/4') {
            criticalBoundaries = [0, 1, 2]; // å¼ºåˆ¶ä½¿ç”¨å››åˆ†éŸ³ç¬¦è¾¹ç•Œ
            console.log(`    ğŸµ 3/4æ‹beaming: å¼ºåˆ¶ä½¿ç”¨å››åˆ†éŸ³ç¬¦è¾¹ç•Œ [0, 1, 2]`);
        } else if (currentBeatLevel === 'quarter') {
            // å››åˆ†éŸ³ç¬¦æ‹ç‚¹å±‚çº§æ—¶ï¼Œä½¿ç”¨å››åˆ†éŸ³ç¬¦è¾¹ç•Œ
            criticalBoundaries = [0, 1, 2, 3];
        } else if (currentBeatLevel === 'half') {
            // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å±‚çº§æ—¶ï¼Œä½¿ç”¨äºŒåˆ†éŸ³ç¬¦è¾¹ç•Œ
            criticalBoundaries = [0, 2];
        } else if (currentBeatLevel === 'whole') {
            // å…¨éŸ³ç¬¦æ‹ç‚¹å±‚çº§æ—¶ï¼Œä½¿ç”¨å…¨éŸ³ç¬¦è¾¹ç•Œ
            criticalBoundaries = [0];
        }
        
        for (let i = 0; i < notes.length - 1; i++) {
            const noteEnd = position + notes[i].beats;
            
            // ğŸ¼ ç‰¹æ®Šå¼ºåŒ–ï¼š2/4æ‹ä¸¥æ ¼ç¦æ­¢beamè·¨è¶Šä½ç½®1ï¼ˆç¬¬äºŒæ‹ï¼‰ï¼Œä½†å…è®¸16åˆ†éŸ³ç¬¦åœ¨æ‹å†…è¿æ¥
            if (timeSignature === '2/4') {
                const boundaryPos = 1; // ç¬¬äºŒæ‹å¼€å§‹çš„ä½ç½®

                // ğŸ”¥ ç®€åŒ–ä¿®å¤ï¼šæ£€æŸ¥beamç»„æ˜¯å¦çœŸæ­£è·¨è¶Šåˆ°ç¬¬äºŒæ‹å†…éƒ¨
                const groupStart = position;
                const groupEnd = position + notes.reduce((sum, note) => sum + note.beats, 0);

                // åªæœ‰å½“ç»„çœŸæ­£å»¶ä¼¸åˆ°ç¬¬äºŒæ‹å†…éƒ¨æ—¶æ‰åˆ†å‰²ï¼ˆç»™0.05çš„å®¹å¿åº¦ï¼‰
                if (groupStart < boundaryPos && groupEnd > boundaryPos + 0.05) {
                    console.log(`    ğŸµ 2/4æ‹beamé™åˆ¶: beamç»„ä»${groupStart.toFixed(2)}å»¶ä¼¸åˆ°${groupEnd.toFixed(2)}ï¼Œè·¨è¶Šç¬¬äºŒæ‹è¾¹ç•Œ`);
                    return true;
                }

                console.log(`    âœ… 2/4æ‹beamæ£€æŸ¥é€šè¿‡: beamç»„ä»${groupStart.toFixed(2)}åˆ°${groupEnd.toFixed(2)}ï¼Œåœ¨å•ä¸ªæ‹å†…`);
            }
            // ğŸ¼ ç‰¹æ®Šå¼ºåŒ–ï¼š3/4æ‹ä¸¥æ ¼ç¦æ­¢ä»»ä½•beamè·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹
            else if (timeSignature === '3/4') {
                // æ£€æŸ¥å½“å‰éŸ³ç¬¦ç»„æ˜¯å¦è·¨è¶Šä»»ä½•å››åˆ†éŸ³ç¬¦æ‹ç‚¹ (0, 1, 2)
                for (const boundary of [0, 1, 2]) {
                    const boundaryPos = boundary % beatsPerMeasure;
                    // æ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼šå³ä½¿éŸ³ç¬¦åœ¨æ‹ç‚¹ä¸Šå¼€å§‹ï¼Œå¦‚æœç»„åˆè·¨è¶Šä¸‹ä¸€ä¸ªæ‹ç‚¹ä¹Ÿè¦åˆ†å‰²
                    if (position < boundaryPos && noteEnd > boundaryPos) {
                        console.log(`    ğŸµ 3/4æ‹ä¸¥æ ¼beamé™åˆ¶: è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹${boundary}ï¼Œå¿…é¡»åˆ†å‰²beam`);
                        return true;
                    }
                    // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœå½“å‰ç»„åˆçš„ä»»ä½•éƒ¨åˆ†ä¼šå»¶ä¼¸åˆ°ä¸‹ä¸€ä¸ªæ‹ç‚¹ï¼Œä¹Ÿè¦åˆ†å‰²
                    if (position <= boundaryPos && noteEnd > boundaryPos + 0.001) {
                        console.log(`    ğŸµ 3/4æ‹ä¸¥æ ¼beamé™åˆ¶: å»¶ä¼¸è¶…è¿‡å››åˆ†éŸ³ç¬¦æ‹ç‚¹${boundary}ï¼Œå¼ºåˆ¶åˆ†å‰²`);
                        return true;
                    }
                }
            } else {
                // å…¶ä»–æ—¶é—´ç­¾åä½¿ç”¨åŸæœ‰é€»è¾‘
                for (const boundary of criticalBoundaries) {
                    const boundaryPos = boundary % beatsPerMeasure;
                    if (position < boundaryPos && noteEnd > boundaryPos) {
                        console.log(`    è·¨è¶Š${currentBeatLevel || 'é»˜è®¤'}æ‹ç‚¹è¾¹ç•Œ${boundary}`);
                        return true; // è·¨è¶Šå…³é”®è¾¹ç•Œ
                    }
                }
            }
            
            position = noteEnd;
        }
        
        return false;
    },
    
    generateBeamLevels: function(notes) {
        const beamLevels = [];
        const maxLevel = Math.max(...notes.map(note => 
            this.basicRules.beamLevels[note.duration] || 0
        ));
        
        for (let level = 1; level <= maxLevel; level++) {
            const levelNotes = [];
            for (let i = 0; i < notes.length; i++) {
                const noteLevel = this.basicRules.beamLevels[notes[i].duration] || 0;
                if (noteLevel >= level) {
                    levelNotes.push(i);
                }
            }
            if (levelNotes.length >= 2) {
                beamLevels.push({
                    level: level,
                    noteIndices: levelNotes
                });
            }
        }
        
        return beamLevels;
    }
};

const RHYTHM_NOTATION_RULES = {
    // è·å–æ‹å·çš„æ‹ç‚¹ç»“æ„
    getBeatStructure: function(timeSignature) {
        const [beats, beatType] = timeSignature.split('/').map(Number);
        
        switch(timeSignature) {
            case '2/4':
                return {
                    beatsPerMeasure: 2,
                    strongBeats: [0, 1],           // æ‹1, æ‹2
                    subdivisions: [0, 0.5, 1, 1.5] // å…«åˆ†éŸ³ç¬¦çº§åˆ«ï¼š1, +, 2, +
                };
            case '3/4':
                return {
                    beatsPerMeasure: 3,
                    strongBeats: [0, 1, 2],        // æ‹1, æ‹2, æ‹3
                    subdivisions: [0, 0.5, 1, 1.5, 2, 2.5] // 1, +, 2, +, 3, +
                };
            case '4/4':
                return {
                    beatsPerMeasure: 4,
                    strongBeats: [0, 2],           // å¼ºæ‹ï¼šæ‹1, æ‹3
                    mediumBeats: [1, 3],           // æ¬¡å¼ºæ‹ï¼šæ‹2, æ‹4
                    subdivisions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] // å…«åˆ†éŸ³ç¬¦çº§åˆ«
                };
            case '6/8':
                return {
                    beatsPerMeasure: 3,            // 3æ‹ï¼ˆä»¥é™„ç‚¹å››åˆ†éŸ³ç¬¦ä¸ºæ‹å­ï¼‰
                    realBeatsPerMeasure: 2,        // å®é™…æ„Ÿè§‰ï¼š2ä¸ªå¤§æ‹
                    strongBeats: [0, 1.5],         // æ­£ç¡®çš„å¤åˆæ‹å¼ºæ‹ä½ç½®ï¼š0.0å’Œ1.5
                    subdivisions: [0, 0.5, 1, 1.5, 2, 2.5], // å…«åˆ†éŸ³ç¬¦çº§åˆ«ï¼ˆä»¥é™„ç‚¹å››åˆ†éŸ³ç¬¦è®¡ï¼‰
                    compoundMeter: true,           // å¤åˆæ‹å­æ ‡è®°
                    dottedQuarterBased: true       // ä»¥é™„ç‚¹å››åˆ†éŸ³ç¬¦ä¸ºåŸºç¡€å•ä½
                };
            default:
                return {
                    beatsPerMeasure: beats,
                    strongBeats: [0],
                    subdivisions: []
                };
        }
    },

    // ğŸµ åŠ¨æ€ç»†åˆ†è¾¹ç•Œè®¡ç®—ï¼šæ ¹æ®é™„ç‚¹éŸ³ç¬¦è°ƒæ•´æ‹ç‚¹ç»†åˆ†
    getDynamicSubdivisionBoundaries: function(timeSignature, allowedRhythms) {
        // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å¯¹è±¡å¼•ç”¨
        const rules = this.timeSignatureRules[timeSignature];
        if (!rules) {
            console.warn(`âš ï¸ æœªæ‰¾åˆ°æ‹å·${timeSignature}çš„è§„åˆ™ï¼Œä½¿ç”¨é»˜è®¤ç»†åˆ†`);
            return [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]; // é»˜è®¤å…«åˆ†éŸ³ç¬¦ç»†åˆ†
        }

        let subdivisions = [...rules.subdivisionBoundaries]; // å¤åˆ¶é»˜è®¤è¾¹ç•Œ

        if (timeSignature === '4/4' && Array.isArray(allowedRhythms)) {
            // ğŸµ æ ¹æ®é™„ç‚¹éŸ³ç¬¦è°ƒæ•´4/4æ‹çš„ç»†åˆ†è§„åˆ™
            const hasDottedHalf = allowedRhythms.includes('half.');      // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
            const hasDottedQuarter = allowedRhythms.includes('quarter.'); // é™„ç‚¹å››åˆ†éŸ³ç¬¦
            const hasDottedEighth = allowedRhythms.includes('eighth.');   // é™„ç‚¹å…«åˆ†éŸ³ç¬¦

            if (hasDottedEighth) {
                // é™„ç‚¹å…«åˆ†éŸ³ç¬¦å­˜åœ¨æ—¶ï¼ŒæŒ‰åå…­åˆ†éŸ³ç¬¦ç»†åˆ†
                subdivisions = [0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75];
                console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹å…«åˆ†éŸ³ç¬¦ï¼Œè°ƒæ•´ä¸ºåå…­åˆ†éŸ³ç¬¦ç»†åˆ†`);
            } else if (hasDottedQuarter) {
                // é™„ç‚¹å››åˆ†éŸ³ç¬¦å­˜åœ¨æ—¶ï¼ŒæŒ‰å…«åˆ†éŸ³ç¬¦ç»†åˆ†ï¼ˆé»˜è®¤ï¼‰
                subdivisions = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5];
                console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼Œä½¿ç”¨å…«åˆ†éŸ³ç¬¦ç»†åˆ†`);
            } else if (hasDottedHalf) {
                // ä»…é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å­˜åœ¨æ—¶ï¼ŒæŒ‰å››åˆ†éŸ³ç¬¦ç»†åˆ†
                subdivisions = [0, 1, 2, 3];
                console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼Œè°ƒæ•´ä¸ºå››åˆ†éŸ³ç¬¦ç»†åˆ†`);
            }
        }

        return subdivisions;
    },

    // æ£€æµ‹éŸ³ç¬¦æ˜¯å¦è·¨è¶Šé‡è¦æ‹ç‚¹ - åŸºäºä¸¤ç­‰çº§è§„åˆ™
    detectsCrossBeats: function(startPosition, duration, timeSignature, finestRhythmInMeasure) {
        const structure = this.getBeatStructure(timeSignature);
        const endPosition = startPosition + duration;
        
        // æ ¹æ®æœ€ç»†èŠ‚å¥å€¼ç¡®å®šéœ€è¦ä¿æŒæ¸…æ™°çš„æ‹ç‚¹ï¼ˆä¸¤ç­‰çº§è§„åˆ™ï¼‰
        const criticalBeats = this.getCriticalBeatsForFinestRhythm(
            finestRhythmInMeasure, 
            timeSignature
        );
        
        // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦è·¨è¶Šä»»ä½•å…³é”®æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            if (startPosition < beatPoint && endPosition > beatPoint) {
                return {
                    crossesBeat: true,
                    beatPoint: beatPoint,
                    splitPositions: [beatPoint]
                };
            }
        }
        
        return { crossesBeat: false };
    },
    
    // æ™ºèƒ½è·¨æ‹æ£€æµ‹ï¼šä½¿ç”¨å±€éƒ¨èŠ‚å¥åˆ†æ
    detectsCrossBeatsWithLocalRhythm: function(startPosition, duration, timeSignature, allNotes, noteType = 'note') {
        const endPosition = startPosition + duration;
        const tolerance = 0.0001;
        
        // æ”¯æŒä¸åŒæ—¶é—´ç­¾å
        if (timeSignature === '6/8') {
            return this.detectsCrossBeatsFor6_8(startPosition, duration, allNotes, noteType);
        } else if (timeSignature === '3/4') {
            return this.detectsCrossBeatsFor3_4(startPosition, duration, allNotes, noteType);
        } else if (timeSignature !== '4/4') {
            // å¯¹äºå…¶ä»–æ—¶é—´ç­¾åï¼Œä½¿ç”¨åŸºæœ¬é€»è¾‘
            return this.detectsCrossBeatsGeneric(startPosition, duration, timeSignature, allNotes, noteType);
        }
        
        // è·å–å±€éƒ¨èŠ‚å¥åˆ†æçš„å…³é”®æ‹ç‚¹
        const criticalBeats = this.getCriticalBeatsWithLocalRhythm(allNotes, timeSignature);
        
        // ğŸš¨ ç¦ç”¨æ—§çš„å…¨å±€16åˆ†éŸ³ç¬¦æ£€æµ‹é€»è¾‘ - ç”±æ–°çš„åŒºé—´æ£€æµ‹é€»è¾‘æ›¿ä»£
        // è¿™é‡Œåªä¿ç•™äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹çš„æ£€æµ‹ï¼Œ16åˆ†éŸ³ç¬¦åŒºé—´æ£€æµ‹åœ¨å…¶ä»–åœ°æ–¹å¤„ç†
        console.log(`  ğŸ” [é€šç”¨æ£€æµ‹] ä½¿ç”¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æµ‹ï¼Œ16åˆ†éŸ³ç¬¦åŒºé—´æ£€æµ‹å·²åœ¨å‰é¢å¤„ç†`);
        
        // ğŸ¼ æ£€æŸ¥æ˜¯å¦æœ‰16åˆ†éŸ³ç¬¦ - å½“æ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹éƒ½æ˜¯å…³é”®æ‹ç‚¹æ—¶
        const has16thNotes = false; // ğŸ”¥ å¼ºåˆ¶ç¦ç”¨ï¼Œé¿å…ä¸åŒºé—´æ£€æµ‹å†²çª
        
        // è·³è¿‡æ—§çš„16åˆ†éŸ³ç¬¦å…¨å±€æ£€æµ‹é€»è¾‘ï¼Œç»§ç»­ä½¿ç”¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æµ‹
        
        // 4/4æ‹çš„å››åˆ†éŸ³ç¬¦ç‰¹æ®Šå¤„ç†
        if (Math.abs(duration - 1.0) < tolerance && noteType === 'note') {
            console.log(`  ğŸµ æ£€æŸ¥å››åˆ†éŸ³ç¬¦: ä½ç½®=${startPosition}, æ—¶é•¿=${duration}`);
            
            // **è§„åˆ™4ï¼šä¸“é—¨é’ˆå¯¹å¼±æ‹ä½ç½®çš„å››åˆ†éŸ³ç¬¦å¤„ç†**
            // ä½†æ˜¯ï¼Œå¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œåˆ™ä¸éœ€è¦æ‹†åˆ†ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ï¼ˆå› ä¸ºä¸éœ€è¦æ˜¾ç¤ºå…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰
            if (Math.abs(startPosition - 1.5) < 0.01) {
                if (has16thNotes) {
                    console.log(`  âœ… ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ï¼Œæœ‰16åˆ†éŸ³ç¬¦å­˜åœ¨ï¼Œä¸åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹æ‹†åˆ†`);
                    // ç»§ç»­æ‰§è¡Œåé¢çš„æ£€æŸ¥ï¼Œçœ‹æ˜¯å¦è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹
                } else {
                    console.log(`  ğŸš¨ğŸš¨ğŸš¨ è§„åˆ™4ç”Ÿæ•ˆï¼š1.5æ‹ä½ç½®çš„å››åˆ†éŸ³ç¬¦å¿…é¡»æ‹†åˆ†ä¸ºä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦å¹¶ç”¨tieè¿æ¥ï¼ˆé¿å…è·¨è¶Šç¬¬3æ‹å¼ºæ‹ï¼‰`);
                    console.log(`  ğŸš¨ æ‹†åˆ†è¯¦æƒ…: ä½ç½®1.5-2.5 â†’ 1.5-2.0 + 2.0-2.5`);
                    return {
                        crossesBeat: true,
                        beatPoint: 2, // åœ¨2æ‹ä½ç½®ï¼ˆéŸ³ä¹ç†è®ºç¬¬3æ‹ï¼‰æ‹†åˆ†
                        splitPositions: [2]
                    };
                }
            }
            
            // æ£€æŸ¥å››åˆ†éŸ³ç¬¦æ˜¯å¦è·¨è¶Šä»»ä½•å…³é”®æ‹ç‚¹
            const beatPoints = [1, 2, 3];
            for (const beat of beatPoints) {
                if (startPosition < beat - tolerance && endPosition > beat + tolerance) {
                    // æ£€æŸ¥è¿™ä¸ªæ‹ç‚¹æ˜¯å¦åœ¨å…³é”®æ‹ç‚¹åˆ—è¡¨ä¸­
                    const isCritical = criticalBeats.some(cb => Math.abs(cb - beat) < tolerance);
                    if (!isCritical) {
                        console.log(`  âœ… å››åˆ†éŸ³ç¬¦è·¨è¶Šæ‹ç‚¹${beat}ï¼Œä½†è¯¥æ‹ç‚¹ä¸éœ€è¦æ˜ç¡®ï¼Œä¸æ‹†åˆ†`);
                        continue; // è·³è¿‡è¿™ä¸ªæ‹ç‚¹
                    }
                    
                    // å››åˆ†éŸ³ç¬¦è·¨è¶Šå…³é”®æ‹ç‚¹
                    // åªæœ‰å½“å®ƒä»æ•´æ•°æ‹å¼€å§‹æ—¶æ‰ä¸æ‹†åˆ†
                    const startsOnBeat = Math.abs(startPosition - Math.round(startPosition)) < tolerance;
                    if (!startsOnBeat) {
                        // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»è¢«å…¶ä»–éŸ³ç¬¦æ˜ç¡®
                        if (this.isBeatPointAlreadyClear(startPosition, endPosition, beat, allNotes, timeSignature)) {
                            console.log(`  âœ… å››åˆ†éŸ³ç¬¦è·¨è¶Šæ‹ç‚¹${beat}ï¼Œä½†æ‹ç‚¹å·²æ˜ç¡®ï¼Œä¸æ‹†åˆ†`);
                            continue;
                        }
                        
                        // ä»x.5æ‹å¼€å§‹çš„å››åˆ†éŸ³ç¬¦éœ€è¦æ‹†åˆ†ä¸”æ‹ç‚¹æœªæ˜ç¡®
                        console.log(`  ğŸ¯ å››åˆ†éŸ³ç¬¦ä»${startPosition}æ‹å¼€å§‹ï¼Œè·¨è¶Šå…³é”®æ‹ç‚¹${beat}ä¸”æ‹ç‚¹æœªæ˜ç¡®ï¼Œéœ€è¦æ‹†åˆ†`);
                        return {
                            crossesBeat: true,
                            beatPoint: beat,
                            splitPositions: [beat]
                        };
                    }
                }
            }
        }
        
        console.log(`  ğŸ” æ£€æŸ¥${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'} [${startPosition}-${endPosition}] æ˜¯å¦è·¨è¶Šå…³é”®æ‹ç‚¹: [${criticalBeats.join(', ')}]`);
        
        // ğŸ¼ å¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œè®°å½•ä¸€ä¸‹ä¾›è°ƒè¯•
        if (has16thNotes) {
            console.log(`  ğŸ¼ æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦åœºæ™¯ - åªåœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ [0,1,2,3] æ‹†åˆ†ï¼Œä¸åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ [0.5,1.5,2.5,3.5] æ‹†åˆ†`);
        }
        
        // æ£€æŸ¥éŸ³ç¬¦/ä¼‘æ­¢ç¬¦æ˜¯å¦è·¨è¶Šä»»ä½•å…³é”®æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            if (startPosition < beatPoint - tolerance && endPosition > beatPoint + tolerance) {
                console.log(`  âš ï¸ ${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'}è·¨è¶Šå…³é”®æ‹ç‚¹ ${beatPoint}ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ‹†åˆ†...`);
                
                // ğŸ¼ ç‰¹æ®Šè§„åˆ™ï¼šå¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œä»»ä½•æ¨¡ç³Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹çš„éŸ³ç¬¦éƒ½éœ€è¦æ‹†åˆ†
                if (has16thNotes) {
                    // æ£€æŸ¥å½“å‰æ‹ç‚¹æ˜¯å¦æ˜¯å››åˆ†éŸ³ç¬¦æ‹ç‚¹
                    const quarterBeats = [0, 1, 2, 3];
                    const isQuarterBeat = quarterBeats.some(qb => Math.abs(beatPoint - qb) < tolerance);
                    
                    if (isQuarterBeat) {
                        // éŸ³ç¬¦è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹å°±éœ€è¦æ‹†åˆ†ï¼ˆé™¤éä»å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹ï¼‰
                        const startsOnQuarterBeat = quarterBeats.some(pos => Math.abs(startPosition - pos) < tolerance);
                        
                        if (!startsOnQuarterBeat) {
                            // ä¸æ˜¯ä»å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹çš„éŸ³ç¬¦ï¼Œè·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ—¶éœ€è¦æ‹†åˆ†
                            console.log(`  ğŸ¯ æœ‰16åˆ†éŸ³ç¬¦æ—¶ï¼Œä½ç½®${startPosition}çš„${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'}ï¼ˆ${duration}æ‹ï¼‰è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹${beatPoint}ï¼Œéœ€è¦æ‹†åˆ†`);
                            return {
                                crossesBeat: true,
                                beatPoint: beatPoint,
                                splitPositions: [beatPoint]
                            };
                        }
                    }
                    // ä»å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹çš„éŸ³ç¬¦æˆ–éå››åˆ†éŸ³ç¬¦æ‹ç‚¹ç»§ç»­æ­£å¸¸æ£€æŸ¥
                }
                
                // ä¼‘æ­¢ç¬¦éœ€è¦æ‹†åˆ†æ¥æ˜ç¡®æ‹ç‚¹ï¼ˆé™¤äº†ä¸Šé¢16åˆ†éŸ³ç¬¦çš„ç‰¹æ®Šæƒ…å†µï¼‰
                if (noteType === 'rest') {
                    // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»æ˜ç¡®æ˜¾ç¤º
                    if (this.isBeatPointAlreadyClear(startPosition, endPosition, beatPoint, allNotes, timeSignature)) {
                        console.log(`  âœ… æ‹ç‚¹${beatPoint}å·²ç»æ˜ç¡®ï¼Œä¼‘æ­¢ç¬¦ä¸éœ€è¦æ‹†åˆ†`);
                        continue; // è·³è¿‡è¿™ä¸ªæ‹ç‚¹ï¼Œä¸æ‹†åˆ†
                    }
                    
                    console.log(`  ğŸ”¥ éœ€è¦æ‹†åˆ†ï¼šä¼‘æ­¢ç¬¦è·¨è¶Šæ‹ç‚¹${beatPoint}ä¸”æ‹ç‚¹æœªæ˜ç¡®`);
                    return {
                        crossesBeat: true,
                        beatPoint: beatPoint,
                        splitPositions: [beatPoint]
                    };
                }
                
                // å¯¹äºéŸ³ç¬¦ï¼Œæ£€æŸ¥æ˜¯å¦ç¬¦åˆ"æ­£æ‹ä¸Šç›¸åŒæ—¶å€¼éŸ³ç¬¦"çš„ä¾‹å¤–æ¡ä»¶
                // ğŸ¯ ä¼ å…¥å…³é”®æ‹ç‚¹ä¿¡æ¯ï¼Œè€ƒè™‘å±€éƒ¨èŠ‚å¥åˆ†æ
                if (this.isNoteOnCorrespondingBeat(startPosition, duration, beatPoint, criticalBeats)) {
                    console.log(`  ğŸ¯ ä¾‹å¤–å¤„ç†ï¼šéŸ³ç¬¦åœ¨å¯¹åº”æ‹ç‚¹ä¸Šï¼Œä¸æ‹†åˆ† (ä½ç½®${startPosition}, æ—¶é•¿${duration}, è·¨è¶Šæ‹ç‚¹${beatPoint})`);
                    continue; // è·³è¿‡è¿™ä¸ªæ‹ç‚¹ï¼Œä¸æ‹†åˆ†
                }
                
                // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»æ˜ç¡®æ˜¾ç¤º
                if (this.isBeatPointAlreadyClear(startPosition, endPosition, beatPoint, allNotes, timeSignature)) {
                    console.log(`  âœ… æ‹ç‚¹${beatPoint}å·²ç»æ˜ç¡®ï¼Œä¸éœ€è¦æ‹†åˆ†æ­¤éŸ³ç¬¦`);
                    continue; // è·³è¿‡è¿™ä¸ªæ‹ç‚¹ï¼Œä¸æ‹†åˆ†
                }
                
                console.log(`  ğŸ”¥ éœ€è¦æ‹†åˆ†ï¼šéŸ³ç¬¦è·¨è¶Šæ‹ç‚¹${beatPoint}ä¸”æ‹ç‚¹æœªæ˜ç¡®`);
                return {
                    crossesBeat: true,
                    beatPoint: beatPoint,
                    splitPositions: [beatPoint]
                };
            }
        }
        
        return { crossesBeat: false };
    },
    
    // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦ç¬¦åˆ"æ­£æ‹ä¸Šç›¸åŒæ—¶å€¼éŸ³ç¬¦"çš„ä¾‹å¤–æ¡ä»¶
    isNoteOnCorrespondingBeat: function(startPosition, duration, crossedBeatPoint, criticalBeats = []) {
        const tolerance = 0.0001;
        
        // ğŸ¼ ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œä»»ä½•ä¸åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šçš„éŸ³ç¬¦éƒ½éœ€è¦æ‹†åˆ†
        const has16thNotes = criticalBeats.includes(0) && criticalBeats.includes(1) && 
                             criticalBeats.includes(2) && criticalBeats.includes(3);
        
        if (has16thNotes) {
            // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦ä»å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹
            const quarterBeats = [0, 1, 2, 3];
            const startsOnQuarterBeat = quarterBeats.some(pos => Math.abs(startPosition - pos) < tolerance);
            
            if (!startsOnQuarterBeat) {
                console.log(`    ğŸ¼ æœ‰16åˆ†éŸ³ç¬¦åœºæ™¯ï¼šä½ç½®${startPosition}çš„éŸ³ç¬¦ï¼ˆ${duration}æ‹ï¼‰ä¸åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼Œæ¨¡ç³Šäº†æ‹ç‚¹ï¼Œéœ€è¦æ‹†åˆ†`);
                return false; // éœ€è¦æ‹†åˆ†
            }
        }
        
        // é‡è¦ä¿®æ­£ï¼šè§„åˆ™åº”è¯¥æ˜¯æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦åœ¨å®ƒ**è·¨è¶Šçš„æ‹ç‚¹å¯¹åº”çš„æ—¶å€¼çº§æ•°**ä¸Š
        // è€Œä¸æ˜¯ä»…ä»…æ£€æŸ¥èµ·å§‹ä½ç½®
        
        // äºŒåˆ†éŸ³ç¬¦ï¼ˆ2æ‹ï¼‰ï¼šç‰¹æ®Šå¤„ç†
        // å½“è·¨è¶Šæ‹ç‚¹2æ—¶ï¼Œåªæœ‰ä»ä½ç½®0æˆ–2å¼€å§‹çš„äºŒåˆ†éŸ³ç¬¦æ‰ä¸æ‹†åˆ†
        if (Math.abs(duration - 2) < tolerance) {
            // å¦‚æœè·¨è¶Šæ‹ç‚¹2ï¼Œæ£€æŸ¥æ˜¯å¦ä»æ­£ç¡®ä½ç½®å¼€å§‹
            if (Math.abs(crossedBeatPoint - 2) < tolerance) {
                // è·¨è¶Šæ‹ç‚¹2çš„äºŒåˆ†éŸ³ç¬¦åªæœ‰ä»0æˆ–2å¼€å§‹æ‰ç¬¦åˆä¾‹å¤–
                const validStarts = [0, 2];
                const isValid = validStarts.some(pos => Math.abs(startPosition - pos) < tolerance);
                if (isValid) {
                    console.log(`    ğŸ¯ äºŒåˆ†éŸ³ç¬¦ä»ä½ç½®${startPosition}è·¨è¶Šæ‹ç‚¹${crossedBeatPoint} - ç¬¦åˆä¾‹å¤–ï¼Œä¸æ‹†åˆ†`);
                    return true;
                } else {
                    console.log(`    âŒ äºŒåˆ†éŸ³ç¬¦ä»ä½ç½®${startPosition}è·¨è¶Šæ‹ç‚¹${crossedBeatPoint} - ä¸ç¬¦åˆä¾‹å¤–ï¼Œéœ€è¦æ‹†åˆ†`);
                    return false;
                }
            }
            // å…¶ä»–æƒ…å†µçš„äºŒåˆ†éŸ³ç¬¦
            const halfBeats = [0, 2];
            const isOnHalfBeat = halfBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
            if (isOnHalfBeat) {
                console.log(`    ğŸ¯ äºŒåˆ†éŸ³ç¬¦åœ¨äºŒåˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - ä¸æ‹†åˆ†`);
                return true;
            } else {
                console.log(`    âŒ äºŒåˆ†éŸ³ç¬¦ä¸åœ¨äºŒåˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - éœ€è¦æ‹†åˆ†`);
                return false;
            }
        }
        
        // å››åˆ†éŸ³ç¬¦ï¼ˆ1æ‹ï¼‰ï¼šåªæœ‰åœ¨å››åˆ†éŸ³ç¬¦æ­£æ‹ä¸Šæ‰ä¸æ‹†åˆ† (0, 1, 2, 3)
        // ç‰¹åˆ«å¼ºè°ƒï¼šå››åˆ†éŸ³ç¬¦åœ¨åæ‹ï¼ˆ1.5, 2.5, 3.5ï¼‰ä¸Šå¿…é¡»æ‹†åˆ†ï¼
        // ğŸ¯ æ–°å¢ï¼šå¦‚æœå½“å‰éœ€è¦æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1,3ï¼‰ï¼Œå››åˆ†éŸ³ç¬¦åœ¨2æ‹ä½ç½®ä¹Ÿå¿…é¡»æ‹†åˆ†ï¼
        if (Math.abs(duration - 1) < tolerance) {
            const quarterBeats = [0, 1, 2, 3]; // å››åˆ†éŸ³ç¬¦çš„æ­£æ‹
            const offBeats = [0.5, 1.5, 2.5, 3.5]; // åæ‹ï¼ˆå…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰
            
            const isOnQuarterBeat = quarterBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
            const isOnOffBeat = offBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
            
            if (isOnOffBeat) {
                console.log(`    âŒ å››åˆ†éŸ³ç¬¦åœ¨åæ‹ä¸Š: ä½ç½®${startPosition} - å¿…é¡»æ‹†åˆ†ï¼ˆä¿æŠ¤äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°åº¦ï¼‰`);
                return false; // åæ‹ä¸Šçš„å››åˆ†éŸ³ç¬¦å¿…é¡»æ‹†åˆ†
            } else if (isOnQuarterBeat) {
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
                // å¦‚æœå…³é”®æ‹ç‚¹åªåŒ…å«1å’Œ3ï¼ˆäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰ï¼Œè¯´æ˜å½“å‰åŒºåŸŸæœ€å°æ—¶å€¼æ˜¯å…«åˆ†éŸ³ç¬¦
                // æ­¤æ—¶å››åˆ†éŸ³ç¬¦å³ä½¿åœ¨2æ‹ä½ç½®ä¹Ÿåº”è¯¥æ‹†åˆ†ï¼Œä»¥ä¿æŠ¤äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°åº¦
                const needsHalfNoteBeatClarity = criticalBeats.length === 2 && 
                    criticalBeats.includes(1) && criticalBeats.includes(3) && 
                    !criticalBeats.includes(2) && !criticalBeats.includes(4);
                
                if (needsHalfNoteBeatClarity && (Math.abs(startPosition - 2) < tolerance)) {
                    console.log(`    âŒ å››åˆ†éŸ³ç¬¦åœ¨2æ‹ä½ç½®ï¼Œä½†éœ€è¦æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹: ä½ç½®${startPosition} - å¿…é¡»æ‹†åˆ†ï¼ˆå…«åˆ†éŸ³ç¬¦åŒºåŸŸï¼‰`);
                    return false; // éœ€è¦æ‹†åˆ†ä»¥ä¿æŠ¤äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
                }
                
                console.log(`    ğŸ¯ å››åˆ†éŸ³ç¬¦åœ¨å››åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - ä¸æ‹†åˆ†`);
                return true;
            } else {
                console.log(`    âŒ å››åˆ†éŸ³ç¬¦ä¸åœ¨å››åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - éœ€è¦æ‹†åˆ†`);
                return false;
            }
        }
        
        // å…«åˆ†éŸ³ç¬¦ï¼ˆ0.5æ‹ï¼‰ï¼šåªæœ‰åœ¨å…«åˆ†éŸ³ç¬¦æ­£æ‹ä¸Šæ‰ä¸æ‹†åˆ† (0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5)
        if (Math.abs(duration - 0.5) < tolerance) {
            const eighthBeats = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5];
            const isOnEighthBeat = eighthBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
            if (isOnEighthBeat) {
                console.log(`    ğŸ¯ å…«åˆ†éŸ³ç¬¦åœ¨å…«åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - ä¸æ‹†åˆ†`);
                return true;
            } else {
                console.log(`    âŒ å…«åˆ†éŸ³ç¬¦ä¸åœ¨å…«åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - éœ€è¦æ‹†åˆ†`);
                return false;
            }
        }
        
        // åå…­åˆ†éŸ³ç¬¦ï¼ˆ0.25æ‹ï¼‰ï¼šåªæœ‰åœ¨åå…­åˆ†éŸ³ç¬¦æ­£æ‹ä¸Šæ‰ä¸æ‹†åˆ†
        if (Math.abs(duration - 0.25) < tolerance) {
            // æ£€æŸ¥æ˜¯å¦åœ¨åå…­åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š (0, 0.25, 0.5, 0.75, 1, 1.25, ...)
            const position16th = Math.round(startPosition / 0.25) * 0.25;
            const isOnSixteenthBeat = Math.abs(startPosition - position16th) < tolerance;
            if (isOnSixteenthBeat) {
                console.log(`    ğŸ¯ åå…­åˆ†éŸ³ç¬¦åœ¨åå…­åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - ä¸æ‹†åˆ†`);
                return true;
            } else {
                console.log(`    âŒ åå…­åˆ†éŸ³ç¬¦ä¸åœ¨åå…­åˆ†éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - éœ€è¦æ‹†åˆ†`);
                return false;
            }
        }
        
        // å…¨éŸ³ç¬¦ï¼ˆ4æ‹ï¼‰ï¼šåªæœ‰åœ¨å…¨éŸ³ç¬¦æ­£æ‹ä¸Šæ‰ä¸æ‹†åˆ† (0)
        if (Math.abs(duration - 4) < tolerance) {
            const isOnWholeBeat = Math.abs(startPosition - 0) < tolerance;
            if (isOnWholeBeat) {
                console.log(`    ğŸ¯ å…¨éŸ³ç¬¦åœ¨å…¨éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - ä¸æ‹†åˆ†`);
                return true;
            } else {
                console.log(`    âŒ å…¨éŸ³ç¬¦ä¸åœ¨å…¨éŸ³ç¬¦æ­£æ‹ä¸Š: ä½ç½®${startPosition} - éœ€è¦æ‹†åˆ†`);
                return false;
            }
        }
        
        console.log(`    âš ï¸ æœªè¯†åˆ«çš„éŸ³ç¬¦æ—¶å€¼: ${duration}æ‹ - é»˜è®¤æ‹†åˆ†`);
        return false;
    },
    
    // 6/8æ‹çš„è·¨æ‹æ£€æµ‹
    detectsCrossBeatsFor6_8: function(startPosition, duration, allNotes, noteType = 'note') {
        const endPosition = startPosition + duration;
        const tolerance = 0.0001;
        
        // è·å–6/8æ‹çš„å…³é”®æ‹ç‚¹
        const criticalBeats = this.getCriticalBeatsFor6_8(allNotes);
        
        console.log(`  ğŸµ 6/8æ‹æ£€æŸ¥${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'} [${startPosition}-${endPosition}] è·¨æ‹: [${criticalBeats.join(', ')}]`);
        
        // æ£€æŸ¥æ˜¯å¦è·¨è¶Šå…³é”®æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            if (startPosition < beatPoint - tolerance && endPosition > beatPoint + tolerance) {
                console.log(`  âš ï¸ 6/8æ‹${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'}è·¨è¶Šæ‹ç‚¹ ${beatPoint}`);
                
                // æ£€æŸ¥6/8æ‹çš„ç‰¹æ®Šä¾‹å¤–è§„åˆ™
                if (noteType === 'note' && this.isNoteOnCorrespondingBeatFor6_8(startPosition, duration, beatPoint)) {
                    console.log(`  ğŸ¯ 6/8æ‹ä¾‹å¤–ï¼šéŸ³ç¬¦åœ¨å¯¹åº”æ‹ç‚¹ä¸Šï¼Œä¸æ‹†åˆ†`);
                    continue;
                }
                
                // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»æ˜ç¡®
                if (this.isBeatPointAlreadyClear(startPosition, endPosition, beatPoint, allNotes, '6/8')) {
                    console.log(`  âœ… 6/8æ‹æ‹ç‚¹${beatPoint}å·²æ˜ç¡®ï¼Œä¸æ‹†åˆ†`);
                    continue;
                }
                
                console.log(`  ğŸ”¥ 6/8æ‹éœ€è¦æ‹†åˆ†ï¼šè·¨è¶Šæ‹ç‚¹${beatPoint}`);
                return {
                    crossesBeat: true,
                    beatPoint: beatPoint,
                    splitPositions: [beatPoint]
                };
            }
        }
        
        return { crossesBeat: false };
    },
    
    // 3/4æ‹çš„è·¨æ‹æ£€æµ‹
    detectsCrossBeatsFor3_4: function(startPosition, duration, allNotes, noteType = 'note') {
        const endPosition = startPosition + duration;
        const tolerance = 0.0001;
        
        // ğŸ¼ ç‰¹æ®Šå¤„ç†ï¼šé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆ3æ‹ï¼‰åœ¨3/4æ‹ä¸­æ˜¯å®Œæ•´å°èŠ‚ï¼Œæ°¸è¿œä¸æ‹†åˆ†
        if (Math.abs(duration - 3) < tolerance && noteType === 'note') {
            // 3æ‹çš„éŸ³ç¬¦ï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼‰åœ¨3/4æ‹ä¸­å æ»¡æ•´ä¸ªå°èŠ‚ï¼Œæ— è®ºä½ç½®å¦‚ä½•éƒ½ä¸åº”è¯¥æ‹†åˆ†
            console.log(`  ğŸ¯ 3/4æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼šæ—¶é•¿3æ‹ï¼Œä½ç½®${startPosition}ï¼Œå æ»¡æ•´ä¸ªå°èŠ‚ï¼Œæ°¸ä¸æ‹†åˆ†`);
            return { crossesBeat: false };
        }
        
        // è·å–3/4æ‹çš„å…³é”®æ‹ç‚¹
        const criticalBeats = this.getCriticalBeatsFor3_4(allNotes);
        
        console.log(`  ğŸµ 3/4æ‹æ£€æŸ¥${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'} [${startPosition}-${endPosition}] è·¨æ‹: [${criticalBeats.join(', ')}]`);
        
        // æ£€æŸ¥æ˜¯å¦è·¨è¶Šå…³é”®æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            if (startPosition < beatPoint - tolerance && endPosition > beatPoint + tolerance) {
                console.log(`  âš ï¸ 3/4æ‹${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'}è·¨è¶Šæ‹ç‚¹ ${beatPoint}`);
                
                // æ£€æŸ¥3/4æ‹çš„ç‰¹æ®Šä¾‹å¤–è§„åˆ™
                if (noteType === 'note' && this.isNoteOnCorrespondingBeatFor3_4(startPosition, duration, beatPoint)) {
                    console.log(`  ğŸ¯ 3/4æ‹ä¾‹å¤–ï¼šéŸ³ç¬¦åœ¨å¯¹åº”æ‹ç‚¹ä¸Šï¼Œä¸æ‹†åˆ†`);
                    continue;
                }
                
                // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»æ˜ç¡®
                if (this.isBeatPointAlreadyClear(startPosition, endPosition, beatPoint, allNotes, '3/4')) {
                    console.log(`  âœ… 3/4æ‹æ‹ç‚¹${beatPoint}å·²æ˜ç¡®ï¼Œä¸æ‹†åˆ†`);
                    continue;
                }
                
                console.log(`  ğŸ”¥ 3/4æ‹éœ€è¦æ‹†åˆ†ï¼šè·¨è¶Šæ‹ç‚¹${beatPoint}`);
                return {
                    crossesBeat: true,
                    beatPoint: beatPoint,
                    splitPositions: [beatPoint]
                };
            }
        }
        
        return { crossesBeat: false };
    },
    
    // é€šç”¨è·¨æ‹æ£€æµ‹ï¼ˆç”¨äºå…¶ä»–æ—¶é—´ç­¾åï¼‰
    detectsCrossBeatsGeneric: function(startPosition, duration, timeSignature, allNotes, noteType = 'note') {
        const endPosition = startPosition + duration;
        const tolerance = 0.0001;
        
        // ä½¿ç”¨ä¼ ç»Ÿçš„å…³é”®æ‹ç‚¹é€»è¾‘
        const validNotes = allNotes.filter(n => {
            if (!n) {
                console.error(`âš ï¸ ç©ºéŸ³ç¬¦åœ¨finestRhythmè®¡ç®—ä¸­`);
                return false;
            }
            if (!n.type) {
                console.error(`âš ï¸ éŸ³ç¬¦ç¼ºå°‘typeå±æ€§: ${JSON.stringify(n)}`);
                return false;
            }
            if (typeof n.beats !== 'number') {
                console.error(`âš ï¸ éŸ³ç¬¦beatså±æ€§æ— æ•ˆ: ${JSON.stringify(n)}`);
                return false;
            }
            return n.type === 'note' && !n.isTriplet;
        });
        
        if (validNotes.length === 0) {
            console.error(`âš ï¸ æ²¡æœ‰æœ‰æ•ˆéŸ³ç¬¦è®¡ç®—finestRhythm`);
            return [0]; // è¿”å›é»˜è®¤æ‹ç‚¹
        }
        
        const finestRhythm = Math.min(...validNotes.map(n => n.beats));
        
        const criticalBeats = this.getCriticalBeatsForFinestRhythm(finestRhythm, timeSignature);
        
        console.log(`  ğŸµ ${timeSignature}æ‹æ£€æŸ¥${noteType === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'} [${startPosition}-${endPosition}] è·¨æ‹: [${criticalBeats.join(', ')}]`);
        
        // æ£€æŸ¥æ˜¯å¦è·¨è¶Šå…³é”®æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            if (startPosition < beatPoint - tolerance && endPosition > beatPoint + tolerance) {
                console.log(`  ğŸ”¥ ${timeSignature}æ‹éœ€è¦æ‹†åˆ†ï¼šè·¨è¶Šæ‹ç‚¹${beatPoint}`);
                return {
                    crossesBeat: true,
                    beatPoint: beatPoint,
                    splitPositions: [beatPoint]
                };
            }
        }
        
        return { crossesBeat: false };
    },
    
    // 6/8æ‹çš„å¯¹åº”æ‹ç‚¹æ£€æŸ¥
    isNoteOnCorrespondingBeatFor6_8: function(startPosition, duration, crossedBeatPoint) {
        const tolerance = 0.0001;
        
        // 6/8æ‹ä¸­ï¼Œé™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼ˆ1.5æ‹ï¼‰åº”è¯¥åœ¨ä¸»æ‹0å’Œ1.5ä¸Š
        if (Math.abs(duration - 1.5) < tolerance) {
            const mainBeats = [0, 1.5];
            return mainBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        // å››åˆ†éŸ³ç¬¦ï¼ˆ1æ‹ï¼‰åœ¨6/8æ‹ä¸­åº”è¯¥åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š
        if (Math.abs(duration - 1) < tolerance) {
            const quarterBeats = [0, 1, 2];
            return quarterBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        // å…«åˆ†éŸ³ç¬¦ï¼ˆ0.5æ‹ï¼‰åº”è¯¥åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆ6ä¸ªå…«åˆ†éŸ³ç¬¦ä½ç½®ï¼‰
        if (Math.abs(duration - 0.5) < tolerance) {
            const eighthBeats = [0, 0.5, 1, 1.5, 2, 2.5];
            return eighthBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        return false;
    },
    
    // 3/4æ‹çš„å¯¹åº”æ‹ç‚¹æ£€æŸ¥
    isNoteOnCorrespondingBeatFor3_4: function(startPosition, duration, crossedBeatPoint) {
        const tolerance = 0.0001;
        
        // ğŸ¼ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆ3æ‹ï¼‰åœ¨3/4æ‹ä¸­å æ»¡æ•´ä¸ªå°èŠ‚ï¼Œå®Œå…¨åˆæ³•
        if (Math.abs(duration - 3) < tolerance) {
            // å¿…é¡»ä»å°èŠ‚å¼€å§‹ä½ç½®ï¼ˆ0æ‹ï¼‰å¼€å§‹
            if (Math.abs(startPosition - 0) < tolerance) {
                console.log(`  ğŸ¯ 3/4æ‹ä¾‹å¤–ï¼šé™„ç‚¹äºŒåˆ†éŸ³ç¬¦å æ»¡æ•´ä¸ªå°èŠ‚ï¼Œå®Œå…¨åˆæ³•`);
                return true;
            }
        }
        
        // äºŒåˆ†éŸ³ç¬¦ï¼ˆ2æ‹ï¼‰åœ¨3/4æ‹ä¸­åº”è¯¥åœ¨å¼ºæ‹ä¸Š
        if (Math.abs(duration - 2) < tolerance) {
            const strongBeats = [0, 1]; // åªèƒ½åœ¨ç¬¬1æ‹æˆ–ç¬¬2æ‹å¼€å§‹
            return strongBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        // å››åˆ†éŸ³ç¬¦ï¼ˆ1æ‹ï¼‰åº”è¯¥åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š
        if (Math.abs(duration - 1) < tolerance) {
            const quarterBeats = [0, 1, 2];
            return quarterBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        // å…«åˆ†éŸ³ç¬¦ï¼ˆ0.5æ‹ï¼‰åº”è¯¥åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š
        if (Math.abs(duration - 0.5) < tolerance) {
            const eighthBeats = [0, 0.5, 1, 1.5, 2, 2.5];
            return eighthBeats.some(beat => Math.abs(startPosition - beat) < tolerance);
        }
        
        return false;
    },
    
    // æ ¹æ®æœ€ç»†èŠ‚å¥å€¼è·å–å…³é”®æ‹ç‚¹ï¼ˆä¸¤ç­‰çº§è§„åˆ™å®ç°ï¼‰
    getCriticalBeatsForFinestRhythm: function(finestRhythm, timeSignature) {
        const structure = this.getBeatStructure(timeSignature);
        
        if (timeSignature === '4/4') {
            if (finestRhythm <= 0.125) {
                // 32ndéŸ³ç¬¦æˆ–æ›´ç»† -> ä¿æŒå…«åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°
                return [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]; // æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.25) {
                // 16åˆ†éŸ³ç¬¦ -> ä¿æŒå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™° (1,2,3,4)
                return [0, 1, 2, 3]; // å››åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.5) {
                // 8åˆ†éŸ³ç¬¦ -> ä¿æŒäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™° (1,3)
                return [0, 2]; // æ‹1, 3 (äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹)
            } else {
                // å››åˆ†éŸ³ç¬¦æˆ–æ›´é•¿ -> åªä¿æŒå…¨éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°
                return [0]; // åªæœ‰ç¬¬1æ‹
            }
        } else if (timeSignature === '3/4') {
            if (finestRhythm <= 0.125) {
                return [0, 0.5, 1, 1.5, 2, 2.5]; // æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.25) {
                // 16théŸ³ç¬¦ -> ä¿æŒå…«åˆ†éŸ³ç¬¦æ‹ç‚¹å’Œå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°ï¼ˆä¸¤ç­‰çº§è§„åˆ™ï¼‰
                return [0, 0.5, 1, 1.5, 2, 2.5]; // å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ + å››åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.5) {
                return [0, 1, 2]; // æ‹1, 2, 3ï¼ˆ3/4æ‹çš„ç‰¹æ®Šæ€§ï¼‰
            } else {
                return [0]; // åªæœ‰ç¬¬1æ‹
            }
        } else if (timeSignature === '2/4') {
            if (finestRhythm <= 0.125) {
                return [0, 0.5, 1, 1.5]; // æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.25) {
                // 16théŸ³ç¬¦ -> ä¿æŒå…«åˆ†éŸ³ç¬¦æ‹ç‚¹å’Œå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°ï¼ˆä¸¤ç­‰çº§è§„åˆ™ï¼‰
                return [0, 0.5, 1, 1.5]; // å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ + å››åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.5) {
                return [0]; // åªæœ‰ç¬¬1æ‹ï¼ˆå¼ºæ‹ï¼‰
            } else {
                return [0]; // åªæœ‰ç¬¬1æ‹
            }
        } else if (timeSignature === '6/8') {
            if (finestRhythm <= 0.125) {
                return structure.subdivisions; // æ‰€æœ‰ç»†åˆ†æ‹ç‚¹
            } else if (finestRhythm <= 0.25) {
                return [0, 1, 2, 3, 4, 5]; // æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            } else if (finestRhythm <= 0.5) {
                return [0, 3]; // ä¸¤ä¸ªå¤§æ‹
            } else {
                return [0]; // åªæœ‰ç¬¬1æ‹
            }
        }
        
        // é»˜è®¤æƒ…å†µï¼šåªä¿æŒå¼ºæ‹
        return structure.strongBeats;
    },
    
    // æ™ºèƒ½å±€éƒ¨èŠ‚å¥æ£€æµ‹ï¼šæ ¹æ®æ¯æ‹å†…å®¹å†³å®šè¯¥æ‹çš„å…³é”®ç‚¹
    getCriticalBeatsWithLocalRhythm: function(notes, timeSignature) {
        if (timeSignature === '6/8') {
            // 6/8æ‹ï¼šå¤åˆäºŒæ‹å­å¤„ç†
            return this.getCriticalBeatsFor6_8(notes);
        } else if (timeSignature === '3/4') {
            // 3/4æ‹ï¼šç®€å•ä¸‰æ‹å­å¤„ç†  
            return this.getCriticalBeatsFor3_4(notes);
        } else if (timeSignature !== '4/4') {
            // å…¶ä»–æ‹å·ä½¿ç”¨ä¼ ç»Ÿé€»è¾‘
            const finestRhythm = Math.min(...notes
                .filter(n => n.type === 'note' && !n.isTriplet)
                .map(n => n.beats));
            return this.getCriticalBeatsForFinestRhythm(finestRhythm, timeSignature);
        }
        
        const criticalBeats = new Set();
        
        // ğŸ¼ é¦–å…ˆæ‰«ææ•´ä¸ªå°èŠ‚ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰16åˆ†éŸ³ç¬¦
        let has16thNote = false;
        let minBeatValue = Infinity;
        
        console.log(`ğŸ” æ‰«ææ•´ä¸ªå°èŠ‚å¯»æ‰¾16åˆ†éŸ³ç¬¦:`);
        for (const note of notes) {
            // è·³è¿‡ä¸‰è¿éŸ³ï¼Œåªçœ‹æ™®é€šéŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦
            if (!note.isTriplet) {
                minBeatValue = Math.min(minBeatValue, note.beats);
                if (Math.abs(note.beats - 0.25) < 0.001) {
                    has16thNote = true;
                    console.log(`    ğŸ¼ å‘ç°16åˆ†éŸ³ç¬¦ï¼${note.type === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'} 0.25æ‹`);
                }
            }
        }
        
        console.log(`  æ•´ä¸ªå°èŠ‚æœ€å°æ—¶å€¼: ${minBeatValue}æ‹`);
        console.log(`  åŒ…å«16åˆ†éŸ³ç¬¦: ${has16thNote}`);
        
        // ğŸ¯ å¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œç›´æ¥è¿”å›æ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹
        if (has16thNote) {
            criticalBeats.add(0).add(1).add(2).add(3);
            console.log(`ğŸ¼ âœ… æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦ â†’ æ˜¾ç¤ºæ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹ [0, 1, 2, 3]`);
            console.log(`    âš ï¸ ä¸æ˜¾ç¤ºå…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ0.5, 1.5, 2.5, 3.5ï¼‰`);
            const result = Array.from(criticalBeats).sort((a, b) => a - b);
            console.log(`ğŸ¯ æœ€ç»ˆå…³é”®æ‹ç‚¹: [${result.join(', ')}]`);
            return result;
        }
        
        // å¦‚æœæ²¡æœ‰16åˆ†éŸ³ç¬¦ï¼Œç»§ç»­åŸæ¥çš„åŒºåŸŸåˆ†æé€»è¾‘
        // æ–°è§„åˆ™ï¼šæ ¹æ®æ¯äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹é‡Œçš„æœ€å°æ—¶å€¼æ¥ç¡®å®šæ‹ç‚¹æ¸…æ™°åº¦
        // 4/4æ‹çš„äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸï¼š[0-2æ‹] å’Œ [2-4æ‹]
        const halfNoteBeatRegions = [
            { start: 0, end: 2, beatPoint: 0 },  // ç¬¬ä¸€ä¸ªäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸ
            { start: 2, end: 4, beatPoint: 2 }   // ç¬¬äºŒä¸ªäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸ
        ];
        
        // å­˜å‚¨æ¯ä¸ªåŒºåŸŸçš„åˆ†æç»“æœ
        const regionAnalysis = [];
        
        console.log(`ğŸ” æ²¡æœ‰16åˆ†éŸ³ç¬¦ï¼ŒæŒ‰äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åˆ†ææ¯ä¸ªåŒºåŸŸçš„æœ€å°æ—¶å€¼:`);
        
        for (const region of halfNoteBeatRegions) {
            let regionMinValue = Infinity;
            let regionNotes = [];
            
            // è®¡ç®—æ¯ä¸ªéŸ³ç¬¦çš„èµ·å§‹ä½ç½®
            let currentPos = 0;
            for (const note of notes) {
                const noteStart = currentPos;
                const noteEnd = currentPos + note.beats;
                
                // æ£€æŸ¥éŸ³ç¬¦æˆ–ä¼‘æ­¢ç¬¦æ˜¯å¦ä¸å½“å‰åŒºåŸŸæœ‰é‡å 
                // é‡è¦ä¿®æ­£ï¼šåŒ…æ‹¬ä¼‘æ­¢ç¬¦åœ¨å†…çš„åˆ†æï¼ˆç”¨æˆ·å¼ºè°ƒçš„ï¼šåŒ…æ‹¬ä¼‘æ­¢ç¬¦ï¼‰
                if (noteEnd > region.start && noteStart < region.end && !note.isTriplet) {
                    regionMinValue = Math.min(regionMinValue, note.beats);
                    regionNotes.push({
                        beats: note.beats,
                        type: note.type,
                        position: noteStart
                    });
                }
                currentPos += note.beats;
            }
            
            if (regionMinValue === Infinity) {
                regionMinValue = 4; // å¦‚æœåŒºåŸŸä¸ºç©ºï¼Œå‡è®¾ä¸ºå…¨éŸ³ç¬¦
            }
            
            console.log(`  åŒºåŸŸ [${region.start}-${region.end}æ‹]: æœ€å°æ—¶å€¼=${regionMinValue}æ‹`);
            regionNotes.forEach(n => {
                console.log(`    ${n.type}: ${n.beats}æ‹ @ ä½ç½®${n.position}`);
            });
            
            // æ ¹æ®æœ€å°æ—¶å€¼ç¡®å®šéœ€è¦æ˜¾ç¤ºçš„æ‹ç‚¹ï¼ˆå¤§ä¸¤ä¸ªå±‚çº§ï¼‰
            let requiredBeatLevel;
            if (regionMinValue <= 0.25) {
                // åå…­åˆ†éŸ³ç¬¦ï¼ˆ0.25æ‹ï¼‰â†’ æ˜¾ç¤ºå››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1,2,3,4ï¼‰ï¼Œå…«åˆ†éŸ³ç¬¦çš„æ‹ç‚¹å°±ä¸éœ€è¦æ˜¾ç¤º
                requiredBeatLevel = 'quarter';
                console.log(`    ğŸ¼ æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦ï¼éœ€è¦æ˜¾ç¤ºæ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1,2,3,4ï¼‰`);
            } else if (regionMinValue <= 0.5) {
                // å…«åˆ†éŸ³ç¬¦ï¼ˆ0.5æ‹ï¼‰â†’ æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1,3ï¼‰ï¼Œå››åˆ†éŸ³ç¬¦çš„æ‹ç‚¹å°±ä¸éœ€è¦æ˜¾ç¤º
                requiredBeatLevel = 'half';
                console.log(`    â†’ éœ€è¦æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1,3ï¼‰`);
            } else if (regionMinValue <= 1) {
                // å››åˆ†éŸ³ç¬¦ï¼ˆ1æ‹ï¼‰â†’ æ˜¾ç¤ºå…¨éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1ï¼‰ï¼ŒäºŒåˆ†éŸ³ç¬¦çš„æ‹ç‚¹å°±ä¸éœ€è¦æ˜¾ç¤º
                requiredBeatLevel = 'whole';
                console.log(`    â†’ éœ€è¦æ˜¾ç¤ºå…¨éŸ³ç¬¦æ‹ç‚¹ï¼ˆ1ï¼‰`);
            } else {
                // æœ€å°æ—¶å€¼æ˜¯2åˆ†éŸ³ç¬¦æˆ–æ›´é•¿ â†’ ä¸éœ€è¦é¢å¤–æ‹ç‚¹
                requiredBeatLevel = 'none';
                console.log(`    â†’ ä¸éœ€è¦é¢å¤–æ‹ç‚¹`);
            }
            
            // å­˜å‚¨åˆ†æç»“æœè€Œä¸æ˜¯ç«‹å³æ·»åŠ æ‹ç‚¹
            regionAnalysis.push({
                region: region,
                minValue: regionMinValue,
                beatLevel: requiredBeatLevel
            });
        }
        
        // ğŸ¯ æ ¸å¿ƒæ”¹æ­£ï¼šæ ¹æ®æœ€å°éŸ³ç¬¦å€¼å†³å®šæ‹ç‚¹
        console.log(`ğŸ”§ æ ¹æ®èŠ‚å¥å¤æ‚åº¦ç¡®å®šæ‹ç‚¹ï¼š`);
        console.log(`  åŒºåŸŸåˆ†æç»“æœ:`, regionAnalysis.map(r => ({
            region: `${r.region.start}-${r.region.end}`,
            minValue: r.minValue,
            beatLevel: r.beatLevel
        })));
        
        // ğŸ¼ æ–°è§„åˆ™ï¼šå¦‚æœä»»ä¸€åŒºåŸŸæœ‰16åˆ†éŸ³ç¬¦ï¼Œæ˜¾ç¤ºæ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹
        const has16thInAnyRegion = regionAnalysis.some(r => r && r.beatLevel === 'quarter');
        
        console.log(`  ğŸ” æ£€æŸ¥æ˜¯å¦æœ‰16åˆ†éŸ³ç¬¦: ${has16thInAnyRegion}`);
        
        if (has16thInAnyRegion) {
            // æœ‰16åˆ†éŸ³ç¬¦ï¼šæ˜¾ç¤ºæ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ0,1,2,3ï¼‰
            criticalBeats.add(0).add(1).add(2).add(3);
            console.log(`    ğŸ¼ æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦ â†’ æ˜¾ç¤ºæ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹ [0, 1, 2, 3]`);
            console.log(`    âš ï¸ ä¸æ˜¾ç¤ºå…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ0.5, 1.5, 2.5, 3.5ï¼‰`);
        } else {
            // æ²¡æœ‰16åˆ†éŸ³ç¬¦ï¼ŒæŒ‰åŒºåŸŸå¤„ç†
            const region1 = regionAnalysis[0];
            if (region1) {
                console.log(`  ğŸ“ åŒºåŸŸ1 [0-2æ‹]:`);
                if (region1.beatLevel === 'half') {
                    // 8åˆ†éŸ³ç¬¦ â†’ åªéœ€è¦æ˜¾ç¤ºæ‹ç‚¹1
                    criticalBeats.add(0);
                    console.log(`    â†’ æœ‰8åˆ†éŸ³ç¬¦ â†’ æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ [0] (ç¬¬1æ‹)`);
                } else if (region1.beatLevel === 'whole') {
                    // 4åˆ†éŸ³ç¬¦ â†’ åªéœ€è¦æ˜¾ç¤ºæ‹ç‚¹1
                    criticalBeats.add(0);
                    console.log(`    â†’ æœ‰4åˆ†éŸ³ç¬¦ â†’ æ˜¾ç¤ºå…¨éŸ³ç¬¦æ‹ç‚¹ [0] (ç¬¬1æ‹)`);
                } else {
                    console.log(`    â†’ ç®€å•èŠ‚å¥ï¼Œä¸éœ€è¦é¢å¤–æ‹ç‚¹`);
                }
            }
            
            // å¤„ç†ç¬¬äºŒä¸ªåŒºåŸŸï¼ˆ2-4æ‹ï¼‰
            const region2 = regionAnalysis[1];
            if (region2) {
                console.log(`  ğŸ“ åŒºåŸŸ2 [2-4æ‹]:`);
                if (region2.beatLevel === 'half') {
                    // 8åˆ†éŸ³ç¬¦ â†’ åªéœ€è¦æ˜¾ç¤ºæ‹ç‚¹3
                    criticalBeats.add(2);
                    console.log(`    â†’ æœ‰8åˆ†éŸ³ç¬¦ â†’ æ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ [2] (ç¬¬3æ‹)`);
                } else if (region2.beatLevel === 'whole') {
                    // 4åˆ†éŸ³ç¬¦ â†’ ç†è®ºä¸Šéœ€è¦æ˜¾ç¤ºå…¨éŸ³ç¬¦æ‹ç‚¹ï¼Œä½†åœ¨4/4æ‹ä¸­ç¬¬äºŒä¸ªåŒºåŸŸæ²¡æœ‰ç‹¬ç«‹çš„å…¨éŸ³ç¬¦æ‹ç‚¹
                    // æ‰€ä»¥ä¸æ·»åŠ é¢å¤–æ‹ç‚¹ï¼ˆæ‹ç‚¹1å·²ç»åœ¨ç¬¬ä¸€ä¸ªåŒºåŸŸå¤„ç†ï¼‰
                    console.log(`    â†’ æœ‰4åˆ†éŸ³ç¬¦ â†’ ç¬¬äºŒä¸ªåŒºåŸŸä¸éœ€è¦é¢å¤–çš„å…¨éŸ³ç¬¦æ‹ç‚¹`);
                } else {
                    console.log(`    â†’ ç®€å•èŠ‚å¥ï¼Œä¸éœ€è¦é¢å¤–æ‹ç‚¹`);
                }
            }
        }
        
        const result = Array.from(criticalBeats).sort((a, b) => a - b);
        console.log(`ğŸ¯ æœ€ç»ˆå…³é”®æ‹ç‚¹: [${result.join(', ')}]`);
        return result;
    },

    // 6/8æ‹çš„å…³é”®æ‹ç‚¹åˆ†æï¼ˆå¤åˆäºŒæ‹å­ï¼‰
    getCriticalBeatsFor6_8: function(notes) {
        console.log(`ğŸµ 6/8æ‹å…³é”®æ‹ç‚¹åˆ†æ - å¤åˆäºŒæ‹å­`);
        
        const criticalBeats = new Set();
        
        // 6/8æ‹åŸºæœ¬ç»“æ„ï¼š2ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹å­ (0-1.5, 1.5-3)
        // æ¯ä¸ªä¸»æ‹åŒ…å«3ä¸ªå…«åˆ†éŸ³ç¬¦å­æ‹ï¼ˆå…±3ä¸ªå››åˆ†éŸ³ç¬¦æ‹é•¿åº¦ï¼‰
        const mainBeats = [
            { start: 0, end: 1.5, center: 0.75 },  // ç¬¬ä¸€ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ï¼ˆ3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
            { start: 1.5, end: 3, center: 2.25 }   // ç¬¬äºŒä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ï¼ˆ3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
        ];
        
        // æ€»æ˜¯æ˜¾ç¤ºä¸»æ‹ç‚¹
        criticalBeats.add(0).add(1.5);
        console.log(`  â†’ ä¸»æ‹ç‚¹: 0, 1.5 (ä¸¤ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹)`);
        
        // ğŸ”¥ æ£€æµ‹æ˜¯å¦åœ¨16åˆ†éŸ³ç¬¦ç¯å¢ƒä¸‹
        const has16thNotes = notes.some(note => !note.isTriplet && Math.abs(note.beats - 0.25) < 0.001);
        
        if (has16thNotes) {
            // 16åˆ†éŸ³ç¬¦ç¯å¢ƒï¼šæ·»åŠ æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            criticalBeats.add(0.5).add(1).add(2).add(2.5);
            console.log(`  ğŸ” 16åˆ†éŸ³ç¬¦ç¯å¢ƒï¼šæ·»åŠ æ‰€æœ‰å…«åˆ†éŸ³ç¬¦æ‹ç‚¹: 0.5, 1, 2, 2.5`);
        } else {
            // åˆ†ææ¯ä¸ªä¸»æ‹å†…çš„èŠ‚å¥å¤æ‚åº¦
            let position = 0;
            for (const beat of mainBeats) {
                let beatMinValue = Infinity;
                
                // é‡ç½®positionè®¡ç®—
                position = 0;
                
                // æ‰¾åˆ°è¯¥æ‹å†…çš„æœ€å°æ—¶å€¼
                for (const note of notes) {
                    if (note.type === 'note' && !note.isTriplet) {
                        const noteStart = position;
                        const noteEnd = position + note.beats;
                        
                        // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦ä¸å½“å‰æ‹é‡å 
                        if (noteEnd > beat.start && noteStart < beat.end) {
                            beatMinValue = Math.min(beatMinValue, note.beats);
                        }
                    }
                    position += note.beats;
                }
                
                // æ ¹æ®æ‹å†…æœ€å°æ—¶å€¼å†³å®šæ˜¯å¦éœ€è¦ç»†åˆ†æ‹ç‚¹
                if (beatMinValue <= 0.5) {
                    // éœ€è¦æ˜¾ç¤ºå…«åˆ†éŸ³ç¬¦å±‚çº§çš„æ‹ç‚¹
                    if (beat.start === 0) {
                        criticalBeats.add(0.5).add(1);
                        console.log(`  â†’ ç¬¬ä¸€æ‹æœ‰å…«åˆ†éŸ³ç¬¦ï¼Œæ·»åŠ ç»†åˆ†æ‹ç‚¹: 0.5, 1`);
                    } else if (beat.start === 1.5) {
                        criticalBeats.add(2).add(2.5);
                        console.log(`  â†’ ç¬¬äºŒæ‹æœ‰å…«åˆ†éŸ³ç¬¦ï¼Œæ·»åŠ ç»†åˆ†æ‹ç‚¹: 2, 2.5`);
                    }
                }
            }
        }
        
        const result = Array.from(criticalBeats).sort((a, b) => a - b);
        console.log(`ğŸ¯ 6/8æ‹æœ€ç»ˆå…³é”®æ‹ç‚¹: [${result.join(', ')}]`);
        return result;
    },

    // 3/4æ‹çš„å…³é”®æ‹ç‚¹åˆ†æï¼ˆç®€å•ä¸‰æ‹å­ï¼‰
    getCriticalBeatsFor3_4: function(notes) {
        console.log(`ğŸµ 3/4æ‹å…³é”®æ‹ç‚¹åˆ†æ - ç®€å•ä¸‰æ‹å­`);
        
        const criticalBeats = new Set();
        
        // 3/4æ‹åŸºæœ¬ç»“æ„ï¼š3ä¸ªå››åˆ†éŸ³ç¬¦æ‹å­ (0, 1, 2)
        criticalBeats.add(0).add(1).add(2);
        console.log(`  â†’ ä¸»æ‹ç‚¹: 0, 1, 2 (ä¸‰ä¸ªå››åˆ†éŸ³ç¬¦æ‹)`);
        
        // åˆ†ææ˜¯å¦éœ€è¦å…«åˆ†éŸ³ç¬¦ç»†åˆ†
        let needsEighthSubdivision = false;
        for (const note of notes) {
            if (note.type === 'note' && !note.isTriplet && note.beats <= 0.5) {
                needsEighthSubdivision = true;
                break;
            }
        }
        
        if (needsEighthSubdivision) {
            // æ·»åŠ å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼ˆ+æ‹ï¼‰
            criticalBeats.add(0.5).add(1.5).add(2.5);
            console.log(`  â†’ æœ‰å…«åˆ†éŸ³ç¬¦ï¼Œæ·»åŠ ç»†åˆ†æ‹ç‚¹: 0.5, 1.5, 2.5`);
        }
        
        const result = Array.from(criticalBeats).sort((a, b) => a - b);
        console.log(`ğŸ¯ 3/4æ‹æœ€ç»ˆå…³é”®æ‹ç‚¹: [${result.join(', ')}]`);
        return result;
    },
    
    // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å·²ç»æ˜ç¡®æ˜¾ç¤º
    isBeatPointAlreadyClear: function(noteStart, noteEnd, beatPoint, allNotes, timeSignature) {
        if (timeSignature !== '4/4' && timeSignature !== '6/8' && timeSignature !== '3/4') {
            return false; // æš‚ä¸æ”¯æŒçš„æ‹å·
        }
        
        // åˆ†ææ•´ä¸ªå°èŠ‚çš„èŠ‚å¥æƒ…å†µï¼Œç¡®å®šå“ªäº›æ‹ç‚¹å·²ç»è¢«æ˜ç¡®æ˜¾ç¤º
        const criticalBeats = this.getCriticalBeatsWithLocalRhythm(allNotes, timeSignature);
        
        // æ£€æŸ¥å½“å‰æ‹ç‚¹æ˜¯å¦åœ¨å…³é”®æ‹ç‚¹åˆ—è¡¨ä¸­
        const tolerance = 0.0001;
        const isBeatPointCritical = criticalBeats.some(cb => Math.abs(cb - beatPoint) < tolerance);
        
        console.log(`    ğŸ” æ£€æŸ¥æ‹ç‚¹${beatPoint}æ˜¯å¦æ˜ç¡®: åœ¨å…³é”®æ‹ç‚¹åˆ—è¡¨=${isBeatPointCritical}, å…³é”®æ‹ç‚¹=[${criticalBeats.join(', ')}]`);
        
        if (!isBeatPointCritical) {
            // å¦‚æœè¿™ä¸ªæ‹ç‚¹ä¸åœ¨å…³é”®æ‹ç‚¹åˆ—è¡¨ä¸­ï¼Œè¯´æ˜å®ƒä¸éœ€è¦è¢«æ˜ç¡®æ˜¾ç¤º
            return true; // æ‹ç‚¹å·²ç»"æ˜ç¡®"ï¼ˆä¸éœ€è¦æ˜¾ç¤ºï¼‰
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–éŸ³ç¬¦å·²ç»åœ¨è¿™ä¸ªæ‹ç‚¹ä¸Šå¼€å§‹æˆ–ç»“æŸï¼Œä½¿æ‹ç‚¹å˜å¾—æ˜ç¡®
        let currentPos = 0;
        for (const note of allNotes) {
            const noteStartPos = currentPos;
            const noteEndPos = currentPos + note.beats;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰éŸ³ç¬¦åœ¨è¿™ä¸ªæ‹ç‚¹å¼€å§‹
            if (Math.abs(noteStartPos - beatPoint) < tolerance) {
                console.log(`    âœ… æ‹ç‚¹${beatPoint}å·²è¢«éŸ³ç¬¦å¼€å§‹ä½ç½®æ˜ç¡® (éŸ³ç¬¦@${noteStartPos})`);
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰éŸ³ç¬¦åœ¨è¿™ä¸ªæ‹ç‚¹ç»“æŸ
            if (Math.abs(noteEndPos - beatPoint) < tolerance) {
                console.log(`    âœ… æ‹ç‚¹${beatPoint}å·²è¢«éŸ³ç¬¦ç»“æŸä½ç½®æ˜ç¡® (éŸ³ç¬¦@${noteStartPos}-${noteEndPos})`);
                return true;
            }
            
            currentPos += note.beats;
        }
        
        console.log(`    âŒ æ‹ç‚¹${beatPoint}æœªè¢«æ˜ç¡®ï¼Œéœ€è¦æ‹†åˆ†è·¨è¶Šå®ƒçš„éŸ³ç¬¦`);
        return false;
    },
    
    // æ‹†åˆ†è·¨æ‹éŸ³ç¬¦
    splitCrossBeatNote: function(startPosition, duration, pitch, timeSignature, finestRhythm) {
        const crossInfo = this.detectsCrossBeats(startPosition, duration, timeSignature, finestRhythm);
        
        if (!crossInfo.crossesBeat) {
            return [{
                startPosition: startPosition,
                duration: duration,
                pitch: pitch,
                tied: false
            }];
        }
        
        // æ‹†åˆ†éŸ³ç¬¦
        const splitPosition = crossInfo.splitPositions[0];
        const firstDuration = splitPosition - startPosition;
        const secondDuration = duration - firstDuration;
        
        return [
            {
                startPosition: startPosition,
                duration: firstDuration,
                pitch: pitch,
                tied: true,
                tieType: 'start'
            },
            {
                startPosition: splitPosition,
                duration: secondDuration,
                pitch: pitch,
                tied: true,
                tieType: 'stop'
            }
        ];
    },
    
    // æ™ºèƒ½æ‹†åˆ†è·¨æ‹éŸ³ç¬¦ - ä½¿ç”¨å±€éƒ¨èŠ‚å¥åˆ†æ
    splitCrossBeatNoteWithLocalRhythm: function(startPosition, duration, pitch, timeSignature, allNotes) {
        const crossInfo = this.detectsCrossBeatsWithLocalRhythm(startPosition, duration, timeSignature, allNotes);
        
        if (!crossInfo.crossesBeat) {
            return [{
                startPosition: startPosition,
                duration: duration,
                pitch: pitch,
                tied: false
            }];
        }
        
        // åœ¨æ‹ç‚¹ä½ç½®æ‹†åˆ†
        const splitPosition = crossInfo.splitPositions[0];
        const firstDuration = splitPosition - startPosition;
        const secondDuration = duration - firstDuration;
        
        console.log(`  ğŸ¼ åœ¨æ‹ç‚¹${splitPosition}æ‹†åˆ†: ${firstDuration}æ‹ + ${secondDuration}æ‹`);
        
        return [
            {
                startPosition: startPosition,
                duration: firstDuration,
                pitch: pitch,
                tied: true,
                tieType: 'start'
            },
            {
                startPosition: splitPosition,
                duration: secondDuration,
                pitch: pitch,
                tied: true,
                tieType: 'stop'
            }
        ];
    },
    
    // éªŒè¯æ‹ç‚¹æ¸…æ™°åº¦ - ä½¿ç”¨æ™ºèƒ½æ‹ç‚¹æ£€æµ‹
    validateBeatClarity: function(notes, timeSignature) {
        const violations = [];
        let currentPosition = 0;
        
        // è·å–å°èŠ‚è¾¹ç•Œï¼ˆæ ¹æ®æ‹å·ç¡®å®šæ­£ç¡®çš„æ‹æ•°ï¼‰
        const structure = this.getBeatStructure(timeSignature);
        const measureBeats = structure.beatsPerMeasure;
        
        notes.forEach((note, index) => {
            if (!note.isTriplet) { // æ’é™¤ä¸‰è¿éŸ³ï¼Œä½†åŒ…æ‹¬éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦
                // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦è¶…å‡ºå°èŠ‚è¾¹ç•Œ
                const noteEndPosition = currentPosition + note.beats;
                if (noteEndPosition > measureBeats + 0.001) { // å…è®¸å¾®å°çš„æµ®ç‚¹è¯¯å·®
                    console.warn(`âš ï¸ éŸ³ç¬¦${index + 1}è¶…å‡ºå°èŠ‚è¾¹ç•Œ: ä½ç½®${currentPosition} + æ—¶é•¿${note.beats} = ${noteEndPosition} > ${measureBeats}`);
                    return; // è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„éŸ³ç¬¦éªŒè¯
                }
                
                console.log(`ğŸ” éªŒè¯éŸ³ç¬¦${index + 1}: ä½ç½®${currentPosition.toFixed(4)} æ—¶é•¿${note.beats.toFixed(4)} ç»“æŸ${noteEndPosition.toFixed(4)} ç±»å‹${note.type}`);
                
                const crossInfo = this.detectsCrossBeatsWithLocalRhythm(
                    currentPosition, 
                    note.beats, 
                    timeSignature,
                    notes, // ä½¿ç”¨æ™ºèƒ½å±€éƒ¨æ£€æµ‹
                    note.type  // ä¼ å…¥éŸ³ç¬¦ç±»å‹
                );
                if (crossInfo.crossesBeat) {
                    console.log(`âš ï¸ æ£€æµ‹åˆ°è·¨æ‹: éŸ³ç¬¦${index + 1} è·¨è¶Šæ‹ç‚¹${crossInfo.beatPoint}`);
                    // ç¡®ä¿è·¨è¶Šçš„æ‹ç‚¹åœ¨æœ‰æ•ˆèŒƒå›´å†…
                    if (crossInfo.beatPoint < measureBeats) {
                        violations.push({
                            noteIndex: index,
                            position: currentPosition,
                            duration: note.beats,
                            crossedBeat: crossInfo.beatPoint,
                            message: `${note.type === 'note' ? 'éŸ³ç¬¦' : 'ä¼‘æ­¢ç¬¦'}è·¨è¶Šå…³é”®æ‹ç‚¹${crossInfo.beatPoint + 1}ä½†æœªè¢«æ‹†åˆ†`
                        });
                    } else {
                        console.warn(`âš ï¸ å¿½ç•¥æ— æ•ˆæ‹ç‚¹: éŸ³ç¬¦${index + 1}è·¨è¶Šæ‹ç‚¹${crossInfo.beatPoint}ï¼Œè¶…å‡ºå°èŠ‚èŒƒå›´[0-${measureBeats})`);
                    }
                } else {
                    console.log(`âœ… éŸ³ç¬¦${index + 1}ä¸è·¨æ‹`);
                }
            }
            currentPosition += note.beats;
        });
        
        return {
            valid: violations.length === 0,
            violations: violations
        };
    },
    
    // è®¡ç®—æ‹ç‚¹å±‚çº§
    calculateBeatLevels: function(notes, timeSignature) {
        // æ‰¾åˆ°æœ€ç»†çš„èŠ‚å¥å€¼
        const finestRhythm = Math.min(...notes
            .filter(n => n.type === 'note')
            .map(n => n.beats));
        
        const levels = [];
        
        if (finestRhythm <= 0.125) { // 32ndéŸ³ç¬¦æˆ–æ›´ç»†
            levels.push({ level: '32nd', beat: 0.125 });
            levels.push({ level: '16th', beat: 0.25 });
            levels.push({ level: 'eighth', beat: 0.5 });
        } else if (finestRhythm <= 0.25) { // 16théŸ³ç¬¦
            levels.push({ level: '16th', beat: 0.25 });
            levels.push({ level: 'eighth', beat: 0.5 });
            levels.push({ level: 'quarter', beat: 1.0 });
        } else if (finestRhythm <= 0.5) { // å…«åˆ†éŸ³ç¬¦
            levels.push({ level: 'eighth', beat: 0.5 });
            levels.push({ level: 'quarter', beat: 1.0 });
            levels.push({ level: 'half', beat: 2.0 });
        } else { // å››åˆ†éŸ³ç¬¦æˆ–æ›´é•¿
            levels.push({ level: 'quarter', beat: 1.0 });
            levels.push({ level: 'half', beat: 2.0 });
            levels.push({ level: 'whole', beat: 4.0 });
        }
        
        return levels;
    },
    
    // å…«åˆ†éŸ³ç¬¦åˆ†ç»„è§„åˆ™
    validateBeamGrouping: function(notes, timeSignature) {
        const structure = this.getBeatStructure(timeSignature);
        // ç°æœ‰çš„åˆ†ç»„éªŒè¯é€»è¾‘
        return true;
    }
};

// ğŸµ ä¸“ä¸šè®°è°±è§„åˆ™ï¼šä¸´æ—¶è®°å·è§„èŒƒ
const ACCIDENTAL_RULES = {
    // æé†’å¼ä¸´æ—¶è®°å·ï¼šå‰ä¸€å°èŠ‚è¢«æ”¹å˜çš„éŸ³åœ¨ä¸‹ä¸€å°èŠ‚æ¢å¤æ—¶éœ€è¦æé†’
    needsCourtesyAccidental: function(currentNote, previousMeasureNotes, keySignature) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æé†’å¼è¿˜åŸå·
        return false; // ç®€åŒ–å®ç°
    },
    
    // åŠéŸ³é‚»è¿‘éŸ³çš„æ­£ç¡®æ‹¼å†™
    getChromaticSpelling: function(notes, keySignature) {
        // åˆç†åˆ†é…åŠéŸ³é˜¶çš„éŸ³åï¼Œé¿å…å¤§é‡è¿˜åŸå·
        return notes; // ç®€åŒ–å®ç°
    }
};

// è·å–è°ƒå·çš„ä¸»å’Œå¼¦éŸ³ï¼ˆ1, 3, 5åº¦ï¼‰
function getTonicChordTones(keySignature) {
    const keyInfo = KEY_SIGNATURES[keySignature];
    if (!keyInfo) return [0, 4, 7]; // é»˜è®¤Cå¤§è°ƒ
    
    const tonic = keyInfo.tonic;
    const isMinor = keyInfo.mode === 'minor';
    
    if (isMinor) {
        return [tonic, (tonic + 3) % 12, (tonic + 7) % 12]; // 1, b3, 5
    } else {
        return [tonic, (tonic + 4) % 12, (tonic + 7) % 12]; // 1, 3, 5
    }
}

// æ£€æŸ¥æŸä¸ªéŸ³ç¬¦æ˜¯å¦å·²è¢«è°ƒå·å‡é™
function isNoteAffectedByKeySignature(noteClass, keySignature) {
    const keyInfo = KEY_SIGNATURES[keySignature];
    if (!keyInfo) return { isSharp: false, isFlat: false };
    
    return {
        isSharp: keyInfo.sharps.includes(noteClass),
        isFlat: keyInfo.flats.includes(noteClass)
    };
}

// ====== ç§å­éšæœºæ•°ç”Ÿæˆå™¨ ======
class SeededRandom {
    constructor(seed) {
        this.seed = seed;
        this.current = seed;
    }

    next() {
        this.current = (this.current * 9301 + 49297) % 233280;
        return this.current / 233280;
    }

    nextInt(min, max) {
        return Math.floor(this.next() * (max - min)) + min;
    }

    nextFloat() {
        return this.next();
    }

    choice(array) {
        if (!array || !Array.isArray(array) || array.length === 0) return null;
        return array[this.nextInt(0, array.length)];
    }

    weighted(choices, weights) {
        const totalWeight = weights.reduce((sum, w) => sum + w, 0);
        let random = this.nextFloat() * totalWeight;
        
        for (let i = 0; i < choices.length; i++) {
            random -= weights[i];
            if (random <= 0) return choices[i];
        }
        
        return choices[choices.length - 1];
    }
}

// ====== æ™ºèƒ½æ—‹å¾‹ç”Ÿæˆå™¨ ======
class IntelligentMelodyGenerator {
    constructor(measures, keySignature, timeSignature, clef, seed) {
        this.measures = measures;
        this.keySignature = keySignature;
        this.timeSignature = timeSignature;
        this.clef = clef;
        this.seed = seed;
        this.random = new SeededRandom(seed);
        const toolHref = (typeof window !== 'undefined' && window.location && window.location.href) ? window.location.href : '';
        this.isJianpuTool = !!(typeof window !== 'undefined' && window.__IS_JIANPU_TOOL) || toolHref.includes('jianpu-generator.html');
        
        // æ ¹æ®å½“å‰è°±å·è·å–æ­£ç¡®çš„éŸ³åŸŸè®¾ç½®ï¼ˆä¸æ›´æ–°UIï¼‰
        const actualRange = getRangeForClef(clef);
        const clefName = clef === 'treble' ? 'é«˜éŸ³è°±å·' : clef === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·';
        const settingType = (userSettings.clefRanges[clef] && userSettings.clefRanges[clef].hasCustomRange) ? 'è‡ªå®šä¹‰' : 'é»˜è®¤';
        console.log(`ğŸ¼ æ—‹å¾‹ç”Ÿæˆå™¨ä½¿ç”¨${clefName}çš„${settingType}éŸ³åŸŸ: ${actualRange.min}-${actualRange.max}`);
        
        this.rules = {
            timeSignature: timeSignature, // æ—¶é—´ç­¾å
            range: { 
                min: actualRange.min, 
                max: actualRange.max 
            }, // éŸ³åŸŸèŒƒå›´ï¼ˆåˆ›å»ºæ–°å¯¹è±¡é¿å…å¼•ç”¨é—®é¢˜ï¼Œæ”¯æŒA2-A6èŒƒå›´ï¼‰
            allowedDurations: this.getTimeSignatureAppropriateRhythms(timeSignature, userSettings.allowedRhythms), // æ ¹æ®æ‹å·è°ƒæ•´å…è®¸çš„èŠ‚å¥
            allowWeakBeats: false, // Upbeat functionality removed
            accidentalRate: (userSettings.accidentalRate || 0) / 100, // ä¸´æ—¶è®°å·æ¦‚ç‡
            maxJump: userSettings.maxJump || 12, // æœ€å¤§éŸ³ç¨‹è·³åŠ¨
            // è®¾ç½®ä¸€äº›é»˜è®¤çš„éŸ³ä¹è§„åˆ™
            stepwisePreferred: true, // ä»¥çº§è¿›ä¸ºä¸»
            maxConsecutiveJumps: 2, // æœ€å¤§è¿ç»­è·³è¿›æ•°
            restRatio: 0.15, // ä¼‘æ­¢ç¬¦æ¯”ä¾‹
            jumpMustReturn: true // å¤§è·³åä¼˜å…ˆå›å½’çº§è¿›
        };
        // ä¸´æ—¶è®°å·æ¦‚ç‡ä¸¥æ ¼é™å®šåœ¨0-1ä¹‹é—´ï¼Œä¸¥æ ¼éµå®ˆç”¨æˆ·è®¾ç½®
        this.rules.accidentalRate = Math.max(0, Math.min(1, this.rules.accidentalRate));

        // Cantus firmus é£æ ¼çº¦æŸï¼ˆä¸å½±å“èŠ‚å¥ï¼Œåªç®¡æ—‹å¾‹çº¿ï¼‰
        this.cfConfig = {
            maxSpan: 16, // ä¸è¶…è¿‡ååº¦ï¼ˆ16åŠéŸ³ï¼‰
            peakOnce: true, // ä¿æŒå•ä¸€æœ€é«˜éŸ³
            climaxMinLeap: Math.max(4, Math.min(this.rules.maxJump || 12, Math.round((this.rules.maxJump || 12) * 0.6))),
            largeLeapThreshold: Math.min(this.rules.maxJump || 12, 5),
            largeLeapTarget: null
        };
        const resolvedLargeLeapTarget = this.getLargeLeapTargetByMeasures(this.measures);
        if (resolvedLargeLeapTarget && this.cfConfig.largeLeapThreshold >= 4) {
            this.cfConfig.largeLeapTarget = resolvedLargeLeapTarget;
            console.log(`ğŸ¯ å¤§è·³è¿›ç›®æ ‡: ${resolvedLargeLeapTarget.min}-${resolvedLargeLeapTarget.max}æ¬¡ (é˜ˆå€¼${this.cfConfig.largeLeapThreshold}åŠéŸ³)`);
        } else if (resolvedLargeLeapTarget) {
            console.log(`âš ï¸ å½“å‰æœ€å¤§è·³åº¦${this.rules.maxJump}åŠéŸ³è¿‡å°ï¼Œæš‚ä¸å¯ç”¨å¤§è·³è¿›ç›®æ ‡è®¡æ•°`);
        }
        this.cfState = {
            minMidi: null,
            maxMidi: null,
            peakMidi: null,
            peakCount: 0,
            repeatCount: 0,
            lastMidi: null,
            prevMidi: null,
            prevPrevMidi: null,
            lastInterval: null,
            midiHistory: [],
            climaxLeapDone: false,
            largeLeapCount: 0
        };
        
        console.log(`ğŸ¯ æ„é€ å‡½æ•°ä¸­çš„maxJump: ${this.rules.maxJump}, æ¥æº: ${userSettings.maxJump}`);
        
        // è°ƒè¯•ä¸‰è¿éŸ³è®¾ç½®ä¼ é€’
        console.log(`ğŸ›ï¸ ç”Ÿæˆå™¨åˆå§‹åŒ–:`);
        console.log(`   ç”¨æˆ·allowedRhythms: [${userSettings?.allowedRhythms?.join(', ') || 'undefined'}]`);
        
        if (!this.rules) {
            console.error(`âŒ this.rules æœªåˆå§‹åŒ–!`);
            throw new Error('Generator rules not initialized');
        }
        
        if (!Array.isArray(this.rules.allowedDurations)) {
            console.error(`âŒ allowedDurations ä¸æ˜¯æ•°ç»„: ${typeof this.rules.allowedDurations}`);
            throw new Error('allowedDurations must be an array');
        }
        
        console.log(`   ç”Ÿæˆå™¨allowedDurations: [${this.rules.allowedDurations.join(', ')}]`);
        console.log(`   æ”¯æŒä¸‰è¿éŸ³: ${this.rules.allowedDurations.includes('triplet') ? 'âœ…æ˜¯' : 'âŒå¦'}`);

        // åˆå§‹åŒ–å…«åˆ†éŸ³ç¬¦é…å¯¹æ ‡è®°
        this._expectEighthNotePair = false;
        this.chromaticState = {
            active: false,
            remaining: 0,
            direction: 0
        };
        this._pendingAccidentalPreference = null;
        this.slideAssignmentState = null;

        // é¦–å…ˆåˆå§‹åŒ–éŸ³é˜¶
        this.scale = KEY_SCALES[keySignature] || KEY_SCALES['C']; // å¦‚æœè°ƒå·æ— æ•ˆï¼Œé»˜è®¤ä½¿ç”¨Cå¤§è°ƒ
        if (!this.scale) {
            console.error('âš ï¸ æ— æ•ˆçš„è°ƒå·ï¼Œä½¿ç”¨Cå¤§è°ƒä½œä¸ºé»˜è®¤');
            this.scale = [0, 2, 4, 5, 7, 9, 11];
        }
        
        // æ ¹æ®ç”¨æˆ·éŸ³åŸŸè®¾ç½®åŠ¨æ€ç”Ÿæˆä¼˜é€‰å¼€å§‹å’Œç»“æŸéŸ³ç¬¦
        this.rules.preferredStarts = this.generatePreferredNotes('starts');
        this.rules.preferredEnds = this.generatePreferredNotes('ends');
        this.stats = {
            noteCount: 0,
            restCount: 0,
            beamCount: 0,
            minMidi: Infinity,
            maxMidi: -Infinity,
            maxInterval: 0,
            restRatio: 0,
            largeLeapCount: 0
        };
        
        // è§£ææ‹å· - æ­£ç¡®å¤„ç†å¤åˆæ‹å­
        const [beats, beatType] = timeSignature.split('/').map(Number);
        
        // æ­£ç¡®è®¡ç®—æ¯å°èŠ‚çš„å››åˆ†éŸ³ç¬¦æ‹æ•°
        if (timeSignature === '6/8') {
            // 6/8æ‹ = 6ä¸ªå…«åˆ†éŸ³ç¬¦ = 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹çš„é•¿åº¦
            this.beatsPerMeasure = 3;
            this.beatUnit = 4; // ä»¥å››åˆ†éŸ³ç¬¦ä¸ºåŸºå‡†å•ä½è®¡ç®—
            console.log('ğŸµ 6/8æ‹ï¼š6ä¸ªå…«åˆ†éŸ³ç¬¦ = 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹é•¿åº¦');
        } else if (timeSignature === '3/4') {
            // 3/4æ‹ = 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹
            this.beatsPerMeasure = 3;
            this.beatUnit = 4;
            console.log('ğŸµ 3/4æ‹ï¼š3ä¸ªå››åˆ†éŸ³ç¬¦æ‹');
        } else {
            // å…¶ä»–æ‹å·ä½¿ç”¨ä¼ ç»Ÿè®¡ç®—ï¼ˆè‡ªå®šä¹‰æ‹å·éœ€æŒ‰åˆ†æ¯æ¢ç®—ä¸ºå››åˆ†éŸ³ç¬¦æ‹ï¼‰
            if (beatType && beatType !== 4) {
                this.beatsPerMeasure = beats * (4 / beatType);
                this.beatUnit = beatType;
                console.log(`ğŸµ ${timeSignature}æ‹ï¼š${beats}ä¸ª${beatType}åˆ†éŸ³ç¬¦ = ${this.beatsPerMeasure}ä¸ªå››åˆ†éŸ³ç¬¦æ‹é•¿åº¦`);
            } else {
                this.beatsPerMeasure = beats;
                this.beatUnit = beatType;
            }
        }
        
        console.log(`ğŸµ åˆå§‹åŒ–æ™ºèƒ½ç”Ÿæˆå™¨: ${measures}å°èŠ‚ ${timeSignature} ${keySignature}è°ƒ ${clef}è°±å·`);
        console.log(`ğŸ¹ éŸ³åŸŸ: MIDI ${this.rules.range.min}-${this.rules.range.max} æœ€å¤§è·³åŠ¨: ${this.rules.maxJump}åŠéŸ³`);
    }

    /**
     * æ ¹æ®æ—¶é—´ç­¾åè·å–åˆé€‚çš„èŠ‚å¥ç±»å‹
     */
    getTimeSignatureAppropriateRhythms(timeSignature, userAllowedRhythms) {
        console.log(`ğŸ” getTimeSignatureAppropriateRhythms è°ƒè¯•:`);
        console.log(`  - timeSignature: ${timeSignature} (ç±»å‹: ${typeof timeSignature})`);
        console.log(`  - userAllowedRhythms: ${userAllowedRhythms} (ç±»å‹: ${typeof userAllowedRhythms})`);
        console.log(`  - æ˜¯æ•°ç»„: ${Array.isArray(userAllowedRhythms)}`);
        
        // 6/8æ‹çš„ç‰¹æ®Šå¤„ç†ï¼šå°Šé‡ç”¨æˆ·è®¾ç½®ä½†ç¡®ä¿å¿…è¦çš„èŠ‚å¥ç±»å‹
        // ä¸å†å¼ºåˆ¶ä½¿ç”¨å›ºå®šèŠ‚å¥ï¼Œè€Œæ˜¯åœ¨ç”¨æˆ·è®¾ç½®åŸºç¡€ä¸Šæ·»åŠ å¿…è¦æ”¯æŒ
        console.log(`ğŸµ 6/8æ‹å°†å°Šé‡ç”¨æˆ·èŠ‚å¥è®¾ç½®`);
        
        // ğŸ”¥ ä¿®å¤ï¼šä¸¥æ ¼ä½¿ç”¨ç”¨æˆ·è®¾ç½®ï¼Œä¸æ·»åŠ ä»»ä½•é»˜è®¤å€¼
        let baseRhythms = Array.isArray(userAllowedRhythms) ? [...userAllowedRhythms] : [];
        console.log(`  - baseRhythms: [${baseRhythms.join(', ')}]`);
        
        // ğŸ”¥ ä¿®å¤ï¼šuserSettings.allowedRhythmså·²ç»å­˜å‚¨å†…éƒ¨æ ¼å¼ï¼ˆquarter.ç­‰ï¼‰ï¼Œæ— éœ€è½¬æ¢
        console.log(`ğŸµ ${timeSignature}æ‹è½¬æ¢åçš„èŠ‚å¥ï¼ˆåŒ…æ‹¬é™„ç‚¹éŸ³ç¬¦ï¼‰: [${baseRhythms.join(', ')}]`);
        
        console.log(`ğŸ¯ ${timeSignature}æ‹æœ€ç»ˆå…è®¸çš„èŠ‚å¥: [${baseRhythms.join(', ')}]`);
        return baseRhythms;
    }

    /**
     * æ ¹æ®éŸ³åŸŸå’Œè°ƒå·åŠ¨æ€ç”Ÿæˆä¼˜é€‰éŸ³ç¬¦
     */
    generatePreferredNotes(type) {
        const scale = this.scale;
        const range = this.rules.range;
        const preferredNotes = [];
        
        // ç¡®ä¿scaleæ˜¯æœ‰æ•ˆæ•°ç»„ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤éŸ³é˜¶
        const effectiveScale = Array.isArray(scale) ? scale : [0, 2, 4, 5, 7, 9, 11];
        
        // è·å–å½“å‰è°ƒå·çš„æ­£ç¡®ä¸»å’Œå¼¦éŸ³ï¼ˆ1, 3, 5åº¦ï¼‰
        const targetScaleDegrees = getTonicChordTones(this.keySignature);
        
        console.log(`ğŸ¼ è°ƒå·${this.keySignature}çš„ä¸»å’Œå¼¦éŸ³: ${targetScaleDegrees.join(', ')}`);
        
        // ä¿®å¤ï¼šåªåœ¨æŒ‡å®šéŸ³åŸŸèŒƒå›´å†…ç”Ÿæˆä¸»å’Œå¼¦éŸ³
        console.log(`ğŸ” [generatePreferredNotes] éŸ³åŸŸ: ${range.min}-${range.max}, è°ƒå·: ${this.keySignature}`);
        console.log(`ğŸ” [generatePreferredNotes] è®¡ç®—å…«åº¦èŒƒå›´: ${Math.floor(range.min / 12)} åˆ° ${Math.floor(range.max / 12)}`);
        
        for (let octave = Math.floor(range.min / 12); octave <= Math.floor(range.max / 12); octave++) {
            for (const scaleDegree of targetScaleDegrees) {
                const midi = octave * 12 + scaleDegree;
                console.log(`ğŸ” [generatePreferredNotes] æ£€æŸ¥: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi}, éŸ³åŸŸå†…=${midi >= range.min && midi <= range.max}`);
                
                if (midi >= range.min && midi <= range.max && effectiveScale.includes(scaleDegree)) {
                    preferredNotes.push(midi);
                    console.log(`ğŸ¼ æ·»åŠ ä¸»å’Œå¼¦éŸ³: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi}`);
                } else if (midi < range.min) {
                    console.log(`ğŸš¨ è·³è¿‡è¿‡ä½ä¸»å’Œå¼¦éŸ³: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi} < ${range.min}`);
                } else if (midi > range.max) {
                    console.log(`ğŸš¨ è·³è¿‡è¿‡é«˜ä¸»å’Œå¼¦éŸ³: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi} > ${range.max}`);
                } else if (!effectiveScale.includes(scaleDegree)) {
                    console.log(`ğŸš¨ è·³è¿‡éè°ƒå†…éŸ³: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi}`);
                }
            }
        }
        
        // å¦‚æœæ²¡æœ‰åˆé€‚çš„ä¼˜é€‰éŸ³ç¬¦ï¼Œä½¿ç”¨éŸ³åŸŸå†…çš„æ‰€æœ‰è°ƒå†…éŸ³ç¬¦
        if (preferredNotes.length === 0) {
            console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°ä¸»å’Œå¼¦éŸ³ï¼Œä½¿ç”¨æ‰€æœ‰è°ƒå†…éŸ³ç¬¦');
            for (let octave = Math.floor(range.min / 12); octave <= Math.floor(range.max / 12); octave++) {
                for (const scaleDegree of effectiveScale) {
                    const midi = octave * 12 + scaleDegree;
                    if (midi >= range.min && midi <= range.max) {
                        preferredNotes.push(midi);
                        console.log(`ğŸ¼ æ·»åŠ è°ƒå†…éŸ³ç¬¦: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi}`);
                    } else if (midi < range.min) {
                        console.log(`ğŸš¨ è·³è¿‡è¿‡ä½è°ƒå†…éŸ³ç¬¦: octave=${octave}, scaleDegree=${scaleDegree}, midi=${midi} < ${range.min}`);
                    }
                }
            }
        }
        
        console.log(`ğŸ¼ ç”Ÿæˆ${type === 'starts' ? 'å¼€å§‹' : 'ç»“æŸ'}ä¼˜é€‰éŸ³ç¬¦: ${preferredNotes.join(',')}`);
        
        // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æ‰€æœ‰ä¼˜é€‰éŸ³ç¬¦éƒ½åœ¨éŸ³åŸŸå†…
        const safePreferredNotes = preferredNotes.filter(midi => {
            const isValid = midi >= range.min && midi <= range.max;
            if (!isValid) {
                console.error(`ğŸš¨ [generatePreferredNotes] è¿‡æ»¤å¼‚å¸¸ä¼˜é€‰éŸ³ç¬¦: MIDI ${midi} (éŸ³åŸŸ: ${range.min}-${range.max})`);
            }
            return isValid;
        });
        
        if (safePreferredNotes.length === 0) {
            const safeFallback = range.min + Math.floor((range.max - range.min) / 2);
            console.log(`ğŸ¼ ä½¿ç”¨å®‰å…¨å›é€€éŸ³ç¬¦: ${safeFallback}`);
            return [safeFallback];
        }
        
        return safePreferredNotes;
    }

    /**
     * ç”Ÿæˆå®Œæ•´æ—‹å¾‹
     */
    generateMelody() {
        const melody = [];
        let lastMidi = null;
        let lastDirection = 0; // -1ä¸‹è¡Œ, 0å¹³è¡Œ, 1ä¸Šè¡Œ
        let consecutiveJumps = 0;
        let measureDirectionChanges = 0;
        this.slideAssignmentState = createSlideAssignmentState(this.random);
        console.log(`ğŸšï¸ Slideé¢‘ç‡æ§åˆ¶: ${this.slideAssignmentState.slideFrequency}% -> æœŸæœ›${this.slideAssignmentState.expectedSlides.toFixed(2)}ä¸ª, ${this.slideAssignmentState.isUnlimited ? 'ä¸é™æ•°é‡æ¨¡å¼' : `æœ¬æ¡é¢„ç®—${this.slideAssignmentState.slideBudget}ä¸ª`}`);
        
        for (let measureIndex = 0; measureIndex < this.measures; measureIndex++) {
            console.log(`\\n--- ç”Ÿæˆç¬¬${measureIndex + 1}å°èŠ‚ ---`);
            
            const measureData = this.generateMeasure(
                measureIndex, 
                lastMidi, 
                lastDirection, 
                consecutiveJumps
            );
            
            // éªŒè¯å°èŠ‚æ•°æ®çš„å®Œæ•´æ€§
            if (!measureData || !measureData.notes || measureData.notes.length === 0) {
                console.error(`ç”Ÿæˆçš„å°èŠ‚${measureIndex + 1}ä¸ºç©ºï¼Œåˆ›å»ºåº”æ€¥å°èŠ‚`);
                const emergencyMeasure = {
                    notes: [{
                        type: 'rest',
                        duration: 'whole',
                        beats: this.beatsPerMeasure
                    }],
                    beams: [],
                    directionChanges: 0
                };
                melody.push(emergencyMeasure);
            } else {
                melody.push(measureData);
            }
            
            // æ›´æ–°çŠ¶æ€
            const lastNote = this.getLastNote(measureData.notes);
            if (lastNote) {
                lastMidi = lastNote.midi;
                this.cfState.lastNoteBeats = typeof lastNote.beats === 'number' ? lastNote.beats : null;
            } else {
                this.cfState.lastNoteBeats = null;
            }
            
            // è®¡ç®—æ–¹å‘å˜åŒ–
            measureDirectionChanges = this.countDirectionChanges(measureData.notes);
            
            // æ›´æ–°ç»Ÿè®¡
            this.updateStats(measureData);
        }
        
        // æœ€ç»ˆç»Ÿè®¡
        this.stats.restRatio = this.stats.restCount / (this.stats.noteCount + this.stats.restCount);
        
        // ğŸ”§ é¦–å…ˆæ£€æŸ¥userSettingsçŠ¶æ€
        this.debugUserSettingsState();
        
        // ğŸ” ç”Ÿæˆç»¼åˆæ¼”å¥æ³•è°ƒè¯•æŠ¥å‘Š
        this.generateArticulationDebugReport(melody);
        
        // ğŸ”¥ æœ€åä¸€é“é˜²çº¿ï¼šå…¨å±€æ¼”å¥æ³•å®‰å…¨æ£€æŸ¥
        const cadenceAligned = this.enforceFinalChordTone(melody);
        const sanitizedMelody = this.sanitizeArticulations(cadenceAligned);
        const tiePlacedSlideMelody = this.normalizeSlidePlacementOnTiedNotes(sanitizedMelody);
        const slurSafeMelody = this.removeStaccatoFromSlurStarts(tiePlacedSlideMelody);
        const glissSanitizedMelody = this.sanitizeGlissandoPairs(slurSafeMelody);
        const glissReadyMelody = this.ensureAtLeastOneGlissando(glissSanitizedMelody);
        const tiePlacedAfterFallbackMelody = this.normalizeSlidePlacementOnTiedNotes(glissReadyMelody);
        const pairSafeMelody = this.sanitizeTwoNoteArticulationConflicts(tiePlacedAfterFallbackMelody);
        const nonConsecutiveSlideMelody = this.sanitizeConsecutiveSlides(pairSafeMelody);
        const singleTechniqueMelody = this.sanitizeSingleTechniquePerNote(nonConsecutiveSlideMelody);
        const speedSafeSlideMelody = this.sanitizeSlideMinimumDuration(singleTechniqueMelody);
        const slideLimitedMelody = this.enforceSlideLimitPerMelody(speedSafeSlideMelody);
        
        console.log(`âœ… æ—‹å¾‹ç”Ÿæˆå®Œæˆ: ${this.stats.noteCount}éŸ³ç¬¦ ${this.stats.restCount}ä¼‘æ­¢ ä¼‘æ­¢æ¯”ä¾‹${(this.stats.restRatio*100).toFixed(1)}%`);
        
        return slideLimitedMelody;
    }

    canAssignSlideArticulation(type) {
        return canAssignSlideWithState(this.slideAssignmentState, type);
    }

    consumeSlideArticulation(type) {
        return consumeSlideWithState(this.slideAssignmentState, type);
    }

    enforceSlideLimitPerMelody(measures) {
        if (!Array.isArray(measures)) return measures;
        if (this.slideAssignmentState?.isUnlimited) {
            return measures;
        }

        let slideCount = 0;
        let removed = 0;

        measures.forEach(measure => {
            if (!measure || !Array.isArray(measure.notes)) return;
            measure.notes.forEach(note => {
                if (!note || note.type !== 'note' || !isSlideArticulationType(note.articulation)) return;
                if (slideCount < MAX_SLIDES_PER_MELODY) {
                    slideCount++;
                    return;
                }
                note.articulation = null;
                removed++;
            });
        });

        if (removed > 0) {
            console.log(`ğŸš« å·²é™åˆ¶ä¸ºæ¯æ¡æ—‹å¾‹æœ€å¤š${MAX_SLIDES_PER_MELODY}ä¸ªslideï¼Œç§»é™¤é¢å¤–slideæ•°é‡: ${removed}`);
        }

        return measures;
    }

    /**
     * ç”Ÿæˆå•ä¸ªå°èŠ‚
     */
    generateMeasure(measureIndex, lastMidi, lastDirection, consecutiveJumps) {
        const notes = [];
        let remainingBeats = this.beatsPerMeasure;
        let currentBeat = 0; // å½“å‰åœ¨å°èŠ‚å†…çš„æ‹å­ä½ç½®

        // é‡ç½®å…«åˆ†éŸ³ç¬¦é…å¯¹æ ‡è®°åœ¨æ¯ä¸ªå°èŠ‚å¼€å§‹æ—¶
        this._expectEighthNotePair = false;
        this._beatPatternQueue = [];
        this._lastBeatHad16th = false;
        this._sixteenthRun = 0;
        let currentMidi = lastMidi;
        let currentDirection = lastDirection;
        let currentConsecutiveJumps = consecutiveJumps;
        let measureDirectionChanges = 0;
        
        // ç¬¬ä¸€å°èŠ‚ç‰¹æ®Šå¤„ç†
        if (measureIndex === 0) {
            // Upbeat functionality removed
            
            if (this.rules.preferredStarts) {
                currentMidi = this.random.choice(this.rules.preferredStarts);
                console.log(`ğŸµ [generateMeasure] ç¬¬ä¸€å°èŠ‚é€‰æ‹©preferredStarts: ${currentMidi}, å€™é€‰: [${this.rules.preferredStarts.join(',')}]`);
                if (currentMidi < 50) {
                    console.error(`ğŸš¨ [generateMeasure] preferredStartså¼‚å¸¸ä½éŸ³: MIDI ${currentMidi}`);
                }
            } else {
                currentMidi = this.generateInScaleNote(null);
                console.log(`ğŸµ [generateMeasure] ç¬¬ä¸€å°èŠ‚ä½¿ç”¨generateInScaleNote: ${currentMidi}`);
            }
        }
        
        // æœ€åä¸€å°èŠ‚ç‰¹æ®Šå¤„ç†
        const isLastMeasure = measureIndex === this.measures - 1;
        
        let loopSafety = 0;
        const maxLoopIterations = 50; // é˜²æ­¢æ— é™å¾ªç¯
        let previousRemainingBeats = remainingBeats; // ç”¨äºæ£€æµ‹å¾ªç¯è¿›åº¦
        
        while (remainingBeats > 0.001 && loopSafety < maxLoopIterations) {
            loopSafety++;
            console.log(`å°èŠ‚${measureIndex + 1} - è¿­ä»£${loopSafety}: å‰©ä½™${remainingBeats}æ‹`);
            
            // æ£€æµ‹å¾ªç¯æ˜¯å¦å¡ä½ï¼ˆåœ¨æ¯æ¬¡è¿­ä»£å¼€å§‹æ—¶ï¼‰
            if (loopSafety > 1 && Math.abs(remainingBeats - previousRemainingBeats) < 0.001) {
                console.error(`ğŸš¨ å¾ªç¯å¡ä½æ£€æµ‹ï¼ç¬¬${loopSafety}æ¬¡è¿­ä»£ï¼Œå‰©ä½™æ‹æ•°æ²¡æœ‰å˜åŒ–: ${remainingBeats}æ‹`);
                console.error(`ğŸ” è°ƒè¯•ä¿¡æ¯:`);
                console.error(`  - å°èŠ‚å·²æœ‰å…ƒç´ æ•°é‡: ${notes.length}`);
                console.error(`  - å½“å‰MIDI: ${currentMidi}`);
                console.error(`  - å…è®¸çš„æ—¶å€¼: ${this.rules.allowedDurations.join(', ')}`);
                console.error(`  - æ˜¯å¦å…è®¸ä¸‰è¿éŸ³: ${this.rules.allowedDurations.includes('triplet')}`);
                
                console.log(`ğŸš¨ å¼ºåˆ¶æ·»åŠ åº”æ€¥ä¼‘æ­¢ç¬¦ä»¥ç»§ç»­å¾ªç¯`);
                let emergencyBeats = Math.min(remainingBeats, 0.125); // æœ€å¤š32nd note

                // ğŸ”¥ 6/8æ‹ç‰¹æ®Šå¤„ç†ï¼šç¡®ä¿åº”æ€¥ä¼‘æ­¢ç¬¦ä¸è·¨è¶Šè¾¹ç•Œ
                if (this.timeSignature === '6/8') {
                    const noteEndPosition = currentBeat + emergencyBeats;
                    const criticalBoundaries = [0, 1.5, 3];

                    for (const boundary of criticalBoundaries) {
                        if (currentBeat < boundary && noteEndPosition > boundary) {
                            emergencyBeats = boundary - currentBeat;
                            console.log(`âš ï¸ 6/8æ‹åº”æ€¥ä¼‘æ­¢ç¬¦è¾¹ç•Œè°ƒæ•´ï¼šé¿å…è·¨è¶Šè¾¹ç•Œ${boundary}ï¼Œè°ƒæ•´ä¸º${emergencyBeats}æ‹`);
                            break;
                        }
                    }
                }

                const emergencyRestDuration = this.beatsToRestDuration(emergencyBeats);

                notes.push({
                    type: 'rest',
                    duration: emergencyRestDuration,
                    beats: emergencyBeats
                });

                console.log(`âœ… æ·»åŠ åº”æ€¥ä¼‘æ­¢ç¬¦: ${emergencyRestDuration} (${emergencyBeats}æ‹)`);
                remainingBeats -= emergencyBeats;
                currentBeat += emergencyBeats;
                previousRemainingBeats = remainingBeats;
                continue;
            }
            
            previousRemainingBeats = remainingBeats;
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³ - å¢å¼ºè°ƒè¯•
            console.log(`\nğŸ” ä¸‰è¿éŸ³æ£€æŸ¥: å‰©ä½™${remainingBeats}æ‹, ä½ç½®${currentBeat}`);
            const canGenerate = this.canGenerateTriplet(remainingBeats);
            console.log(`   ç»“æœ: ${canGenerate ? 'âœ…å¯ä»¥ç”Ÿæˆ' : 'âŒä¸èƒ½ç”Ÿæˆ'}`);
            
            if (canGenerate) {
                console.log(`ğŸµ å°è¯•ç”Ÿæˆä¸‰è¿éŸ³ï¼Œå‰©ä½™æ‹æ•°: ${remainingBeats}, å½“å‰MIDI: ${currentMidi}`);
                
                try {
                    const triplet = this.generateTriplet(currentMidi, currentDirection, remainingBeats, currentBeat, measureIndex);
                    
                    // æ›´ä¸¥æ ¼çš„ä¸‰è¿éŸ³éªŒè¯ï¼ˆç°åœ¨æ”¯æŒä¼‘æ­¢ç¬¦ï¼‰
                    const tripletValid = triplet && 
                                       Array.isArray(triplet.notes) && 
                                       triplet.notes.length === 3 && 
                                       typeof triplet.totalBeats === 'number' &&
                                       triplet.totalBeats > 0 &&
                                       triplet.totalBeats <= remainingBeats + 0.001 &&
                                       triplet.notes.every(element => 
                                           (element.type === 'note' || element.type === 'rest') && 
                                           element.beats > 0 && 
                                           element.isTriplet === true
                                       );
                    
                    if (tripletValid) {
                        // ä¸‰è¿éŸ³éªŒè¯é€šè¿‡ï¼Œæ·»åŠ åˆ°å°èŠ‚ä¸­
                        notes.push(...triplet.notes);
                        remainingBeats -= triplet.totalBeats;
                        currentBeat += triplet.totalBeats;
                        currentMidi = triplet.lastMidi;
                        currentDirection = triplet.lastDirection;
                        console.log(`    âœ… ä¸‰è¿éŸ³æˆåŠŸ: ${triplet.notes.length}ä¸ªéŸ³ç¬¦ (${triplet.totalBeats}æ‹), å‰©ä½™: ${remainingBeats}æ‹`);
                        
                        // éªŒè¯å‰©ä½™æ‹æ•°ä¸ä¸ºè´Ÿæ•°
                        if (remainingBeats < -0.001) {
                            console.error(`ğŸš¨ ä¸‰è¿éŸ³åå‰©ä½™æ‹æ•°ä¸ºè´Ÿ: ${remainingBeats}`);
                            remainingBeats = 0; // å¼ºåˆ¶å½’é›¶
                        }
                        continue;
                    } else {
                        console.log(`âŒ ä¸‰è¿éŸ³éªŒè¯å¤±è´¥è¯¦æƒ…:`);
                        console.log(`  - tripletå­˜åœ¨: ${!!triplet}`);
                        console.log(`  - notesæ˜¯æ•°ç»„: ${Array.isArray(triplet?.notes)}`);
                        console.log(`  - notesé•¿åº¦: ${triplet?.notes?.length}`);
                        console.log(`  - totalBeats: ${triplet?.totalBeats}`);
                        console.log(`  - totalBeats <= remainingBeats: ${triplet?.totalBeats <= remainingBeats + 0.001}`);
                        console.log(`  - æ‰€æœ‰éŸ³ç¬¦æœ‰æ•ˆ: ${triplet?.notes?.every(note => note.type === 'note' && note.beats > 0)}`);
                        console.log(`âŒ ä¸‰è¿éŸ³å¤±è´¥ï¼Œè½¬ä¸ºæ™®é€šéŸ³ç¬¦ç”Ÿæˆæ¨¡å¼`);
                    }
                } catch (error) {
                    console.error(`âŒ ä¸‰è¿éŸ³ç”Ÿæˆå¼‚å¸¸: ${error.message}`);
                    console.error(`é”™è¯¯å †æ ˆ:`, error.stack);
                }
            }
            
            // ğŸ”¥ 6/8æ‹ä¸“é—¨çš„èŠ‚å¥æ¨¡å¼ç”Ÿæˆ - ä¼˜å…ˆä½¿ç”¨é¢‘ç‡æ§åˆ¶ç‰ˆæœ¬
            if (this.timeSignature === '6/8' && notes.length === 0 && remainingBeats === this.beatsPerMeasure) {
                console.log(`ğŸµ 6/8æ‹èŠ‚å¥æ¨¡å¼ç”Ÿæˆ: ä¼˜å…ˆä½¿ç”¨é¢‘ç‡æ§åˆ¶ç‰ˆæœ¬`);
                
                // ğŸ¯ ä¼˜å…ˆä½¿ç”¨åº”ç”¨äº†é¢‘ç‡æ§åˆ¶çš„generateAdaptiveRhythmPatterns
                let rhythmPattern = null;
                
                try {
                    // è·å–ç”¨æˆ·è®¾ç½®çš„èŠ‚å¥ç±»å‹
                    const userRhythms = this.rules?.allowedDurations || [];
                    console.log(`ğŸ” ç”¨æˆ·å…è®¸çš„6/8æ‹èŠ‚å¥: [${userRhythms.join(', ')}]`);
                    
                    // ğŸ”¥ ç›´æ¥åº”ç”¨é¢‘ç‡æ§åˆ¶æ£€æŸ¥
                    console.log(`ğŸ¯ åº”ç”¨é¢‘ç‡æ§åˆ¶åˆ°6/8æ‹æ¨¡å¼é€‰æ‹©`);
                    
                    // è·å–åŸºç¡€æ¨¡å¼
                    const basePattern = this.choose6_8RhythmPattern();
                    if (basePattern && basePattern.length > 0) {
                        console.log(`ğŸ” åŸºç¡€æ¨¡å¼: ${basePattern.map(n => n.duration).join(' ')}`);
                        
                        // ğŸ”¥ å¼ºåŒ–é¢‘ç‡æ§åˆ¶ï¼šæ£€æŸ¥æ¨¡å¼ä¸­çš„æ¯ç§èŠ‚å¥ç±»å‹æ˜¯å¦è¢«é¢‘ç‡æ§åˆ¶é˜»æ­¢
                        const rhythmTypes = [...new Set(basePattern.map(n => n.duration))];
                        console.log(`ğŸ” æ¨¡å¼åŒ…å«çš„èŠ‚å¥ç±»å‹: [${rhythmTypes.join(', ')}]`);
                        
                        let shouldBlockPattern = false;
                        for (const rhythmType of rhythmTypes) {
                            // ğŸ”¥ é«˜çº§è®¾ç½®ä¼˜å…ˆçº§ï¼šæ£€æŸ¥ç”¨æˆ·çš„é¢‘ç‡è®¾ç½®ï¼ˆé«˜çº§è®¾ç½®è¦†ç›–åŸºæœ¬è®¾ç½®ï¼‰
                            if (userSettings?.rhythmFrequencies) {
                                let freqKey = rhythmType;
                                // ğŸ¯ å®Œæ•´æ˜ å°„èŠ‚å¥ç±»å‹åˆ°é¢‘ç‡è®¾ç½®çš„é”®
                                if (rhythmType === '16th') freqKey = '16th';
                                else if (rhythmType === 'eighth') freqKey = 'eighth';
                                else if (rhythmType === 'quarter') freqKey = 'quarter';
                                else if (rhythmType === 'quarter.') freqKey = 'dotted-quarter'; // ğŸ”¥ ä¿®å¤ï¼šé™„ç‚¹å››åˆ†éŸ³ç¬¦ä½¿ç”¨ä¸“é—¨çš„é¢‘ç‡æ§åˆ¶
                                else if (rhythmType === 'half') freqKey = 'half';
                                else if (rhythmType === 'half.') freqKey = 'dotted-half'; // ğŸ”¥ å…³é”®æ˜ å°„ï¼šé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                                else if (rhythmType === 'whole') freqKey = 'whole';
                                else if (rhythmType === 'duplet') freqKey = 'duplet';
                                else if (rhythmType === 'quadruplet') freqKey = 'quadruplet';
                                else if (rhythmType === 'triplet') freqKey = 'triplet';
                                
                                const frequency = userSettings.rhythmFrequencies[freqKey];
                                if (frequency !== undefined) {
                                    console.log(`ğŸ¯ é«˜çº§è®¾ç½®é¢‘ç‡æ§åˆ¶æ£€æŸ¥ï¼š${rhythmType} -> ${freqKey} = ${frequency}%`);
                                    if (frequency === 0) {
                                        console.log(`ğŸš« é«˜çº§è®¾ç½®é˜»æ­¢ï¼š${rhythmType}ï¼ˆæ˜ å°„åˆ°${freqKey}ï¼‰é¢‘ç‡ä¸º0%ï¼Œå®Œå…¨é˜»æ­¢æ­¤æ¨¡å¼`);
                                        shouldBlockPattern = true;
                                        break; // ä»»ä½•ä¸€ç§èŠ‚å¥ç±»å‹é¢‘ç‡ä¸º0å°±é˜»æ­¢æ•´ä¸ªæ¨¡å¼
                                    }
                                } else {
                                    console.log(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°${rhythmType}çš„é¢‘ç‡è®¾ç½®ï¼ˆé”®ï¼š${freqKey}ï¼‰`);
                                }
                            } else {
                                console.log(`âš ï¸ ç”¨æˆ·é¢‘ç‡è®¾ç½®ä¸å­˜åœ¨`);
                            }
                        }
                        
                        if (!shouldBlockPattern) {
                            console.log(`âœ… æ¨¡å¼é€šè¿‡é¢‘ç‡æ§åˆ¶æ£€æŸ¥ï¼Œå…è®¸ä½¿ç”¨`);
                            rhythmPattern = basePattern;
                        } else {
                            console.log(`âŒ æ¨¡å¼è¢«é¢‘ç‡æ§åˆ¶é˜»æ­¢ï¼Œå¯»æ‰¾æ›¿ä»£æ¨¡å¼`);
                            
                            // ğŸ”¥ æ™ºèƒ½å›é€€ï¼šæ ¹æ®ç”¨æˆ·é¢‘ç‡è®¾ç½®åˆ›å»ºå®‰å…¨æ¨¡å¼
                            const allowedRhythms = Object.entries(userSettings?.rhythmFrequencies || {})
                                .filter(([key, freq]) => freq > 0)
                                .map(([key]) => key);
                            console.log(`ğŸ” å…è®¸çš„èŠ‚å¥ç±»å‹ï¼ˆé¢‘ç‡>0ï¼‰: [${allowedRhythms.join(', ')}]`);
                            
                            // æŒ‰ä¼˜å…ˆçº§åˆ›å»ºå®‰å…¨æ¨¡å¼
                            if (allowedRhythms.includes('dotted-half') && allowedRhythms.length >= 1) {
                                // ä¼˜å…ˆä½¿ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆå¦‚æœè¢«å…è®¸ï¼‰
                                rhythmPattern = [
                                    { duration: 'half.', beats: 3.0 }
                                ];
                                console.log(`ğŸ”„ ä½¿ç”¨å®‰å…¨çš„é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼`);
                            } else if (allowedRhythms.includes('quarter.')) {
                                // ğŸ”¥ ä¿®å¤æ··æ·†é”™è¯¯ï¼šåªæœ‰å½“ç”¨æˆ·æ˜ç¡®å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦æ—¶æ‰ä½¿ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼
                                rhythmPattern = [
                                    { duration: 'quarter.', beats: 1.5 },
                                    { duration: 'quarter.', beats: 1.5 }
                                ];
                                console.log(`ğŸ”„ ä½¿ç”¨å®‰å…¨çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰`);
                            } else if (allowedRhythms.includes('quarter') && allowedRhythms.includes('eighth')) {
                                // ğŸ”¥ ä¿®å¤ï¼šæ™®é€šå››åˆ†éŸ³ç¬¦éœ€è¦ä¸å…«åˆ†éŸ³ç¬¦ç»„åˆæ‰èƒ½åœ¨6/8æ‹ä¸­å·¥ä½œ
                                rhythmPattern = [
                                    { duration: 'quarter', beats: 1.0 },   // ç¬¬ä¸€ç»„ï¼šå››åˆ†éŸ³ç¬¦(1æ‹) + å…«åˆ†éŸ³ç¬¦(0.5æ‹)
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'quarter', beats: 1.0 },   // ç¬¬äºŒç»„ï¼šå››åˆ†éŸ³ç¬¦(1æ‹) + å…«åˆ†éŸ³ç¬¦(0.5æ‹)  
                                    { duration: 'eighth', beats: 0.5 }
                                ];
                                console.log(`ğŸ”„ ä½¿ç”¨å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦æ··åˆæ¨¡å¼ï¼ˆ6/8æ‹é€‚é…ï¼‰`);
                            } else if (allowedRhythms.includes('eighth')) {
                                // ä½¿ç”¨å…«åˆ†éŸ³ç¬¦æ¨¡å¼
                                rhythmPattern = [
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'eighth', beats: 0.5 },
                                    { duration: 'eighth', beats: 0.5 }
                                ];
                                console.log(`ğŸ”„ ä½¿ç”¨å®‰å…¨çš„å…«åˆ†éŸ³ç¬¦æ¨¡å¼`);
                            } else {
                                console.error(`âŒ æ— æ³•åˆ›å»ºå®‰å…¨æ¨¡å¼ï¼šæ²¡æœ‰å¯ç”¨çš„åŸºç¡€èŠ‚å¥ç±»å‹`);
                                console.error(`ğŸ” è°ƒè¯•ä¿¡æ¯ï¼šå…è®¸çš„èŠ‚å¥ç±»å‹ = [${allowedRhythms.join(', ')}]`);
                                console.error(`ğŸ” ç”¨æˆ·é¢‘ç‡è®¾ç½®:`, userSettings?.rhythmFrequencies);
                                
                                // ğŸ”¥ ä¸¥æ ¼éµå¾ªç”¨æˆ·é€‰æ‹©ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•å¯ç”¨çš„èŠ‚å¥ç±»å‹
                                const userRhythms = this.rules?.allowedDurations || [];
                                console.error(`ğŸ” ç”¨æˆ·å‹¾é€‰çš„åŸºç¡€èŠ‚å¥ç±»å‹: [${userRhythms.join(', ')}]`);
                                
                                if (userRhythms.includes('eighth')) {
                                    // ä»…åœ¨ç”¨æˆ·å‹¾é€‰å…«åˆ†éŸ³ç¬¦çš„æƒ…å†µä¸‹ä½¿ç”¨
                                    rhythmPattern = [
                                        { duration: 'eighth', beats: 0.5 },
                                        { duration: 'eighth', beats: 0.5 },
                                        { duration: 'eighth', beats: 0.5 },
                                        { duration: 'eighth', beats: 0.5 },
                                        { duration: 'eighth', beats: 0.5 },
                                        { duration: 'eighth', beats: 0.5 }
                                    ];
                                    console.log(`âœ… ä¸¥æ ¼å›é€€ï¼šä½¿ç”¨å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰`);
                                } else if (userRhythms.includes('half.') || userRhythms.includes('dotted-half')) {
                                    // å°è¯•é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                                    rhythmPattern = [
                                        { duration: 'half.', beats: 3.0 }
                                    ];
                                    console.log(`âœ… ä¸¥æ ¼å›é€€ï¼šä½¿ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰`);
                                } else if (userRhythms.includes('quarter.')) {
                                    // ğŸ”¥ ä¿®å¤æ··æ·†é”™è¯¯ï¼šåªæœ‰ç”¨æˆ·å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦æ—¶æ‰ä½¿ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦
                                    rhythmPattern = [
                                        { duration: 'quarter.', beats: 1.5 },
                                        { duration: 'quarter.', beats: 1.5 }
                                    ];
                                    console.log(`âœ… ä¸¥æ ¼å›é€€ï¼šä½¿ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰`);
                                } else if (userRhythms.includes('quarter') && userRhythms.includes('eighth')) {
                                    // ğŸ”¥ ä¿®å¤ï¼šæ™®é€šå››åˆ†éŸ³ç¬¦éœ€è¦ä¸å…«åˆ†éŸ³ç¬¦ç»„åˆæ‰èƒ½åœ¨6/8æ‹ä¸­æ­£ç¡®å·¥ä½œ
                                    rhythmPattern = [
                                        { duration: 'quarter', beats: 1.0 },   // å››åˆ†éŸ³ç¬¦
                                        { duration: 'eighth', beats: 0.5 },    // å…«åˆ†éŸ³ç¬¦
                                        { duration: 'quarter', beats: 1.0 },   // å››åˆ†éŸ³ç¬¦
                                        { duration: 'eighth', beats: 0.5 }     // å…«åˆ†éŸ³ç¬¦
                                    ];
                                    console.log(`âœ… ä¸¥æ ¼å›é€€ï¼šä½¿ç”¨å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦ç»„åˆæ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰è¿™ä¸¤ç§èŠ‚å¥ï¼‰`);
                                } else {
                                    // ğŸš¨ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨çš„6/8æ‹èŠ‚å¥ç±»å‹
                                    console.error(`âŒ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨äº6/8æ‹çš„èŠ‚å¥ç±»å‹ï¼`);
                                    console.error(`âŒ æ— æ³•ç”Ÿæˆ6/8æ‹æ¨¡å¼ï¼Œå°†è¿”å›null`);
                                    rhythmPattern = null;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.warn(`âš ï¸ é¢‘ç‡æ§åˆ¶ç‰ˆæœ¬ç”Ÿæˆå¤±è´¥: ${error.message}ï¼Œå›é€€åˆ°åŸºç¡€ç‰ˆæœ¬`);
                }
                
                // æœ€åçš„å›é€€é€‰é¡¹
                if (!rhythmPattern) {
                    console.log(`ğŸ”„ æœ€ç»ˆå›é€€åˆ°åŸºç¡€6/8æ‹æ¨¡å¼ç”Ÿæˆ`);
                    rhythmPattern = this.choose6_8RhythmPattern();
                }
                
                if (rhythmPattern && rhythmPattern.length > 0) {
                    console.log(`âœ… æœ€ç»ˆé€‰æ‹©6/8æ‹èŠ‚å¥æ¨¡å¼: ${rhythmPattern.map(d => d.duration).join(' ')}`);
                    
                    // æŒ‰ç…§é€‰å®šçš„èŠ‚å¥æ¨¡å¼ç”Ÿæˆæ•´ä¸ªå°èŠ‚
                    for (const patternNote of rhythmPattern) {
                        if (!patternNote || !patternNote.duration || typeof patternNote.beats !== 'number') {
                            console.error(`âš ï¸ æ— æ•ˆçš„æ¨¡å¼éŸ³ç¬¦: ${JSON.stringify(patternNote)}`);
                            continue;
                        }
                        
                        const shouldBeRest = this.shouldPlaceRest(remainingBeats, notes.length, measureIndex);
                        
                        if (shouldBeRest) {
                            notes.push({
                                type: 'rest',
                                duration: patternNote.duration,
                                beats: patternNote.beats
                            });
                            console.log(`    âœ… æ·»åŠ ä¼‘æ­¢ç¬¦: ${patternNote.duration} (${patternNote.beats}æ‹)`);
                        } else {
                            // ç”ŸæˆéŸ³ç¬¦
                            let nextMidi;
                            try {
                                // åˆ›å»ºä¸Šä¸‹æ–‡ä¿¡æ¯
                                const noteContext = {
                                    isMeasureStart: currentBeat === 0,
                                    isMeasureEnd: remainingBeats === patternNote.beats,
                                    isPhrasEnd: isLastMeasure && remainingBeats === patternNote.beats,
                                    isCadence: isLastMeasure && remainingBeats <= this.beatsPerMeasure * 0.5,
                                    measureIndex,
                                    totalMeasures: this.measures,
                                    currentBeat,
                                    remainingBeats,
                                    beats: patternNote.beats
                                };
                                nextMidi = this.generateNextNote(
                                    currentMidi,
                                    currentDirection,
                                    currentConsecutiveJumps,
                                    isLastMeasure && remainingBeats === patternNote.beats,
                                    noteContext
                                );
                            } catch (error) {
                                console.error(`ç”ŸæˆéŸ³ç¬¦é”™è¯¯:`, error.message);
                                nextMidi = currentMidi || this.generateInScaleNote(null);
                            }
                            
                            const note = {
                                type: 'note',
                                midi: nextMidi,
                                duration: patternNote.duration,
                                beats: patternNote.beats
                            };
                            notes.push(note);
                            console.log(`    âœ… æ·»åŠ éŸ³ç¬¦: ${midiToNoteName(nextMidi)} ${patternNote.duration} (${patternNote.beats}æ‹)`);
                            
                            currentMidi = nextMidi;
                        }
                        
                        remainingBeats -= patternNote.beats;
                        currentBeat += patternNote.beats;
                    }
                    
                    // å¦‚æœæŒ‰èŠ‚å¥æ¨¡å¼ç”Ÿæˆå®Œæ•´å°èŠ‚ï¼Œè·³å‡ºå¾ªç¯
                    if (remainingBeats <= 0.001) {
                        break;
                    }
                }
            }
            
            // é€‰æ‹©æ—¶å€¼ (æ™®é€šéŸ³ç¬¦ç”Ÿæˆæ¨¡å¼)
            console.log(`ğŸ¶ æ™®é€šéŸ³ç¬¦ç”Ÿæˆ: å‰©ä½™æ‹æ•°${remainingBeats}, å°èŠ‚å·²æœ‰${notes.length}ä¸ªå…ƒç´ , å½“å‰ä½ç½®${currentBeat}`);
            const duration = this.chooseDuration(remainingBeats, notes.length === 0, currentBeat);
            const beats = this.durationToBeats(duration);
            console.log(`ğŸ“ é€‰æ‹©æ—¶å€¼: ${duration} (${beats}æ‹), å‰©ä½™ç©ºé—´: ${remainingBeats}æ‹`);
            
            if (beats > remainingBeats + 0.001) {
                // æ—¶å€¼è¿‡å¤§ï¼Œæ”¹ç”¨ä¼‘æ­¢ç¬¦å¡«å……
                console.log(`âš ï¸ æ‰€é€‰æ—¶å€¼${beats}æ‹è¿‡å¤§ï¼Œå‰©ä½™ä»…${remainingBeats}æ‹ï¼Œç”¨ä¼‘æ­¢ç¬¦å¡«å……`);

                // ğŸ”¥ 6/8æ‹ç‰¹æ®Šå¤„ç†ï¼šè®¡ç®—å®‰å…¨çš„ä¼‘æ­¢ç¬¦æ—¶å€¼
                let safeRestBeats = remainingBeats;
                if (this.timeSignature === '6/8') {
                    // ç¡®ä¿ä¼‘æ­¢ç¬¦ä¸ä¼šè·¨è¶Š6/8æ‹çš„å…³é”®è¾¹ç•Œ
                    const noteEndPosition = currentBeat + remainingBeats;
                    const criticalBoundaries = [0, 1.5, 3];

                    for (const boundary of criticalBoundaries) {
                        if (currentBeat < boundary && noteEndPosition > boundary) {
                            safeRestBeats = boundary - currentBeat;
                            console.log(`âš ï¸ 6/8æ‹å¡«å……ä¼‘æ­¢ç¬¦è¾¹ç•Œè°ƒæ•´ï¼š${remainingBeats}æ‹ -> ${safeRestBeats}æ‹ï¼ˆé¿å…è·¨è¶Šè¾¹ç•Œ${boundary}ï¼‰`);
                            break;
                        }
                    }
                }

                // ğŸ”¥ é™„ç‚¹å…«åˆ†éŸ³ç¬¦ç²¾ç¡®å¡«å……ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦æ‹†åˆ†åˆ†æ•°æ‹
                const proposedRestDuration = this.beatsToRestDuration(safeRestBeats);
                const actualRestBeats = this.durationToBeats(proposedRestDuration);
                const restBeatsDifference = Math.abs(safeRestBeats - actualRestBeats);

                if (restBeatsDifference > 0.001) {
                    console.log(`ğŸ”§ [åˆ†æ•°æ‹ä¿®å¤] æ£€æµ‹åˆ°ä¼‘æ­¢ç¬¦æ—¶å€¼ä¸åŒ¹é…ï¼šéœ€è¦${safeRestBeats}æ‹ï¼Œä½†${proposedRestDuration}å®é™…æ˜¯${actualRestBeats}æ‹`);

                    // æ™ºèƒ½æ‹†åˆ†åˆ†æ•°æ‹ä¸ºå¤šä¸ªç²¾ç¡®ä¼‘æ­¢ç¬¦
                    const restSegments = this.splitFractionalBeats(safeRestBeats);

                    for (const segment of restSegments) {
                        const segmentDuration = this.beatsToRestDuration(segment);
                        notes.push({
                            type: 'rest',
                            duration: segmentDuration,
                            beats: segment
                        });
                        console.log(`âœ… æ·»åŠ æ‹†åˆ†ä¼‘æ­¢ç¬¦: ${segmentDuration} (${segment}æ‹)`);
                    }

                    remainingBeats -= safeRestBeats;
                    currentBeat += safeRestBeats;
                } else {
                    // æ ‡å‡†å¤„ç†ï¼šå•ä¸ªä¼‘æ­¢ç¬¦
                    notes.push({
                        type: 'rest',
                        duration: proposedRestDuration,
                        beats: safeRestBeats
                    });
                    console.log(`âœ… æ·»åŠ å¡«å……ä¼‘æ­¢ç¬¦: ${proposedRestDuration} (${safeRestBeats}æ‹)`);
                    remainingBeats -= safeRestBeats;
                    currentBeat += safeRestBeats;
                }

                // å¦‚æœè¿˜æœ‰å‰©ä½™æ‹æ•°ï¼Œç»§ç»­å¾ªç¯ï¼›å¦åˆ™ç»“æŸ
                if (remainingBeats <= 0.001) {
                    break;
                }
                continue; // ç»§ç»­å¤„ç†å‰©ä½™æ‹æ•°
            }
            
            // å†³å®šæ˜¯éŸ³ç¬¦è¿˜æ˜¯ä¼‘æ­¢ç¬¦
            const shouldBeRest = this.shouldPlaceRest(
                remainingBeats, 
                notes.length, 
                measureIndex
            );
            console.log(`ğŸ¯ éŸ³ç¬¦ç±»å‹å†³ç­–: ${shouldBeRest ? 'ä¼‘æ­¢ç¬¦' : 'éŸ³ç¬¦'}`);
            
            if (shouldBeRest) {
                // æ·»åŠ ä¼‘æ­¢ç¬¦ï¼Œä½†éœ€è¦æ£€æŸ¥6/8æ‹è¾¹ç•Œ
                let safeBeats = beats;
                let safeDuration = duration;

                if (this.timeSignature === '6/8') {
                    const noteEndPosition = currentBeat + beats;
                    const criticalBoundaries = [0, 1.5, 3];

                    for (const boundary of criticalBoundaries) {
                        if (currentBeat < boundary && noteEndPosition > boundary) {
                            safeBeats = boundary - currentBeat;
                            safeDuration = this.beatsToRestDuration(safeBeats);
                            console.log(`âš ï¸ 6/8æ‹ä¼‘æ­¢ç¬¦è¾¹ç•Œè°ƒæ•´ï¼š${duration}(${beats}æ‹) -> ${safeDuration}(${safeBeats}æ‹)`);
                            break;
                        }
                    }
                }

                notes.push({
                    type: 'rest',
                    duration: safeDuration,
                    beats: safeBeats
                });
                console.log(`    âœ… æ·»åŠ ä¼‘æ­¢ç¬¦: ${safeDuration} (${safeBeats}æ‹)`);

                // æ›´æ–°å‰©ä½™æ‹æ•°å’Œä½ç½®ï¼ˆä½¿ç”¨å®é™…æ·»åŠ çš„æ‹æ•°ï¼‰
                remainingBeats -= safeBeats;
                currentBeat += safeBeats;
            } else {
                // ç”ŸæˆéŸ³ç¬¦
                console.log(`ğŸµ å¼€å§‹ç”Ÿæˆä¸‹ä¸€ä¸ªéŸ³ç¬¦: å½“å‰MIDI=${currentMidi}, æ–¹å‘=${currentDirection}`);
                
                let nextMidi;
                try {
                    // åˆ›å»ºä¸Šä¸‹æ–‡ä¿¡æ¯ç”¨äºå°è°ƒå˜åŒ–éŸ³å¤„ç†
                    const noteContext = {
                        isMeasureStart: currentBeat === 0,
                        isMeasureEnd: remainingBeats - beats <= 0.001,
                        isPhrasEnd: isLastMeasure && remainingBeats - beats <= 0.5,
                        isCadence: isLastMeasure && remainingBeats <= this.beatsPerMeasure * 0.5,
                        measureIndex,
                        totalMeasures: this.measures,
                        currentBeat,
                        remainingBeats,
                        beats
                    };
                    nextMidi = this.generateNextNote(
                        currentMidi, 
                        currentDirection, 
                        currentConsecutiveJumps,
                        isLastMeasure && remainingBeats - beats <= 0.5, // æ˜¯å¦ä¸ºç»“æŸéŸ³
                        noteContext
                    );
                    console.log(`âœ… éŸ³ç¬¦ç”ŸæˆæˆåŠŸ: MIDI ${nextMidi}`);
                } catch (error) {
                    console.error(`âŒ éŸ³ç¬¦ç”Ÿæˆå¤±è´¥: ${error.message}`);
                    console.error(`ä½¿ç”¨åº”æ€¥éŸ³ç¬¦ç”Ÿæˆç­–ç•¥`);
                    // åº”æ€¥å¤„ç†ï¼šä½¿ç”¨å½“å‰éŸ³ç¬¦æˆ–éŸ³åŸŸä¸­ç‚¹
                    nextMidi = currentMidi || Math.floor((this.rules.range.min + this.rules.range.max) / 2);
                }
                
                // ä¸¥æ ¼éªŒè¯éŸ³ç¨‹è·³åŠ¨é™åˆ¶
                if (currentMidi !== null) {
                    const actualInterval = Math.abs(nextMidi - currentMidi);
                    if (actualInterval > this.rules.maxJump) {
                        console.error(`âŒ éŸ³ç¨‹è·³åŠ¨è¿è§„: ${actualInterval}åŠéŸ³ > ${this.rules.maxJump}åŠéŸ³ - å¼ºåˆ¶ä¿®æ­£ï¼`);
                        console.error(`   è°ƒå·: ${this.keySignature}, å‰ä¸€éŸ³ç¬¦: ${currentMidi} -> å½“å‰éŸ³ç¬¦: ${nextMidi}`);
                        
                        // å¼ºåˆ¶ä¿®æ­£ï¼šå°†éŸ³ç¬¦é™åˆ¶åœ¨å…è®¸çš„è·³åº¦èŒƒå›´å†…
                        const maxAllowedUp = currentMidi + this.rules.maxJump;
                        const maxAllowedDown = currentMidi - this.rules.maxJump;
                        
                        if (nextMidi > maxAllowedUp) {
                            nextMidi = Math.min(maxAllowedUp, this.rules.range.max);
                            console.error(`   ä¿®æ­£ä¸ºå‘ä¸Šè·³åº¦é™åˆ¶: MIDI ${nextMidi}`);
                        } else if (nextMidi < maxAllowedDown) {
                            nextMidi = Math.max(maxAllowedDown, this.rules.range.min);
                            console.error(`   ä¿®æ­£ä¸ºå‘ä¸‹è·³åº¦é™åˆ¶: MIDI ${nextMidi}`);
                        }
                        
                        this.stats.constraintViolations = (this.stats.constraintViolations || 0) + 1;
                    } else {
                        console.log(`âœ… éŸ³ç¨‹è·³åº¦åˆè§„: ${actualInterval}åŠéŸ³ â‰¤ ${this.rules.maxJump}åŠéŸ³`);
                    }
                }
                
                // ä¸¥æ ¼éªŒè¯éŸ³åŸŸèŒƒå›´
                if (nextMidi < this.rules.range.min || nextMidi > this.rules.range.max) {
                    console.error(`âŒ éŸ³åŸŸè¿è§„: MIDI ${nextMidi} ä¸åœ¨ ${this.rules.range.min}-${this.rules.range.max} èŒƒå›´å†… - å¼ºåˆ¶ä¿®æ­£ï¼`);
                    console.error(`   è°ƒå·: ${this.keySignature}, è°±å·: ${this.clef}`);
                    console.error(`   å‰ä¸€éŸ³ç¬¦: ${currentMidi}, å½“å‰éŸ³ç¬¦: ${nextMidi}`);
                    console.error(`   éŸ³ç¬¦ç±»å‹: ${nextMidi < 50 ? 'å¼‚å¸¸ä½éŸ³' : nextMidi > 80 ? 'å¼‚å¸¸é«˜éŸ³' : 'æ­£å¸¸'}`);
                    
                    // å¼ºåˆ¶ä¿®æ­£åˆ°éŸ³åŸŸèŒƒå›´å†…
                    const originalMidi = nextMidi;
                    nextMidi = Math.max(this.rules.range.min, Math.min(this.rules.range.max, nextMidi));
                    console.error(`   ä¿®æ­£: ${originalMidi} -> ${nextMidi}`);
                    
                    this.stats.constraintViolations = (this.stats.constraintViolations || 0) + 1;
                } else {
                    console.log(`âœ… éŸ³åŸŸåˆè§„: MIDI ${nextMidi} åœ¨ ${this.rules.range.min}-${this.rules.range.max} èŒƒå›´å†…`);
                }
                
                let preferredAccidental = this.consumeAccidentalPreference(nextMidi);
                if (typeof currentMidi === 'number' && Math.abs(nextMidi - currentMidi) === 1) {
                    const directionPreference = nextMidi > currentMidi ? '#' : 'b';
                    if (!preferredAccidental || preferredAccidental !== directionPreference) {
                        preferredAccidental = directionPreference;
                    }
                }
                const { step, octave, alter } = this.midiToMusicXML(nextMidi, preferredAccidental);
                
                const noteObject = {
                    type: 'note',
                    duration: duration,
                    beats: beats,
                    step: step,
                    octave: octave,
                    alter: alter,
                    midi: nextMidi
                };

                // æ™®é€šSlideéœ€è¦è¿æ¥â€œå‰ä¸€ä¸ªéŸ³ç¬¦ -> å½“å‰éŸ³ç¬¦â€ã€‚
                // ç”Ÿæˆé˜¶æ®µè¿˜æ‹¿ä¸åˆ°â€œä¸‹ä¸€ä¸ªéŸ³ç¬¦â€ï¼Œå› æ­¤åœ¨è¿™é‡Œå›å¡«åˆ°å‰ä¸€ä¸ªç›¸é‚»éŸ³ç¬¦ã€‚
                let glissAssignedToPrevious = false;
                const previousElement = notes.length > 0 ? notes[notes.length - 1] : null;
                const prePreviousElement = notes.length > 1 ? notes[notes.length - 2] : null;
                const wouldCreateConsecutiveSlide =
                    prePreviousElement &&
                    prePreviousElement.type === 'note' &&
                    isSlideArticulationType(prePreviousElement.articulation);
                const previousSlideAllowed = isSlideDurationAllowed(previousElement, this.durationToBeats?.bind(this));
                const currentSlideAllowed = isSlideDurationAllowed(noteObject, this.durationToBeats?.bind(this));
                if (
                    userSettings.articulations.enabled &&
                    this.clef === 'treble' &&
                    Array.isArray(userSettings.articulations.guitar) &&
                    userSettings.articulations.guitar.includes('glissando') &&
                    this.canAssignSlideArticulation('glissando') &&
                    previousElement &&
                    previousElement.type === 'note' &&
                    typeof previousElement.midi === 'number' &&
                    !previousElement.articulation &&
                    previousSlideAllowed &&
                    currentSlideAllowed &&
                    !wouldCreateConsecutiveSlide
                ) {
                    const interval = Math.abs(noteObject.midi - previousElement.midi);
                    if (interval >= 1 && interval <= 12) {
                    const linkChance = interval <= 2 ? 0.18 : 0.35;
                    if (this.random.nextFloat() < linkChance) {
                        previousElement.articulation = 'glissando';
                        if (this.consumeSlideArticulation('glissando')) {
                            glissAssignedToPrevious = true;
                            console.log(`ğŸ¸ å›å¡«Glissando: ${previousElement.midi} -> ${noteObject.midi} (éŸ³ç¨‹${interval}åŠéŸ³)`);
                        } else {
                            previousElement.articulation = null;
                        }
                    }
                }
                }
                
                // ä¸ºéŸ³ç¬¦é€‰æ‹©åˆé€‚çš„articulation
                const articulation = glissAssignedToPrevious
                    ? null
                    : this.selectArticulation(
                        noteObject, 
                        notes.filter(n => n.type === 'note').length, // å½“å‰éŸ³ç¬¦ç´¢å¼•
                        notes.filter(n => n.type === 'note'), // åªè€ƒè™‘éŸ³ç¬¦ï¼Œä¸åŒ…æ‹¬ä¼‘æ­¢ç¬¦
                        measureIndex,
                        this.clef
                    );
                
                // å¤„ç†acciaccatura - å¦‚æœé€‰ä¸­äº†acciaccaturaï¼Œç”Ÿæˆå®é™…çš„è£…é¥°éŸ³ç¬¦
                if (articulation === 'acciaccatura') {
                    const acciaccaturaNote = this.generateAcciaccaturaNote(noteObject);
                    if (acciaccaturaNote) {
                        // å°†è£…é¥°éŸ³ä¿¡æ¯é™„åŠ åˆ°ä¸»éŸ³ç¬¦ä¸Šï¼Œè€Œä¸æ˜¯ä½œä¸ºç‹¬ç«‹éŸ³ç¬¦
                        noteObject.graceNote = acciaccaturaNote;
                        console.log(`ğŸµ å°†è£…é¥°éŸ³é™„åŠ åˆ°ä¸»éŸ³ç¬¦ä¸Š: ${acciaccaturaNote.step}${acciaccaturaNote.octave} -> ${noteObject.step}${noteObject.octave}`);
                    }
                    notes.push(noteObject);
                } else {
                    if (articulation) {
                        noteObject.articulation = articulation;
                    }
                    notes.push(noteObject);
                }
                
                // æ›´æ–°æ–¹å‘å’Œè·³è¿›çŠ¶æ€
                if (currentMidi !== null) {
                    const interval = nextMidi - currentMidi;
                    if (Math.abs(interval) > 2) { // å¤§äºäºŒåº¦ä¸ºè·³è¿›
                        currentConsecutiveJumps++;
                    } else {
                        currentConsecutiveJumps = 0;
                    }
                    
                    const newDirection = interval > 0 ? 1 : (interval < 0 ? -1 : 0);
                    if (newDirection !== currentDirection && newDirection !== 0) {
                        measureDirectionChanges++;
                    }
                    currentDirection = newDirection;
                }
                
                currentMidi = nextMidi;
                
                console.log(`    éŸ³ç¬¦: ${step}${octave} ${duration} (${beats}æ‹) MIDI:${nextMidi}`);

                // éŸ³ç¬¦ä¹Ÿéœ€è¦æ›´æ–°å‰©ä½™æ‹æ•°å’Œä½ç½®
                remainingBeats -= beats;
                currentBeat += beats;
            }

            // æ³¨æ„ï¼šä¼‘æ­¢ç¬¦çš„å‰©ä½™æ‹æ•°å’Œä½ç½®å·²åœ¨ä¸Šé¢æ›´æ–°äº†ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤æ›´æ–°
            console.log(`âœ… å®Œæˆä¸€æ¬¡è¿­ä»£: å‰©ä½™${remainingBeats}æ‹ï¼Œå½“å‰ä½ç½®${currentBeat}ï¼Œå°èŠ‚ç°æœ‰${notes.length}ä¸ªå…ƒç´ `);
        }
        
        // å¾ªç¯å®‰å…¨æ£€æŸ¥
        if (loopSafety >= maxLoopIterations) {
            console.warn(`è­¦å‘Š: å°èŠ‚ç”Ÿæˆè¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œå‰©ä½™æ‹æ•°: ${remainingBeats}`);
            // å¼ºåˆ¶ç»“æŸå°èŠ‚
            if (remainingBeats > 0) {
                const restDuration = this.beatsToRestDuration(remainingBeats);
                notes.push({
                    type: 'rest',
                    duration: restDuration,
                    beats: remainingBeats
                });
            }
        }
        
        // éªŒè¯å’Œä¿®å¤å°èŠ‚å®Œæ•´æ€§
        let totalBeats = notes.reduce((sum, note) => sum + note.beats, 0);
        const beatsDifference = this.beatsPerMeasure - totalBeats;
        
        if (Math.abs(beatsDifference) > 0.001) {
            console.warn(`âš ï¸ å°èŠ‚${measureIndex + 1}æ—¶å€¼ä¸åŒ¹é…: æœŸæœ›${this.beatsPerMeasure}, å®é™…${totalBeats}, å·®å€¼${beatsDifference}`);
            
            if (beatsDifference > 0) {
                // å°èŠ‚æ—¶å€¼ä¸è¶³ï¼Œæ·»åŠ ä¼‘æ­¢ç¬¦å¡«å……
                console.log(`æ­£åœ¨ç”¨ä¼‘æ­¢ç¬¦å¡«å……${beatsDifference}æ‹`);

                // ğŸ”¥ é™„ç‚¹å…«åˆ†éŸ³ç¬¦ç²¾ç¡®ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦æ‹†åˆ†åˆ†æ•°æ‹
                const proposedRestDuration = this.beatsToRestDuration(beatsDifference);
                const actualRestBeats = this.durationToBeats(proposedRestDuration);
                const restBeatsDifference = Math.abs(beatsDifference - actualRestBeats);

                if (restBeatsDifference > 0.001) {
                    console.log(`ğŸ”§ [æœ€ç»ˆéªŒè¯-åˆ†æ•°æ‹ä¿®å¤] æ£€æµ‹åˆ°æ—¶å€¼ä¸åŒ¹é…ï¼šéœ€è¦${beatsDifference}æ‹ï¼Œä½†${proposedRestDuration}å®é™…æ˜¯${actualRestBeats}æ‹`);

                    // æ™ºèƒ½æ‹†åˆ†åˆ†æ•°æ‹ä¸ºå¤šä¸ªç²¾ç¡®ä¼‘æ­¢ç¬¦
                    const restSegments = this.splitFractionalBeats(beatsDifference);

                    for (const segment of restSegments) {
                        const segmentDuration = this.beatsToRestDuration(segment);
                        notes.push({
                            type: 'rest',
                            duration: segmentDuration,
                            beats: segment
                        });
                        console.log(`âœ… æ·»åŠ æœ€ç»ˆéªŒè¯æ‹†åˆ†ä¼‘æ­¢ç¬¦: ${segmentDuration} (${segment}æ‹)`);
                        totalBeats += segment;
                    }
                } else {
                    // æ ‡å‡†å¤„ç†ï¼šå•ä¸ªä¼‘æ­¢ç¬¦
                    notes.push({
                        type: 'rest',
                        duration: proposedRestDuration,
                        beats: beatsDifference
                    });
                    totalBeats += beatsDifference;
                }
            } else if (beatsDifference < 0) {
                // å°èŠ‚æ—¶å€¼è¶…è¿‡ï¼Œç§»é™¤æœ€åçš„éŸ³ç¬¦/ä¼‘æ­¢ç¬¦æˆ–è°ƒæ•´æ—¶å€¼
                console.log(`å°èŠ‚æ—¶å€¼è¶…è¿‡${Math.abs(beatsDifference)}æ‹ï¼Œå°è¯•ä¿®å¤`);
                
                // ç®€å•çš„ä¿®å¤ç­–ç•¥ï¼šç§»é™¤æœ€åçš„å…ƒç´ ç›´åˆ°æ—¶å€¼åŒ¹é…
                while (notes.length > 0 && totalBeats > this.beatsPerMeasure) {
                    const lastNote = notes.pop();
                    totalBeats -= lastNote.beats;
                    console.log(`ç§»é™¤äº†æœ€åä¸€ä¸ª${lastNote.type}: ${lastNote.beats}æ‹`);
                }
                
                // å¦‚æœè¿˜æ˜¯ä¸è¶³ï¼Œæ·»åŠ ä¼‘æ­¢ç¬¦å¡«å……
                const finalDifference = this.beatsPerMeasure - totalBeats;
                if (finalDifference > 0) {
                    const restDuration = this.beatsToRestDuration(finalDifference);
                    notes.push({
                        type: 'rest',
                        duration: restDuration,
                        beats: finalDifference
                    });
                    totalBeats += finalDifference;
                }
            }
        }
        
        // æœ€ç»ˆéªŒè¯å’Œå¼ºåˆ¶ä¿®å¤
        if (notes.length === 0) {
            console.error(`é”™è¯¯: å°èŠ‚${measureIndex + 1}ä¸ºç©ºï¼Œæ·»åŠ å…¨ä¼‘æ­¢ç¬¦`);
            notes.push({
                type: 'rest',
                duration: this.beatsToRestDuration(this.beatsPerMeasure),
                beats: this.beatsPerMeasure
            });
        } else {
            // å†æ¬¡æ£€æŸ¥æœ€ç»ˆæ—¶å€¼
            const finalTotalBeats = notes.reduce((sum, note) => sum + note.beats, 0);
            const finalBeatsDifference = this.beatsPerMeasure - finalTotalBeats;
            
            if (Math.abs(finalBeatsDifference) > 0.001) {
                console.error(`ä¸¥é‡é”™è¯¯: å°èŠ‚${measureIndex + 1}æœ€ç»ˆæ—¶å€¼ä»ä¸åŒ¹é…: æœŸæœ›${this.beatsPerMeasure}, å®é™…${finalTotalBeats}`);
                
                if (finalBeatsDifference > 0) {
                    // è¿˜æ˜¯ä¸è¶³ï¼Œæœ€åä¸€æ¬¡å¡«å……
                    // ğŸ”¥ é™„ç‚¹å…«åˆ†éŸ³ç¬¦ç²¾ç¡®ä¿®å¤ï¼šæœ€ç»ˆæ•‘æ•‘å¡«å……ä¹Ÿéœ€è¦åˆ†æ•°æ‹å¤„ç†
                    const proposedFinalRestDuration = this.beatsToRestDuration(finalBeatsDifference);
                    const actualFinalRestBeats = this.durationToBeats(proposedFinalRestDuration);
                    const finalRestBeatsDifference = Math.abs(finalBeatsDifference - actualFinalRestBeats);

                    if (finalRestBeatsDifference > 0.001) {
                        console.log(`ğŸ”§ [æœ€ç»ˆæ•‘æ•‘å¡«å……-åˆ†æ•°æ‹ä¿®å¤] æ£€æµ‹åˆ°æ—¶å€¼ä¸åŒ¹é…ï¼šéœ€è¦${finalBeatsDifference}æ‹ï¼Œä½†${proposedFinalRestDuration}å®é™…æ˜¯${actualFinalRestBeats}æ‹`);

                        // æ™ºèƒ½æ‹†åˆ†åˆ†æ•°æ‹ä¸ºå¤šä¸ªç²¾ç¡®ä¼‘æ­¢ç¬¦
                        const finalRestSegments = this.splitFractionalBeats(finalBeatsDifference);

                        for (const segment of finalRestSegments) {
                            const segmentDuration = this.beatsToRestDuration(segment);
                            notes.push({
                                type: 'rest',
                                duration: segmentDuration,
                                beats: segment
                            });
                            console.log(`âœ… æ·»åŠ æœ€ç»ˆæ•‘æ•‘å¡«å……æ‹†åˆ†ä¼‘æ­¢ç¬¦: ${segmentDuration} (${segment}æ‹)`);
                        }
                    } else {
                        // æ ‡å‡†å¤„ç†ï¼šå•ä¸ªä¼‘æ­¢ç¬¦
                        notes.push({
                            type: 'rest',
                            duration: proposedFinalRestDuration,
                            beats: finalBeatsDifference
                        });
                        console.log(`æœ€ç»ˆæ•‘æ•‘å¡«å……: ${finalBeatsDifference}æ‹ä¼‘æ­¢ç¬¦`);
                    }
                }
            }
        }
        
        // æœ€ç»ˆæœ€ç»ˆéªŒè¯ - å¼ºåˆ¶æ£€æŸ¥
        const absoluteFinalBeats = notes.reduce((sum, note) => sum + note.beats, 0);
        const absoluteFinalDifference = this.beatsPerMeasure - absoluteFinalBeats;
        
        if (Math.abs(absoluteFinalDifference) > 0.001) {
            console.error(`âŒ æœ€ç»ˆéªŒè¯å¤±è´¥: å°èŠ‚${measureIndex + 1} - æ€»æ—¶é•¿${absoluteFinalBeats}æ‹, æœŸæœ›${this.beatsPerMeasure}æ‹, å·®å€¼${absoluteFinalDifference}æ‹`);
            
            if (absoluteFinalDifference > 0.001) {
                // ä»ç„¶ä¸è¶³ï¼Œå¼ºåˆ¶æ·»åŠ ä¼‘æ­¢ç¬¦
                console.log(`å¼ºåˆ¶æ·»åŠ æœ€åçš„ä¼‘æ­¢ç¬¦: ${absoluteFinalDifference}æ‹`);

                // ğŸ”¥ 6/8æ‹ç‰¹æ®Šå¤„ç†ï¼šç¡®ä¿æœ€ç»ˆå¡«å……ä¼‘æ­¢ç¬¦ä¸è·¨è¶Šè¾¹ç•Œ
                let safeRestBeats = absoluteFinalDifference;
                if (this.timeSignature === '6/8') {
                    // è®¡ç®—å½“å‰ä½ç½®ï¼ˆåŸºäºå·²æœ‰éŸ³ç¬¦çš„æ€»æ—¶é•¿ï¼‰
                    const currentPosition = this.beatsPerMeasure - absoluteFinalDifference;
                    const noteEndPosition = currentPosition + absoluteFinalDifference;
                    const criticalBoundaries = [0, 1.5, 3];

                    for (const boundary of criticalBoundaries) {
                        if (currentPosition < boundary && noteEndPosition > boundary) {
                            safeRestBeats = boundary - currentPosition;
                            console.log(`âš ï¸ 6/8æ‹æœ€ç»ˆå¡«å……ä¼‘æ­¢ç¬¦è¾¹ç•Œè°ƒæ•´ï¼š${absoluteFinalDifference}æ‹ -> ${safeRestBeats}æ‹ï¼ˆé¿å…è·¨è¶Šè¾¹ç•Œ${boundary}ï¼‰`);
                            break;
                        }
                    }
                }

                const emergencyRestDuration = this.beatsToRestDuration(safeRestBeats);
                notes.push({
                    type: 'rest',
                    duration: emergencyRestDuration,
                    beats: safeRestBeats
                });

                // å¦‚æœè°ƒæ•´åè¿˜æœ‰å‰©ä½™ï¼Œé€’å½’æ·»åŠ 
                const remainingAfterAdjustment = absoluteFinalDifference - safeRestBeats;
                if (remainingAfterAdjustment > 0.001) {
                    console.log(`é€’å½’æ·»åŠ å‰©ä½™å¡«å……: ${remainingAfterAdjustment}æ‹`);
                    const additionalRestDuration = this.beatsToRestDuration(remainingAfterAdjustment);
                    notes.push({
                        type: 'rest',
                        duration: additionalRestDuration,
                        beats: remainingAfterAdjustment
                    });
                }
            } else if (absoluteFinalDifference < -0.001) {
                // è¶…å‡ºäº†ï¼Œæˆªæ–­æœ€åçš„éŸ³ç¬¦
                console.log(`å°èŠ‚è¶…é•¿ï¼Œå°è¯•æˆªæ–­æœ€åçš„å…ƒç´ `);
                const excess = Math.abs(absoluteFinalDifference);
                if (notes.length > 0) {
                    const lastNote = notes[notes.length - 1];
                    if (lastNote.beats > excess) {
                        lastNote.beats -= excess;
                        console.log(`ç¼©çŸ­æœ€åå…ƒç´ æ—¶å€¼: ${lastNote.duration} ç°åœ¨ä¸º ${lastNote.beats}æ‹`);
                    } else {
                        notes.pop();
                        console.log(`ç§»é™¤æœ€åä¸€ä¸ªå…ƒç´ `);
                    }
                }
            }
        }
        
        // ç»å¯¹æœ€ç»ˆéªŒè¯
        const trueFinalBeats = notes.reduce((sum, note) => sum + note.beats, 0);
        console.log(`å°èŠ‚${measureIndex + 1}æœ€ç»ˆçŠ¶æ€: ${notes.length}ä¸ªå…ƒç´ , æ€»æ—¶é•¿${trueFinalBeats}æ‹ (æœŸæœ›${this.beatsPerMeasure}æ‹)`);
        
        if (Math.abs(trueFinalBeats - this.beatsPerMeasure) > 0.001) {
            console.error(`ğŸš¨ ä¸¥é‡é”™è¯¯: å°èŠ‚${measureIndex + 1}æ—¶å€¼ä»ä¸åŒ¹é…! å®é™…${trueFinalBeats}æ‹ vs æœŸæœ›${this.beatsPerMeasure}æ‹`);
        }
        
        // ğŸµ åº”ç”¨æ‹ç‚¹æ¸…æ™°åº¦è§„åˆ™ - æ‹†åˆ†è·¨æ‹éŸ³ç¬¦
        let correctedNotes = this.applybeatClarityRules(notes, measureIndex);

        // è‡ªå®šä¹‰æ‹å·ï¼šæŒ‰åˆ†ç»„è¾¹ç•Œè¿›è¡Œæ‹ç‚¹æ¸…æ™°åŒ–æ‹†åˆ†ï¼ˆä»…è‡ªå®šä¹‰åˆ†æ”¯ï¼‰
        correctedNotes = this.applyCustomGroupingBeatClarity(correctedNotes, measureIndex);
        correctedNotes = this.normalizeCustomTies(correctedNotes, measureIndex);
        correctedNotes = this.mergeCustomGroupingTiedNotes(correctedNotes, measureIndex);
        correctedNotes = this.normalizeCustomTies(correctedNotes, measureIndex);

        // è‡ªå®šä¹‰æ‹å·ï¼šæ ‡è®°å¼ºæ‹ä½ç½®ï¼ˆç”¨äºé‡éŸ³/èŠ‚å¥æ„ŸçŸ¥ï¼‰
        const customGrouping = getCustomBeatGrouping(this.timeSignature, measureIndex);
        if (customGrouping && Array.isArray(customGrouping.starts)) {
            const strongStarts = customGrouping.starts;
            let position = 0;
            correctedNotes.forEach(note => {
                const isStrong = strongStarts.some(start => Math.abs(position - start) < 0.001);
                note.isStrong = isStrong;
                position += note.beats;
            });
        }
        
        // è·å–å½“å‰æ‹ç‚¹æ˜¾ç¤ºå±‚çº§ï¼ˆç”¨äºç¬¦æ§“åˆ†ç»„ï¼‰
        const beamingTimeSignature = getBeamingReferenceTimeSignature(this.timeSignature || '4/4');
        const beamSignatureForGeneration = (!isBuiltInTimeSignature(this.timeSignature) && this.timeSignature)
            ? this.timeSignature
            : beamingTimeSignature;
        const criticalBeats = RHYTHM_NOTATION_RULES.getCriticalBeatsWithLocalRhythm(correctedNotes, beamingTimeSignature);
        let currentBeatLevel = null;
        if (beamingTimeSignature === '4/4') {
            if (criticalBeats.includes(1) && criticalBeats.includes(2) && criticalBeats.includes(3)) {
                currentBeatLevel = 'quarter';
            } else if (criticalBeats.includes(2)) {
                currentBeatLevel = 'half'; 
            } else if (criticalBeats.includes(0) && criticalBeats.length === 1) {
                currentBeatLevel = 'whole';
            }
        }
        console.log(`ğŸ¼ ç¬¦æ§“åˆ†ç»„æ‹ç‚¹å±‚çº§: ${currentBeatLevel}, å…³é”®æ‹ç‚¹: [${criticalBeats.join(', ')}]`);
        
        // ç”Ÿæˆbeamä¿¡æ¯
        console.log(`ğŸ” å³å°†è°ƒç”¨generateBeamsï¼Œä¼ å…¥${correctedNotes.length}ä¸ªéŸ³ç¬¦`);
        const beamGroups = this.generateBeams(correctedNotes, currentBeatLevel, beamSignatureForGeneration);
        console.log(`ğŸ” generateBeamsè¿”å›äº†${beamGroups.length}ä¸ªbeamç»„`);
        beamGroups.forEach((group, i) => {
            console.log(`  beamç»„${i+1}: start=${group.start}, end=${group.end}, notes=[${group.notes.join(',')}]`);
        });
        
        // æœ€ç»ˆå°èŠ‚éªŒè¯ - ç¡®ä¿ä¸è¿”å›ç©ºå°èŠ‚
        if (!notes || notes.length === 0) {
            console.error(`ğŸš¨ ä¸¥é‡é”™è¯¯: å°èŠ‚${measureIndex + 1}ç”Ÿæˆä¸ºç©ºï¼`);
            console.error(`ğŸ” ç©ºå°èŠ‚è°ƒè¯•ä¿¡æ¯:`);
            console.error(`  - åˆå§‹æ‹æ•°: ${this.beatsPerMeasure}`);
            console.error(`  - æœ€ç»ˆå‰©ä½™æ‹æ•°: ${remainingBeats}`);
            console.error(`  - å¾ªç¯å®‰å…¨è®¡æ•°å™¨: ${loopSafety}/${maxLoopIterations}`);
            console.error(`  - å…è®¸çš„æ—¶å€¼: ${this.rules.allowedDurations.join(', ')}`);
            console.error(`  - éŸ³åŸŸ: MIDI ${this.rules.range.min}-${this.rules.range.max}`);
            console.error(`  - æœ€å¤§éŸ³ç¨‹è·³åº¦: ${this.rules.maxJump}åŠéŸ³`);
            console.error(`ğŸš¨ å¼ºåˆ¶æ·»åŠ å…¨ä¼‘æ­¢ç¬¦ä»¥é¿å…ç©ºå°èŠ‚`);
            
            notes = [{
                type: 'rest',
                duration: 'whole',
                beats: this.beatsPerMeasure
            }];
        }
        
        console.log(`âœ… å°èŠ‚${measureIndex + 1}ç”Ÿæˆå®Œæˆï¼ŒåŒ…å«${correctedNotes.length}ä¸ªå…ƒç´ `);
        correctedNotes.forEach((note, i) => {
            console.log(`  [${i}] ${note.type}: ${note.duration} (${note.beats}æ‹)${note.midi ? ` MIDI:${note.midi}` : ''}`);
        });
        
        return {
            notes: correctedNotes,
            beams: beamGroups,
            directionChanges: measureDirectionChanges
        };
    }

    /**
     * åº”ç”¨æ‹ç‚¹æ¸…æ™°åº¦è§„åˆ™ - æ‹†åˆ†è·¨æ‹éŸ³ç¬¦å¹¶æ·»åŠ è¿éŸ³å¼§
     */
    applybeatClarityRules(notes, measureIndex) {
        console.log(`ğŸµ åº”ç”¨æ™ºèƒ½æ‹ç‚¹æ¸…æ™°åº¦è§„åˆ™ - å°èŠ‚${measureIndex + 1} (åŒ…æ‹¬ä¼‘æ­¢ç¬¦)`);
        console.log(`ğŸ¯ ä½¿ç”¨å±€éƒ¨èŠ‚å¥æ£€æµ‹: æ¯æ‹ç‹¬ç«‹åˆ†æèŠ‚å¥å¤æ‚åº¦`);
        
        // è°ƒè¯•ï¼šæ˜¾ç¤ºè¾“å…¥çš„éŸ³ç¬¦ä¿¡æ¯
        console.log(`ğŸ“‹ è¾“å…¥éŸ³ç¬¦æ¸…å• (${notes.length}ä¸ª):`);
        notes.forEach((note, i) => {
            console.log(`  [${i}] ${note.type}: ${note.duration} (${note.beats}æ‹)${note.isTriplet ? ' [ä¸‰è¿éŸ³]' : ''}${note.midi ? ` MIDI:${note.midi}` : ''}`);
        });
        
        // ğŸš¨ å®Œå…¨é‡å†™ï¼šä¸¥æ ¼æŒ‰ç…§åŒºé—´ç‹¬ç«‹è§„åˆ™å®ç°16åˆ†éŸ³ç¬¦æ£€æµ‹
        console.log(`ğŸ¼ [å®Œå…¨é‡å†™] å¼€å§‹ä¸¥æ ¼åŒºé—´ç‹¬ç«‹çš„16åˆ†éŸ³ç¬¦å¤„ç†`);
        
        // æ£€æŸ¥æ—¶é—´ç­¾åæ˜¯å¦é€‚ç”¨
        const supportedTimeSignatures = ['2/4', '3/4', '4/4'];
        let sixteenthRegionsProcessed = false;
        
        if (supportedTimeSignatures.includes(this.timeSignature)) {
            // ğŸ¯ æ­¥éª¤1ï¼šç²¾ç¡®åˆ†ææ¯ä¸ªåŒºé—´å†…æ˜¯å¦æœ‰16åˆ†éŸ³ç¬¦
            const regions = [
                { start: 0, end: 2, name: "å‰åŠæ‹åŒºé—´(0-2)", hasS16th: false, quarterBeats: [0, 1, 2] },
                { start: 2, end: 4, name: "ååŠæ‹åŒºé—´(2-4)", hasS16th: false, quarterBeats: [2, 3] }
            ];
            
            let currentPos = 0;
            for (const note of notes) {
                const noteEnd = currentPos + note.beats;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯16åˆ†éŸ³ç¬¦
                if (!note.isTriplet && Math.abs(note.beats - 0.25) < 0.001) {
                    console.log(`  ğŸ“ å‘ç°16åˆ†éŸ³ç¬¦: ä½ç½®${currentPos}-${noteEnd} (${note.beats}æ‹)`);
                    
                    // åˆ¤æ–­16åˆ†éŸ³ç¬¦å®Œå…¨ä½äºå“ªä¸ªåŒºé—´å†…
                    for (const region of regions) {
                        if (currentPos >= region.start && noteEnd <= region.end) {
                            if (!region.hasS16th) {
                                region.hasS16th = true;
                                console.log(`    âœ… ${region.name}ç¡®è®¤åŒ…å«16åˆ†éŸ³ç¬¦`);
                            }
                        }
                    }
                }
                currentPos += note.beats;
            }
            
            // ğŸ”¥ æ­¥éª¤2ï¼šå¯¹æ¯ä¸ªåŒ…å«16åˆ†éŸ³ç¬¦çš„åŒºé—´è¿›è¡Œç‹¬ç«‹å¤„ç†
            const regionsWithS16th = regions.filter(r => r.hasS16th);
            console.log(`ğŸ¯ æœ€ç»ˆåŒºé—´åˆ†æ: [${regionsWithS16th.map(r => r.name).join(', ')}]åŒ…å«16åˆ†éŸ³ç¬¦`);
            
            if (regionsWithS16th.length > 0) {
                console.log(`ğŸ¼ [ä¸¥æ ¼åŒºé—´æ‹†åˆ†] å¼€å§‹å¤„ç†åŒ…å«16åˆ†éŸ³ç¬¦çš„åŒºé—´`);
                sixteenthRegionsProcessed = true;
                
                let processPos = 0;
                const processedNotes = [];
                
                for (const note of notes) {
                    const noteEnd = Math.round((processPos + note.beats) * 10000) / 10000;
                    const startPos = Math.round(processPos * 10000) / 10000;
                    
                    console.log(`ğŸ” å¤„ç†éŸ³ç¬¦: ä½ç½®${startPos}-${noteEnd}, æ—¶é•¿${note.beats}æ‹, ç±»å‹=${note.type}`);
                    
                    // ğŸ”¥ æ ¸å¿ƒé€»è¾‘ï¼šæ£€æŸ¥éŸ³ç¬¦æ˜¯å¦è·¨è¶ŠåŒ…å«16åˆ†éŸ³ç¬¦åŒºé—´çš„è¾¹ç•Œ
                    let splitPoints = [];
                    
                    if (note.beats > 0.25 && !note.isTriplet) {
                        // æ£€æŸ¥æ‰€æœ‰åŒ…å«16åˆ†éŸ³ç¬¦çš„åŒºé—´çš„å››åˆ†éŸ³ç¬¦æ‹ç‚¹
                        for (const region of regionsWithS16th) {
                            for (const beat of region.quarterBeats) {
                                // ä¸¥æ ¼è·¨æ‹æ£€æµ‹
                                if (startPos < beat && noteEnd > beat) {
                                    if (!splitPoints.includes(beat)) {
                                        splitPoints.push(beat);
                                        console.log(`  âœ‚ï¸ å¿…é¡»æ‹†åˆ†ç‚¹${beat}: è·¨è¶Š${region.name}çš„å››åˆ†éŸ³ç¬¦æ‹ç‚¹`);
                                    }
                                }
                            }
                        }
                    }
                    
                    // æ‰§è¡Œæ‹†åˆ†
                    if (splitPoints.length > 0) {
                        splitPoints.sort((a, b) => a - b);
                        const splitNotes = this.splitNoteAtMultiplePoints(note, processPos, splitPoints);
                        processedNotes.push(...splitNotes);
                        console.log(`  â†’ æ‹†åˆ†å®Œæˆ: 1ä¸ªéŸ³ç¬¦ â†’ ${splitNotes.length}ä¸ªç‰‡æ®µ`);
                    } else {
                        processedNotes.push(note);
                        console.log(`  â†’ éŸ³ç¬¦æ— éœ€æ‹†åˆ†`);
                    }
                    
                    processPos += note.beats;
                }
                
                notes = processedNotes;
                console.log(`ğŸ¼ [ä¸¥æ ¼åŒºé—´æ‹†åˆ†] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length}`);
            } else {
                console.log(`ğŸµ æ— 16åˆ†éŸ³ç¬¦åŒºé—´ï¼Œç»§ç»­ä½¿ç”¨åŸæœ‰é€»è¾‘`);
            }
        } else {
            console.log(`âš ï¸ æ—¶é—´ç­¾å${this.timeSignature}ä¸æ”¯æŒ16åˆ†éŸ³ç¬¦åŒºé—´æ£€æµ‹`);
        }
        
        // ğŸµ ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™ - å°†æ­£æ‹å†…çš„è¿ç»­ä¼‘æ­¢ç¬¦åˆå¹¶
        notes = this.mergeRestsByBeats(notes);

        // ğŸµ å››åˆ†éŸ³ç¬¦æ‹ç‚¹å†…ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™
        notes = this.mergeAdjacentRestsInQuarterBeats(notes);

        // ğŸµ äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å†…ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™
        notes = this.mergeAdjacentRestsInHalfBeats(notes);
        
        // è°ƒè¯•ï¼šæ˜¾ç¤ºå…³é”®æ‹ç‚¹ä¿¡æ¯
        const criticalBeats = RHYTHM_NOTATION_RULES.getCriticalBeatsWithLocalRhythm(notes, this.timeSignature);
        console.log(`ğŸ¯ å…³é”®æ‹ç‚¹: [${criticalBeats.join(', ')}]`);
        
        // ç‰¹åˆ«æ£€æŸ¥å¸¸è§é—®é¢˜ï¼šå››åˆ†éŸ³ç¬¦è·¨è¶ŠäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
        console.log(`ğŸ” å¸¸è§é—®é¢˜æ£€æŸ¥ï¼š`);
        let pos = 0;
        notes.forEach((note, i) => {
            if (note.type === 'note' && note.beats === 1 && !note.isTriplet) { // å››åˆ†éŸ³ç¬¦
                const noteEnd = pos + note.beats;
                const crossesBeat2 = pos < 2 && noteEnd > 2; // è·¨è¶Šç¬¬3æ‹(ä½ç½®2)
                if (crossesBeat2) {
                    console.log(`  âš ï¸ å››åˆ†éŸ³ç¬¦${i + 1}è·¨è¶ŠäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹: ä½ç½®${pos} â†’ ${noteEnd} (è·¨è¶Šæ‹ç‚¹2)`);
                }
            }
            pos += note.beats;
        });
        
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†äº†16åˆ†éŸ³ç¬¦åŒºé—´
        if (sixteenthRegionsProcessed) {
            console.log(`ğŸ”„ 16åˆ†éŸ³ç¬¦åŒºé—´å·²å®Œå…¨å¤„ç†ï¼Œç›´æ¥è¿”å›ç»“æœ`);
            // 16åˆ†éŸ³ç¬¦åŒºé—´å¤„ç†å®Œæˆï¼Œç›´æ¥è¿›å…¥æœ€åéªŒè¯é˜¶æ®µ
            let finalNotes = [...notes];
            let maxAttempts = 5;
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                const validation = RHYTHM_NOTATION_RULES.validateBeatClarity(finalNotes, this.timeSignature);
                if (validation.valid) {
                    console.log(`âœ… æ‹ç‚¹æ¸…æ™°åº¦éªŒè¯é€šè¿‡ - æ‰€æœ‰è·¨æ‹éŸ³ç¬¦å·²æ­£ç¡®æ‹†åˆ†`);
                    break;
                }
                
                attempts++;
                console.log(`âš ï¸ ç¬¬${attempts}æ¬¡ä¿®å¤è·¨æ‹é—®é¢˜ï¼Œå‘ç°${validation.violations.length}ä¸ªè¿è§„`);
                // å¦‚æœä»æœ‰é—®é¢˜ï¼Œè¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„ä¿®å¤é€»è¾‘
                break; // æš‚æ—¶ç›´æ¥é€€å‡ºï¼Œé¿å…æ— é™å¾ªç¯
            }
            
            console.log(`âœ… 16åˆ†éŸ³ç¬¦åŒºé—´å¤„ç†å®Œæˆï¼Œè¿”å›${finalNotes.length}ä¸ªå…ƒç´ `);
            return finalNotes;
        }
        
        console.log(`ğŸ”„ æ‰§è¡Œæ­£å¸¸çš„äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æµ‹é€»è¾‘`);
        const correctedNotes = [];
        let currentPosition = 0;
        
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            
            // æ£€æŸ¥æ˜¯å¦è·¨æ‹ï¼ˆéŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦éƒ½éœ€è¦æ£€æŸ¥ï¼‰ - ä½¿ç”¨æ™ºèƒ½å±€éƒ¨èŠ‚å¥æ£€æµ‹
            const crossInfo = RHYTHM_NOTATION_RULES.detectsCrossBeatsWithLocalRhythm(
                currentPosition, 
                note.beats, 
                this.timeSignature,
                notes,  // ä¼ å…¥æ‰€æœ‰éŸ³ç¬¦è¿›è¡Œå±€éƒ¨åˆ†æ
                note.type  // ä¼ å…¥éŸ³ç¬¦ç±»å‹ï¼ˆ'note' æˆ– 'rest'ï¼‰
            );
            
            console.log(`ğŸ” æ£€æŸ¥éŸ³ç¬¦${i + 1}: ä½ç½®${currentPosition} æ—¶é•¿${note.beats} â†’ ${crossInfo.crossesBeat ? `è·¨è¶Šæ‹ç‚¹${crossInfo.beatPoint}` : 'ä¸è·¨æ‹'}`);
            
            if (!crossInfo.crossesBeat) {
                // ä¸è·¨æ‹ï¼Œç›´æ¥æ·»åŠ 
                correctedNotes.push(note);
                currentPosition += note.beats;
                console.log(`  ${note.type === 'note' ? 'éŸ³ç¬¦' : 'ä¼‘æ­¢ç¬¦'}${i + 1}: ${note.beats}æ‹ - ä¸è·¨æ‹ âœ…`);
                continue;
            }
            
            // ä¸‰è¿éŸ³ä¸èƒ½è¢«ç»†åˆ†ï¼Œå³ä½¿è·¨æ‹ä¹Ÿè¦ä¿æŒå®Œæ•´
            if (note.isTriplet) {
                correctedNotes.push(note);
                currentPosition += note.beats;
                console.log(`  ä¸‰è¿éŸ³${i + 1}: ${note.beats}æ‹ - è·¨æ‹ä½†ä¸æ‹†åˆ† ğŸµ`);
                continue;
            }
            
            // è·¨æ‹ï¼Œéœ€è¦æ‹†åˆ†
            console.log(`  ${note.type === 'note' ? 'éŸ³ç¬¦' : 'ä¼‘æ­¢ç¬¦'}${i + 1}: ${note.beats}æ‹ - è·¨è¶Šæ‹ç‚¹${crossInfo.beatPoint + 1} âš ï¸`);
            
            if (note.type === 'note') {
                // éŸ³ç¬¦æ‹†åˆ† - ä½¿ç”¨æ™ºèƒ½å±€éƒ¨èŠ‚å¥åˆ†æ
                const splitNotes = RHYTHM_NOTATION_RULES.splitCrossBeatNoteWithLocalRhythm(
                    currentPosition,
                    note.beats,
                    note.midi,
                    this.timeSignature,
                    notes  // ä¼ å…¥æ‰€æœ‰éŸ³ç¬¦è¿›è¡Œå±€éƒ¨åˆ†æ
                );
                
                // å°†æ‹†åˆ†çš„éŸ³ç¬¦æ·»åŠ åˆ°ç»“æœä¸­
                splitNotes.forEach((splitNote, splitIndex) => {
                    const correctedNote = {
                        type: 'note',
                        duration: this.beatsToNoteDuration(splitNote.duration),
                        beats: splitNote.duration,
                        step: note.step,
                        octave: note.octave,
                        alter: note.alter,
                        midi: splitNote.pitch
                    };
                    
                    // æ·»åŠ è¿éŸ³å¼§ä¿¡æ¯
                    if (splitNote.tied) {
                        correctedNote.tied = true;
                        correctedNote.tieType = splitNote.tieType;
                    }
                    
                    correctedNotes.push(correctedNote);
                    console.log(`    æ‹†åˆ†${splitIndex + 1}: ${splitNote.duration}æ‹ (tie: ${splitNote.tieType || 'none'})`);
                });
            } else if (note.type === 'rest') {
                // ä¼‘æ­¢ç¬¦æ‹†åˆ† - åœ¨æ‹ç‚¹å¤„åˆ†å‰²
                const splitPosition = crossInfo.splitPositions[0];
                const firstDuration = splitPosition - currentPosition;
                const secondDuration = note.beats - firstDuration;
                
                // ç¬¬ä¸€ä¸ªä¼‘æ­¢ç¬¦æ®µ
                const firstRest = {
                    type: 'rest',
                    duration: this.beatsToRestDuration(firstDuration),
                    beats: firstDuration
                };
                
                // ç¬¬äºŒä¸ªä¼‘æ­¢ç¬¦æ®µ
                const secondRest = {
                    type: 'rest', 
                    duration: this.beatsToRestDuration(secondDuration),
                    beats: secondDuration
                };
                
                correctedNotes.push(firstRest);
                correctedNotes.push(secondRest);
                console.log(`    æ‹†åˆ†ä¼‘æ­¢ç¬¦: ${firstDuration}æ‹ + ${secondDuration}æ‹`);
            }
            
            currentPosition += note.beats;
        }
        
        console.log(`âœ… æ‹ç‚¹è§„åˆ™å¤„ç†å®Œæˆ: ${notes.length} -> ${correctedNotes.length} ä¸ªå…ƒç´ `);
        
        // é€’å½’éªŒè¯å¹¶ä¿®å¤ä»»ä½•å‰©ä½™çš„è·¨æ‹é—®é¢˜
        let finalNotes = correctedNotes;
        let maxAttempts = 5; // é˜²æ­¢æ— é™å¾ªç¯
        let attempts = 0;
        
        while (attempts < maxAttempts) {
            const validation = RHYTHM_NOTATION_RULES.validateBeatClarity(finalNotes, this.timeSignature);
            if (validation.valid) {
                console.log(`âœ… æ‹ç‚¹æ¸…æ™°åº¦éªŒè¯é€šè¿‡ - æ‰€æœ‰è·¨æ‹éŸ³ç¬¦å·²æ­£ç¡®æ‹†åˆ†`);
                break;
            }
            
            attempts++;
            console.log(`âš ï¸ ç¬¬${attempts}æ¬¡ä¿®å¤è·¨æ‹é—®é¢˜ï¼Œå‘ç°${validation.violations.length}ä¸ªè¿è§„`);
            
            // ä¿®å¤è·¨æ‹é—®é¢˜
            const repairedNotes = [];
            let currentPos = 0;
            
            for (let i = 0; i < finalNotes.length; i++) {
                const note = finalNotes[i];
                const violation = validation.violations.find(v => v.noteIndex === i);
                
                if (violation && !note.isTriplet) {
                    console.log(`  ğŸ”§ ä¿®å¤éŸ³ç¬¦${i + 1}: ä½ç½®${currentPos} è·¨è¶Šæ‹ç‚¹${violation.crossedBeat}`);
                    
                    // åœ¨è¿è§„æ‹ç‚¹å¤„æ‹†åˆ†
                    const splitPosition = violation.crossedBeat;
                    const firstDuration = splitPosition - currentPos;
                    const secondDuration = note.beats - firstDuration;
                    
                    if (note.type === 'note') {
                        // æ‹†åˆ†éŸ³ç¬¦
                        const firstNote = {
                            type: 'note',
                            duration: this.beatsToNoteDuration(firstDuration),
                            beats: firstDuration,
                            step: note.step,
                            octave: note.octave,
                            alter: note.alter,
                            midi: note.midi,
                            tied: true,
                            tieType: 'start'
                        };
                        
                        const secondNote = {
                            type: 'note',
                            duration: this.beatsToNoteDuration(secondDuration),
                            beats: secondDuration,
                            step: note.step,
                            octave: note.octave,
                            alter: note.alter,
                            midi: note.midi,
                            tied: true,
                            tieType: 'stop'
                        };
                        
                        repairedNotes.push(firstNote, secondNote);
                        console.log(`    æ‹†åˆ†éŸ³ç¬¦: ${firstDuration}æ‹ + ${secondDuration}æ‹`);
                    } else {
                        // æ‹†åˆ†ä¼‘æ­¢ç¬¦
                        const firstRest = {
                            type: 'rest',
                            duration: this.beatsToRestDuration(firstDuration),
                            beats: firstDuration
                        };
                        
                        const secondRest = {
                            type: 'rest',
                            duration: this.beatsToRestDuration(secondDuration),
                            beats: secondDuration
                        };
                        
                        repairedNotes.push(firstRest, secondRest);
                        console.log(`    æ‹†åˆ†ä¼‘æ­¢ç¬¦: ${firstDuration}æ‹ + ${secondDuration}æ‹`);
                    }
                } else {
                    // æ²¡æœ‰è¿è§„ï¼Œç›´æ¥æ·»åŠ 
                    repairedNotes.push(note);
                }
                
                currentPos += note.beats;
            }
            
            finalNotes = repairedNotes;
            
            if (attempts >= maxAttempts) {
                console.error(`âŒ è¾¾åˆ°æœ€å¤§ä¿®å¤å°è¯•æ¬¡æ•°ï¼Œä»æœ‰è·¨æ‹é—®é¢˜å­˜åœ¨`);
                break;
            }
        }
        
        // æ›´æ–°correctedNotesä¸ºä¿®å¤åçš„ç‰ˆæœ¬
        correctedNotes.splice(0, correctedNotes.length, ...finalNotes);
        
        // é¢å¤–éªŒè¯ï¼šæ£€æŸ¥æ‰€æœ‰tiedéŸ³ç¬¦æ˜¯å¦æ­£ç¡®é…å¯¹ä¸”ç›¸é‚»
        const tiedNotes = correctedNotes.filter(n => n.type === 'note' && n.tied);
        const startTies = tiedNotes.filter(n => n.tieType === 'start');
        const stopTies = tiedNotes.filter(n => n.tieType === 'stop');
        
        // éªŒè¯tieåªè¿æ¥ç›¸é‚»çš„åŒéŸ³é«˜éŸ³ç¬¦
        for (let i = 0; i < correctedNotes.length; i++) {
            const currentNote = correctedNotes[i];
            
            // æ£€æŸ¥å°èŠ‚æœ€åä¸€ä¸ªéŸ³ç¬¦æ˜¯å¦æœ‰æœªå®Œæˆçš„tie
            if (i === correctedNotes.length - 1 && currentNote.type === 'note' && 
                currentNote.tied && currentNote.tieType === 'start') {
                console.warn(`âš ï¸ å°èŠ‚æœ«å°¾çš„tieæœªå®Œæˆï¼Œç§»é™¤tieæ ‡è®°`);
                currentNote.tied = false;
                currentNote.tieType = null;
            }
            
            // æ£€æŸ¥tieæ˜¯å¦è¿æ¥æ­£ç¡®çš„éŸ³ç¬¦
            if (i < correctedNotes.length - 1 && currentNote.type === 'note' && 
                currentNote.tied && currentNote.tieType === 'start') {
                const nextNote = correctedNotes[i + 1];
                // tieçš„ä¸‹ä¸€ä¸ªéŸ³ç¬¦å¿…é¡»æ˜¯ç›¸é‚»çš„åŒéŸ³é«˜éŸ³ç¬¦
                if (!nextNote || nextNote.type !== 'note' || !nextNote.tied || 
                    nextNote.midi !== currentNote.midi) {
                    console.error(`âŒ æ— æ•ˆçš„tie: ç´¢å¼•${i}çš„éŸ³ç¬¦å°è¯•è¿æ¥éç›¸é‚»æˆ–ä¸åŒéŸ³é«˜çš„éŸ³ç¬¦`);
                    // ä¿®å¤ï¼šç§»é™¤æ— æ•ˆçš„tie
                    currentNote.tied = false;
                    currentNote.tieType = null;
                }
            }
        }
        
        if (startTies.length !== stopTies.length) {
            console.error(`âŒ Tieé…å¯¹é”™è¯¯: ${startTies.length}ä¸ªstartï¼Œ${stopTies.length}ä¸ªstop`);
        } else if (tiedNotes.length > 0) {
            console.log(`âœ… TieéªŒè¯é€šè¿‡: ${startTies.length}å¯¹è¿éŸ³å¼§æ­£ç¡®é…å¯¹`);
        }
        
        // åº”ç”¨è¿éŸ³ç¬¦åˆå¹¶è§„åˆ™ï¼ˆä¼˜å…ˆçº§1ï¼šå…ˆæ‰§è¡Œåˆå¹¶ï¼‰
        // ğŸ”¥ ä¼ å…¥å…³é”®æ‹ç‚¹ä¿¡æ¯ï¼Œé˜²æ­¢åœ¨å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹é”™è¯¯åˆå¹¶å››åˆ†éŸ³ç¬¦
        const mergedNotes = this.mergeTiedNotes(correctedNotes, measureIndex, criticalBeats);
        
        return mergedNotes;
    }

    /**
     * è‡ªå®šä¹‰æ‹å·ï¼šæŒ‰åˆ†ç»„è¾¹ç•Œæ‹†åˆ†è·¨ç»„éŸ³ç¬¦ï¼ˆä½¿ç”¨ tie è¿æ¥ï¼‰
     * simple: 2ä¸ªåˆ†æ¯å•ä½ä¸ºä¸€ç»„
     * compound: 3ä¸ªåˆ†æ¯å•ä½ä¸ºä¸€ç»„
     */
    applyCustomGroupingBeatClarity(notes, measureIndex) {
        if (!this.timeSignature || isBuiltInTimeSignature(this.timeSignature)) {
            return notes;
        }

        const parsed = parseTimeSignatureString(this.timeSignature);
        if (!parsed) return notes;

        const unit = 4 / parsed.beatType; // åˆ†æ¯å•ä½å¯¹åº”çš„æ‹å€¼ï¼ˆä»¥å››åˆ†éŸ³ç¬¦ä¸º1æ‹ï¼‰
        if (!unit || !Number.isFinite(unit)) return notes;

        const isCompound = isCompoundTimeSignature(this.timeSignature);
        const groupSize = unit * (isCompound ? 3 : 1);
        if (!groupSize || !Number.isFinite(groupSize)) return notes;

        const measureLength = parsed.beats * unit;
        const boundaries = [];
        for (let pos = groupSize; pos < measureLength - 0.0001; pos += groupSize) {
            boundaries.push(Math.round(pos * 10000) / 10000);
        }

        if (boundaries.length === 0) return notes;

        console.log(`ğŸ¼ è‡ªå®šä¹‰æ‹å·æ‹ç‚¹æ¸…æ™°åŒ–: ${this.timeSignature} ${isCompound ? 'compound' : 'simple'}, åˆ†ç»„å¤§å°=${groupSize}æ‹, è¾¹ç•Œ=[${boundaries.join(', ')}]`);

        const corrected = [];
        let currentPos = 0;
        const tolerance = 0.0001;

        for (const note of notes) {
            const noteEnd = currentPos + note.beats;
            if (note.type !== 'note' || note.isTriplet) {
                corrected.push(note);
                currentPos = noteEnd;
                continue;
            }

            const splitPoints = boundaries.filter(b => b > currentPos + tolerance && b < noteEnd - tolerance);
            if (splitPoints.length === 0) {
                corrected.push(note);
                currentPos = noteEnd;
                continue;
            }

            const segments = this.splitNoteAtMultiplePoints(note, currentPos, splitPoints);
            segments.forEach(segment => {
                // ä¼‘æ­¢ç¬¦ä¸å…è®¸ tieï¼ˆè¿™é‡Œåªå¤„ç†éŸ³ç¬¦ï¼‰
                if (segment.type === 'note') {
                    segment.tied = true;
                }
                corrected.push(segment);
            });
            console.log(`  ğŸ”ª æ‹†åˆ†è·¨ç»„éŸ³ç¬¦: ${note.duration}(${note.beats}æ‹) -> ${segments.length}æ®µ (ä½ç½®${currentPos}-${noteEnd})`);
            currentPos = noteEnd;
        }

        return corrected;
    }

    /**
     * è‡ªå®šä¹‰æ‹å·ï¼šè§„èŒƒåŒ–tieé“¾ï¼Œç¡®ä¿ç›¸é‚»åŒéŸ³ç¬¦æ®µå½¢æˆæœ‰æ•ˆé“¾æ¡
     */
    normalizeCustomTies(notes, measureIndex) {
        if (!this.timeSignature || isBuiltInTimeSignature(this.timeSignature)) {
            return notes;
        }

        const normalized = [...notes];
        let i = 0;
        let cleanedSingles = 0;

        while (i < normalized.length) {
            const current = normalized[i];
            if (!current || current.type !== 'note' || (!current.tied && !current.tieType)) {
                i++;
                continue;
            }

            if (current.midi === undefined || current.midi === null) {
                current.tied = false;
                current.tieType = null;
                cleanedSingles++;
                i++;
                continue;
            }

            const group = [current];
            let j = i + 1;
            while (j < normalized.length) {
                const next = normalized[j];
                if (!next || next.type !== 'note') break;
                if (next.midi !== current.midi) break;
                if (!next.tied && !next.tieType) break;
                group.push(next);
                j++;
            }

            if (group.length > 1) {
                this.ensureTiedChain(group);
            } else {
                current.tied = false;
                current.tieType = null;
                cleanedSingles++;
            }

            i = j;
        }

        if (cleanedSingles > 0) {
            console.log(`ğŸ§¹ è‡ªå®šä¹‰æ‹å·tieè§„èŒƒåŒ–: æ¸…ç†${cleanedSingles}ä¸ªå­¤ç«‹tie`);
        }

        return normalized;
    }

    /**
     * è‡ªå®šä¹‰æ‹å·ï¼šåˆå¹¶åˆ†ç»„å†…çš„è¿éŸ³ç¬¦æ®µï¼Œé¿å…æ— æ„ä¹‰æ‹†åˆ†
     * ä»…åœ¨ä¸è·¨è¶Šåˆ†ç»„è¾¹ç•Œä¸”ä¸å½±å“æ‹ç‚¹å¯è¯»æ€§æ—¶åˆå¹¶
     */
    mergeCustomGroupingTiedNotes(notes, measureIndex) {
        if (!this.timeSignature || isBuiltInTimeSignature(this.timeSignature)) {
            return notes;
        }

        const grouping = getCustomBeatGrouping(this.timeSignature, measureIndex);
        if (!grouping || !Array.isArray(grouping.starts)) {
            return notes;
        }

        const boundaries = grouping.starts
            .slice(1)
            .map(pos => Math.round(pos * 10000) / 10000);
        const totalBeats = grouping.totalBeats;
        const tolerance = 0.0001;
        const merged = [];
        let i = 0;
        let currentPos = 0;

        const isStandardDuration = (beats, duration) => {
            const expected = this.durationToBeats(duration);
            return Math.abs(beats - expected) < 0.01;
        };

        const isWithinSingleGroup = (startPos, endPos) => {
            if (boundaries.length === 0) return true;
            return !boundaries.some(boundary => boundary > startPos + tolerance && boundary < endPos - tolerance);
        };

        const mergeSegmentsWithinGroup = (segments) => {
            const output = [];
            let idx = 0;
            while (idx < segments.length) {
                let sum = 0;
                let bestEnd = null;
                let bestDuration = null;

                for (let end = idx; end < segments.length; end++) {
                    sum += segments[end].beats;
                    if (sum > totalBeats + tolerance) break;
                    const duration = this.beatsToNoteDuration(sum);
                    if (end > idx && duration && isStandardDuration(sum, duration)) {
                        if (this.rules.allowedDurations.includes(duration)) {
                            bestEnd = end;
                            bestDuration = duration;
                        }
                    }
                }

                if (bestEnd !== null && bestDuration) {
                    const mergedNote = {
                        ...segments[idx],
                        duration: bestDuration,
                        beats: segments.slice(idx, bestEnd + 1).reduce((acc, seg) => acc + seg.beats, 0),
                        tied: true,
                        tieType: null
                    };
                    output.push(mergedNote);
                    idx = bestEnd + 1;
                    continue;
                }

                output.push(segments[idx]);
                idx += 1;
            }
            return output;
        };

        while (i < notes.length) {
            const current = notes[i];

            if (!current || current.type !== 'note' || !current.tied || current.tieType !== 'start') {
                merged.push(current);
                currentPos += current ? current.beats : 0;
                i += 1;
                continue;
            }

            const chain = [current];
            let j = i + 1;
            while (j < notes.length) {
                const next = notes[j];
                if (!next || next.type !== 'note') break;
                if (!next.tied && !next.tieType) break;
                if (next.midi !== current.midi) break;
                chain.push(next);
                if (next.tieType === 'stop') {
                    j += 1;
                    break;
                }
                j += 1;
            }

            const chainStartPos = currentPos;
            const chainEndPos = chainStartPos + chain.reduce((acc, seg) => acc + seg.beats, 0);

            if (chain.length < 2) {
                merged.push(current);
                currentPos += current.beats;
                i += 1;
                continue;
            }

            if (!isWithinSingleGroup(chainStartPos, chainEndPos)) {
                // æŒ‰åˆ†ç»„è¾¹ç•Œæ‹†å¼€å¤„ç†
                let segmentPos = chainStartPos;
                let buffer = [];

                const flushBuffer = () => {
                    if (buffer.length === 0) return;
                    const mergedBuffer = mergeSegmentsWithinGroup(buffer);
                    mergedBuffer.forEach(note => merged.push(note));
                    buffer = [];
                };

                for (const segment of chain) {
                    const segmentEnd = segmentPos + segment.beats;
                    const crossesBoundary = boundaries.some(boundary =>
                        boundary > segmentPos + tolerance && boundary < segmentEnd - tolerance
                    );

                    if (crossesBoundary) {
                        flushBuffer();
                        merged.push(segment);
                        segmentPos = segmentEnd;
                        continue;
                    }

                    buffer.push(segment);

                    const hitsBoundary = boundaries.some(boundary => Math.abs(segmentEnd - boundary) < tolerance);
                    if (hitsBoundary) {
                        flushBuffer();
                    }
                    segmentPos = segmentEnd;
                }

                flushBuffer();
            } else {
                const mergedChain = mergeSegmentsWithinGroup(chain);
                mergedChain.forEach(note => merged.push(note));
            }

            currentPos = chainEndPos;
            i += chain.length;
        }

        return merged;
    }

    /**
     * è®¡ç®—éŸ³ç¬¦åœ¨å°èŠ‚ä¸­çš„ä½ç½®
     */
    calculateNotePosition(notes, targetNote) {
        let position = 0;
        for (const note of notes) {
            if (note === targetNote) {
                return position;
            }
            position += note.beats;
        }
        return position;
    }

    /**
     * åœ¨å¤šä¸ªæ‹ç‚¹å¤„æ‹†åˆ†éŸ³ç¬¦
     */
    splitNoteAtMultiplePoints(note, startPos, splitPoints) {
        if (splitPoints.length === 0) {
            return [note];
        }
        
        console.log(`    ğŸ”ª æ‰§è¡Œç»ˆææ‹†åˆ†: ${note.beats}æ‹${note.type}ï¼Œåœ¨[${splitPoints.join(', ')}]å¤„æ‹†åˆ†`);
        
        const segments = [];
        let currentStart = startPos;
        
        // æŒ‰æ‹†åˆ†ç‚¹é¡ºåºæ‹†åˆ†
        for (let i = 0; i < splitPoints.length; i++) {
            const splitAt = splitPoints[i];
            const segmentDuration = splitAt - currentStart;
            
            if (segmentDuration > 0.001) { // é¿å…é›¶é•¿åº¦ç‰‡æ®µ
                const segment = {
                    ...note,
                    duration: note.type === 'note' ? this.beatsToNoteDuration(segmentDuration) : this.beatsToRestDuration(segmentDuration),
                    beats: segmentDuration,
                    tied: note.type === 'note', // åªæœ‰éŸ³ç¬¦éœ€è¦è¿çº¿
                    tieType: i === 0 ? 'start' : 'continue'
                };
                
                // ğŸ”¥ ç¡®ä¿è¿çº¿ä¿¡æ¯æ­£ç¡®
                if (note.type === 'note') {
                    segment.tied = true;
                }
                
                segments.push(segment);
                console.log(`    âœ… ç‰‡æ®µ${i + 1}: ${segmentDuration}æ‹ (${segment.tieType}) - ${segment.duration}`);
            }
            
            currentStart = splitAt;
        }
        
        // æ·»åŠ æœ€åä¸€ä¸ªç‰‡æ®µ
        const finalDuration = (startPos + note.beats) - currentStart;
        if (finalDuration > 0.001) {
            const finalSegment = {
                ...note,
                duration: note.type === 'note' ? this.beatsToNoteDuration(finalDuration) : this.beatsToRestDuration(finalDuration),
                beats: finalDuration,
                tied: note.type === 'note',
                tieType: 'stop'
            };
            
            // ğŸ”¥ ç¡®ä¿è¿çº¿ä¿¡æ¯æ­£ç¡®
            if (note.type === 'note') {
                finalSegment.tied = true;
            }
            
            segments.push(finalSegment);
            console.log(`    âœ… æœ€åç‰‡æ®µ: ${finalDuration}æ‹ (${finalSegment.tieType}) - ${finalSegment.duration}`);
        }
        
        console.log(`    ğŸ¯ æ‹†åˆ†å®Œæˆ: åŸ1ä¸ªéŸ³ç¬¦ â†’ ${segments.length}ä¸ªç‰‡æ®µ`);
        return segments;
    }

    /**
     * ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™ - å°†æ­£æ‹å†…çš„è¿ç»­ä¼‘æ­¢ç¬¦åˆå¹¶ä¸ºä¸€ä¸ªè¯¥æ‹æ—¶å€¼çš„ä¼‘æ­¢ç¬¦
     */
    mergeRestsByBeats(notes) {
        console.log(`ğŸµ [ä¼‘æ­¢ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†ï¼ŒåŸå§‹éŸ³ç¬¦æ•°é‡: ${notes.length}`);
        
        if (this.timeSignature === '3/4') {
            return this.mergeRestsByBeatsFor3_4(notes);
        } else if (this.timeSignature !== '4/4') {
            console.log(`ğŸµ [ä¼‘æ­¢ç¬¦åˆå¹¶] ä»…æ”¯æŒ4/4æ‹å’Œ3/4æ‹ï¼Œè·³è¿‡å¤„ç†`);
            return notes;
        }
        
        const finestRhythm = Math.min(...notes.map(n => n.beats));
        const hasSixteenth = finestRhythm <= 0.25 + 0.0001;
        // å®šä¹‰æ­£æ‹åŒºé—´ï¼ˆ4/4æ‹ï¼‰
        const beatRegions = [
            { start: 0, end: 1, duration: 1, name: 'ç¬¬1æ‹' },    // ç¬¬1æ‹ï¼šå››åˆ†æ‹
            { start: 1, end: 2, duration: 1, name: 'ç¬¬2æ‹' },    // ç¬¬2æ‹ï¼šå››åˆ†æ‹ 
            { start: 2, end: 3, duration: 1, name: 'ç¬¬3æ‹' },    // ç¬¬3æ‹ï¼šå››åˆ†æ‹
            { start: 3, end: 4, duration: 1, name: 'ç¬¬4æ‹' },    // ç¬¬4æ‹ï¼šå››åˆ†æ‹
            // æ³¨ï¼šå…ˆå¤„ç†å°åŒºé—´ï¼Œå†å¤„ç†å¤§åŒºé—´
        ];
        if (!hasSixteenth) {
            // åªæœ‰åœ¨æ²¡æœ‰16åˆ†éŸ³ç¬¦æ—¶ï¼Œå…è®¸åˆå¹¶åˆ°äºŒåˆ†æ‹åŒºé—´ï¼Œé¿å…æ‹ç‚¹æ¨¡ç³Š
            beatRegions.push(
                { start: 0, end: 2, duration: 2, name: 'å‰åŠå°èŠ‚' },
                { start: 2, end: 4, duration: 2, name: 'ååŠå°èŠ‚' }
            );
        } else {
            console.log(`ğŸµ [ä¼‘æ­¢ç¬¦åˆå¹¶] æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦ï¼Œè·³è¿‡äºŒåˆ†æ‹åŒºé—´åˆå¹¶`);
        }
        
        let mergedNotes = [...notes];
        let hasChanges = true;
        let iterations = 0;
        const maxIterations = 10;
        
        while (hasChanges && iterations < maxIterations) {
            hasChanges = false;
            iterations++;
            
            console.log(`ğŸµ [ä¼‘æ­¢ç¬¦åˆå¹¶] ç¬¬${iterations}æ¬¡è¿­ä»£`);
            
            for (const region of beatRegions) {
                let currentPos = 0;
                const regionNotes = [];
                let regionStart = -1;
                let regionEnd = -1;
                
                // æ”¶é›†è¯¥åŒºé—´å†…çš„éŸ³ç¬¦
                for (let i = 0; i < mergedNotes.length; i++) {
                    const note = mergedNotes[i];
                    const noteEnd = currentPos + note.beats;
                    
                    // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦åœ¨å½“å‰åŒºé—´å†…
                    if (currentPos >= region.start && noteEnd <= region.end + 0.001) {
                        if (regionStart === -1) regionStart = i;
                        regionEnd = i;
                        regionNotes.push({ note, index: i, startPos: currentPos });
                    }
                    
                    currentPos += note.beats;
                }
                
                // æ£€æŸ¥åŒºé—´æ˜¯å¦å…¨éƒ¨æ˜¯ä¼‘æ­¢ç¬¦ï¼Œä¸”æ—¶å€¼æ€»å’Œç­‰äºè¯¥æ­£æ‹æ—¶å€¼
                if (regionNotes.length > 1) {
                    const allRests = regionNotes.every(item => item.note.type === 'rest');
                    const totalDuration = regionNotes.reduce((sum, item) => sum + item.note.beats, 0);
                    const durationMatches = Math.abs(totalDuration - region.duration) < 0.001;
                    
                    if (allRests && durationMatches) {
                        console.log(`ğŸ¯ [ä¼‘æ­¢ç¬¦åˆå¹¶] ${region.name}å…¨éƒ¨æ˜¯ä¼‘æ­¢ç¬¦(${regionNotes.length}ä¸ª)ï¼Œåˆå¹¶ä¸ºä¸€ä¸ª${region.duration}æ‹ä¼‘æ­¢ç¬¦`);
                        
                        // åˆ›å»ºåˆå¹¶åçš„ä¼‘æ­¢ç¬¦
                        const mergedRest = {
                            type: 'rest',
                            duration: this.beatsToRestDuration(region.duration),
                            beats: region.duration
                        };
                        
                        // æ›¿æ¢åŸæ¥çš„ä¼‘æ­¢ç¬¦
                        mergedNotes.splice(regionStart, regionEnd - regionStart + 1, mergedRest);
                        hasChanges = true;
                        
                        console.log(`âœ… [ä¼‘æ­¢ç¬¦åˆå¹¶] æˆåŠŸåˆå¹¶${region.name}çš„ä¼‘æ­¢ç¬¦`);
                        break; // è¿›è¡Œä¸‹ä¸€æ¬¡è¿­ä»£
                    }
                }
            }
        }
        
        console.log(`ğŸµ [ä¼‘æ­¢ç¬¦åˆå¹¶] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} â†’ ${mergedNotes.length}`);
        return mergedNotes;
    }
    
    /**
     * äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å†…ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™
     * åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å†…ï¼Œå°†ç›¸é‚»çš„ä¼‘æ­¢ç¬¦åˆå¹¶ä¸ºæ›´å¤§çš„ä¼‘æ­¢ç¬¦
     */
    mergeAdjacentRestsInHalfBeats(notes) {
        if (this.timeSignature !== '4/4') {
            console.log(`ğŸµ [ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶] ä»…æ”¯æŒ4/4æ‹ï¼Œå½“å‰: ${this.timeSignature}`);
            return notes;
        }
        const finestRhythm = Math.min(...notes.map(n => n.beats));
        if (finestRhythm <= 0.25 + 0.0001) {
            console.log(`ğŸµ [ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶] æ£€æµ‹åˆ°16åˆ†éŸ³ç¬¦ï¼Œè·³è¿‡äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å†…åˆå¹¶`);
            return notes;
        }
        
        console.log(`ğŸµ [ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†ï¼ŒåŸå§‹éŸ³ç¬¦æ•°é‡: ${notes.length}`);
        
        // å®šä¹‰äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸ
        const halfBeatRegions = [
            { start: 0, end: 2, name: 'å‰åŠå°èŠ‚ï¼ˆæ‹1-2ï¼‰' },
            { start: 2, end: 4, name: 'ååŠå°èŠ‚ï¼ˆæ‹3-4ï¼‰' }
        ];
        
        let mergedNotes = [...notes];
        let hasChanges = true;
        let iterations = 0;
        const maxIterations = 5;
        
        while (hasChanges && iterations < maxIterations) {
            hasChanges = false;
            iterations++;
            console.log(`ğŸµ [ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶] ç¬¬${iterations}æ¬¡è¿­ä»£`);
            
            for (const region of halfBeatRegions) {
                const regionResult = this.mergeAdjacentRestsInRegion(mergedNotes, region);
                if (regionResult.hasChanges) {
                    mergedNotes = regionResult.notes;
                    hasChanges = true;
                    console.log(`  âœ… ${region.name}æœ‰ç›¸é‚»ä¼‘æ­¢ç¬¦è¢«åˆå¹¶`);
                    break; // è¿›è¡Œä¸‹ä¸€æ¬¡è¿­ä»£
                }
            }
        }
        
        console.log(`ğŸµ [ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} â†’ ${mergedNotes.length}`);
        return mergedNotes;
    }
    
    /**
     * åœ¨æŒ‡å®šåŒºåŸŸå†…åˆå¹¶ç›¸é‚»çš„ä¼‘æ­¢ç¬¦
     */
    mergeAdjacentRestsInRegion(notes, region) {
        let currentPos = 0;
        const regionNotes = [];
        
        // æ”¶é›†åŒºåŸŸå†…çš„æ‰€æœ‰éŸ³ç¬¦åŠå…¶ä½ç½®ä¿¡æ¯
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteStart = currentPos;
            const noteEnd = currentPos + note.beats;
            
            // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦åœ¨å½“å‰åŒºåŸŸå†…
            if (noteStart >= region.start - 0.001 && noteStart < region.end - 0.001) {
                regionNotes.push({
                    index: i,
                    note: note,
                    start: noteStart,
                    end: noteEnd
                });
            }
            
            currentPos += note.beats;
        }
        
        if (regionNotes.length < 2) {
            return { hasChanges: false, notes: notes };
        }
        
        console.log(`  ğŸ” ${region.name}åŒ…å«${regionNotes.length}ä¸ªéŸ³ç¬¦`);
        
        // æŸ¥æ‰¾ç›¸é‚»çš„ä¼‘æ­¢ç¬¦åºåˆ—
        let mergedNotes = [...notes];
        
        for (let i = 0; i < regionNotes.length - 1; i++) {
            const current = regionNotes[i];
            const next = regionNotes[i + 1];
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºç›¸é‚»çš„ä¼‘æ­¢ç¬¦
            if (current.note.type === 'rest' && next.note.type === 'rest' &&
                Math.abs(current.end - next.start) < 0.001) {
                
                console.log(`    ğŸ¯ å‘ç°ç›¸é‚»ä¼‘æ­¢ç¬¦: ä½ç½®${current.start}-${current.end} + ${next.start}-${next.end}`);
                
                // è®¡ç®—åˆå¹¶åçš„æ—¶å€¼
                const totalBeats = current.note.beats + next.note.beats;
                const mergedDuration = this.beatsToRestDuration(totalBeats);
                
                if (mergedDuration) {
                    console.log(`    âœ… åˆå¹¶ä¸º${totalBeats}æ‹ä¼‘æ­¢ç¬¦ (${mergedDuration})`);
                    
                    // åˆ›å»ºåˆå¹¶åçš„ä¼‘æ­¢ç¬¦
                    const mergedRest = {
                        type: 'rest',
                        duration: mergedDuration,
                        beats: totalBeats
                    };
                    
                    // æ›¿æ¢åŸæ¥çš„ä¸¤ä¸ªä¼‘æ­¢ç¬¦
                    mergedNotes.splice(current.index, 2, mergedRest);
                    
                    return { hasChanges: true, notes: mergedNotes };
                }
            }
        }
        
        return { hasChanges: false, notes: notes };
    }

    /**
     * å››åˆ†éŸ³ç¬¦æ‹ç‚¹å†…ç›¸é‚»ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™
     * ä»…åœ¨å•ä¸ªå››åˆ†æ‹å†…éƒ¨åˆå¹¶ç›¸é‚»ä¼‘æ­¢ç¬¦ï¼Œä¸è·¨è¶Šæ‹ç‚¹
     */
    mergeAdjacentRestsInQuarterBeats(notes) {
        if (this.timeSignature !== '4/4') {
            console.log(`ğŸµ [å››åˆ†æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ä»…æ”¯æŒ4/4æ‹ï¼Œå½“å‰: ${this.timeSignature}`);
            return notes;
        }

        console.log(`ğŸµ [å››åˆ†æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†ï¼ŒåŸå§‹éŸ³ç¬¦æ•°é‡: ${notes.length}`);

        const beatRegions = [
            { start: 0, end: 1, name: 'ç¬¬1æ‹' },
            { start: 1, end: 2, name: 'ç¬¬2æ‹' },
            { start: 2, end: 3, name: 'ç¬¬3æ‹' },
            { start: 3, end: 4, name: 'ç¬¬4æ‹' }
        ];

        let mergedNotes = [...notes];
        let hasChanges = true;
        let iterations = 0;
        const maxIterations = 10;

        while (hasChanges && iterations < maxIterations) {
            hasChanges = false;
            iterations++;
            console.log(`ğŸµ [å››åˆ†æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ç¬¬${iterations}æ¬¡è¿­ä»£`);

            for (const region of beatRegions) {
                const regionResult = this.mergeAdjacentRestsInQuarterRegion(mergedNotes, region);
                if (regionResult.hasChanges) {
                    mergedNotes = regionResult.notes;
                    hasChanges = true;
                    console.log(`  âœ… ${region.name}å†…ç›¸é‚»ä¼‘æ­¢ç¬¦è¢«åˆå¹¶`);
                    break;
                }
            }
        }

        console.log(`ğŸµ [å››åˆ†æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} â†’ ${mergedNotes.length}`);
        return mergedNotes;
    }

    /**
     * åœ¨å•ä¸ªå››åˆ†æ‹åŒºåŸŸå†…åˆå¹¶ç›¸é‚»ä¼‘æ­¢ç¬¦ï¼ˆè¦æ±‚å®Œå…¨è½åœ¨è¯¥æ‹å†…ï¼‰
     */
    mergeAdjacentRestsInQuarterRegion(notes, region) {
        let currentPos = 0;
        const regionNotes = [];
        const tolerance = 0.001;

        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteStart = currentPos;
            const noteEnd = currentPos + note.beats;

            if (noteStart >= region.start - tolerance && noteEnd <= region.end + tolerance) {
                regionNotes.push({
                    index: i,
                    note: note,
                    start: noteStart,
                    end: noteEnd
                });
            }

            currentPos = noteEnd;
        }

        if (regionNotes.length < 2) {
            return { hasChanges: false, notes: notes };
        }

        for (let i = 0; i < regionNotes.length - 1; i++) {
            const current = regionNotes[i];
            const next = regionNotes[i + 1];

            if (current.note.type === 'rest' && next.note.type === 'rest' &&
                Math.abs(current.end - next.start) < tolerance) {

                const totalBeats = current.note.beats + next.note.beats;
                const mergedDuration = this.beatsToRestDuration(totalBeats);

                if (mergedDuration) {
                    const mergedRest = {
                        type: 'rest',
                        duration: mergedDuration,
                        beats: totalBeats
                    };
                    const mergedNotes = [...notes];
                    mergedNotes.splice(current.index, 2, mergedRest);
                    return { hasChanges: true, notes: mergedNotes };
                }
            }
        }

        return { hasChanges: false, notes: notes };
    }

    /**
     * 3/4æ‹ä¸“ç”¨çš„ä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™ - åŸºäºæ‹ç‚¹å±‚çº§æ™ºèƒ½åˆå¹¶
     */
    mergeRestsByBeatsFor3_4(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†ï¼ŒåŸå§‹éŸ³ç¬¦æ•°é‡: ${notes.length}`);
        
        // åˆ†æå½“å‰éŸ³ç¬¦çš„æœ€å°æ—¶å€¼ï¼Œç¡®å®šéœ€è¦ä¿æŒçš„æ‹ç‚¹å±‚çº§
        const finestRhythm = Math.min(...notes.map(n => n.beats));
        console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] æœ€å°æ—¶å€¼: ${finestRhythm}æ‹`);
        
        let mergedNotes = [...notes];
        let hasChanges = true;
        let iterations = 0;
        const maxIterations = 5;
        
        // æ ¹æ®æœ€å°æ—¶å€¼ç¡®å®šæ‹ç‚¹åˆå¹¶ç­–ç•¥
        let beatRegions = [];
        
        if (finestRhythm <= 0.5) {
            // æœ‰å…«åˆ†éŸ³ç¬¦æˆ–æ›´å°æ—¶å€¼ - åªéœ€è¦ä¿æŒé‡è¦çš„å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°
            console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å…«åˆ†éŸ³ç¬¦çº§åˆ« - ä¿æŒç¬¬1æ‹å’Œç¬¬3æ‹æ¸…æ™°`);
            beatRegions = [
                // äºŒåˆ†éŸ³ç¬¦çº§åˆ«çš„åˆå¹¶ï¼ˆè·¨è¶Šä¸¤ä¸ªå››åˆ†éŸ³ç¬¦æ‹ï¼‰
                { start: 0, end: 2, duration: 2, name: 'ç¬¬1-2æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰', type: 'half' },
                // å››åˆ†éŸ³ç¬¦çº§åˆ«çš„åˆå¹¶
                { start: 0, end: 1, duration: 1, name: 'ç¬¬1æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' },
                { start: 1, end: 2, duration: 1, name: 'ç¬¬2æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' },
                { start: 2, end: 3, duration: 1, name: 'ç¬¬3æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' }
            ];
        } else {
            // åªæœ‰å››åˆ†éŸ³ç¬¦æˆ–æ›´å¤§æ—¶å€¼ - å¯ä»¥æ›´è‡ªç”±åœ°åˆå¹¶
            console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å››åˆ†éŸ³ç¬¦çº§åˆ« - å¯ä»¥åˆå¹¶æ›´å¤§åŒºé—´`);
            beatRegions = [
                // æ•´å°èŠ‚åˆå¹¶ï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼‰
                { start: 0, end: 3, duration: 3, name: 'æ•´å°èŠ‚ï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼‰', type: 'dotted-half' },
                // äºŒåˆ†éŸ³ç¬¦çº§åˆ«çš„åˆå¹¶
                { start: 0, end: 2, duration: 2, name: 'ç¬¬1-2æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰', type: 'half' },
                { start: 1, end: 3, duration: 2, name: 'ç¬¬2-3æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰', type: 'half' },
                // å››åˆ†éŸ³ç¬¦çº§åˆ«çš„åˆå¹¶
                { start: 0, end: 1, duration: 1, name: 'ç¬¬1æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' },
                { start: 1, end: 2, duration: 1, name: 'ç¬¬2æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' },
                { start: 2, end: 3, duration: 1, name: 'ç¬¬3æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰', type: 'quarter' }
            ];
        }
        
        while (hasChanges && iterations < maxIterations) {
            hasChanges = false;
            iterations++;
            
            console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ç¬¬${iterations}æ¬¡è¿­ä»£`);
            
            // æŒ‰ç…§ä»å¤§åˆ°å°çš„é¡ºåºå°è¯•åˆå¹¶ï¼ˆä¼˜å…ˆåˆå¹¶æ›´å¤§çš„åŒºé—´ï¼‰
            for (const region of beatRegions) {
                let currentPos = 0;
                const regionNotes = [];
                let regionStart = -1;
                let regionEnd = -1;
                
                // æ”¶é›†åŒºé—´å†…çš„æ‰€æœ‰éŸ³ç¬¦
                for (let i = 0; i < mergedNotes.length; i++) {
                    const note = mergedNotes[i];
                    const noteEnd = currentPos + note.beats;
                    
                    // éŸ³ç¬¦ä¸åŒºé—´æœ‰é‡å 
                    if (currentPos < region.end && noteEnd > region.start) {
                        if (regionStart === -1) regionStart = i;
                        regionEnd = i;
                        regionNotes.push({ note, index: i });
                    }
                    
                    currentPos = noteEnd;
                }
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
                if (regionNotes.length > 1) {
                    const allRests = regionNotes.every(item => item.note.type === 'rest');
                    const totalDuration = regionNotes.reduce((sum, item) => sum + item.note.beats, 0);
                    const durationMatches = Math.abs(totalDuration - region.duration) < 0.001;
                    
                    // æ£€æŸ¥åŒºé—´æ˜¯å¦å®Œæ•´ï¼ˆæ²¡æœ‰éŸ³ç¬¦è·¨è¶Šè¾¹ç•Œï¼‰
                    const regionComplete = this.isRegionCompleteFor3_4(regionNotes, region, mergedNotes);
                    
                    if (allRests && durationMatches && regionComplete) {
                        console.log(`ğŸ¯ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ${region.name}å…¨éƒ¨æ˜¯ä¼‘æ­¢ç¬¦(${regionNotes.length}ä¸ª)ï¼Œåˆå¹¶ä¸ºä¸€ä¸ª${region.duration}æ‹ä¼‘æ­¢ç¬¦`);
                        
                        // åˆ›å»ºåˆå¹¶åçš„ä¼‘æ­¢ç¬¦
                        const mergedRest = {
                            type: 'rest',
                            duration: this.beatsToRestDuration(region.duration),
                            beats: region.duration
                        };
                        
                        // æ›¿æ¢åŸæ¥çš„ä¼‘æ­¢ç¬¦
                        mergedNotes.splice(regionStart, regionEnd - regionStart + 1, mergedRest);
                        hasChanges = true;
                        
                        console.log(`âœ… [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] æˆåŠŸåˆå¹¶${region.name}çš„ä¼‘æ­¢ç¬¦`);
                        break; // è¿›è¡Œä¸‹ä¸€æ¬¡è¿­ä»£
                    }
                }
            }
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} â†’ ${mergedNotes.length}`);
        return mergedNotes;
    }

    /**
     * æ£€æŸ¥3/4æ‹åŒºé—´æ˜¯å¦å®Œæ•´ï¼ˆæ²¡æœ‰éŸ³ç¬¦è·¨è¶Šè¾¹ç•Œï¼‰
     */
    isRegionCompleteFor3_4(regionNotes, region, allNotes) {
        // ç®€å•æ£€æŸ¥ï¼šç¡®ä¿åŒºé—´å†…çš„éŸ³ç¬¦æ€»æ—¶å€¼ç­‰äºåŒºé—´æ—¶å€¼
        let currentPos = 0;
        for (let i = 0; i < allNotes.length; i++) {
            const note = allNotes[i];
            const noteEnd = currentPos + note.beats;
            
            // æ‰¾åˆ°åŒºé—´å¼€å§‹ä½ç½®
            if (Math.abs(currentPos - region.start) < 0.001) {
                let regionPos = currentPos;
                let regionNoteCount = 0;
                
                // æ£€æŸ¥åŒºé—´å†…çš„éŸ³ç¬¦
                while (regionPos < region.end - 0.001 && i + regionNoteCount < allNotes.length) {
                    const regionNote = allNotes[i + regionNoteCount];
                    regionPos += regionNote.beats;
                    regionNoteCount++;
                    
                    // å¦‚æœéŸ³ç¬¦è·¨è¶Šäº†åŒºé—´è¾¹ç•Œï¼Œè¯´æ˜åŒºé—´ä¸å®Œæ•´
                    if (regionPos > region.end + 0.001) {
                        console.log(`ğŸ” [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ${region.name}åŒºé—´ä¸å®Œæ•´ï¼šéŸ³ç¬¦è·¨è¶Šè¾¹ç•Œ`);
                        return false;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æ°å¥½å¡«æ»¡åŒºé—´
                const regionComplete = Math.abs(regionPos - region.end) < 0.001;
                console.log(`ğŸ” [3/4æ‹ä¼‘æ­¢ç¬¦åˆå¹¶] ${region.name}åŒºé—´å®Œæ•´æ€§æ£€æŸ¥: ${regionComplete ? 'å®Œæ•´' : 'ä¸å®Œæ•´'}`);
                return regionComplete;
            }
            
            currentPos = noteEnd;
        }
        
        return false;
    }

    /**
     * åˆ¤æ–­tiedç»„åˆæ˜¯å¦æ˜¯çœŸæ­£çš„è·¨æ‹æ‹†åˆ†
     */
    isActualCrossBeatSplit(tiedGroup, allNotes, criticalBeats = []) {
        if (tiedGroup.length < 2) return false;
        
        // è®¡ç®—tiedç»„çš„èµ·å§‹ä½ç½®
        const startPosition = this.calculateNotePosition(allNotes, tiedGroup[0]);
        const totalBeats = tiedGroup.reduce((sum, note) => sum + note.beats, 0);
        const endPosition = startPosition + totalBeats;
        
        // ğŸ”¥ æ£€æµ‹æ˜¯å¦åœ¨16åˆ†éŸ³ç¬¦ç¯å¢ƒä¸‹
        const has16thNotes = allNotes.some(note => !note.isTriplet && Math.abs(note.beats - 0.25) < 0.001);
        
        // ğŸ¯ æ ¹æ®ç¯å¢ƒé€‰æ‹©æ£€æŸ¥çš„æ‹ç‚¹
        let keyBeats;
        if (has16thNotes) {
            // 16åˆ†éŸ³ç¬¦ç¯å¢ƒï¼šæ£€æŸ¥æ‰€æœ‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹
            keyBeats = [0, 1, 2, 3];
            console.log(`  ğŸ” 16åˆ†éŸ³ç¬¦ç¯å¢ƒè·¨æ‹æ£€æŸ¥: ${startPosition}-${endPosition}, æ£€æŸ¥æ‹ç‚¹[${keyBeats.join(', ')}]`);
        } else {
            // æ­£å¸¸ç¯å¢ƒï¼šæ£€æŸ¥äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ 
            keyBeats = [1, 2, 3];
            console.log(`  ğŸ” æ­£å¸¸ç¯å¢ƒè·¨æ‹æ£€æŸ¥: ${startPosition}-${endPosition}, æ£€æŸ¥æ‹ç‚¹[${keyBeats.join(', ')}]`);
        }
        
        // æ£€æŸ¥æ˜¯å¦è·¨è¶Šå…³é”®æ‹ç‚¹
        const tolerance = 0.01;
        
        for (const beat of keyBeats) {
            if (startPosition < beat - tolerance && endPosition > beat + tolerance) {
                console.log(`  âœ… ç¡®è®¤è·¨æ‹: è·¨è¶Šæ‹ç‚¹${beat} (${has16thNotes ? '16åˆ†éŸ³ç¬¦ç¯å¢ƒ' : 'æ­£å¸¸ç¯å¢ƒ'})`);
                
                // ğŸ”¥ 16åˆ†éŸ³ç¬¦ç¯å¢ƒä¸‹ï¼šæ‰€æœ‰è·¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹çš„éƒ½æ˜¯çœŸæ­£çš„è·¨æ‹æ‹†åˆ†
                if (has16thNotes) {
                    return true;
                }
                
                // æ­£å¸¸ç¯å¢ƒä¸‹çš„åŸæœ‰é€»è¾‘
                const startsOnBeat = Math.abs(startPosition - Math.round(startPosition)) < tolerance;
                
                // ğŸµ è§„åˆ™4ä¸“é—¨ä¿æŠ¤ï¼š1.5æ‹ä½ç½®ï¼ˆä»£ç ä½ç½®ï¼ŒéŸ³ä¹ç†è®º2.5æ‹ï¼‰å››åˆ†éŸ³ç¬¦æ‹†åˆ†
                // ä½¿ç”¨æ›´å®½æ¾çš„å®¹å·®ä»¥å¤„ç†æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
                const is1_5BeatQuarter = Math.abs(totalBeats - 1.0) < 0.01 && 
                    Math.abs(startPosition - 1.5) < 0.01;
                
                if (is1_5BeatQuarter) {
                    console.log(`  ğŸš¨ğŸš¨ğŸš¨ è§„åˆ™4ä¿æŠ¤æ¿€æ´»ï¼š1.5æ‹ä½ç½®å››åˆ†éŸ³ç¬¦æ‹†åˆ†ä¸å¯åˆå¹¶ï¼ˆé¿å…è·¨è¶Šç¬¬3æ‹å¼ºæ‹ï¼‰`);
                    console.log(`  ğŸš¨ è¯¦æƒ…: èµ·å§‹ä½ç½®=${startPosition}, æ€»æ‹æ•°=${totalBeats}, tiedç»„é•¿åº¦=${tiedGroup.length}`);
                    return true; // 1.5æ‹ä½ç½®å››åˆ†éŸ³ç¬¦æ‹†åˆ†å¿…é¡»ä¿æŠ¤
                }
                
                // ğŸ¯ å…³é”®ä¿æŠ¤ï¼šåªæœ‰ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†éœ€è¦ä¿æŠ¤
                // ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ä¼šè·¨è¶Šç¬¬3æ‹ï¼Œå¿…é¡»ä¿æŒæ‹†åˆ†çŠ¶æ€
                const is1_5PositionQuarter = Math.abs(totalBeats - 1.0) < 0.01 && 
                    Math.abs(startPosition - 1.5) < 0.01;
                
                if (is1_5PositionQuarter) {
                    console.log(`  ğŸ¯ æ£€æµ‹åˆ°ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†: å¿…é¡»ä¿æŠ¤ï¼Œç¦æ­¢åˆå¹¶`);
                    return true; // ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†å¿…é¡»ä¿æŠ¤
                }
                
                // ğŸ¯ æ–°å¢ï¼šæ£€æŸ¥å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†ä¿æŠ¤
                // å¦‚æœå…³é”®æ‹ç‚¹åªæ˜¾ç¤ºäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹[0,2]ï¼Œè¯´æ˜å½“å‰æ˜¯å…«åˆ†éŸ³ç¬¦åœºæ™¯
                // æ­¤æ—¶å››åˆ†éŸ³ç¬¦è·¨è¶Šä½ç½®2çš„æ‹†åˆ†å¿…é¡»ä¿æŠ¤
                const isEighthNoteScenario = criticalBeats.length === 2 && 
                    criticalBeats.includes(0) && criticalBeats.includes(2) && 
                    !criticalBeats.includes(1) && !criticalBeats.includes(3);
                
                if (isEighthNoteScenario && Math.abs(totalBeats - 1.0) < tolerance && Math.abs(beat - 2) < tolerance) {
                    console.log(`  ğŸ”¥ å…«åˆ†éŸ³ç¬¦åœºæ™¯ï¼šå››åˆ†éŸ³ç¬¦è·¨è¶Šä½ç½®2çš„æ‹†åˆ†å¿…é¡»ä¿æŠ¤, èµ·å§‹${startPosition}æ‹, ç¦æ­¢åˆå¹¶`);
                    return true; // å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹è·¨è¶Šä½ç½®2çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†å¿…é¡»ä¿æŠ¤
                }
                
                // å››åˆ†éŸ³ç¬¦åœ¨æ­£æ‹ä¸Šå¯ä»¥ä¸æ‹†åˆ†
                if (Math.abs(totalBeats - 1.0) < tolerance && startsOnBeat) {
                    return false; // ä¸æ˜¯è·¨æ‹æ‹†åˆ†ï¼Œå¯ä»¥åˆå¹¶
                }
                
                return true; // ç¡®å®æ˜¯è·¨æ‹æ‹†åˆ†ï¼Œéœ€è¦ä¿æŠ¤
            }
        }
        
        return false; // ä¸è·¨æ‹ï¼Œå¯ä»¥åˆå¹¶
    }

    /**
     * æ£€æŸ¥åˆå¹¶ä¼‘æ­¢ç¬¦æ˜¯å¦ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦
     */
    checkRestMergeAffectsBeatClarity(startPosition, totalBeats, allNotes, timeSignature) {
        const endPosition = startPosition + totalBeats;
        const tolerance = 0.0001;
        
        // è·å–éœ€è¦æ˜ç¡®çš„å…³é”®æ‹ç‚¹
        const criticalBeats = RHYTHM_NOTATION_RULES.getCriticalBeatsWithLocalRhythm(allNotes, timeSignature);
        
        console.log(`    ğŸ” æ£€æŸ¥ä¼‘æ­¢ç¬¦åˆå¹¶ [${startPosition}-${endPosition}] å…³é”®æ‹ç‚¹: [${criticalBeats.join(', ')}]`);
        
        // æ–°è§„åˆ™ï¼šæ£€æŸ¥æ˜¯å¦åœ¨å®Œæ•´æ‹ç‚¹å†…å…¨æ˜¯ä¼‘æ­¢ç¬¦
        const beatTypes = this.checkIfFullBeatOfRests(startPosition, endPosition, allNotes, timeSignature);
        if (beatTypes.length > 0) {
            console.log(`    âœ… å®Œæ•´${beatTypes[0]}æ‹ç‚¹å†…å…¨æ˜¯ä¼‘æ­¢ç¬¦ï¼Œå¯ä»¥åˆå¹¶`);
            return false; // æ‹ç‚¹å†…å…¨æ˜¯ä¼‘æ­¢ç¬¦ï¼Œå¯ä»¥åˆå¹¶
        }
        
        // æ£€æŸ¥åˆå¹¶åçš„ä¼‘æ­¢ç¬¦èŒƒå›´å†…æ˜¯å¦åŒ…å«éœ€è¦æ˜ç¡®çš„æ‹ç‚¹
        for (const beatPoint of criticalBeats) {
            // å¦‚æœæ‹ç‚¹åœ¨ä¼‘æ­¢ç¬¦èŒƒå›´å†…ï¼Œåˆå¹¶ä¼šæ¨¡ç³Šè¿™ä¸ªæ‹ç‚¹
            if (startPosition < beatPoint - tolerance && endPosition > beatPoint + tolerance) {
                console.log(`    âŒ åˆå¹¶ä¼šæ¨¡ç³Šå…³é”®æ‹ç‚¹${beatPoint}ï¼Œä¸åº”è¯¥åˆå¹¶`);
                return true; // ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦
            }
            
            // å¦‚æœæ‹ç‚¹æ°å¥½åœ¨ä¼‘æ­¢ç¬¦çš„è¾¹ç•Œä¸Šï¼Œæ£€æŸ¥è¿™ä¸ªæ‹ç‚¹æ˜¯å¦å·²ç»è¢«å…¶ä»–éŸ³ç¬¦æ˜ç¡®äº†
            if (Math.abs(startPosition - beatPoint) < tolerance || Math.abs(endPosition - beatPoint) < tolerance) {
                // æ‹ç‚¹åœ¨è¾¹ç•Œä¸Šï¼Œæ£€æŸ¥æ˜¯å¦å·²ç»è¢«æ˜ç¡®
                if (!RHYTHM_NOTATION_RULES.isBeatPointAlreadyClear(startPosition, endPosition, beatPoint, allNotes, timeSignature)) {
                    console.log(`    âŒ æ‹ç‚¹${beatPoint}åœ¨ä¼‘æ­¢ç¬¦è¾¹ç•Œä¸Šä½†æœªè¢«æ˜ç¡®ï¼Œä¸åº”è¯¥åˆå¹¶`);
                    return true; // ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦
                }
            }
        }
        
        console.log(`    âœ… åˆå¹¶ä¸ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦`);
        return false; // ä¸ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦ï¼Œå¯ä»¥åˆå¹¶
    }

    /**
     * æ£€æŸ¥æ­£æ‹å†…æ˜¯å¦å…¨æ˜¯ä¼‘æ­¢ç¬¦
     * æ­£æ‹å®šä¹‰ï¼š(1,2,3,4), (1,3), (1) æ ¹æ®å½“å‰æ‹ç‚¹å±‚çº§
     */
    checkIfFullBeatOfRests(startPosition, endPosition, allNotes, timeSignature) {
        const tolerance = 0.0001;
        
        // æ ¹æ®æ‹å·é€‰æ‹©æ‹ç‚¹å±‚çº§
        let beatHierarchy;
        
        if (timeSignature === '6/8') {
            beatHierarchy = this.getBeatHierarchyFor6_8();
        } else if (timeSignature === '3/4') {
            beatHierarchy = this.getBeatHierarchyFor3_4();
        } else if (timeSignature === '4/4') {
            beatHierarchy = this.getBeatHierarchyFor4_4();
        } else {
            // å…¶ä»–æ‹å·ä½¿ç”¨åŸºæœ¬å±‚çº§
            beatHierarchy = this.getBeatHierarchyGeneric(timeSignature);
        }
        
        console.log(`      ğŸµ ${timeSignature}æ‹æ£€æŸ¥å±‚æ¬¡åŒ–æ‹ç‚¹åˆå¹¶: ${startPosition}-${endPosition}`);
        
        // æ£€æŸ¥ä¼‘æ­¢ç¬¦æ˜¯å¦æ°å¥½ç¬¦åˆæŸä¸ªæ‹ç‚¹èŒƒå›´
        for (const beat of beatHierarchy) {
            if (Math.abs(startPosition - beat.start) < tolerance && Math.abs(endPosition - beat.end) < tolerance) {
                // æ£€æŸ¥è¯¥æ‹ç‚¹èŒƒå›´å†…æ˜¯å¦å…¨æ˜¯ä¼‘æ­¢ç¬¦
                const isFullBeatOfRests = this.checkBeatRangeContainsOnlyRests(beat.start, beat.end, allNotes);
                if (isFullBeatOfRests) {
                    console.log(`      âœ… ${timeSignature}æ‹å®Œæ•´${beat.type}æ‹ç‚¹ ${beat.start}-${beat.end} å†…å…¨æ˜¯ä¼‘æ­¢ç¬¦ï¼Œå¯ä»¥åˆå¹¶`);
                    return [beat.type]; // è¿”å›æ‹ç‚¹ç±»å‹ç”¨äºåˆå¹¶åˆ¤æ–­
                }
            }
        }
        
        console.log(`      âŒ ${timeSignature}æ‹ä¼‘æ­¢ç¬¦èŒƒå›´${startPosition}-${endPosition}ä¸ç¬¦åˆä»»ä½•å®Œæ•´æ‹ç‚¹`);
        return [];
    }

    // 4/4æ‹çš„æ‹ç‚¹å±‚çº§
    getBeatHierarchyFor4_4() {
        return [
            // åå…­åˆ†éŸ³ç¬¦å±‚çº§ï¼ˆæœ€ç»†ï¼‰
            { start: 0, end: 0.25, type: 'sixteenth' },
            { start: 0.25, end: 0.5, type: 'sixteenth' },
            { start: 0.5, end: 0.75, type: 'sixteenth' },
            { start: 0.75, end: 1, type: 'sixteenth' },
            { start: 1, end: 1.25, type: 'sixteenth' },
            { start: 1.25, end: 1.5, type: 'sixteenth' },
            { start: 1.5, end: 1.75, type: 'sixteenth' },
            { start: 1.75, end: 2, type: 'sixteenth' },
            { start: 2, end: 2.25, type: 'sixteenth' },
            { start: 2.25, end: 2.5, type: 'sixteenth' },
            { start: 2.5, end: 2.75, type: 'sixteenth' },
            { start: 2.75, end: 3, type: 'sixteenth' },
            { start: 3, end: 3.25, type: 'sixteenth' },
            { start: 3.25, end: 3.5, type: 'sixteenth' },
            { start: 3.5, end: 3.75, type: 'sixteenth' },
            { start: 3.75, end: 4, type: 'sixteenth' },
            // å…«åˆ†æ‹ç‚¹å±‚çº§
            { start: 0, end: 0.5, type: 'eighth' },
            { start: 0.5, end: 1, type: 'eighth' },
            { start: 1, end: 1.5, type: 'eighth' },
            { start: 1.5, end: 2, type: 'eighth' },
            { start: 2, end: 2.5, type: 'eighth' },
            { start: 2.5, end: 3, type: 'eighth' },
            { start: 3, end: 3.5, type: 'eighth' },
            { start: 3.5, end: 4, type: 'eighth' },
            // å››åˆ†éŸ³ç¬¦æ‹ç‚¹å±‚çº§
            { start: 0, end: 1, type: 'quarter' },
            { start: 1, end: 2, type: 'quarter' },
            { start: 2, end: 3, type: 'quarter' },
            { start: 3, end: 4, type: 'quarter' },
            // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å±‚çº§
            { start: 0, end: 2, type: 'half' },
            { start: 2, end: 4, type: 'half' },
            // å…¨éŸ³ç¬¦æ‹ç‚¹å±‚çº§ï¼ˆæœ€ç²—ï¼‰
            { start: 0, end: 4, type: 'whole' }
        ];
    }

    // 6/8æ‹çš„æ‹ç‚¹å±‚çº§ - 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹é•¿åº¦ï¼ˆ6ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
    getBeatHierarchyFor6_8() {
        return [
            // åå…­åˆ†éŸ³ç¬¦å±‚çº§ï¼ˆæœ€ç»†ï¼‰- 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹ = 12ä¸ªåå…­åˆ†éŸ³ç¬¦
            { start: 0, end: 0.25, type: 'sixteenth' },
            { start: 0.25, end: 0.5, type: 'sixteenth' },
            { start: 0.5, end: 0.75, type: 'sixteenth' },
            { start: 0.75, end: 1, type: 'sixteenth' },
            { start: 1, end: 1.25, type: 'sixteenth' },
            { start: 1.25, end: 1.5, type: 'sixteenth' },
            { start: 1.5, end: 1.75, type: 'sixteenth' },
            { start: 1.75, end: 2, type: 'sixteenth' },
            { start: 2, end: 2.25, type: 'sixteenth' },
            { start: 2.25, end: 2.5, type: 'sixteenth' },
            { start: 2.5, end: 2.75, type: 'sixteenth' },
            { start: 2.75, end: 3, type: 'sixteenth' },
            // å…«åˆ†éŸ³ç¬¦å±‚çº§ï¼ˆ6/8æ‹çš„åŸºæœ¬å•ä½ï¼‰
            { start: 0, end: 0.5, type: 'eighth' },      // ç¬¬1ä¸ªå…«åˆ†éŸ³ç¬¦
            { start: 0.5, end: 1, type: 'eighth' },      // ç¬¬2ä¸ªå…«åˆ†éŸ³ç¬¦
            { start: 1, end: 1.5, type: 'eighth' },      // ç¬¬3ä¸ªå…«åˆ†éŸ³ç¬¦
            { start: 1.5, end: 2, type: 'eighth' },      // ç¬¬4ä¸ªå…«åˆ†éŸ³ç¬¦
            { start: 2, end: 2.5, type: 'eighth' },      // ç¬¬5ä¸ªå…«åˆ†éŸ³ç¬¦
            { start: 2.5, end: 3, type: 'eighth' },      // ç¬¬6ä¸ªå…«åˆ†éŸ³ç¬¦
            // é™„ç‚¹å››åˆ†éŸ³ç¬¦å±‚çº§ï¼ˆ6/8æ‹çš„ä¸»æ‹ - æ¯1.5ä¸ªå››åˆ†éŸ³ç¬¦æ‹ï¼‰
            { start: 0, end: 1.5, type: 'dotted-quarter' },   // ç¬¬ä¸€ä¸ªä¸»æ‹ï¼ˆ3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
            { start: 1.5, end: 3, type: 'dotted-quarter' },   // ç¬¬äºŒä¸ªä¸»æ‹ï¼ˆ3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
            // å…¨å°èŠ‚ï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ - 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹é•¿åº¦ï¼‰
            { start: 0, end: 3, type: 'dotted-half' }
        ];
    }

    // 3/4æ‹çš„æ‹ç‚¹å±‚çº§
    getBeatHierarchyFor3_4() {
        return [
            // åå…­åˆ†éŸ³ç¬¦å±‚çº§ï¼ˆæœ€ç»†ï¼‰- 3ä¸ªå››åˆ†éŸ³ç¬¦ = 12ä¸ªåå…­åˆ†éŸ³ç¬¦
            { start: 0, end: 0.25, type: 'sixteenth' },
            { start: 0.25, end: 0.5, type: 'sixteenth' },
            { start: 0.5, end: 0.75, type: 'sixteenth' },
            { start: 0.75, end: 1, type: 'sixteenth' },
            { start: 1, end: 1.25, type: 'sixteenth' },
            { start: 1.25, end: 1.5, type: 'sixteenth' },
            { start: 1.5, end: 1.75, type: 'sixteenth' },
            { start: 1.75, end: 2, type: 'sixteenth' },
            { start: 2, end: 2.25, type: 'sixteenth' },
            { start: 2.25, end: 2.5, type: 'sixteenth' },
            { start: 2.5, end: 2.75, type: 'sixteenth' },
            { start: 2.75, end: 3, type: 'sixteenth' },
            // å…«åˆ†éŸ³ç¬¦å±‚çº§
            { start: 0, end: 0.5, type: 'eighth' },
            { start: 0.5, end: 1, type: 'eighth' },
            { start: 1, end: 1.5, type: 'eighth' },
            { start: 1.5, end: 2, type: 'eighth' },
            { start: 2, end: 2.5, type: 'eighth' },
            { start: 2.5, end: 3, type: 'eighth' },
            // å››åˆ†éŸ³ç¬¦å±‚çº§
            { start: 0, end: 1, type: 'quarter' },
            { start: 1, end: 2, type: 'quarter' },
            { start: 2, end: 3, type: 'quarter' },
            // äºŒåˆ†éŸ³ç¬¦å±‚çº§
            { start: 0, end: 2, type: 'half' },
            { start: 1, end: 3, type: 'half' },
            // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆå…¨å°èŠ‚ï¼‰
            { start: 0, end: 3, type: 'dotted-half' }
        ];
    }

    getBeatStructure(timeSignature) {
        if (typeof RHYTHM_NOTATION_RULES?.getBeatStructure === 'function') {
            return RHYTHM_NOTATION_RULES.getBeatStructure(timeSignature);
        }
        const parsed = parseTimeSignatureString(timeSignature);
        const beatsPerMeasure = parsed ? parsed.beats : 4;
        return {
            beatsPerMeasure,
            strongBeats: [0],
            subdivisions: []
        };
    }

    // é€šç”¨æ‹ç‚¹å±‚çº§ç”Ÿæˆ
    getBeatHierarchyGeneric(timeSignature) {
        const structure = this.getBeatStructure(timeSignature);
        const beatHierarchy = [];
        const maxBeats = structure.beatsPerMeasure;
        
        // ç”ŸæˆåŸºæœ¬çš„æ‹ç‚¹å±‚çº§
        // åå…­åˆ†éŸ³ç¬¦å±‚çº§
        for (let i = 0; i < maxBeats; i += 0.25) {
            beatHierarchy.push({ start: i, end: i + 0.25, type: 'sixteenth' });
        }
        
        // å…«åˆ†éŸ³ç¬¦å±‚çº§
        for (let i = 0; i < maxBeats; i += 0.5) {
            beatHierarchy.push({ start: i, end: i + 0.5, type: 'eighth' });
        }
        
        // å››åˆ†éŸ³ç¬¦å±‚çº§
        for (let i = 0; i < maxBeats; i += 1) {
            beatHierarchy.push({ start: i, end: i + 1, type: 'quarter' });
        }
        
        // äºŒåˆ†éŸ³ç¬¦å±‚çº§
        for (let i = 0; i < maxBeats; i += 2) {
            if (i + 2 <= maxBeats) {
                beatHierarchy.push({ start: i, end: i + 2, type: 'half' });
            }
        }
        
        // å…¨å°èŠ‚
        beatHierarchy.push({ start: 0, end: maxBeats, type: 'whole' });
        
        return beatHierarchy;
    }

    /**
     * æ£€æŸ¥æŒ‡å®šæ‹ç‚¹èŒƒå›´å†…æ˜¯å¦å…¨æ˜¯ä¼‘æ­¢ç¬¦
     */
    checkBeatRangeContainsOnlyRests(beatStart, beatEnd, allNotes) {
        const tolerance = 0.0001;
        let position = 0;
        
        for (const note of allNotes) {
            const noteStart = position;
            const noteEnd = position + note.beats;
            
            // å¦‚æœéŸ³ç¬¦ä¸æ­£æ‹èŒƒå›´æœ‰é‡å 
            if (noteEnd > beatStart + tolerance && noteStart < beatEnd - tolerance) {
                // å¦‚æœæ˜¯éŸ³ç¬¦ï¼ˆéä¼‘æ­¢ç¬¦ï¼‰ï¼Œè¿”å›false
                if (note.type === 'note') {
                    return false;
                }
            }
            
            position += note.beats;
        }
        
        return true; // è¯¥èŒƒå›´å†…æ²¡æœ‰éŸ³ç¬¦ï¼Œå…¨æ˜¯ä¼‘æ­¢ç¬¦
    }

    /**
     * æ£€æŸ¥å››åˆ†éŸ³ç¬¦åœ¨æ­£æ‹ä¸Šçš„ä¾‹å¤–è§„åˆ™
     * åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå¦‚æœæ¨¡ç³ŠäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹çš„æ˜¯ä¸¤ä¸ªå‡ºç°åœ¨æ­£æ‹çš„å››åˆ†éŸ³ç¬¦ï¼Œåˆ™å¯ä»¥å°†å…¶åˆå¹¶æˆä¸€ä¸ªäºŒåˆ†éŸ³ç¬¦
     */
    checkQuarterNoteOnStrongBeatException(tiedGroup, allNotes, startPosition, criticalBeats = []) {
        const tolerance = 0.0001;
        
        // ğŸ¯ è¿™æ˜¯ä¸€ä¸ªä¾‹å¤–è§„åˆ™ï¼šå³ä½¿åœ¨å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ï¼Œç›¸é‚»æ­£æ‹ä¸Šçš„ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦ä¹Ÿå¯ä»¥åˆå¹¶ä¸ºäºŒåˆ†éŸ³ç¬¦
        // è¿™æ˜¯ç”¨æˆ·æ˜ç¡®è¦æ±‚çš„ä¾‹å¤–æƒ…å†µ
        const isEighthNoteScenario = criticalBeats.length === 2 && 
            criticalBeats.includes(0) && criticalBeats.includes(2) && 
            !criticalBeats.includes(1) && !criticalBeats.includes(3);
        
        if (isEighthNoteScenario) {
            console.log(`  ğŸ¯ å…«åˆ†éŸ³ç¬¦åœºæ™¯ï¼šæ£€æŸ¥ç›¸é‚»æ­£æ‹å››åˆ†éŸ³ç¬¦åˆå¹¶ä¾‹å¤–è§„åˆ™`);
        }
        
        // åªé€‚ç”¨äºä¸¤ä¸ªå››åˆ†éŸ³ç¬¦çš„æƒ…å†µ
        if (tiedGroup.length !== 2) return false;
        
        // æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯å››åˆ†éŸ³ç¬¦ (1æ‹)
        const isAllQuarterNotes = tiedGroup.every(note => Math.abs(note.beats - 1.0) < tolerance);
        if (!isAllQuarterNotes) return false;
        
        // æ£€æŸ¥åˆå¹¶åæ˜¯å¦ä¸ºäºŒåˆ†éŸ³ç¬¦ (2æ‹)
        const totalBeats = tiedGroup.reduce((sum, note) => sum + note.beats, 0);
        if (Math.abs(totalBeats - 2.0) > tolerance) return false;
        
        const endPosition = startPosition + totalBeats;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºç›¸é‚»æ­£æ‹ä¸Šçš„ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦
        // ç›¸é‚»æ­£æ‹ç»„åˆï¼š(0,1), (1,2), (2,3) - å¯¹åº”æ‹1+2, æ‹2+3, æ‹3+4
        const adjacentQuarterBeatPairs = [
            [0, 1], // ç¬¬1æ‹+ç¬¬2æ‹
            [1, 2], // ç¬¬2æ‹+ç¬¬3æ‹  
            [2, 3]  // ç¬¬3æ‹+ç¬¬4æ‹
        ];
        
        let isAdjacentQuarterBeats = false;
        
        for (const [beat1, beat2] of adjacentQuarterBeatPairs) {
            if (Math.abs(startPosition - beat1) < tolerance && 
                Math.abs(endPosition - (beat2 + 1)) < tolerance) {
                isAdjacentQuarterBeats = true;
                console.log(`  ğŸ¯ å‘ç°ç›¸é‚»æ­£æ‹å››åˆ†éŸ³ç¬¦: æ‹${beat1+1}+æ‹${beat2+1} (ä½ç½®${beat1}-${beat2+1})`);
                break;
            }
        }
        
        if (!isAdjacentQuarterBeats) {
            console.log(`  ğŸ” ä¾‹å¤–è§„åˆ™æ£€æŸ¥: ä¸æ˜¯ç›¸é‚»æ­£æ‹ä¸Šçš„å››åˆ†éŸ³ç¬¦ç»„åˆï¼Œèµ·å§‹ä½ç½®${startPosition}`);
            return false;
        }
        
        // æ£€æŸ¥è¿™ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦æ˜¯å¦æ¨¡ç³Šäº†äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
        const halfNoteBeatPoints = [0, 2]; // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åœ¨4/4æ‹ä¸­æ˜¯ç¬¬1æ‹å’Œç¬¬3æ‹(ä½ç½®0å’Œ2)
        
        let blursHalfNoteBeatPoint = false;
        for (const beatPoint of halfNoteBeatPoints) {
            // å¦‚æœäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹è¢«è¿™ä¸ªtiedç»„è·¨è¶Šï¼Œè¯´æ˜æ¨¡ç³Šäº†äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
            if (startPosition < beatPoint + tolerance && endPosition > beatPoint + tolerance) {
                // ä½†æ˜¯å¦‚æœtiedç»„æ°å¥½ä»è¿™ä¸ªæ‹ç‚¹å¼€å§‹ï¼Œåˆ™ä¸ç®—æ¨¡ç³Š
                if (Math.abs(startPosition - beatPoint) < tolerance) {
                    continue; // ä»æ‹ç‚¹å¼€å§‹ï¼Œä¸ç®—æ¨¡ç³Š
                }
                blursHalfNoteBeatPoint = true;
                console.log(`  ğŸ” æ£€æµ‹åˆ°æ¨¡ç³ŠäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹${beatPoint}: tiedç»„[${startPosition}-${endPosition}]è·¨è¶Šäº†æ­¤æ‹ç‚¹`);
                break;
            }
        }
        
        if (!blursHalfNoteBeatPoint) {
            console.log(`  ğŸ” ä¾‹å¤–è§„åˆ™æ£€æŸ¥: tiedç»„[${startPosition}-${endPosition}]æœªæ¨¡ç³ŠäºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼Œä¸åº”ç”¨ä¾‹å¤–è§„åˆ™`);
            return false;
        }
        
        console.log(`  ğŸ¯ âœ… ä¾‹å¤–è§„åˆ™ç”Ÿæ•ˆ: ä¸¤ä¸ªæ­£æ‹å››åˆ†éŸ³ç¬¦æ¨¡ç³Šäº†äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ï¼Œå…è®¸åˆå¹¶ä¸ºäºŒåˆ†éŸ³ç¬¦`);
        return true;
    }

    /**
     * ç¡®ä¿tiedé“¾æ¡çš„tieTypeè®¾ç½®æ­£ç¡®
     * å¤šä¸ªè¿ç»­éŸ³ç¬¦åº”è¯¥å½¢æˆé“¾æ¡ï¼šfirst(start) â†’ middle(continue) â†’ last(stop)
     */
    ensureTiedChain(tiedGroup) {
        if (tiedGroup.length < 2) {
            return; // å•ä¸ªéŸ³ç¬¦æ— éœ€å¤„ç†
        }
        
        console.log(`  ğŸ”— è®¾ç½®tiedé“¾æ¡: ${tiedGroup.length}ä¸ªéŸ³ç¬¦`);
        
        // è®¾ç½®tiedé“¾æ¡çš„tieType
        for (let i = 0; i < tiedGroup.length; i++) {
            if (i === 0) {
                // ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼šstart
                tiedGroup[i].tieType = 'start';
                console.log(`    éŸ³ç¬¦${i + 1}: tieType = start`);
            } else if (i === tiedGroup.length - 1) {
                // æœ€åä¸€ä¸ªéŸ³ç¬¦ï¼šstop
                tiedGroup[i].tieType = 'stop';
                console.log(`    éŸ³ç¬¦${i + 1}: tieType = stop`);
            } else {
                // ä¸­é—´çš„éŸ³ç¬¦ï¼šcontinue (åœ¨MusicXMLä¸­ç”¨start+stopè¡¨ç¤º)
                tiedGroup[i].tieType = 'continue';
                console.log(`    éŸ³ç¬¦${i + 1}: tieType = continue`);
            }
            
            // ç¡®ä¿æ‰€æœ‰éŸ³ç¬¦éƒ½æ ‡è®°ä¸ºtied
            tiedGroup[i].tied = true;
        }
    }

    /**
     * 4/4æ‹ä¸“ç”¨ï¼šåˆå¹¶æ­£æ‹ä¸Šçš„ä¸¤ä¸ªè¿ç»­å››åˆ†éŸ³ç¬¦ä¸ºäºŒåˆ†éŸ³ç¬¦
     */
    mergeQuarterNotesOnStrongBeatsIn4_4(notes, measureIndex) {
        console.log(`ğŸµ [4/4æ‹å››åˆ†éŸ³ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†å°èŠ‚${measureIndex + 1}ï¼Œè¾“å…¥${notes.length}ä¸ªéŸ³ç¬¦`);
        
        const mergedNotes = [];
        let i = 0;
        let currentPosition = 0;
        const tolerance = 0.0001;
        
        while (i < notes.length) {
            const currentNote = notes[i];
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å››åˆ†éŸ³ç¬¦
            if (currentNote.type === 'note' && 
                Math.abs(currentNote.beats - 1.0) < tolerance && 
                i < notes.length - 1) {
                
                const nextNote = notes[i + 1];
                const nextPosition = currentPosition + currentNote.beats;
                
                // æ£€æŸ¥ä¸‹ä¸€ä¸ªéŸ³ç¬¦æ˜¯å¦ä¹Ÿæ˜¯å››åˆ†éŸ³ç¬¦
                if (nextNote && nextNote.type === 'note' && 
                    Math.abs(nextNote.beats - 1.0) < tolerance) {
                    
                    // æ£€æŸ¥ä¸¤ä¸ªéŸ³ç¬¦æ˜¯å¦åœ¨æ­£æ‹ä¸Š
                    const isFirstOnBeat = Math.abs(currentPosition - Math.floor(currentPosition)) < tolerance;
                    const isSecondOnBeat = Math.abs(nextPosition - Math.floor(nextPosition)) < tolerance;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯è¿ç»­çš„æ­£æ‹ï¼ˆ0-1, 1-2, 2-3ï¼‰
                    const areConsecutiveBeats = isFirstOnBeat && isSecondOnBeat && 
                                               Math.abs(nextPosition - currentPosition - 1.0) < tolerance;
                    
                    // ç‰¹åˆ«æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬1-2æ‹æˆ–ç¬¬3-4æ‹
                    // æ³¨æ„ï¼šä¸åŒ…æ‹¬ç¬¬2-3æ‹ï¼Œå› ä¸ºè¿™ä¼šè·¨è¶Šå¼ºå¼±æ‹
                    const isBeats1_2 = Math.abs(currentPosition) < tolerance && Math.abs(nextPosition - 1.0) < tolerance;
                    const isBeats3_4 = Math.abs(currentPosition - 2.0) < tolerance && Math.abs(nextPosition - 3.0) < tolerance;
                    
                    // æ£€æŸ¥éŸ³é«˜æ˜¯å¦ç›¸åŒï¼ˆåŒ…æ‹¬å¤„ç†tiedéŸ³ç¬¦çš„æƒ…å†µï¼‰
                    const sameNotes = currentNote.midi === nextNote.midi;
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯tiedéŸ³ç¬¦ï¼ˆå¦‚æœæ˜¯ï¼Œä¹Ÿåº”è¯¥åˆå¹¶ï¼‰
                    const areTiedNotes = currentNote.tied && currentNote.tieType === 'start' && 
                                        nextNote.tied && nextNote.tieType === 'stop';
                    
                    if (areConsecutiveBeats && (isBeats1_2 || isBeats3_4) && 
                        (sameNotes || areTiedNotes)) {
                        // åˆå¹¶æˆäºŒåˆ†éŸ³ç¬¦
                        const halfNote = {
                            ...currentNote,
                            duration: 'half',
                            beats: 2,
                            tied: false,
                            tieType: null,
                            // ä¿ç•™ç¬¬ä¸€ä¸ªéŸ³ç¬¦çš„articulationï¼ˆå¦‚æœæœ‰ï¼‰
                            articulation: currentNote.articulation
                        };
                        
                        mergedNotes.push(halfNote);
                        const endPos = nextPosition + nextNote.beats;
                        console.log(`  âœ… åˆå¹¶æ­£æ‹å››åˆ†éŸ³ç¬¦: ä½ç½®${currentPosition.toFixed(1)}-${endPos.toFixed(1)} -> äºŒåˆ†éŸ³ç¬¦`);
                        
                        i += 2; // è·³è¿‡ä¸¤ä¸ªéŸ³ç¬¦
                        currentPosition = endPos;
                        continue;
                    }
                }
            }
            
            // ä¸èƒ½åˆå¹¶ï¼Œä¿æŒåŸæ ·
            mergedNotes.push(currentNote);
            currentPosition += currentNote.beats;
            i++;
        }
        
        console.log(`ğŸµ [4/4æ‹å››åˆ†éŸ³ç¬¦åˆå¹¶] å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${mergedNotes.length}`);
        return mergedNotes;
    }
    
    /**
     * è¿éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦è‡ªåŠ¨åˆå¹¶ç®—æ³•
     * å°†è¿ç»­çš„tiedéŸ³ç¬¦å’Œè¿ç»­çš„ä¼‘æ­¢ç¬¦åˆå¹¶ä¸ºæ›´å¤§çš„æ—¶å€¼ï¼ˆå¦‚æœä¸å½±å“æ‹ç‚¹æ¸…æ™°åº¦ï¼‰
     */
    mergeTiedNotes(notes, measureIndex, criticalBeats = []) {
        console.log(`ğŸ”— åº”ç”¨è¿éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦åˆå¹¶è§„åˆ™ - å°èŠ‚${measureIndex + 1}`);
        
        // ğŸ¼ 3/4æ‹ä¸“ç”¨çš„tiedéŸ³ç¬¦ä¼˜åŒ–è½¬æ¢
        if (this.timeSignature === '3/4') {
            notes = this.optimize3_4TiedNotes(notes, measureIndex);
        }
        
        // ğŸ¼ 4/4æ‹ä¸“ç”¨ï¼šåˆå¹¶æ­£æ‹ä¸Šçš„ä¸¤ä¸ªè¿ç»­å››åˆ†éŸ³ç¬¦ä¸ºäºŒåˆ†éŸ³ç¬¦
        if (this.timeSignature === '4/4') {
            notes = this.mergeQuarterNotesOnStrongBeatsIn4_4(notes, measureIndex);
        }
        
        const mergedNotes = [];
        let i = 0;
        
        while (i < notes.length) {
            const currentNote = notes[i];
            
            // å¤„ç†ä¼‘æ­¢ç¬¦åˆå¹¶
            if (currentNote.type === 'rest') {
                const restGroup = [currentNote];
                let j = i + 1;
                
                // æ”¶é›†æ‰€æœ‰è¿ç»­çš„ä¼‘æ­¢ç¬¦ï¼ˆä¸ç®¡æ—¶å€¼æ˜¯å¦ç›¸åŒï¼‰
                while (j < notes.length && notes[j].type === 'rest') {
                    restGroup.push(notes[j]);
                    j++;
                }
                
                // å°è¯•åˆå¹¶ä¼‘æ­¢ç¬¦ï¼ˆå¦‚æœæœ‰å¤šä¸ªï¼‰
                if (restGroup.length >= 2) {
                    // è®¡ç®—ä¼‘æ­¢ç¬¦ç»„çš„ä½ç½®èŒƒå›´
                    let restGroupStartPosition = 0;
                    for (let k = 0; k < i; k++) {
                        restGroupStartPosition += notes[k].beats;
                    }
                    
                    const totalBeats = restGroup.reduce((sum, rest) => sum + rest.beats, 0);
                    const restGroupEndPosition = restGroupStartPosition + totalBeats;
                    
                    // æ£€æŸ¥åˆå¹¶åçš„ä¼‘æ­¢ç¬¦æ˜¯å¦ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦
                    const wouldAffectBeatClarity = this.checkRestMergeAffectsBeatClarity(
                        restGroupStartPosition,
                        totalBeats,
                        notes,
                        this.timeSignature
                    );
                    
                    console.log(`  ğŸ” æ£€æŸ¥ä¼‘æ­¢ç¬¦åˆå¹¶å½±å“æ‹ç‚¹: ä½ç½®${restGroupStartPosition}-${restGroupEndPosition} (${totalBeats}æ‹) â†’ ${wouldAffectBeatClarity ? 'ä¼šå½±å“' : 'ä¸å½±å“'}`);
                    
                    if (!wouldAffectBeatClarity) {
                        // ä¸å½±å“æ‹ç‚¹æ¸…æ™°åº¦ï¼Œå¯ä»¥åˆå¹¶
                        const mergedDuration = this.beatsToRestDuration(totalBeats);
                        const expectedBeats = this.durationToBeats(mergedDuration);
                        const tolerance = 0.01;
                        
                        if (Math.abs(totalBeats - expectedBeats) < tolerance) {
                            const mergedRest = {
                                type: 'rest',
                                duration: mergedDuration,
                                beats: totalBeats
                            };
                            
                            mergedNotes.push(mergedRest);
                            console.log(`  âœ… åˆå¹¶${restGroup.length}ä¸ªä¼‘æ­¢ç¬¦: ${restGroup.map(r => r.duration).join('+')} -> ${mergedDuration}`);
                            i = j; // è·³è¿‡æ•´ä¸ªä¼‘æ­¢ç¬¦ç»„
                            continue;
                        } else {
                            console.log(`  âŒ ä¼‘æ­¢ç¬¦æ€»æ—¶å€¼${totalBeats}æ— æ³•è¡¨ç¤ºä¸ºå•ä¸€ä¼‘æ­¢ç¬¦ï¼Œä¸åˆå¹¶`);
                        }
                    } else {
                        console.log(`  âŒ åˆå¹¶ä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦ï¼Œä¸åˆå¹¶`);
                    }
                }
                
                // ä¸èƒ½åˆå¹¶ï¼Œæ·»åŠ ç¬¬ä¸€ä¸ªä¼‘æ­¢ç¬¦
                mergedNotes.push(currentNote);
                i++;
                continue;
            }
            
            // ä¸æ˜¯éŸ³ç¬¦æˆ–ä¸æ˜¯tiedå¼€å§‹ï¼Œç›´æ¥æ·»åŠ 
            if (currentNote.type !== 'note' || !currentNote.tied || currentNote.tieType !== 'start') {
                mergedNotes.push(currentNote);
                i++;
                continue;
            }
            
            // æ£€æŸ¥ä¸‰è¿éŸ³ä¿æŠ¤
            if (currentNote.isTriplet) {
                mergedNotes.push(currentNote);
                i++;
                continue;
            }
            
            // æ”¶é›†è¿ç»­çš„tiedéŸ³ç¬¦ç»„ï¼ˆæ— é™åˆ¶ï¼Œå½¢æˆtiedé“¾æ¡ï¼‰
            const tiedGroup = [currentNote];
            let j = i + 1;
            
            // æ”¶é›†æ‰€æœ‰è¿ç»­çš„åŒéŸ³é«˜tiedéŸ³ç¬¦ - å¿…é¡»æ˜¯ç›¸é‚»çš„ï¼Œä¸èƒ½æœ‰å…¶ä»–éŸ³ç¬¦æˆ–ä¼‘æ­¢ç¬¦é—´éš”
            while (j < notes.length) {
                const nextNote = notes[j];
                
                // å¦‚æœä¸æ˜¯ç›¸é‚»ä½ç½®çš„éŸ³ç¬¦ï¼ˆj != i+1æ—¶ï¼‰ï¼Œæ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰étiedéŸ³ç¬¦
                if (j > i + 1) {
                    // æ£€æŸ¥å‰ä¸€ä¸ªå…ƒç´ æ˜¯å¦ä¹Ÿæ˜¯tiedç»„çš„ä¸€éƒ¨åˆ†
                    const prevInGroup = notes[j - 1];
                    if (!prevInGroup.tied || prevInGroup.midi !== currentNote.midi) {
                        // ä¸­é—´æœ‰étiedéŸ³ç¬¦æˆ–ä¸åŒéŸ³é«˜çš„éŸ³ç¬¦ï¼Œåœæ­¢æ”¶é›†
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯åŒéŸ³é«˜çš„tiedéŸ³ç¬¦
                if (nextNote.type === 'note' && 
                    nextNote.tied && 
                    nextNote.midi === currentNote.midi &&
                    !nextNote.isTriplet) {
                    
                    tiedGroup.push(nextNote);
                    
                    // å¦‚æœé‡åˆ°tiedç»“æŸï¼Œåœæ­¢æ”¶é›†
                    if (nextNote.tieType === 'stop') {
                        j++; // åŒ…å«stopéŸ³ç¬¦åç»“æŸ
                        break;
                    }
                    
                    j++;
                } else {
                    // ä¸è¿ç»­ï¼Œåœæ­¢æ”¶é›†
                    break;
                }
            }
            
            // å°è¯•åˆå¹¶tiedéŸ³ç¬¦ç»„
            if (tiedGroup.length >= 2) {
                const totalBeats = tiedGroup.reduce((sum, note) => sum + note.beats, 0);
                const mergedDuration = this.beatsToNoteDuration(totalBeats);
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºæ ‡å‡†éŸ³ç¬¦æ—¶å€¼ï¼ˆå…è®¸ä¸€å®šè¯¯å·®ï¼‰
                const expectedBeats = this.durationToBeats(mergedDuration);
                const tolerance = 0.01;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºäº†beat clarityæ‹†åˆ†çš„éŸ³ç¬¦ï¼ˆä¸åº”è¯¥åˆå¹¶ï¼‰
                // ä½¿ç”¨æ™ºèƒ½å±€éƒ¨èŠ‚å¥åˆ†ææ¥å†³å®šæ˜¯å¦éœ€è¦ä¿æŒæ‹†åˆ†
                
                // è®¡ç®—tiedç»„çš„æ—¶é—´èŒƒå›´
                const tiedStartPos = this.calculateNotePosition(notes, tiedGroup[0]);
                const tiedEndPos = tiedStartPos + totalBeats;
                
                // åˆ†ætiedç»„æ‰€åœ¨æ—¶é—´æ®µçš„å±€éƒ¨èŠ‚å¥å¤æ‚åº¦
                // ä½¿ç”¨æ–°è§„åˆ™ï¼šåˆ¤æ–­tiedç»„æ‰€åœ¨çš„äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸçš„æœ€å°æ—¶å€¼
                let hasLocalFineDivisions = false;
                
                // ç¡®å®štiedç»„æ‰€åœ¨çš„äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹åŒºåŸŸ
                const regionStart = tiedStartPos < 2 ? 0 : 2;
                const regionEnd = tiedStartPos < 2 ? 2 : 4;
                
                let regionMinValue = Infinity;
                for (const note of notes) {
                    if (note.isTriplet) continue;
                    
                    const notePos = this.calculateNotePosition(notes, note);
                    const noteEnd = notePos + note.beats;
                    
                    // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦ä¸tiedç»„æ‰€åœ¨çš„äºŒåˆ†éŸ³ç¬¦åŒºåŸŸæœ‰é‡å 
                    if (noteEnd > regionStart && notePos < regionEnd) {
                        regionMinValue = Math.min(regionMinValue, note.beats);
                    }
                }
                
                // æ ¹æ®æ–°è§„åˆ™åˆ¤æ–­æ˜¯å¦æœ‰ç»†åˆ†éŸ³ç¬¦éœ€è¦ä¿æŒæ‹ç‚¹æ¸…æ™°
                if (regionMinValue <= 0.25) {
                    // åŒºåŸŸæœ€å°æ—¶å€¼æ˜¯16åˆ†éŸ³ç¬¦ â†’ éœ€è¦å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°
                    hasLocalFineDivisions = true;
                } else if (regionMinValue <= 0.5) {
                    // åŒºåŸŸæœ€å°æ—¶å€¼æ˜¯8åˆ†éŸ³ç¬¦ â†’ éœ€è¦äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°ï¼Œä½†ä¸å½±å“quarter+quarteråˆå¹¶
                    hasLocalFineDivisions = false;
                } else {
                    // åŒºåŸŸæœ€å°æ—¶å€¼æ˜¯4åˆ†éŸ³ç¬¦æˆ–æ›´é•¿ â†’ ä¸éœ€è¦é¢å¤–æ‹ç‚¹é™åˆ¶
                    hasLocalFineDivisions = false;
                }
                
                // æ£€æµ‹æ˜¯å¦ä¸ºbeat clarityæ‹†åˆ†ï¼š
                // æ ¹æ®æ–°è§„åˆ™ï¼šæ‰€æœ‰è·¨æ‹éŸ³ç¬¦éƒ½åº”è¯¥æ‹†åˆ†ï¼Œé™¤éåœ¨è‡ªå·±å¯¹åº”çš„æ­£æ‹ä¸Š
                // å…³é”®ä¿®å¤ï¼šæ£€æŸ¥beatsæ€»å’Œè€Œédurationå­—æ®µï¼Œå› ä¸ºæ‹†åˆ†åçš„durationä¼šæ ¹æ®beatsé‡æ–°è®¡ç®—
                
                // æ™ºèƒ½åˆå¹¶é€»è¾‘ï¼šåŒºåˆ†è·¨æ‹æ‹†åˆ†å’Œå¯åˆå¹¶çš„è¿éŸ³ç¬¦
                // ğŸ”¥ ä¼ å…¥å…³é”®æ‹ç‚¹ä¿¡æ¯ï¼Œç¡®ä¿å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹çš„æ‹†åˆ†ä¿æŠ¤
                const isActualCrossBeatSplit = this.isActualCrossBeatSplit(tiedGroup, notes, criticalBeats);
                
                const isBeatClaritySplit = tiedGroup.length >= 2 && 
                    tiedGroup[0].tieType === 'start' && 
                    tiedGroup[tiedGroup.length - 1].tieType === 'stop' && 
                    isActualCrossBeatSplit; // åªä¿æŠ¤çœŸæ­£çš„è·¨æ‹æ‹†åˆ†
                
                // ğŸ¯ æ–°å¢ä¾‹å¤–è§„åˆ™ï¼šå½“æœ€å°éŸ³ç¬¦æ—¶å€¼æ˜¯å…«åˆ†éŸ³ç¬¦æ—¶ï¼Œä¸¤ä¸ªåœ¨æ­£æ‹ä¸Šçš„å››åˆ†éŸ³ç¬¦å¯ä»¥åˆå¹¶
                // ğŸ”¥ ä¼ å…¥å…³é”®æ‹ç‚¹ä¿¡æ¯ï¼Œåœ¨å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ç¦ç”¨æ­¤ä¾‹å¤–
                const quarterNoteException = this.checkQuarterNoteOnStrongBeatException(tiedGroup, notes, tiedStartPos, criticalBeats);
                
                // ğŸ¼ ç›¸é‚»æ­£æ‹éŸ³ç¬¦åˆå¹¶è§„åˆ™ï¼šä¸¤ä¸ªç›¸åŒæ—¶å€¼çš„éŸ³ç¬¦åœ¨ç›¸é‚»æ­£æ‹ä¸Šï¼Œåº”è¯¥åˆå¹¶è€Œä¸ä½¿ç”¨è¿çº¿
                // ğŸ”¥ ä¼ å…¥å…³é”®æ‹ç‚¹ä¿¡æ¯ï¼Œé˜²æ­¢åœ¨æ‹ç‚¹ä¿æŠ¤åœºæ™¯ä¸‹é”™è¯¯åˆå¹¶
                const adjacentBeatMerge = this.checkAdjacentBeatMerge(tiedGroup, notes, criticalBeats);
                
                // ğŸš¨ å¼ºåˆ¶ç¦æ­¢åˆå¹¶æ‹†åˆ†éŸ³ç¬¦ï¼ˆç”¨äºè¿æ†ï¼‰
                const isSplitForBeaming = tiedGroup.length === 2 && 
                    tiedGroup[0].tieType === 'start' && 
                    tiedGroup[1].tieType === 'stop';
                
                if ((isBeatClaritySplit && !quarterNoteException && !adjacentBeatMerge) || isSplitForBeaming) {
                    // ä¿æŒæ‹†åˆ†çŠ¶æ€ä»¥ç»´æŒbeat clarityï¼Œä½†ç¡®ä¿tiedé“¾æ¡æ­£ç¡®
                    this.ensureTiedChain(tiedGroup);
                    tiedGroup.forEach(note => mergedNotes.push(note));
                    const reason = isSplitForBeaming ? '(ä¿æŒè¿æ†èƒ½åŠ›)' : `(åŒºåŸŸæœ€å°æ—¶å€¼=${regionMinValue}æ‹, éœ€è¦ç»†åˆ†æ‹ç‚¹=${hasLocalFineDivisions})`;
                    console.log(`  âŒ ä¿æŒæ‹†åˆ†: ${tiedGroup.map(n => n.duration).join('+')} ${reason}`);
                    i += tiedGroup.length; // æ­£ç¡®è·³è¿‡å·²å¤„ç†çš„éŸ³ç¬¦æ•°é‡
                } else if (Math.abs(totalBeats - expectedBeats) < tolerance) {
                    // å¯ä»¥åˆå¹¶
                    const mergeReason = adjacentBeatMerge ? 'ğŸ¼ğŸ¼ ç›¸é‚»æ­£æ‹åˆå¹¶ ğŸ¼ğŸ¼' : 
                                      quarterNoteException ? 'ä¾‹å¤–è§„åˆ™(æ­£æ‹å››åˆ†éŸ³ç¬¦â†’äºŒåˆ†éŸ³ç¬¦)' : 'æ­£å¸¸åˆå¹¶';
                    const mergedNote = {
                        type: 'note',
                        duration: mergedDuration,
                        beats: totalBeats,
                        step: currentNote.step,
                        octave: currentNote.octave,
                        alter: currentNote.alter,
                        midi: currentNote.midi
                        // ç§»é™¤tiedå±æ€§
                    };
                    
                    mergedNotes.push(mergedNote);
                    console.log(`  âœ… åˆå¹¶${tiedGroup.length}ä¸ªè¿éŸ³ç¬¦: ${tiedGroup.map(n => n.duration).join('+')} -> ${mergedDuration} (${mergeReason})`);
                    
                    i += tiedGroup.length; // è·³è¿‡å·²åˆå¹¶çš„éŸ³ç¬¦æ•°é‡
                } else {
                    // ä¸èƒ½åˆå¹¶ï¼Œä¿æŒåŸæ ·ï¼Œä½†ç¡®ä¿tiedé“¾æ¡æ­£ç¡®
                    this.ensureTiedChain(tiedGroup);
                    tiedGroup.forEach(note => mergedNotes.push(note));
                    console.log(`  âŒ æ— æ³•åˆå¹¶${tiedGroup.length}ä¸ªè¿éŸ³ç¬¦: æ€»æ—¶é•¿${totalBeats}æ‹ä¸ç­‰äºæ ‡å‡†æ—¶å€¼`);
                    i += tiedGroup.length; // è·³è¿‡å·²å¤„ç†çš„éŸ³ç¬¦æ•°é‡
                }
            } else {
                // å•ç‹¬çš„tiedéŸ³ç¬¦ï¼Œä¿æŒåŸæ ·
                mergedNotes.push(currentNote);
                i++;
            }
        }
        
        console.log(`âœ… è¿éŸ³ç¬¦åˆå¹¶å®Œæˆ: ${notes.length} -> ${mergedNotes.length} ä¸ªå…ƒç´ `);
        return mergedNotes;
    }

    /**
     * 3/4æ‹ä¸“ç”¨çš„tiedéŸ³ç¬¦ä¼˜åŒ–è½¬æ¢
     */
    optimize3_4TiedNotes(notes, measureIndex) {
        console.log(`ğŸ¼ [3/4æ‹tiedéŸ³ç¬¦ä¼˜åŒ–] å¼€å§‹å¤„ç†å°èŠ‚${measureIndex + 1}ï¼Œè¾“å…¥${notes.length}ä¸ªéŸ³ç¬¦`);
        
        // æ˜¾ç¤ºè¾“å…¥éŸ³ç¬¦è¯¦æƒ…
        notes.forEach((note, i) => {
            console.log(`  è¾“å…¥éŸ³ç¬¦${i}: ${note.type} ${note.duration} beats:${note.beats} tied:${note.tied} midi:${note.midi}`);
        });
        
        let optimizedNotes = [...notes];
        
        // ğŸ¯ è½¬æ¢1: å››åˆ†éŸ³ç¬¦+äºŒåˆ†éŸ³ç¬¦ -> é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ (æœ€é«˜ä¼˜å…ˆçº§)
        // ğŸ¯ è½¬æ¢2: äºŒåˆ†éŸ³ç¬¦+å››åˆ†éŸ³ç¬¦ -> é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ (æœ€é«˜ä¼˜å…ˆçº§)
        console.log(`ğŸ”¥ [3/4æ‹ä¼˜åŒ–] æ‰§è¡Œæ ¸å¿ƒè½¬æ¢: å››åˆ†+äºŒåˆ†éŸ³ç¬¦ç»„åˆ`);
        optimizedNotes = this.convertQuarterHalfToeDottedHalf(optimizedNotes);
        
        // è½¬æ¢3: å…­ä¸ªè¿ç»­å…«åˆ†éŸ³ç¬¦ -> å…«åˆ†éŸ³ç¬¦+é™„ç‚¹å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦
        optimizedNotes = this.convertSixEighthsToOptimalPattern(optimizedNotes);
        
        // è½¬æ¢4: æ‰©å±•çš„å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ä¼˜åŒ–ï¼ˆåŒ…æ‹¬ä¼‘æ­¢ç¬¦ï¼‰
        optimizedNotes = this.convertSixEighthsPatternWithRests(optimizedNotes);
        
        // è½¬æ¢5: åæ‹ä½ç½®çš„å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦ä¼˜åŒ–
        optimizedNotes = this.convertOffbeatTiedEighths(optimizedNotes);
        
        // è½¬æ¢6: å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹çš„è¿çº¿éŸ³ç¬¦åˆå¹¶ï¼ˆåªè¦ä¿è¯å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°ï¼‰
        optimizedNotes = this.mergeConnectedNotesInEighthNoteScenario(optimizedNotes);
        
        // è½¬æ¢7: ç¡®ä¿è‡³å°‘ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ˜ç¡®
        optimizedNotes = this.ensureTwoBeatPointsClarity(optimizedNotes);
        
        // è½¬æ¢8: æ‹ç‚¹å†…ä¼‘æ­¢ç¬¦åˆå¹¶
        optimizedNotes = this.mergeBeatPointRests(optimizedNotes);
        
        // ğŸ“Š æœ€ç»ˆéªŒè¯å’Œç»Ÿè®¡
        console.log(`ğŸ¼ [3/4æ‹tiedéŸ³ç¬¦ä¼˜åŒ–] å®Œæˆå¤„ç†ï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«é™„ç‚¹éŸ³ç¬¦ï¼ˆä¼˜åŒ–æˆåŠŸçš„æ ‡å¿—ï¼‰
        const dottedHalves = optimizedNotes.filter(n => n.duration === 'half.').length;
        const dottedQuarters = optimizedNotes.filter(n => n.duration === 'quarter.').length;
        const tiedNotes = optimizedNotes.filter(n => n.tied === true).length;
        
        console.log(`ğŸ“ˆ [3/4æ‹ä¼˜åŒ–ç»“æœç»Ÿè®¡]:`);
        console.log(`  é™„ç‚¹äºŒåˆ†éŸ³ç¬¦: ${dottedHalves}ä¸ª`);
        console.log(`  é™„ç‚¹å››åˆ†éŸ³ç¬¦: ${dottedQuarters}ä¸ª`);
        console.log(`  å‰©ä½™tiedéŸ³ç¬¦: ${tiedNotes}ä¸ª`);
        
        if (dottedHalves > 0) {
            console.log(`âœ… [3/4æ‹ä¼˜åŒ–æˆåŠŸ] æˆåŠŸè½¬æ¢äº†${dottedHalves}ä¸ªé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼`);
        } else if (notes.length >= 2) {
            console.log(`âš ï¸ [3/4æ‹ä¼˜åŒ–æé†’] æœªæ‰¾åˆ°å¯è½¬æ¢çš„å››åˆ†+äºŒåˆ†éŸ³ç¬¦ç»„åˆ`);
        }
        
        // æ˜¾ç¤ºæœ€ç»ˆéŸ³ç¬¦è¯¦æƒ…
        optimizedNotes.forEach((note, i) => {
            console.log(`  è¾“å‡ºéŸ³ç¬¦${i}: ${note.type} ${note.duration} beats:${note.beats} tied:${note.tied}`);
        });
        
        return optimizedNotes;
    }

    /**
     * è½¬æ¢å››åˆ†éŸ³ç¬¦+äºŒåˆ†éŸ³ç¬¦æˆ–äºŒåˆ†éŸ³ç¬¦+å››åˆ†éŸ³ç¬¦ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
     */
    convertQuarterHalfToeDottedHalf(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥å››åˆ†+äºŒåˆ†éŸ³ç¬¦ç»„åˆè½¬æ¢ï¼Œå…±${notes.length}ä¸ªéŸ³ç¬¦`);
        
        // è¯¦ç»†æ—¥å¿—ï¼šæ˜¾ç¤ºæ‰€æœ‰éŸ³ç¬¦ä¿¡æ¯
        notes.forEach((note, index) => {
            console.log(`  éŸ³ç¬¦${index}: duration=${note.duration}, type=${note.type}, tieType=${note.tieType}, tied=${note.tied}`);
        });
        
        const optimizedNotes = [];
        let i = 0;
        
        while (i < notes.length) {
            const currentNote = notes[i];
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦ä¼˜åŒ–çš„éŸ³ç¬¦ç»„åˆ  
            if (currentNote.type === 'note' && i < notes.length - 1) {
                const nextNote = notes[i + 1];
                
                console.log(`  æ£€æŸ¥éŸ³ç¬¦å¯¹${i}-${i+1}: ${currentNote.duration}(tied:${currentNote.tied}) + ${nextNote.duration}(tied:${nextNote.tied})`);
                
                // ğŸ¯ æ ¸å¿ƒä¼˜åŒ–ï¼šå››åˆ†éŸ³ç¬¦+äºŒåˆ†éŸ³ç¬¦ OR äºŒåˆ†éŸ³ç¬¦+å››åˆ†éŸ³ç¬¦ -> é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                const isQuarterHalfPattern = (
                    (currentNote.duration === 'quarter' && nextNote.duration === 'half') ||
                    (currentNote.duration === 'half' && nextNote.duration === 'quarter')
                );
                
                const areBothNotes = (currentNote.type === 'note' && nextNote.type === 'note');
                
                // ğŸ¯ ä¸¥æ ¼æ£€æŸ¥ï¼šå¿…é¡»æ˜¯ç›¸åŒéŸ³é«˜ä¸”ç›¸é‚»çš„éŸ³ç¬¦æ‰èƒ½è½¬æ¢ä¸ºé™„ç‚¹éŸ³ç¬¦
                const haveSamePitch = (
                    currentNote.midi && nextNote.midi && currentNote.midi === nextNote.midi
                );
                
                // âœ¨ æ–°å¢ï¼šæ£€æŸ¥éŸ³ç¬¦çš„ä½ç½®æ˜¯å¦é€‚åˆåˆå¹¶ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                const canFormDottedHalf = this.canFormDottedHalfIn3_4(currentNote, nextNote, i, notes);
                
                // ğŸ¯ ç²¾ç¡®ä¼˜åŒ–ï¼šåªè½¬æ¢ç¬¦åˆæ¡ä»¶çš„å››åˆ†+äºŒåˆ†æˆ–äºŒåˆ†+å››åˆ†åŒéŸ³ç»„åˆ
                if (isQuarterHalfPattern && areBothNotes && haveSamePitch && canFormDottedHalf) {
                    console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] å‘ç°å¯è½¬æ¢çš„å››åˆ†éŸ³ç¬¦+äºŒåˆ†éŸ³ç¬¦ç»„åˆï¼Œè½¬æ¢ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦`);
                    console.log(`    åŸå§‹: ${currentNote.duration}(${currentNote.midi}) + ${nextNote.duration}(${nextNote.midi})`);
                    
                    // åˆ›å»ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                    const dottedHalfNote = {
                        ...currentNote,
                        duration: 'half.',
                        beats: 3,
                        tied: false,
                        tieType: null // ç§»é™¤tieæ ‡è®°
                    };
                    
                    console.log(`âœ… [3/4æ‹ä¼˜åŒ–] æˆåŠŸåˆ›å»ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦(midi:${dottedHalfNote.midi})`);
                    optimizedNotes.push(dottedHalfNote);
                    i += 2; // è·³è¿‡ä¸‹ä¸€ä¸ªéŸ³ç¬¦
                    continue;
                }
            }
            
            // ä¸ç¬¦åˆè½¬æ¢æ¡ä»¶ï¼Œä¿æŒåŸæ ·
            optimizedNotes.push(currentNote);
            i++;
        }
        
        // ğŸš€ å¼ºåˆ¶ä¼˜åŒ–ï¼šå¦‚æœæ²¡æœ‰æ‰¾åˆ°tiedæ¨¡å¼ï¼Œç›´æ¥å¯»æ‰¾å››åˆ†+äºŒåˆ†æˆ–äºŒåˆ†+å››åˆ†ç»„åˆå¹¶å¼ºåˆ¶è½¬æ¢
        if (optimizedNotes.length === notes.length && notes.length >= 2) {
            console.log(`ğŸ” [3/4æ‹å¼ºåˆ¶ä¼˜åŒ–] æœªæ‰¾åˆ°tiedæ¨¡å¼ï¼Œå°è¯•å¼ºåˆ¶è½¬æ¢ä»»ä½•å››åˆ†+äºŒåˆ†æˆ–äºŒåˆ†+å››åˆ†ç»„åˆ`);
            
            for (let j = 0; j < notes.length - 1; j++) {
                const note1 = notes[j];
                const note2 = notes[j + 1];
                
                // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯å››åˆ†+äºŒåˆ†æˆ–äºŒåˆ†+å››åˆ†çš„åŒéŸ³ç¬¦ç»„åˆ
                if (note1.type === 'note' && note2.type === 'note') {
                    const isQuarterHalf = (note1.duration === 'quarter' && note2.duration === 'half');
                    const isHalfQuarter = (note1.duration === 'half' && note2.duration === 'quarter');
                    const haveSamePitch = (note1.midi && note2.midi && note1.midi === note2.midi);
                    
                    if ((isQuarterHalf || isHalfQuarter) && haveSamePitch) {
                        console.log(`ğŸ¯ [3/4æ‹å¼ºåˆ¶ä¼˜åŒ–] æ‰¾åˆ°${note1.duration}+${note2.duration}åŒéŸ³ç»„åˆï¼Œå¼ºåˆ¶è½¬æ¢ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦`);
                        console.log(`    éŸ³ç¬¦1: ${note1.duration}(midi:${note1.midi})`);
                        console.log(`    éŸ³ç¬¦2: ${note2.duration}(midi:${note2.midi})`);
                        
                        // åˆ›å»ºå¼ºåˆ¶ä¼˜åŒ–ç‰ˆæœ¬
                        const forcedOptimized = [];
                        for (let k = 0; k < notes.length; k++) {
                            if (k === j) {
                                // æ·»åŠ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                                forcedOptimized.push({
                                    ...note1,
                                    duration: 'half.',
                                    beats: 3,
                                    tied: false,
                                    tieType: null
                                });
                                console.log(`âœ… [3/4æ‹å¼ºåˆ¶ä¼˜åŒ–] åˆ›å»ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ›¿æ¢ä½ç½®${j}-${j+1}`);
                            } else if (k === j + 1) {
                                // è·³è¿‡ç¬¬äºŒä¸ªéŸ³ç¬¦
                                continue;
                            } else {
                                forcedOptimized.push(notes[k]);
                            }
                        }
                        console.log(`ğŸš€ [3/4æ‹å¼ºåˆ¶ä¼˜åŒ–] å¼ºåˆ¶è½¬æ¢æˆåŠŸï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${forcedOptimized.length}`);
                        return forcedOptimized;
                    }
                }
            }
            // ç§»é™¤äº†è¶…æ¿€è¿›ä¼˜åŒ–ï¼Œé¿å…é”™è¯¯è½¬æ¢ä¸åŒéŸ³é«˜çš„éŸ³ç¬¦ç»„åˆ
            
            console.log(`âš ï¸ [3/4æ‹å¼ºåˆ¶ä¼˜åŒ–] æœªæ‰¾åˆ°ä»»ä½•å››åˆ†+äºŒåˆ†æˆ–äºŒåˆ†+å››åˆ†ç»„åˆ`);
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] å››åˆ†+äºŒåˆ†éŸ³ç¬¦è½¬æ¢å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }

    /**
     * æ£€æŸ¥ä¸¤ä¸ªéŸ³ç¬¦æ˜¯å¦å¯ä»¥åœ¨3/4æ‹ä¸­å½¢æˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
     */
    canFormDottedHalfIn3_4(note1, note2, startIndex, allNotes) {
        // åŸºæœ¬æ£€æŸ¥ï¼šå¿…é¡»æ˜¯ç›¸åŒéŸ³é«˜çš„éŸ³ç¬¦
        if (!note1.midi || !note2.midi || note1.midi !== note2.midi) {
            console.log(`  âŒ [3/4æ‹æ£€æŸ¥] éŸ³é«˜ä¸åŒï¼Œä¸èƒ½åˆå¹¶: ${note1.midi} vs ${note2.midi}`);
            return false;
        }

        // æ£€æŸ¥æ—¶å€¼ç»„åˆï¼šå››åˆ†+äºŒåˆ†(1+2=3) æˆ– äºŒåˆ†+å››åˆ†(2+1=3)
        const totalBeats = note1.beats + note2.beats;
        if (Math.abs(totalBeats - 3) > 0.001) {
            console.log(`  âŒ [3/4æ‹æ£€æŸ¥] æ€»æ—¶å€¼ä¸æ˜¯3æ‹: ${totalBeats}`);
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå°èŠ‚è¾¹ç•Œï¼ˆ3/4æ‹ä¸€å°èŠ‚3æ‹ï¼‰
        let currentPosition = 0;
        for (let i = 0; i < startIndex; i++) {
            currentPosition += allNotes[i].beats || 0;
        }
        
        // ç¡®ä¿è¿™ä¸¤ä¸ªéŸ³ç¬¦çš„åˆå¹¶ä¸ä¼šè·¨è¶Šå°èŠ‚è¾¹ç•Œ
        const startPos = currentPosition % 3;
        const endPos = (currentPosition + totalBeats) % 3;
        
        if (startPos === 0 && Math.abs(endPos - 0) < 0.001) {
            // å®Œæ•´å æ®ä¸€ä¸ª3/4å°èŠ‚ï¼Œè¿™æ˜¯ç†æƒ³æƒ…å†µ
            console.log(`  âœ… [3/4æ‹æ£€æŸ¥] å®Œæ•´å æ®ä¸€ä¸ªå°èŠ‚ï¼Œå¯ä»¥åˆå¹¶ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦`);
            return true;
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨å°èŠ‚å†…çš„åˆç†ä½ç½®
        if (startPos + totalBeats <= 3.001) {
            console.log(`  âœ… [3/4æ‹æ£€æŸ¥] åœ¨å°èŠ‚å†…åˆç†ä½ç½®ï¼Œå¯ä»¥åˆå¹¶ä¸ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦`);
            return true;
        }

        console.log(`  âŒ [3/4æ‹æ£€æŸ¥] è·¨è¶Šå°èŠ‚è¾¹ç•Œï¼Œä¸é€‚åˆåˆå¹¶: èµ·å§‹ä½ç½®${startPos}, æ€»é•¿åº¦${totalBeats}`);
        return false;
    }

    /**
     * è½¬æ¢å…­ä¸ªè¿ç»­å…«åˆ†éŸ³ç¬¦ä¸ºä¼˜åŒ–æ¨¡å¼: å…«åˆ†éŸ³ç¬¦+é™„ç‚¹å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦
     */
    convertSixEighthsToOptimalPattern(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥å…­ä¸ªå…«åˆ†éŸ³ç¬¦ç»„åˆè½¬æ¢`);
        
        const optimizedNotes = [];
        let i = 0;
        
        while (i < notes.length) {
            // æ£€æŸ¥æ˜¯å¦æœ‰è¿ç»­å…­ä¸ªå…«åˆ†éŸ³ç¬¦ï¼ˆå¯èƒ½åŒ…å«tiedè¿æ¥ï¼‰
            if (this.isSixConsecutiveEighths(notes, i)) {
                console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] å‘ç°å…­ä¸ªè¿ç»­å…«åˆ†éŸ³ç¬¦ï¼Œè½¬æ¢ä¸ºä¼˜åŒ–æ¨¡å¼`);
                
                const sixEighths = notes.slice(i, i + 6);
                const optimizedPattern = this.createOptimizedSixEighthsPattern(sixEighths);
                
                optimizedNotes.push(...optimizedPattern);
                i += 6; // è·³è¿‡å…­ä¸ªå…«åˆ†éŸ³ç¬¦
                continue;
            }
            
            // ä¸ç¬¦åˆè½¬æ¢æ¡ä»¶ï¼Œä¿æŒåŸæ ·
            optimizedNotes.push(notes[i]);
            i++;
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] å…­ä¸ªå…«åˆ†éŸ³ç¬¦è½¬æ¢å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }

    /**
     * æ£€æŸ¥ä»æŒ‡å®šä½ç½®å¼€å§‹æ˜¯å¦æœ‰å…­ä¸ªè¿ç»­çš„å…«åˆ†éŸ³ç¬¦
     */
    isSixConsecutiveEighths(notes, startIndex) {
        if (startIndex + 5 >= notes.length) return false;
        
        for (let i = 0; i < 6; i++) {
            const note = notes[startIndex + i];
            
            // å¿…é¡»éƒ½æ˜¯å…«åˆ†éŸ³ç¬¦ï¼ˆåŒ…æ‹¬å…«åˆ†ä¼‘æ­¢ç¬¦ï¼‰
            if (note.duration !== 'eighth') return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦ç¬¦åˆæ¨¡å¼ï¼šç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ˜¯ç‹¬ç«‹çš„ï¼Œä¸­é—´å››ä¸ªæ˜¯tiedè¿æ¥
        const first = notes[startIndex];
        const second = notes[startIndex + 1];
        const fifth = notes[startIndex + 4];
        const sixth = notes[startIndex + 5];
        
        // ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼šå¯ä»¥æ˜¯ä¼‘æ­¢ç¬¦æˆ–ç‹¬ç«‹éŸ³ç¬¦ï¼ˆä¸åº”è¯¥æœ‰tie startï¼‰
        // ç¬¬äºŒåˆ°ç¬¬äº”ä¸ªéŸ³ç¬¦ï¼šåº”è¯¥æ˜¯tiedè¿æ¥ï¼ˆ2-3-4-5ï¼‰
        // ç¬¬å…­ä¸ªéŸ³ç¬¦ï¼šå¯ä»¥æ˜¯ä¼‘æ­¢ç¬¦æˆ–ç‹¬ç«‹éŸ³ç¬¦ï¼ˆä¸åº”è¯¥æœ‰tie stopï¼‰
        
        const middleFourAreTied = 
            second.tieType === 'start' && 
            notes[startIndex + 2].tieType === 'continue' &&
            notes[startIndex + 3].tieType === 'continue' &&
            fifth.tieType === 'stop' &&
            this.notesHaveSamePitch(second, notes[startIndex + 2]) &&
            this.notesHaveSamePitch(notes[startIndex + 2], notes[startIndex + 3]) &&
            this.notesHaveSamePitch(notes[startIndex + 3], fifth);
        
        return middleFourAreTied;
    }

    /**
     * åˆ›å»ºä¼˜åŒ–çš„å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼: å…«åˆ†éŸ³ç¬¦+é™„ç‚¹å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦
     */
    createOptimizedSixEighthsPattern(sixEighths) {
        const first = sixEighths[0];  // ç¬¬ä¸€ä¸ªå…«åˆ†éŸ³ç¬¦ï¼ˆå¯èƒ½æ˜¯ä¼‘æ­¢ç¬¦ï¼‰
        const tiedGroup = sixEighths.slice(1, 5); // ä¸­é—´å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦
        const last = sixEighths[5];   // æœ€åä¸€ä¸ªå…«åˆ†éŸ³ç¬¦ï¼ˆå¯èƒ½æ˜¯ä¼‘æ­¢ç¬¦ï¼‰
        
        // å°†ä¸­é—´å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦åˆå¹¶ä¸ºä¸€ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦
        const dottedQuarter = {
            ...tiedGroup[0], // ä½¿ç”¨ç¬¬ä¸€ä¸ªtiedéŸ³ç¬¦çš„å±æ€§
            duration: 'quarter.',
            beats: 1.5,
            tieType: null // ç§»é™¤tieæ ‡è®°
        };
        
        // ç¡®ä¿ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªéŸ³ç¬¦æ²¡æœ‰tieæ ‡è®°
        const optimizedFirst = { ...first, tieType: null };
        const optimizedLast = { ...last, tieType: null };
        
        console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] åˆ›å»ºä¼˜åŒ–æ¨¡å¼: å…«åˆ†éŸ³ç¬¦ + é™„ç‚¹å››åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦`);
        
        return [optimizedFirst, dottedQuarter, optimizedLast];
    }

    /**
     * è½¬æ¢æ‰©å±•çš„å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåŒ…æ‹¬ä¼‘æ­¢ç¬¦ï¼‰
     * æ¨¡å¼ï¼šå…«åˆ†éŸ³ç¬¦/ä¼‘æ­¢ç¬¦ + å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦/ä¼‘æ­¢ç¬¦
     * è½¬ä¸ºï¼šå…«åˆ†éŸ³ç¬¦/ä¼‘æ­¢ç¬¦ + å…«åˆ†éŸ³ç¬¦tiedé™„ç‚¹å››åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦/ä¼‘æ­¢ç¬¦
     */
    convertSixEighthsPatternWithRests(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥æ‰©å±•å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåŒ…å«ä¼‘æ­¢ç¬¦ï¼‰ï¼Œå…±${notes.length}ä¸ªéŸ³ç¬¦`);
        
        // è¯¦ç»†æ—¥å¿—ï¼šæ˜¾ç¤ºæ‰€æœ‰éŸ³ç¬¦ä¿¡æ¯
        notes.forEach((note, index) => {
            console.log(`  éŸ³ç¬¦${index}: duration=${note.duration}, type=${note.type}, tieType=${note.tieType}, tied=${note.tied}`);
        });
        
        const optimizedNotes = [];
        let i = 0;
        
        while (i < notes.length) {
            if (this.isSixEighthsPatternWithRests(notes, i)) {
                console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] å‘ç°æ‰©å±•å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œè½¬æ¢ä¸ºä¼˜åŒ–æ¨¡å¼`);
                
                const sixEighths = notes.slice(i, i + 6);
                const optimizedPattern = this.createOptimizedSixEighthsPatternWithRests(sixEighths);
                
                optimizedNotes.push(...optimizedPattern);
                i += 6; // è·³è¿‡å…­ä¸ªéŸ³ç¬¦/ä¼‘æ­¢ç¬¦
                continue;
            }
            
            optimizedNotes.push(notes[i]);
            i++;
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ‰©å±•å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼è½¬æ¢å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }
    
    /**
     * æ£€æŸ¥æ‰©å±•çš„å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå¯ä»¥æ˜¯ä¼‘æ­¢ç¬¦ï¼‰
     */
    isSixEighthsPatternWithRests(notes, startIndex) {
        if (startIndex + 5 >= notes.length) return false;
        
        const pattern = notes.slice(startIndex, startIndex + 6);
        
        // æ£€æŸ¥æ‰€æœ‰éƒ½æ˜¯å…«åˆ†éŸ³ç¬¦æˆ–å…«åˆ†ä¼‘æ­¢ç¬¦
        for (let i = 0; i < 6; i++) {
            const note = pattern[i];
            if (note.duration !== 'eighth') return false;
        }
        
        // æ£€æŸ¥æ¨¡å¼ï¼šç¬¬ä¸€ä¸ªï¼ˆä»»æ„ï¼‰ï¼Œä¸­é—´å››ä¸ªtiedè¿æ¥ï¼Œæœ€åä¸€ä¸ªï¼ˆä»»æ„ï¼‰
        const first = pattern[0];
        const tiedGroup = pattern.slice(1, 5);
        const last = pattern[5];
        
        // ç¬¬ä¸€ä¸ªéŸ³ç¬¦/ä¼‘æ­¢ç¬¦å¿…é¡»ç‹¬ç«‹ï¼ˆæ²¡æœ‰tieTypeæˆ–tieTypeä¸ºnullï¼‰
        if (first.tieType && first.tieType !== null) return false;
        
        // ä¸­é—´å››ä¸ªå¿…é¡»æ˜¯tiedè¿æ¥çš„éŸ³ç¬¦ï¼ˆä¸èƒ½æ˜¯ä¼‘æ­¢ç¬¦ï¼‰
        if (tiedGroup[0].type === 'rest') return false; // tiedç»„ä¸èƒ½ä»¥ä¼‘æ­¢ç¬¦å¼€å§‹
        if (!tiedGroup[0].tied) return false; // å¿…é¡»æ˜¯tiedéŸ³ç¬¦
        
        for (let i = 1; i < 4; i++) {
            if (tiedGroup[i].type === 'rest') return false;
            if (!tiedGroup[i].tied) return false; // å¿…é¡»æ˜¯tiedéŸ³ç¬¦
            // ç®€åŒ–éŸ³é«˜æ£€æŸ¥
            if (tiedGroup[i].midi && tiedGroup[0].midi && tiedGroup[i].midi !== tiedGroup[0].midi) return false;
        }
        
        // æœ€åä¸€ä¸ªéŸ³ç¬¦/ä¼‘æ­¢ç¬¦å¿…é¡»ç‹¬ç«‹
        if (last.tieType && last.tieType !== null) return false;
        
        return true;
    }
    
    /**
     * åˆ›å»ºæ‰©å±•å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼çš„ä¼˜åŒ–ç‰ˆæœ¬
     */
    createOptimizedSixEighthsPatternWithRests(sixEighths) {
        const first = sixEighths[0];  // ç¬¬ä¸€ä¸ªï¼ˆéŸ³ç¬¦æˆ–ä¼‘æ­¢ç¬¦ï¼‰
        const tiedGroup = sixEighths.slice(1, 5); // ä¸­é—´å››ä¸ªtiedéŸ³ç¬¦
        const last = sixEighths[5];   // æœ€åä¸€ä¸ªï¼ˆéŸ³ç¬¦æˆ–ä¼‘æ­¢ç¬¦ï¼‰
        
        // åˆ›å»ºå…«åˆ†éŸ³ç¬¦tiedé™„ç‚¹å››åˆ†éŸ³ç¬¦çš„ç»„åˆ
        const eighth = {
            ...tiedGroup[0],
            duration: 'eighth',
            beats: 0.5,
            tieType: 'start'
        };
        
        const dottedQuarter = {
            ...tiedGroup[0],
            duration: 'quarter.',
            beats: 1.5,
            tieType: 'stop'
        };
        
        // ç¡®ä¿ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ²¡æœ‰tieæ ‡è®°
        const optimizedFirst = { ...first, tieType: null };
        const optimizedLast = { ...last, tieType: null };
        
        console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] åˆ›å»ºæ‰©å±•ä¼˜åŒ–æ¨¡å¼: ${first.type} + å…«åˆ†tiedé™„ç‚¹å››åˆ† + ${last.type}`);
        
        return [optimizedFirst, eighth, dottedQuarter, optimizedLast];
    }
    
    /**
     * ç¡®ä¿3/4æ‹è‡³å°‘æœ‰ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ˜ç¡®
     */
    ensureTwoBeatPointsClarity(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥æ‹ç‚¹æ¸…æ™°åº¦ï¼ˆè‡³å°‘ä¸¤ä¸ªå››åˆ†éŸ³ç¬¦æ‹ç‚¹æ˜ç¡®ï¼‰`);
        
        // åˆ†æå½“å‰çš„æ‹ç‚¹æ¸…æ™°åº¦
        const beatPoints = this.analyzeBeatPointClarity(notes);
        const clearBeatPoints = beatPoints.filter(bp => bp.isClear).length;
        
        console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] å½“å‰æ˜ç¡®çš„æ‹ç‚¹æ•°: ${clearBeatPoints} (éœ€è¦è‡³å°‘2ä¸ª)`);
        
        if (clearBeatPoints >= 2) {
            console.log(`âœ… [3/4æ‹ä¼˜åŒ–] æ‹ç‚¹æ¸…æ™°åº¦æ»¡è¶³è¦æ±‚`);
            return notes;
        }
        
        // éœ€è¦æ‹†åˆ†æ¨¡ç³Šæ‹ç‚¹çš„éŸ³ç¬¦ï¼Œä¼˜å…ˆä¿è¯å‰ä¸¤æ‹
        console.log(`âš ï¸ [3/4æ‹ä¼˜åŒ–] æ‹ç‚¹æ¸…æ™°åº¦ä¸è¶³ï¼Œéœ€è¦æ‹†åˆ†æ¨¡ç³ŠéŸ³ç¬¦`);
        return this.splitNotesToClarifyBeats(notes);
    }
    
    /**
     * åˆ†æ3/4æ‹çš„æ‹ç‚¹æ¸…æ™°åº¦
     */
    analyzeBeatPointClarity(notes) {
        const beatPoints = [
            { position: 0, isClear: false }, // ç¬¬1æ‹
            { position: 1, isClear: false }, // ç¬¬2æ‹  
            { position: 2, isClear: false }  // ç¬¬3æ‹
        ];
        
        let currentPosition = 0;
        
        for (const note of notes) {
            const noteStart = currentPosition;
            const noteEnd = currentPosition + note.beats;
            
            // æ£€æŸ¥æ¯ä¸ªæ‹ç‚¹æ˜¯å¦è¢«æ˜ç¡®æ ‡è®°ï¼ˆéŸ³ç¬¦åœ¨æ‹ç‚¹å¼€å§‹æˆ–æ‹ç‚¹è¢«åˆ†å‰²ï¼‰
            beatPoints.forEach(bp => {
                if (Math.abs(noteStart - bp.position) < 0.001) {
                    bp.isClear = true; // éŸ³ç¬¦åœ¨æ‹ç‚¹å¼€å§‹
                } else if (noteStart < bp.position && noteEnd > bp.position) {
                    // éŸ³ç¬¦è·¨è¶Šæ‹ç‚¹ä½†æ²¡æœ‰åœ¨æ‹ç‚¹åˆ†å‰²ï¼Œæ‹ç‚¹æ¨¡ç³Š
                    bp.isClear = false;
                }
            });
            
            currentPosition += note.beats;
        }
        
        console.log(`ğŸ” [3/4æ‹ä¼˜åŒ–] æ‹ç‚¹åˆ†æ: ${beatPoints.map(bp => `æ‹${bp.position + 1}(${bp.isClear ? 'æ˜ç¡®' : 'æ¨¡ç³Š'})`).join(', ')}`);
        return beatPoints;
    }
    
    /**
     * æ‹†åˆ†è·¨æ‹éŸ³ç¬¦ä»¥æ˜ç¡®æ‹ç‚¹
     */
    splitNotesToClarifyBeats(notes) {
        console.log(`ğŸ”§ [3/4æ‹ä¼˜åŒ–] æ‹†åˆ†è·¨æ‹éŸ³ç¬¦ä»¥æ˜ç¡®å‰ä¸¤æ‹`);
        
        const optimizedNotes = [];
        let currentPosition = 0;
        const targetBeatPoints = [0, 1]; // ä¼˜å…ˆæ˜ç¡®ç¬¬1æ‹å’Œç¬¬2æ‹
        
        for (const note of notes) {
            const noteStart = currentPosition;
            const noteEnd = currentPosition + note.beats;
            
            // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦è·¨è¶Šéœ€è¦æ˜ç¡®çš„æ‹ç‚¹
            let needsSplit = false;
            let splitPoint = null;
            
            for (const beatPoint of targetBeatPoints) {
                if (noteStart < beatPoint && noteEnd > beatPoint) {
                    needsSplit = true;
                    splitPoint = beatPoint;
                    break;
                }
            }
            
            if (needsSplit && note.type === 'note') {
                console.log(`ğŸ” [è°ƒè¯•] å‡†å¤‡æ‹†åˆ†æ£€æŸ¥: duration=${note.duration}, beats=${note.beats}, type=${note.type}`);
                
                // ğŸ¼ ç‰¹æ®Šä¾‹å¤–ï¼šé™„ç‚¹äºŒåˆ†éŸ³ç¬¦åœ¨3/4æ‹ä¸­æ˜¯å®Œå…¨åˆæ³•çš„ï¼Œä¸åº”è¯¥è¢«æ‹†åˆ†
                if (note.duration === 'half.' && Math.abs(note.beats - 3) < 0.001) {
                    console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] é™„ç‚¹äºŒåˆ†éŸ³ç¬¦åœ¨3/4æ‹ä¸­æ˜¯åˆæ³•çš„ï¼Œä¸æ‹†åˆ†`);
                    optimizedNotes.push(note);
                    currentPosition += note.beats;
                    continue;
                }
                
                // æ‹†åˆ†éŸ³ç¬¦
                console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] æ‹†åˆ†è·¨æ‹éŸ³ç¬¦: ${note.duration}æ‹ åœ¨ä½ç½®${splitPoint}`);
                
                const firstPartBeats = splitPoint - noteStart;
                const secondPartBeats = noteEnd - splitPoint;
                
                const firstPart = {
                    ...note,
                    duration: this.beatsToDuration(firstPartBeats),
                    beats: firstPartBeats,
                    tieType: 'start'
                };
                
                const secondPart = {
                    ...note,
                    duration: this.beatsToDuration(secondPartBeats),
                    beats: secondPartBeats,
                    tieType: 'stop'
                };
                
                optimizedNotes.push(firstPart, secondPart);
            } else {
                // ä¿æŒåŸæ ·
                optimizedNotes.push(note);
            }
            
            currentPosition += note.beats;
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ‹ç‚¹æ˜ç¡®åŒ–å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }
    
    /**
     * åˆå¹¶æ‹ç‚¹å†…çš„ä¼‘æ­¢ç¬¦
     */
    mergeBeatPointRests(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥æ‹ç‚¹å†…ä¼‘æ­¢ç¬¦åˆå¹¶`);
        
        let optimizedNotes = [...notes];
        const beatRegions = [
            // å››åˆ†éŸ³ç¬¦æ‹ç‚¹
            { start: 0, end: 1, name: 'ç¬¬1æ‹' },
            { start: 1, end: 2, name: 'ç¬¬2æ‹' },
            { start: 2, end: 3, name: 'ç¬¬3æ‹' },
            // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹  
            { start: 0, end: 2, name: 'ç¬¬1-2æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰' },
            { start: 1, end: 3, name: 'ç¬¬2-3æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰' }
        ];
        
        for (const region of beatRegions) {
            optimizedNotes = this.mergeRestsInBeatRegion(optimizedNotes, region);
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ‹ç‚¹å†…ä¼‘æ­¢ç¬¦åˆå¹¶å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }
    
    /**
     * åœ¨æŒ‡å®šæ‹ç‚¹åŒºåŸŸå†…åˆå¹¶ä¼‘æ­¢ç¬¦
     */
    mergeRestsInBeatRegion(notes, region) {
        let currentPosition = 0;
        const regionNotes = [];
        let regionStartIndex = -1;
        let regionEndIndex = -1;
        let regionStartPosition = null;
        let regionEndPosition = null;
        let hasOutsideOverlap = false;
        const tolerance = 0.001;
        
        // æ‰¾åˆ°åŒºåŸŸå†…çš„éŸ³ç¬¦
        for (let i = 0; i < notes.length; i++) {
            const noteStart = currentPosition;
            const noteEnd = currentPosition + notes[i].beats;
            
            if (noteEnd > region.start && noteStart < region.end) {
                if (regionStartIndex === -1) regionStartIndex = i;
                regionEndIndex = i;
                if (regionStartPosition === null) regionStartPosition = noteStart;
                regionEndPosition = noteEnd;
                if (noteStart < region.start - tolerance || noteEnd > region.end + tolerance) {
                    hasOutsideOverlap = true;
                }
                regionNotes.push(notes[i]);
            }
            
            currentPosition += notes[i].beats;
        }
        
        // æ£€æŸ¥åŒºåŸŸå†…æ˜¯å¦å…¨æ˜¯ä¼‘æ­¢ç¬¦
        const allRests = regionNotes.length > 0 && regionNotes.every(note => note.type === 'rest');
        const alignsWithRegion = regionStartPosition !== null &&
            Math.abs(regionStartPosition - region.start) < tolerance &&
            Math.abs(regionEndPosition - region.end) < tolerance;

        if (allRests && regionNotes.length > 1 && alignsWithRegion && !hasOutsideOverlap) {
            console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] ${region.name}å…¨æ˜¯ä¼‘æ­¢ç¬¦ï¼Œåˆå¹¶ä¸ºä¸€ä¸ªä¼‘æ­¢ç¬¦`);
            
            const totalBeats = region.end - region.start;
            const mergedRest = {
                type: 'rest',
                duration: this.beatsToDuration(totalBeats),
                beats: totalBeats
            };
            
            // æ›¿æ¢åŒºåŸŸå†…çš„éŸ³ç¬¦
            const newNotes = [
                ...notes.slice(0, regionStartIndex),
                mergedRest,
                ...notes.slice(regionEndIndex + 1)
            ];
            
            return newNotes;
        }
        
        return notes;
    }
    
    /**
     * å°†æ‹æ•°è½¬æ¢ä¸ºæŒç»­æ—¶é—´å­—ç¬¦ä¸²
     */
    beatsToDuration(beats) {
        if (Math.abs(beats - 3) < 0.001) return 'half.'; // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
        if (Math.abs(beats - 2) < 0.001) return 'half';   // äºŒåˆ†éŸ³ç¬¦
        if (Math.abs(beats - 1.5) < 0.001) return 'quarter.'; // é™„ç‚¹å››åˆ†éŸ³ç¬¦
        if (Math.abs(beats - 1) < 0.001) return 'quarter';    // å››åˆ†éŸ³ç¬¦
        if (Math.abs(beats - 0.75) < 0.001) return 'eighth.'; // é™„ç‚¹å…«åˆ†éŸ³ç¬¦
        if (Math.abs(beats - 0.5) < 0.001) return 'eighth';   // å…«åˆ†éŸ³ç¬¦
        if (Math.abs(beats - 0.25) < 0.001) return '16th';    // åå…­åˆ†éŸ³ç¬¦
        
        // é»˜è®¤è¿”å›å››åˆ†éŸ³ç¬¦
        return 'quarter';
    }

    /**
     * è½¬æ¢åæ‹ä½ç½®çš„å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦ä¸ºå…«åˆ†éŸ³ç¬¦tiedé™„ç‚¹å››åˆ†éŸ³ç¬¦
     * 3/4æ‹çš„åæ‹ä½ç½®ï¼š0.5æ‹ã€1.5æ‹ã€2.5æ‹
     */
    convertOffbeatTiedEighths(notes) {
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] æ£€æŸ¥åæ‹ä½ç½®çš„å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦ï¼Œå…±${notes.length}ä¸ªéŸ³ç¬¦`);
        
        // è¯¦ç»†æ—¥å¿—ï¼šæ˜¾ç¤ºæ‰€æœ‰éŸ³ç¬¦ä¿¡æ¯
        notes.forEach((note, index) => {
            console.log(`  éŸ³ç¬¦${index}: duration=${note.duration}, type=${note.type}, tieType=${note.tieType}, tied=${note.tied}`);
        });
        
        const optimizedNotes = [];
        let currentPosition = 0;
        let i = 0;
        
        while (i < notes.length) {
            const noteStartPosition = currentPosition;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨åæ‹ä½ç½®å¼€å§‹æœ‰å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦
            if (this.isFourTiedEighthsAtOffbeat(notes, i, noteStartPosition)) {
                console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] å‘ç°åæ‹ä½ç½®å››ä¸ªtiedå…«åˆ†éŸ³ç¬¦ï¼Œä½ç½®${noteStartPosition}`);
                
                const fourEighths = notes.slice(i, i + 4);
                const optimizedPattern = this.createOffbeatOptimizedPattern(fourEighths);
                
                optimizedNotes.push(...optimizedPattern);
                
                // è·³è¿‡å››ä¸ªå…«åˆ†éŸ³ç¬¦ï¼Œä½†è¦æ›´æ–°ä½ç½®
                currentPosition += 2; // å››ä¸ªå…«åˆ†éŸ³ç¬¦ = 2æ‹
                i += 4;
                continue;
            }
            
            // ä¸ç¬¦åˆæ¡ä»¶ï¼Œä¿æŒåŸæ ·
            optimizedNotes.push(notes[i]);
            currentPosition += notes[i].beats;
            i++;
        }
        
        console.log(`ğŸµ [3/4æ‹ä¼˜åŒ–] åæ‹tiedå…«åˆ†éŸ³ç¬¦è½¬æ¢å®Œæˆï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${optimizedNotes.length}`);
        return optimizedNotes;
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦åœ¨åæ‹ä½ç½®æœ‰å››ä¸ªtiedçš„å…«åˆ†éŸ³ç¬¦
     */
    isFourTiedEighthsAtOffbeat(notes, startIndex, position) {
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„éŸ³ç¬¦
        if (startIndex + 3 >= notes.length) return false;
        
        // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨åæ‹ï¼ˆ0.5ã€1.5ã€2.5ï¼‰
        const offbeatPositions = [0.5, 1.5, 2.5];
        const isOffbeat = offbeatPositions.some(pos => Math.abs(position - pos) < 0.001);
        if (!isOffbeat) return false;
        
        // æ£€æŸ¥å››ä¸ªéŸ³ç¬¦éƒ½æ˜¯å…«åˆ†éŸ³ç¬¦
        const fourNotes = notes.slice(startIndex, startIndex + 4);
        for (let i = 0; i < 4; i++) {
            if (fourNotes[i].duration !== 'eighth' || fourNotes[i].type === 'rest') {
                return false;
            }
        }
        
        // æ£€æŸ¥æ‰€æœ‰éŸ³ç¬¦éƒ½æ˜¯tied
        for (let i = 0; i < 4; i++) {
            if (!fourNotes[i].tied) {
                console.log(`  éŸ³ç¬¦${i}ä¸æ˜¯tiedéŸ³ç¬¦`);
                return false;
            }
        }
        
        // ç®€åŒ–éŸ³é«˜æ£€æŸ¥
        for (let i = 1; i < 4; i++) {
            if (fourNotes[i].midi && fourNotes[0].midi && fourNotes[i].midi !== fourNotes[0].midi) {
                console.log(`  éŸ³ç¬¦${i}éŸ³é«˜ä¸åŒ¹é…`);
                return false;
            }
        }
        
        console.log(`âœ… [3/4æ‹ä¼˜åŒ–] åœ¨ä½ç½®${position}å‘ç°ç¬¦åˆæ¡ä»¶çš„å››ä¸ªåæ‹tiedå…«åˆ†éŸ³ç¬¦`);
        return true;
    }
    
    /**
     * åˆ›å»ºåæ‹ä½ç½®ä¼˜åŒ–åçš„æ¨¡å¼ï¼šå…«åˆ†éŸ³ç¬¦tiedé™„ç‚¹å››åˆ†éŸ³ç¬¦
     */
    createOffbeatOptimizedPattern(fourEighths) {
        const firstNote = fourEighths[0];
        
        // åˆ›å»ºå…«åˆ†éŸ³ç¬¦ï¼ˆtiedå¼€å§‹ï¼‰
        const eighth = {
            ...firstNote,
            duration: 'eighth',
            beats: 0.5,
            tieType: 'start'
        };
        
        // åˆ›å»ºé™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼ˆtiedç»“æŸï¼‰
        const dottedQuarter = {
            ...firstNote,
            duration: 'quarter.',
            beats: 1.5,
            tieType: 'stop'
        };
        
        console.log(`ğŸ¯ [3/4æ‹ä¼˜åŒ–] åˆ›å»ºåæ‹ä¼˜åŒ–æ¨¡å¼: å…«åˆ†éŸ³ç¬¦tiedé™„ç‚¹å››åˆ†éŸ³ç¬¦`);
        
        return [eighth, dottedQuarter];
    }

    /**
     * ğŸµ 3/4æ‹å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹çš„è¿çº¿éŸ³ç¬¦åˆå¹¶è§„åˆ™
     * å¦‚æœæœ€ä½çš„éŸ³ç¬¦æ—¶å€¼æ˜¯å…«åˆ†éŸ³ç¬¦ï¼Œé‚£åœ¨åªè¦èƒ½ä¿è¯å››åˆ†éŸ³ç¬¦æ‹ç‚¹å‰æä¸‹ï¼Œæ‰€æœ‰å…¶ä»–çš„è¿çº¿éŸ³ç¬¦çš†å¯åˆå¹¶
     */
    mergeConnectedNotesInEighthNoteScenario(notes) {
        console.log(`ğŸµ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] å¼€å§‹å¤„ç†ï¼Œè¾“å…¥${notes.length}ä¸ªéŸ³ç¬¦`);
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯å…«åˆ†éŸ³ç¬¦åœºæ™¯ï¼ˆæœ€å°æ—¶å€¼æ˜¯å…«åˆ†éŸ³ç¬¦ï¼‰
        const finestRhythm = Math.min(...notes
            .filter(n => n.type === 'note')
            .map(n => n.beats));
        
        console.log(`ğŸµ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æœ€å°æ—¶å€¼: ${finestRhythm}æ‹`);
        
        // åªåœ¨å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹æ‰åº”ç”¨æ­¤è§„åˆ™
        if (finestRhythm < 0.5) {
            console.log(`ğŸµ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æœ‰æ¯”å…«åˆ†éŸ³ç¬¦æ›´å°çš„æ—¶å€¼ï¼Œè·³è¿‡å¤„ç†`);
            return notes;
        }
        
        if (finestRhythm > 0.5) {
            console.log(`ğŸµ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æ²¡æœ‰å…«åˆ†éŸ³ç¬¦ï¼Œè·³è¿‡å¤„ç†`);
            return notes;
        }
        
        console.log(`ğŸ¯ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æ£€æµ‹åˆ°å…«åˆ†éŸ³ç¬¦åœºæ™¯ï¼Œå¼€å§‹åº”ç”¨åˆå¹¶è§„åˆ™`);
        
        const mergedNotes = [];
        let i = 0;
        
        while (i < notes.length) {
            const currentNote = notes[i];
            
            // å¤„ç†tiedéŸ³ç¬¦ç»„
            if (currentNote.tied || currentNote.tieType) {
                const tiedGroup = [currentNote];
                let j = i + 1;
                
                // æ”¶é›†æ‰€æœ‰è¿ç»­çš„tiedéŸ³ç¬¦
                while (j < notes.length && (notes[j].tied || notes[j].tieType)) {
                    if (this.notesHaveSamePitch(currentNote, notes[j])) {
                        tiedGroup.push(notes[j]);
                        j++;
                    } else {
                        break;
                    }
                }
                
                // è®¡ç®—tiedç»„çš„ä½ç½®
                let tiedStartPos = 0;
                for (let k = 0; k < i; k++) {
                    tiedStartPos += notes[k].beats;
                }
                
                const totalBeats = tiedGroup.reduce((sum, note) => sum + note.beats, 0);
                const tiedEndPos = tiedStartPos + totalBeats;
                const localStartInBar = tiedStartPos % 3;
                const tolerance = 0.001;

                // ğŸ¯ 3/4 ä¸“ç”¨ï¼šä¸‰è¿å…«åˆ†ï¼ˆtiedï¼‰å¯åˆå¹¶ä¸ºé™„ç‚¹å››åˆ†ï¼Œå…è®¸è·¨è¿‡å¼±æ‹1ä½†ä¸è·¨å°èŠ‚
                const isThreeEighthChain = Math.abs(totalBeats - 1.5) < tolerance &&
                  tiedGroup.every(n => Math.abs(n.beats - 0.5) < tolerance);
                const startsOnDottedAnchor = Math.abs(localStartInBar - 0) < tolerance ||
                  Math.abs(localStartInBar - 1.5) < tolerance;
                
                console.log(`ğŸ”— [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] tiedç»„: ${tiedGroup.length}ä¸ªéŸ³ç¬¦ï¼Œä½ç½®${tiedStartPos}-${tiedEndPos}ï¼Œæ€»æ—¶é•¿${totalBeats}æ‹`);
                
                // æ£€æŸ¥åˆå¹¶åæ˜¯å¦ä¼šå½±å“å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°åº¦
                const quarterBeatPoints = [0, 1, 2]; // 3/4æ‹çš„å››åˆ†éŸ³ç¬¦æ‹ç‚¹
                let wouldAffectBeatClarity = false;

                // ä¾‹å¤–ï¼šç¬¦åˆä¸‰è¿å…«åˆ† -> é™„ç‚¹å››åˆ†çš„æ¨¡å¼æ—¶ï¼Œæ”¾å®½è·¨æ‹æ£€æŸ¥ï¼ˆåªè¦è½åœ¨ 0 æˆ– 1.5 èµ·ç‚¹ï¼‰
                if (!(isThreeEighthChain && startsOnDottedAnchor)) {
                  for (const beatPoint of quarterBeatPoints) {
                      // æ£€æŸ¥tiedç»„æ˜¯å¦è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹ä½†ä¸åœ¨æ‹ç‚¹ä¸Šå¼€å§‹/ç»“æŸ
                      if (tiedStartPos < beatPoint && tiedEndPos > beatPoint &&
                          Math.abs(tiedStartPos - beatPoint) > 0.001 && 
                          Math.abs(tiedEndPos - beatPoint) > 0.001) {
                          console.log(`âš ï¸ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] tiedç»„è·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹${beatPoint}ä¸”ä¸åœ¨æ‹ç‚¹è¾¹ç•Œï¼Œä¼šå½±å“æ‹ç‚¹æ¸…æ™°åº¦`);
                          wouldAffectBeatClarity = true;
                          break;
                      }
                  }
                } else {
                  console.log('âœ… [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] å‘½ä¸­ä¸‰è¿å…«åˆ†â†’é™„ç‚¹å››åˆ†ä¾‹å¤–ï¼Œå…è®¸åˆå¹¶');
                }
                
                // åªè¦ä¸å½±å“å››åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼Œå°±å…è®¸åˆå¹¶
                if (!wouldAffectBeatClarity) {
                    const mergedDuration = this.beatsToDuration(totalBeats);
                    const expectedBeats = this.durationToBeats(mergedDuration);
                    const tolerance = 0.01;
                    
                    if (Math.abs(totalBeats - expectedBeats) < tolerance) {
                        const mergedNote = {
                            ...currentNote,
                            duration: mergedDuration,
                            beats: totalBeats,
                            tied: false,
                            tieType: undefined
                        };
                        
                        mergedNotes.push(mergedNote);
                        console.log(`âœ… [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æˆåŠŸåˆå¹¶${tiedGroup.length}ä¸ªtiedéŸ³ç¬¦: ${tiedGroup.map(n => n.duration).join('+')} -> ${mergedDuration}`);
                        
                        i = j; // è·³è¿‡å·²åˆå¹¶çš„éŸ³ç¬¦
                        continue;
                    } else {
                        console.log(`âš ï¸ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] æ— æ³•åˆå¹¶ï¼šæ€»æ—¶é•¿${totalBeats}ä¸å¯¹åº”æ ‡å‡†æ—¶å€¼`);
                    }
                } else {
                    console.log(`âš ï¸ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] ä¸åˆå¹¶ï¼šä¼šå½±å“å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ¸…æ™°åº¦`);
                }
                
                // æ— æ³•åˆå¹¶ï¼Œä¿æŒåŸtiedç»„
                tiedGroup.forEach(note => mergedNotes.push(note));
                i = j;
            } else {
                // étiedéŸ³ç¬¦ï¼Œç›´æ¥æ·»åŠ 
                mergedNotes.push(currentNote);
                i++;
            }
        }
        
        console.log(`ğŸµ [3/4æ‹å…«åˆ†éŸ³ç¬¦åˆå¹¶] å®Œæˆå¤„ç†ï¼ŒéŸ³ç¬¦æ•°é‡: ${notes.length} -> ${mergedNotes.length}`);
        return mergedNotes;
    }
    
    /**
     * æ£€æŸ¥ä¸¤ä¸ªéŸ³ç¬¦æ˜¯å¦æœ‰ç›¸åŒçš„éŸ³é«˜ï¼ˆç”¨äºtiedéŸ³ç¬¦æ£€æŸ¥ï¼‰
     */
    notesHaveSamePitch(note1, note2) {
        // å¦‚æœå…¶ä¸­ä¸€ä¸ªæ˜¯ä¼‘æ­¢ç¬¦ï¼Œä¸èƒ½tied
        if (note1.type === 'rest' || note2.type === 'rest') {
            return false;
        }
        
        // æ£€æŸ¥éŸ³é«˜æ˜¯å¦ç›¸åŒ
        return note1.step === note2.step && 
               note1.octave === note2.octave && 
               note1.alter === note2.alter;
    }

    /**
     * æ£€æŸ¥ç›¸é‚»æ­£æ‹éŸ³ç¬¦åˆå¹¶è§„åˆ™
     * å¦‚æœä¸¤ä¸ªç›¸åŒæ—¶å€¼çš„éŸ³ç¬¦åœ¨ç›¸é‚»æ­£æ‹ä¸Šï¼Œä¸”åˆå¹¶åèƒ½å½¢æˆåˆæ³•æ—¶å€¼ï¼Œåˆ™åº”è¯¥åˆå¹¶
     */
    checkAdjacentBeatMerge(tiedGroup, allNotes, criticalBeats = []) {
        const tolerance = 0.0001;
        
        // åªé€‚ç”¨äºä¸¤ä¸ªéŸ³ç¬¦çš„æƒ…å†µ
        if (tiedGroup.length !== 2) return false;
        
        // ğŸš¨ å…³é”®ä¿®å¤ï¼šç¦æ­¢åˆå¹¶æ‹†åˆ†çš„å…«åˆ†éŸ³ç¬¦ï¼ˆç”¨äºè¿æ†ï¼‰
        // å¦‚æœéŸ³ç¬¦æœ‰ tie å±æ€§ï¼Œè¯´æ˜å®ƒä»¬æ˜¯æ‹†åˆ†äº§ç”Ÿçš„ï¼Œåº”ä¿æŒæ‹†åˆ†çŠ¶æ€ä»¥æ”¯æŒè¿æ†
        if (tiedGroup[0].tieType === 'start' && tiedGroup[1].tieType === 'stop') {
            console.log(`  ğŸš« ç¦æ­¢åˆå¹¶æ‹†åˆ†çš„å…«åˆ†éŸ³ç¬¦: ${tiedGroup[0].duration}+${tiedGroup[1].duration} (ä¿æŒè¿æ†èƒ½åŠ›)`);
            return false;
        }
        
        // ğŸ”¥ å…³é”®æ£€æŸ¥ï¼šå…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ï¼Œç¦æ­¢æŸäº›åˆå¹¶ä»¥ä¿æŠ¤äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
        const isEighthNoteScenario = criticalBeats.length === 2 && 
            criticalBeats.includes(0) && criticalBeats.includes(2) && 
            !criticalBeats.includes(1) && !criticalBeats.includes(3);
        
        if (isEighthNoteScenario) {
            // è®¡ç®—èµ·å§‹ä½ç½®
            const startPosition = this.calculateNotePosition(allNotes, tiedGroup[0]);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå››åˆ†éŸ³ç¬¦åœ¨æ­£æ‹ä¸Šçš„åˆå¹¶
            const isQuarterNoteOnBeat = Math.abs(firstBeats - 1.0) < tolerance &&
                (Math.abs(startPosition % 1) < tolerance); // åœ¨æ•´æ•°æ‹ç‚¹ä¸Šå¼€å§‹
            
            if (isQuarterNoteOnBeat) {
                console.log(`  ğŸ¼ å…è®¸å››åˆ†éŸ³ç¬¦åœ¨æ­£æ‹ä¸Šçš„ç›¸é‚»åˆå¹¶: ä½ç½®${startPosition}`);
                // å››åˆ†éŸ³ç¬¦åœ¨æ­£æ‹ä¸Šçš„åˆå¹¶æ€»æ˜¯å…è®¸çš„
            } else {
                // åœ¨å…«åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ï¼Œç¦æ­¢è·¨è¶Šä½ç½®2(ç¬¬3æ‹)çš„åˆå¹¶å’Œåæ‹ä½ç½®çš„åˆå¹¶
                const crossesHalfNoteBeat = startPosition < 2 - tolerance && 
                    startPosition + tiedGroup[0].beats + tiedGroup[1].beats > 2 + tolerance;
                    
                const startsOnOffBeat = Math.abs(startPosition - 0.5) < tolerance ||
                    Math.abs(startPosition - 1.5) < tolerance ||
                    Math.abs(startPosition - 2.5) < tolerance ||
                    Math.abs(startPosition - 3.5) < tolerance;
                
                if (crossesHalfNoteBeat || startsOnOffBeat) {
                    console.log(`  ğŸ”¥ å…«åˆ†éŸ³ç¬¦åœºæ™¯ï¼šç¦æ­¢ç›¸é‚»æ­£æ‹åˆå¹¶ - èµ·å§‹${startPosition}æ‹ (ä¿æŠ¤äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹)`);
                    return false;
                }
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯ç›¸åŒæ—¶å€¼çš„éŸ³ç¬¦
        const firstBeats = tiedGroup[0].beats;
        const secondBeats = tiedGroup[1].beats;
        if (Math.abs(firstBeats - secondBeats) > tolerance) return false;
        
        // è®¡ç®—èµ·å§‹ä½ç½®
        const startPosition = this.calculateNotePosition(allNotes, tiedGroup[0]);
        const endPosition = startPosition + firstBeats + secondBeats;
        
        // æ£€æŸ¥æ˜¯å¦åœ¨ç›¸é‚»æ­£æ‹ä¸Š
        const adjacentBeats = this.getAdjacentBeatPairs(firstBeats);
        
        for (const [beat1, beat2] of adjacentBeats) {
            if (Math.abs(startPosition - beat1) < tolerance && 
                Math.abs(startPosition + firstBeats - beat2) < tolerance) {
                
                // ğŸ”¥ è§„åˆ™4ä¿æŠ¤ï¼š1.5-2æ‹ä½ç½®çš„éŸ³ç¬¦ä¸èƒ½åˆå¹¶ï¼ˆå³ä½¿æ˜¯ç›¸é‚»æ­£æ‹ï¼‰
                // ä»£ç ä¸­çš„1.5å¯¹åº”éŸ³ä¹ç†è®ºçš„2.5æ‹ï¼Œ2å¯¹åº”éŸ³ä¹ç†è®ºçš„ç¬¬3æ‹
                if (Math.abs(beat1 - 1.5) < tolerance && Math.abs(beat2 - 2) < tolerance) {
                    console.log(`  ğŸš« è§„åˆ™4ä¿æŠ¤ï¼š1.5-2æ‹ä½ç½®çš„éŸ³ç¬¦ä¸èƒ½åˆå¹¶ï¼ˆä¿æŠ¤ç¬¬3æ‹å¼ºæ‹ï¼‰`);
                    return false;
                }
                
                // æ£€æŸ¥åˆå¹¶åæ˜¯å¦å½¢æˆåˆæ³•æ—¶å€¼
                const totalBeats = firstBeats + secondBeats;
                const isLegalDuration = this.isLegalNoteDuration(totalBeats);
                
                if (isLegalDuration) {
                    console.log(`  ğŸ¼ğŸ¼ğŸ¼ ç›¸é‚»æ­£æ‹åˆå¹¶æˆåŠŸ: ${firstBeats}æ‹+${secondBeats}æ‹ åœ¨ä½ç½®${beat1}-${beat2} â†’ ${totalBeats}æ‹ ğŸ¼ğŸ¼ğŸ¼`);
                    return true;
                } else {
                    console.log(`  âŒ ç›¸é‚»æ­£æ‹ä½†æ—¶å€¼ä¸åˆæ³•: ${totalBeats}æ‹`);
                }
            }
        }
        
        return false;
    }

    /**
     * è·å–ç»™å®šæ—¶å€¼çš„ç›¸é‚»æ­£æ‹ç»„åˆ
     */
    getAdjacentBeatPairs(noteBeats) {
        const tolerance = 0.0001;
        
        // å››åˆ†éŸ³ç¬¦(1æ‹)çš„ç›¸é‚»æ­£æ‹ç»„åˆ
        if (Math.abs(noteBeats - 1.0) < tolerance) {
            return [
                [0, 1], [1, 2], [2, 3], [3, 4], // ç›¸é‚»æ•´æ‹
            ];
        }
        
        // å…«åˆ†éŸ³ç¬¦(0.5æ‹)çš„ç›¸é‚»æ­£æ‹ç»„åˆ  
        if (Math.abs(noteBeats - 0.5) < tolerance) {
            return [
                [0, 0.5], [0.5, 1], [1, 1.5], [1.5, 2], 
                [2, 2.5], [2.5, 3], [3, 3.5], [3.5, 4]  // ç›¸é‚»å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
            ];
        }
        
        // åå…­åˆ†éŸ³ç¬¦(0.25æ‹)çš„ç›¸é‚»æ­£æ‹ç»„åˆ
        if (Math.abs(noteBeats - 0.25) < tolerance) {
            return [
                [0, 0.25], [0.25, 0.5], [0.5, 0.75], [0.75, 1],
                [1, 1.25], [1.25, 1.5], [1.5, 1.75], [1.75, 2],
                [2, 2.25], [2.25, 2.5], [2.5, 2.75], [2.75, 3],
                [3, 3.25], [3.25, 3.5], [3.5, 3.75], [3.75, 4]  // ç›¸é‚»åå…­åˆ†éŸ³ç¬¦æ‹ç‚¹
            ];
        }
        
        return [];
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºåˆæ³•çš„éŸ³ç¬¦æ—¶å€¼
     */
    isLegalNoteDuration(beats) {
        const tolerance = 0.0001;
        const legalDurations = [
            4.0,    // å…¨éŸ³ç¬¦
            3.0,    // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
            2.0,    // äºŒåˆ†éŸ³ç¬¦
            1.5,    // é™„ç‚¹å››åˆ†éŸ³ç¬¦
            1.0,    // å››åˆ†éŸ³ç¬¦
            0.75,   // é™„ç‚¹å…«åˆ†éŸ³ç¬¦
            0.5,    // å…«åˆ†éŸ³ç¬¦
            0.375,  // é™„ç‚¹åå…­åˆ†éŸ³ç¬¦
            0.25,   // åå…­åˆ†éŸ³ç¬¦
            0.125   // ä¸‰åäºŒåˆ†éŸ³ç¬¦
        ];
        
        return legalDurations.some(duration => Math.abs(beats - duration) < tolerance);
    }

    /**
     * é€‰æ‹©6/8æ‹çš„èŠ‚å¥æ¨¡å¼
     */
    choose6_8RhythmPattern() {
        // 6/8æ‹ä¸¥æ ¼3+3åˆ†ç»„èŠ‚å¥æ¨¡å¼ï¼šç¡®ä¿ä¸¤å¤§ç»„ï¼Œæ¯ç»„3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶å€¼
        const patterns = [
            // ğŸ”¥ æ–°å¢æ¨¡å¼0: é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ (æ•´å°èŠ‚æŒç»­éŸ³ç¬¦)
            [
                { duration: 'half.', beats: 3.0 }
            ],
            // æ¨¡å¼1: â™ªâ™ªâ™ª â™ªâ™ªâ™ª (å…­ä¸ªå…«åˆ†éŸ³ç¬¦ - æœ€å…¸å‹çš„3+3åˆ†ç»„)
            [
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 }
            ],
            // æ¨¡å¼2: â™©. â™©. (ä¸¤ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦ - æ¯ä¸ªå ä¸€ç»„)
            [
                { duration: 'quarter.', beats: 1.5 },
                { duration: 'quarter.', beats: 1.5 }
            ],
            // æ¨¡å¼3: â™© â™ª | â™© â™ª (å››åˆ†+å…«åˆ†ï¼Œé‡å¤ä¸¤æ¬¡ï¼Œä¸¥æ ¼3+3)
            [
                { duration: 'quarter', beats: 1.0 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter', beats: 1.0 },
                { duration: 'eighth', beats: 0.5 }
            ],
            // æ¨¡å¼4: â™ª â™© | â™ª â™© (å…«åˆ†+å››åˆ†ï¼Œé‡å¤ä¸¤æ¬¡ï¼Œä¸¥æ ¼3+3)
            [
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter', beats: 1.0 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter', beats: 1.0 }
            ],
            // æ¨¡å¼5: â™ªâ™ªâ™ª | â™©. (ä¸‰ä¸ªå…«åˆ† + é™„ç‚¹å››åˆ†ï¼Œä¸¥æ ¼3+3)
            [
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter.', beats: 1.5 }
            ],
            // æ¨¡å¼6: â™©. | â™ªâ™ªâ™ª (é™„ç‚¹å››åˆ† + ä¸‰ä¸ªå…«åˆ†ï¼Œä¸¥æ ¼3+3)
            [
                { duration: 'quarter.', beats: 1.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'eighth', beats: 0.5 }
            ],
            // æ¨¡å¼7: â™© â™ª | â™©. (ç¬¬ä¸€ç»„ï¼šå››åˆ†+å…«åˆ†ï¼Œç¬¬äºŒç»„ï¼šé™„ç‚¹å››åˆ†)
            [
                { duration: 'quarter', beats: 1.0 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter.', beats: 1.5 }
            ],
            // æ¨¡å¼8: â™©. | â™© â™ª (ç¬¬ä¸€ç»„ï¼šé™„ç‚¹å››åˆ†ï¼Œç¬¬äºŒç»„ï¼šå››åˆ†+å…«åˆ†)
            [
                { duration: 'quarter.', beats: 1.5 },
                { duration: 'quarter', beats: 1.0 },
                { duration: 'eighth', beats: 0.5 }
            ],
            // æ¨¡å¼9: â™ª â™© | â™©. (ç¬¬ä¸€ç»„ï¼šå…«åˆ†+å››åˆ†ï¼Œç¬¬äºŒç»„ï¼šé™„ç‚¹å››åˆ†)
            [
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter', beats: 1.0 },
                { duration: 'quarter.', beats: 1.5 }
            ],
            // æ¨¡å¼10: â™©. | â™ª â™© (ç¬¬ä¸€ç»„ï¼šé™„ç‚¹å››åˆ†ï¼Œç¬¬äºŒç»„ï¼šå…«åˆ†+å››åˆ†)
            [
                { duration: 'quarter.', beats: 1.5 },
                { duration: 'eighth', beats: 0.5 },
                { duration: 'quarter', beats: 1.0 }
            ]
        ];

        // è¿‡æ»¤æ‰ä¸åœ¨ç”¨æˆ·é€‰æ‹©èŒƒå›´å†…çš„æ¨¡å¼
        if (!this.rules || !Array.isArray(this.rules.allowedDurations)) {
            console.error(`âš ï¸ è§„åˆ™æˆ–å…è®¸æ—¶å€¼æ•°ç»„æœªæ­£ç¡®åˆå§‹åŒ–: ${JSON.stringify(this.rules)}`);
            return null;
        }
        
        console.log(`ğŸ” ç”¨æˆ·é€‰æ‹©çš„èŠ‚å¥ç±»å‹: ${this.rules.allowedDurations.join(', ')}`);
        const availablePatterns = patterns.filter(pattern => {
            if (!pattern || !Array.isArray(pattern) || pattern.length === 0) {
                console.log(`  æ¨¡å¼ [æ— æ•ˆ]: ä¸å¯ç”¨`);
                return false;
            }
            
            const available = pattern.every(note => {
                if (!note || !note.duration) {
                    console.log(`  æ¨¡å¼éŸ³ç¬¦æ— æ•ˆ: ${JSON.stringify(note)}`);
                    return false;
                }
                return this.rules.allowedDurations.includes(note.duration);
            });
            
            try {
                console.log(`  æ¨¡å¼ [${pattern.map(n => n && n.duration ? n.duration : 'undefined').join(' ')}]: ${available ? 'å¯ç”¨' : 'ä¸å¯ç”¨'}`);
            } catch (error) {
                console.log(`  æ¨¡å¼æ˜¾ç¤ºé”™è¯¯: ${error.message}`);
            }
            
            return available;
        });

        console.log(`ğŸ¯ å¯ç”¨çš„6/8æ‹èŠ‚å¥æ¨¡å¼æ•°é‡: ${availablePatterns.length}`);
        if (availablePatterns.length === 0) {
            console.log(`âš ï¸ æ²¡æœ‰å¯ç”¨çš„6/8æ‹èŠ‚å¥æ¨¡å¼ï¼Œå›é€€åˆ°é€ä¸ªé€‰æ‹©`);
            return null;
        }

        // æ ¹æ®èŠ‚å¥æ¨¡å¼çš„ç‰¹ç‚¹å’Œç”¨æˆ·é¢‘ç‡è®¾ç½®æ¥è®¾ç½®æƒé‡
        const weights = availablePatterns.map(pattern => {
            if (!pattern || !Array.isArray(pattern)) {
                console.log(`âš ï¸ æ— æ•ˆæ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤æƒé‡`);
                return 1;
            }
            
            const durations = pattern.map(n => n && n.duration ? n.duration : 'unknown');
            
            // ğŸ¯ è®¡ç®—æ¨¡å¼ä¸­å„èŠ‚å¥ç±»å‹çš„é¢‘ç‡å½±å“
            let baseWeight = 15; // åŸºç¡€æƒé‡
            let frequencyMultiplier = 1; // é¢‘ç‡ä¹˜æ•°
            
            // æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„é¢‘ç‡
            if (userSettings && userSettings.rhythmFrequencies) {
                const uniqueDurations = [...new Set(durations)];
                let totalUserFrequency = 0;
                let validFrequencyCount = 0;
                let hasZeroFrequency = false;
                
                for (const duration of uniqueDurations) {
                    // ğŸ”¥ ä¿®å¤ï¼šæ­£ç¡®æ˜ å°„durationåˆ°é¢‘ç‡é”®å
                    let freqKey = duration;
                    if (duration === 'half.') {
                        // 6/8æ‹çš„é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ä½¿ç”¨å…¨éŸ³ç¬¦é¢‘ç‡ï¼ˆæ•´å°èŠ‚ï¼‰
                        freqKey = 'whole';
                    } else if (duration === 'quarter.') {
                        // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
                        freqKey = 'dotted-quarter';
                    } else if (duration === 'eighth.') {
                        freqKey = 'dotted-eighth';
                    }

                    const userFreq = userSettings.rhythmFrequencies[freqKey];
                    if (userFreq !== undefined) {
                        if (userFreq === 0) {
                            console.log(`ğŸš« 6/8æ‹æ¨¡å¼åŒ…å«é¢‘ç‡ä¸º0%çš„èŠ‚å¥ç±»å‹: ${duration} (æ˜ å°„åˆ°${freqKey})`);
                            hasZeroFrequency = true;
                            break; // è·³å‡ºå¾ªç¯ï¼Œè¿™ä¸ªæ¨¡å¼ä¸å¯ç”¨
                        }
                        totalUserFrequency += userFreq;
                        validFrequencyCount++;
                    }
                }
                
                // å¦‚æœæœ‰ä»»ä½•é¢‘ç‡ä¸º0çš„èŠ‚å¥ç±»å‹ï¼Œæ•´ä¸ªæ¨¡å¼æƒé‡è®¾ä¸º0
                if (hasZeroFrequency) {
                    return 0;
                }

                // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨å¹³å‡é¢‘ç‡ä½œä¸ºæƒé‡ï¼Œä¸å†ä½œä¸ºä¹˜æ•°
                if (validFrequencyCount > 0) {
                    const averageFrequency = totalUserFrequency / validFrequencyCount;
                    console.log(`ğŸ¯ 6/8æ‹æ¨¡å¼å¹³å‡é¢‘ç‡æƒé‡: ${averageFrequency.toFixed(1)}% (èŠ‚å¥: ${uniqueDurations.join(', ')})`);
                    // ç›´æ¥è¿”å›å¹³å‡é¢‘ç‡ä½œä¸ºæƒé‡
                    return Math.round(averageFrequency);
                }
            }

            // å¦‚æœæ²¡æœ‰é¢‘ç‡è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤æƒé‡
            // ğŸ”¥ éŸ³ä¹ç†è®ºæƒé‡ï¼ˆé’ˆå¯¹6/8æ‹ç‰¹æ€§ä¼˜åŒ–ï¼‰
            if (durations.every(d => d === 'eighth') && durations.length === 6) {
                baseWeight = 15; // é»˜è®¤æƒé‡
            } else if (durations.every(d => d === 'quarter.') && durations.length === 2) {
                baseWeight = 8; // é»˜è®¤æƒé‡
            } else if (durations.includes('half.') && durations.length === 1) {
                baseWeight = 20; // é»˜è®¤æƒé‡
            } else if (durations.length === 4 &&
                     durations[0] === durations[2] &&
                     durations[1] === durations[3]) {
                baseWeight = 10; // å¯¹ç§°çš„3+3åˆ†ç»„
            } else if ((durations[0] === 'eighth' && durations[1] === 'eighth' && durations[2] === 'eighth' && durations[3] === 'quarter.') ||
                     (durations[0] === 'quarter.' && durations[1] === 'eighth' && durations[2] === 'eighth' && durations[3] === 'eighth')) {
                baseWeight = 10; // æ¸…æ™°çš„3+3åˆ†ç»„
            } else if (durations.includes('quarter.')) {
                baseWeight = 10; // å…¶ä»–é™„ç‚¹å››åˆ†éŸ³ç¬¦æ··åˆæ¨¡å¼
            } else if (durations.includes('quarter')) {
                baseWeight = 10; // åŒ…å«å››åˆ†éŸ³ç¬¦çš„æ¨¡å¼
            }

            console.log(`ğŸµ 6/8æ‹æ¨¡å¼é»˜è®¤æƒé‡: [${durations.join(' ')}] = ${baseWeight}`);

            return Math.max(baseWeight, 0); // ç¡®ä¿æƒé‡ä¸ä¸ºè´Ÿæ•°
        });

        // è¿‡æ»¤æ‰æƒé‡ä¸º0çš„æ¨¡å¼
        const filteredPatterns = [];
        const filteredWeights = [];
        for (let i = 0; i < availablePatterns.length; i++) {
            if (weights[i] > 0) {
                filteredPatterns.push(availablePatterns[i]);
                filteredWeights.push(weights[i]);
            }
        }
        
        console.log(`ğŸ¯ 6/8æ‹è¿‡æ»¤åå¯ç”¨æ¨¡å¼æ•°é‡: ${filteredPatterns.length}`);
        
        if (filteredPatterns.length === 0) {
            console.log(`âš ï¸ 6/8æ‹æ‰€æœ‰æ¨¡å¼æƒé‡éƒ½ä¸º0ï¼Œå›é€€åˆ°é»˜è®¤é€»è¾‘`);
            return null;
        }
        
        const selectedPattern = this.random.weighted(filteredPatterns, filteredWeights);
        if (selectedPattern && selectedPattern.length > 0) {
            console.log(`ğŸµ 6/8æ‹é€‰æ‹©èŠ‚å¥æ¨¡å¼: ${selectedPattern.map(n => n.duration).join(' ')}`);
            return selectedPattern;
        } else {
            console.log(`âš ï¸ æ— æ³•é€‰æ‹©6/8æ‹èŠ‚å¥æ¨¡å¼ï¼Œå›é€€åˆ°æ™®é€šæ¨¡å¼`);
            return null;
        }
    }

    /**
     * é€‰æ‹©åˆé€‚çš„æ—¶å€¼
     */
    chooseDuration(remainingBeats, isFirstNote, currentBeat = 0) {
        console.log(`é€‰æ‹©æ—¶å€¼: å‰©ä½™${remainingBeats}æ‹, æ˜¯å¦é¦–éŸ³ç¬¦: ${isFirstNote}, å½“å‰ä½ç½®: ${currentBeat}`);
        
        // ğŸ¯ æ™ºèƒ½é™„ç‚¹éŸ³ç¬¦æ‹ç‚¹å¯¹é½è¿‡æ»¤
        const available = this.rules.allowedDurations.filter(duration => {
            if (duration === 'triplet') {
                return false; // ä¸‰è¿éŸ³ä¸èƒ½ç›´æ¥ä½œä¸ºå•ä¸ªéŸ³ç¬¦çš„æ—¶å€¼
            }

            const beats = this.durationToBeats(duration);
            if (beats > remainingBeats + 0.001) {
                return false; // æ—¶å€¼è¶…è¿‡å‰©ä½™æ‹æ•°
            }

            // ğŸµ é™„ç‚¹éŸ³ç¬¦æ‹ç‚¹å¯¹é½æ£€æŸ¥ï¼ˆä»…åœ¨4/4, 2/4, 3/4æ‹ä¸­åº”ç”¨ï¼‰
            if (this.timeSignature === '4/4' || this.timeSignature === '2/4' || this.timeSignature === '3/4') {
                const tolerance = 0.001;

                // é™„ç‚¹å…«åˆ†éŸ³ç¬¦ (0.75æ‹) åªèƒ½åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹
                if (duration === 'eighth.' && beats === 0.75) {
                    // æ ¹æ®æ‹å·ç¡®å®šå››åˆ†éŸ³ç¬¦æ‹ç‚¹ä½ç½®
                    let quarterBeatPositions;
                    if (this.timeSignature === '4/4') {
                        quarterBeatPositions = [0, 1, 2, 3];
                    } else if (this.timeSignature === '3/4') {
                        quarterBeatPositions = [0, 1, 2];
                    } else if (this.timeSignature === '2/4') {
                        quarterBeatPositions = [0, 1];
                    } else {
                        quarterBeatPositions = [0, 1, 2, 3]; // é»˜è®¤æƒ…å†µ
                    }
                    const isOnQuarterBeat = quarterBeatPositions.some(pos => Math.abs(currentBeat - pos) < tolerance);
                    const positionInBeat = ((currentBeat % 1) + 1) % 1;
                    let allowDotted = isOnQuarterBeat;
                    if (!allowDotted) {
                        const allowSixteenthAligned = this.isJianpuTool &&
                            Array.isArray(this.rules?.allowedDurations) &&
                            this.rules.allowedDurations.includes('16th');
                        const isOnSixteenthOffset = Math.abs(positionInBeat - 0.25) < tolerance;
                        const staysInBeat = positionInBeat + beats <= 1 + tolerance;
                        if (allowSixteenthAligned && isOnSixteenthOffset && staysInBeat) {
                            allowDotted = true;
                        }
                    }

                    if (!allowDotted) {
                        console.log(`ğŸš« é™„ç‚¹å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå½“å‰ä½ç½®${currentBeat}ä¸åœ¨å¯ç”¨æ‹ç‚¹ä¸Š`);
                        return false;
                    }

                    // ğŸ”¥ å¢å¼ºçš„é™„ç‚¹å…«åˆ†éŸ³ç¬¦å‰ç½®æ¡ä»¶æ£€æŸ¥
                    const remainingAfterDotted = remainingBeats - beats;

                    // æ£€æŸ¥1ï¼šå‰©ä½™ç©ºé—´æ˜¯å¦è¿‡å°éš¾ä»¥å¡«å……
                    if (remainingAfterDotted > 0.001 && remainingAfterDotted < 0.24) {
                        console.log(`ğŸš« é™„ç‚¹å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå‰©ä½™ç©ºé—´${remainingAfterDotted}è¿‡å°ï¼Œéš¾ä»¥å¡«å……`);
                        return false;
                    }

                    // æ£€æŸ¥2ï¼šç¡®ä¿å‰©ä½™æ‹æ•°èƒ½å¤Ÿè¢«ç²¾ç¡®å¡«å……ï¼ˆé¿å…åˆ†æ•°æ‹é—®é¢˜ï¼‰
                    if (remainingAfterDotted > 0.001) {
                        // å°è¯•æ‹†åˆ†å‰©ä½™æ‹æ•°ï¼Œçœ‹æ˜¯å¦èƒ½ç²¾ç¡®å¡«å……
                        const remainingSegments = this.splitFractionalBeats(remainingAfterDotted);
                        const totalRemainingBeats = remainingSegments.reduce((sum, seg) => sum + seg, 0);
                        const remainingDifference = Math.abs(remainingAfterDotted - totalRemainingBeats);

                        if (remainingDifference > 0.001) {
                            console.log(`ğŸš« é™„ç‚¹å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå‰©ä½™${remainingAfterDotted}æ‹æ— æ³•ç²¾ç¡®å¡«å……ï¼Œå·®å€¼${remainingDifference}æ‹`);
                            return false;
                        }
                    }

                    // æ£€æŸ¥3ï¼šé¿å…åœ¨å°èŠ‚æ¥è¿‘æœ«å°¾æ—¶ä½¿ç”¨é™„ç‚¹å…«åˆ†éŸ³ç¬¦
                    const positionInMeasure = currentBeat % this.beatsPerMeasure;
                    const timeFromMeasureEnd = this.beatsPerMeasure - positionInMeasure;

                    if (timeFromMeasureEnd < 1.25) { // è·ç¦»å°èŠ‚ç»“æŸå°‘äº1.25æ‹æ—¶
                        console.log(`ğŸš« é™„ç‚¹å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šè·ç¦»å°èŠ‚ç»“æŸä»…${timeFromMeasureEnd}æ‹ï¼Œå®¹æ˜“é€ æˆå¡«å……å›°éš¾`);
                        return false;
                    }

                    console.log(`âœ… é™„ç‚¹å…«åˆ†éŸ³ç¬¦å‰ç½®æ£€æŸ¥é€šè¿‡ï¼šä½ç½®${currentBeat}ï¼Œå‰©ä½™${remainingAfterDotted}æ‹å¯ç²¾ç¡®å¡«å……`);
                }

                // é™„ç‚¹å››åˆ†éŸ³ç¬¦ (1.5æ‹) æ‹ç‚¹å¯¹é½æ£€æŸ¥
                if (duration === 'quarter.' && beats === 1.5) {
                    // é‡æ–°å®šä¹‰å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä½ç½®ï¼ˆæ¯ä¸ªæ‹å·ç‹¬ç«‹å¤„ç†ï¼‰
                    let quarterBeatPositions;
                    if (this.timeSignature === '4/4') {
                        quarterBeatPositions = [0, 1, 2, 3];
                    } else if (this.timeSignature === '3/4') {
                        quarterBeatPositions = [0, 1, 2];
                    } else if (this.timeSignature === '2/4') {
                        quarterBeatPositions = [0, 1];
                    } else {
                        quarterBeatPositions = [0, 1, 2, 3]; // é»˜è®¤æƒ…å†µ
                    }

                    // é™„ç‚¹å››åˆ†éŸ³ç¬¦æœ€å¥½åœ¨å¼ºæ‹å¼€å§‹ (0æ‹, 2æ‹)
                    const strongBeatPositions = [0, 2].filter(pos => quarterBeatPositions.includes(pos));
                    const isOnStrongBeat = strongBeatPositions.some(pos => Math.abs(currentBeat - pos) < tolerance);

                    // å¦‚æœä¸åœ¨å¼ºæ‹ï¼Œæ£€æŸ¥æ˜¯å¦ä¼šé€ æˆæ‹ç‚¹æ··ä¹±
                    if (!isOnStrongBeat) {
                        const nextPosition = currentBeat + beats;
                        const wouldLandOnQuarterBeat = quarterBeatPositions.some(pos => Math.abs(nextPosition - pos) < tolerance);

                        if (!wouldLandOnQuarterBeat) {
                            console.log(`ğŸš« é™„ç‚¹å››åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šä½ç½®${currentBeat}å¼€å§‹ä¼šå¯¼è‡´æ‹ç‚¹æ··ä¹±`);
                            return false;
                        }
                    }
                }

                // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ (3æ‹) åªèƒ½åœ¨å°èŠ‚å¼€å§‹ä½¿ç”¨
                if (duration === 'half.' && beats === 3) {
                    if (Math.abs(currentBeat - 0) > tolerance) {
                        console.log(`ğŸš« é™„ç‚¹äºŒåˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šåªèƒ½åœ¨å°èŠ‚å¼€å§‹ä½¿ç”¨ï¼Œå½“å‰ä½ç½®${currentBeat}`);
                        return false;
                    }
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ™®é€šå››åˆ†éŸ³ç¬¦(1æ‹)å¿…é¡»åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹
                if (duration === 'quarter' && beats === 1) {
                    let quarterBeatPositions;
                    if (this.timeSignature === '4/4') {
                        quarterBeatPositions = [0, 1, 2, 3];
                    } else if (this.timeSignature === '3/4') {
                        quarterBeatPositions = [0, 1, 2];
                    } else if (this.timeSignature === '2/4') {
                        quarterBeatPositions = [0, 1];
                    } else {
                        quarterBeatPositions = [0, 1, 2, 3]; // é»˜è®¤æƒ…å†µ
                    }

                    const isOnQuarterBeat = quarterBeatPositions.some(pos => Math.abs(currentBeat - pos) < tolerance);

                    if (!isOnQuarterBeat) {
                        console.log(`ğŸš« å››åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå½“å‰ä½ç½®${currentBeat}ä¸åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼Œåªèƒ½åœ¨æ‹ç‚¹[${quarterBeatPositions.join(', ')}]å¼€å§‹`);
                        return false;
                    }

                    console.log(`âœ… å››åˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æŸ¥é€šè¿‡ï¼šä½ç½®${currentBeat}åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š`);
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ™®é€šäºŒåˆ†éŸ³ç¬¦(2æ‹)å¿…é¡»åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹
                if (duration === 'half' && beats === 2) {
                    let halfBeatPositions;
                    if (this.timeSignature === '4/4') {
                        halfBeatPositions = [0, 2]; // 4/4æ‹çš„äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
                    } else if (this.timeSignature === '3/4') {
                        halfBeatPositions = [0]; // 3/4æ‹åªèƒ½åœ¨å¼€å§‹
                    } else if (this.timeSignature === '2/4') {
                        halfBeatPositions = [0]; // 2/4æ‹åªèƒ½åœ¨å¼€å§‹
                    } else {
                        halfBeatPositions = [0, 2]; // é»˜è®¤æƒ…å†µ
                    }

                    const isOnHalfBeat = halfBeatPositions.some(pos => Math.abs(currentBeat - pos) < tolerance);

                    if (!isOnHalfBeat) {
                        console.log(`ğŸš« äºŒåˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå½“å‰ä½ç½®${currentBeat}ä¸åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼Œåªèƒ½åœ¨æ‹ç‚¹[${halfBeatPositions.join(', ')}]å¼€å§‹`);
                        return false;
                    }

                    console.log(`âœ… äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æŸ¥é€šè¿‡ï¼šä½ç½®${currentBeat}åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š`);
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ™®é€šå…«åˆ†éŸ³ç¬¦(0.5æ‹)å¿…é¡»åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹å¼€å§‹
                if (duration === 'eighth' && beats === 0.5) {
                    let eighthBeatPositions;
                    if (this.timeSignature === '4/4') {
                        eighthBeatPositions = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5];
                    } else if (this.timeSignature === '3/4') {
                        eighthBeatPositions = [0, 0.5, 1, 1.5, 2, 2.5];
                    } else if (this.timeSignature === '2/4') {
                        eighthBeatPositions = [0, 0.5, 1, 1.5];
                    } else {
                        eighthBeatPositions = [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]; // é»˜è®¤4/4æ‹
                    }

                    const isOnEighthBeat = eighthBeatPositions.some(pos => Math.abs(currentBeat - pos) < tolerance);
                    const positionInBeat = ((currentBeat % 1) + 1) % 1;

                    if (!isOnEighthBeat) {
                        const allowSixteenthSyncopation = this.isJianpuTool && Array.isArray(this.rules?.allowedDurations) && this.rules.allowedDurations.includes('16th');
                        const isOnSixteenthGrid = Math.abs((currentBeat * 4) - Math.round(currentBeat * 4)) < tolerance;
                        if (!allowSixteenthSyncopation || !isOnSixteenthGrid) {
                            console.log(`ğŸš« å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå½“å‰ä½ç½®${currentBeat}ä¸åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼Œåªèƒ½åœ¨æ‹ç‚¹[${eighthBeatPositions.join(', ')}]å¼€å§‹`);
                            return false;
                        }
                        if (positionInBeat > 0.5 + tolerance) {
                            console.log(`ğŸš« å…«åˆ†éŸ³ç¬¦è¢«é˜»æ­¢ï¼šå½“å‰ä½ç½®${currentBeat}ä¼šè·¨è¶Šå››åˆ†éŸ³ç¬¦æ‹ç‚¹`);
                            return false;
                        }
                        console.log(`âœ… å…«åˆ†éŸ³ç¬¦å…è®¸åœ¨16åˆ†ä½å¼€å§‹ï¼ˆç®€è°±+16åˆ†éŸ³ç¬¦å¯ç”¨ï¼‰ï¼šä½ç½®${currentBeat}`);
                    }

                    console.log(`âœ… å…«åˆ†éŸ³ç¬¦æ‹ç‚¹æ£€æŸ¥é€šè¿‡ï¼šä½ç½®${currentBeat}åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š`);
                }
            }

            return true;
        });
        
        const jianpuPatternMode = this.isJianpuTool &&
            (this.timeSignature === '4/4' || this.timeSignature === '2/4' || this.timeSignature === '3/4') &&
            Array.isArray(this.rules?.allowedDurations) &&
            this.rules.allowedDurations.includes('16th') &&
            this.rules.allowedDurations.includes('eighth.');
        if (jianpuPatternMode) {
            const tolerance = 0.001;
            if (Array.isArray(this._beatPatternQueue) && this._beatPatternQueue.length) {
                const queued = this._beatPatternQueue.shift();
                if (available.includes(queued)) {
                    console.log(`ğŸ¯ [ç®€è°±èŠ‚å¥å‹] ä½¿ç”¨é˜Ÿåˆ—æ—¶å€¼: ${queued}`);
                    return queued;
                }
                this._beatPatternQueue = [];
            }
            const positionInBeat = ((currentBeat % 1) + 1) % 1;
            const isOnQuarterBeat = Math.abs(positionInBeat) < tolerance;
            if (isOnQuarterBeat && remainingBeats >= 1 - tolerance) {
                let usePattern = true;
                const longCandidates = ['whole', 'half.', 'half', 'quarter.', 'quarter']
                    .filter((d) => available.includes(d));
                const shortCandidates = ['eighth.', 'eighth', '16th']
                    .filter((d) => available.includes(d));
                if (longCandidates.length && remainingBeats >= 2 - tolerance) {
                    const longFreq = longCandidates.reduce((sum, d) => {
                        const key = mapDurationToFrequencyKey(d);
                        return sum + Math.max(0.1, getUserFrequency('rhythm', key));
                    }, 0);
                    const shortFreq = shortCandidates.reduce((sum, d) => {
                        const key = mapDurationToFrequencyKey(d);
                        return sum + Math.max(0.1, getUserFrequency('rhythm', key));
                    }, 0);
                    const longChance = Math.min(0.65, Math.max(0.25, longFreq / (longFreq + shortFreq + 1)));
                    if (this.random.nextFloat() < longChance) {
                        console.log(`ğŸ¯ [ç®€è°±èŠ‚å¥å‹] è®©ä½é•¿æ—¶å€¼ (æ¦‚ç‡${longChance.toFixed(2)})`);
                        usePattern = false;
                    }
                }
                if (usePattern) {
                    const patterns = [
                        ['16th', '16th', '16th', '16th'],
                        ['16th', 'eighth', '16th'],
                        ['eighth', '16th', '16th'],
                        ['16th', '16th', 'eighth'],
                        ['quarter'],
                        ['eighth', 'eighth'],
                        ['eighth.', '16th'],
                        ['16th', 'eighth.']
                    ];
                    let candidates = patterns.filter((pattern) => pattern.every((d) => available.includes(d)));
                    if (candidates.length) {
                        const has16th = (pattern) => pattern.includes('16th');
                        const no16thCandidates = candidates.filter((p) => !has16th(p));
                        const with16thCandidates = candidates.filter((p) => has16th(p));
                        const sixteenthFreq = getUserFrequency('rhythm', '16th');
                        const sixteenthBeatChance = Math.min(0.7, Math.max(0.25, sixteenthFreq / 120));
                        if (this._lastBeatHad16th && no16thCandidates.length) {
                            candidates = no16thCandidates;
                        } else if (no16thCandidates.length && with16thCandidates.length) {
                            if (this.random.nextFloat() > sixteenthBeatChance) {
                                candidates = no16thCandidates;
                            }
                        }
                        const weights = candidates.map((pattern) => {
                            const total = pattern.reduce((sum, d) => {
                                const key = mapDurationToFrequencyKey(d);
                                const freq = getUserFrequency('rhythm', key);
                                return sum + Math.max(0.1, freq);
                            }, 0);
                            const count16th = pattern.filter((d) => d === '16th').length;
                            const countEighth = pattern.filter((d) => d === 'eighth').length;
                            const countDotted = pattern.filter((d) => d === 'eighth.').length;
                            const densityPenalty =
                                Math.pow(0.55, count16th) *
                                Math.pow(0.75, countEighth) *
                                Math.pow(0.85, countDotted);
                            return Math.max(0.1, (total / pattern.length) * densityPenalty);
                        });
                        const chosen = this.random.weighted(candidates, weights);
                        this._beatPatternQueue = chosen.slice();
                        this._lastBeatHad16th = chosen.includes('16th');
                        const next = this._beatPatternQueue.shift();
                        if (next && available.includes(next)) {
                            console.log(`ğŸ¯ [ç®€è°±èŠ‚å¥å‹] é€‰æ‹©æ–°èŠ‚å¥å‹: ${chosen.join('+')}`);
                            return next;
                        }
                    }
                }
            }
        }

        console.log(`å¯ç”¨æ—¶å€¼: ${available.join(', ')}`);
        
        if (available.length === 0) {
            // æ²¡æœ‰åˆé€‚çš„æ—¶å€¼ï¼Œä½¿ç”¨å‰©ä½™æ‹æ•°å¯¹åº”çš„æ—¶å€¼
            console.log(`âš ï¸ æ²¡æœ‰å¯ç”¨æ—¶å€¼ï¼Œä½¿ç”¨è‡ªåŠ¨åŒ¹é…: ${remainingBeats}æ‹`);
            const autoChosenDuration = this.beatsToNoteDuration(remainingBeats);
            console.log(`âš ï¸ è‡ªåŠ¨é€‰æ‹©æ—¶å€¼: ${autoChosenDuration}`);
            
            // å¦‚æœè‡ªåŠ¨é€‰æ‹©çš„æ—¶å€¼ä»ç„¶ä¸åˆé€‚ï¼Œå°è¯•æ›´å°çš„æ—¶å€¼
            const autoBeats = this.durationToBeats(autoChosenDuration);
            if (autoBeats > remainingBeats + 0.001) {
                console.warn(`âš ï¸ è‡ªåŠ¨æ—¶å€¼${autoChosenDuration}(${autoBeats}æ‹)è¿‡å¤§ï¼Œå‰©ä½™${remainingBeats}æ‹`);
                
                // å°è¯•æ›´ç²¾ç¡®çš„åŒ¹é…ï¼Œä½†è¦æ£€æŸ¥ç”¨æˆ·è®¾ç½®
                if (remainingBeats >= 0.25 && this.rules.allowedDurations.includes('16th')) {
                    return '16th';
                } else if (remainingBeats >= 0.125) {
                    // å¦‚æœ16åˆ†éŸ³ç¬¦ä¸å¯ç”¨ï¼Œå°è¯•å…«åˆ†éŸ³ç¬¦
                    if (remainingBeats >= 0.5) return 'eighth';
                    console.error(`âš ï¸ å‰©ä½™æ‹æ•°${remainingBeats}è¿‡å°ï¼Œä¸”16åˆ†éŸ³ç¬¦è¢«ç¦ç”¨ï¼Œå¼ºåˆ¶ä½¿ç”¨å…«åˆ†éŸ³ç¬¦`);
                    return 'eighth';
                } else {
                    console.error(`âš ï¸ å‰©ä½™æ‹æ•°${remainingBeats}è¿‡å°ï¼Œä½¿ç”¨å…«åˆ†éŸ³ç¬¦`);
                    return 'eighth';
                }
            }
            
            return autoChosenDuration;
        }
        
        // ğŸ”¥ æ–°çš„ç²¾å‡†é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
        console.log(`ğŸ¯ å¼€å§‹ç²¾å‡†èŠ‚å¥é€‰æ‹©ï¼Œå¯ç”¨é€‰é¡¹: [${available.join(', ')}]`);
        
        // ğŸ¯ 4/4æ‹å…«åˆ†éŸ³ç¬¦é…å¯¹é€»è¾‘ï¼šå¦‚æœä¸Šä¸€ä¸ªéŸ³ç¬¦éœ€è¦é…å¯¹ï¼Œä¸”å‰©ä½™0.5æ‹ï¼Œä¼˜å…ˆé€‰æ‹©å…«åˆ†éŸ³ç¬¦
        if (this.timeSignature === '4/4' && this._expectEighthNotePair && Math.abs(remainingBeats - 0.5) < 0.001 && available.includes('eighth')) {
            const eighthFreq = getUserFrequency('rhythm', 'eighth');
            if (eighthFreq > 0) {
                console.log(`ğŸ¯ [å…«åˆ†éŸ³ç¬¦é…å¯¹] å®Œæˆé…å¯¹ï¼šå‰©ä½™0.5æ‹ï¼Œé€‰æ‹©å…«åˆ†éŸ³ç¬¦ä¸ä¸Šä¸€ä¸ªé…å¯¹ï¼ˆç”¨æˆ·é¢‘ç‡: ${eighthFreq}%ï¼‰`);
                this._expectEighthNotePair = false; // é‡ç½®æ ‡è®°
                return 'eighth';
            }
        }

        // ğŸµ æ™ºèƒ½é™„ç‚¹éŸ³ç¬¦ä¼˜å…ˆçº§ï¼šåœ¨åˆé€‚çš„ä½ç½®ä¼˜å…ˆè€ƒè™‘é™„ç‚¹éŸ³ç¬¦
        if (this.timeSignature === '4/4' || this.timeSignature === '2/4' || this.timeSignature === '3/4') {
            const tolerance = 0.001;

            // åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸”å‰©ä½™è‡³å°‘1æ‹æ—¶ï¼Œè€ƒè™‘é™„ç‚¹å…«åˆ†éŸ³ç¬¦
            if (Math.abs(currentBeat % 1) < tolerance && remainingBeats >= 0.75) {
                const dottedEighthPriority = this.isJianpuTool ? 0.12 : 0.4;
                if (available.includes('eighth.') && this.random.nextFloat() < dottedEighthPriority) { // é™ä½ç®€è°±çš„ä¼˜å…ˆæ¦‚ç‡
                    const dottedEighthFreq = getUserFrequency('rhythm', 'dotted-eighth');
                    if (dottedEighthFreq > 0) {
                        console.log(`ğŸµ æ™ºèƒ½ä¼˜å…ˆï¼šåœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹${currentBeat}é€‰æ‹©é™„ç‚¹å…«åˆ†éŸ³ç¬¦`);
                        return 'eighth.';
                    }
                }
            }

            // åœ¨å¼ºæ‹ä¸”å‰©ä½™è‡³å°‘2æ‹æ—¶ï¼Œè€ƒè™‘é™„ç‚¹å››åˆ†éŸ³ç¬¦
            if ((Math.abs(currentBeat - 0) < tolerance || Math.abs(currentBeat - 2) < tolerance) && remainingBeats >= 1.5) {
                if (available.includes('quarter.') && this.random.nextFloat() < 0.3) { // 30%æ¦‚ç‡ä¼˜å…ˆé€‰æ‹©
                    const dottedQuarterFreq = getUserFrequency('rhythm', 'dotted-quarter');
                    if (dottedQuarterFreq > 0) {
                        console.log(`ğŸµ æ™ºèƒ½ä¼˜å…ˆï¼šåœ¨å¼ºæ‹${currentBeat}é€‰æ‹©é™„ç‚¹å››åˆ†éŸ³ç¬¦`);
                        return 'quarter.';
                    }
                }
            }
        }

        // é¦–å…ˆä½¿ç”¨ç²¾å‡†é¢‘ç‡ç³»ç»Ÿè¿›è¡Œé€‰æ‹©
        let selectedDuration = selectDurationByPreciseFrequency(available, this.random);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åº”ç”¨ç‰¹æ®Šè§„åˆ™ï¼ˆä»…åœ¨ç”¨æˆ·é¢‘ç‡å…è®¸çš„æƒ…å†µä¸‹ï¼‰
        const userFreqForSelected = getUserFrequency('rhythm', mapDurationToFrequencyKey(selectedDuration));
        
        if (userFreqForSelected > 0) {
            // åº”ç”¨ç‰¹æ®Šè§„åˆ™ï¼Œä½†ä¿æŒç”¨æˆ·é¢‘ç‡æ§åˆ¶çš„ä¼˜å…ˆçº§
            const shouldApplySpecialRules = this.random.nextFloat() < 0.3; // 30%çš„æ¦‚ç‡åº”ç”¨ç‰¹æ®Šè§„åˆ™
            
            if (shouldApplySpecialRules) {
                // ç‰¹æ®Šè§„åˆ™ï¼šå½“å‰©ä½™æ­£å¥½2æ‹æ—¶ï¼Œå°è¯•ä½¿ç”¨äºŒåˆ†éŸ³ç¬¦
                if (Math.abs(remainingBeats - 2) < 0.001 && available.includes('half')) {
                    const halfFreq = getUserFrequency('rhythm', 'half');
                    if (halfFreq > 0) {
                        selectedDuration = 'half';
                        console.log(`ğŸ“Œ ç‰¹æ®Šè§„åˆ™ç”Ÿæ•ˆï¼šå‰©ä½™2æ‹ï¼Œé€‰æ‹©äºŒåˆ†éŸ³ç¬¦ï¼ˆç”¨æˆ·é¢‘ç‡: ${halfFreq}%ï¼‰`);
                    }
                }
                
                // é¢å¤–è§„åˆ™ï¼šåœ¨ç¬¬3æ‹ï¼ˆcurrentBeat = 2ï¼‰ä¸”å‰©ä½™2æ‹æ—¶ï¼Œä¹Ÿä¼˜å…ˆç”¨äºŒåˆ†éŸ³ç¬¦
                if (Math.abs(currentBeat - 2) < 0.001 && Math.abs(remainingBeats - 2) < 0.001 && available.includes('half')) {
                    const halfFreq = getUserFrequency('rhythm', 'half');
                    if (halfFreq > 0) {
                        selectedDuration = 'half';
                        console.log(`ğŸ“Œ å¼ºåŒ–è§„åˆ™ç”Ÿæ•ˆï¼šç¬¬3æ‹ä½ç½®ä¸”å‰©ä½™2æ‹ï¼Œé€‰æ‹©äºŒåˆ†éŸ³ç¬¦ï¼ˆç”¨æˆ·é¢‘ç‡: ${halfFreq}%ï¼‰`);
                    }
                }

                // ğŸ”¥ æ–°å¢4/4æ‹å…«åˆ†éŸ³ç¬¦é…å¯¹è§„åˆ™ï¼šå½“å‰©ä½™æ­£å¥½1æ‹æ—¶ï¼Œä¼˜å…ˆé€‰æ‹©å…«åˆ†éŸ³ç¬¦ä»¥ä¾¿åç»­é…å¯¹
                if (this.timeSignature === '4/4' && Math.abs(remainingBeats - 1) < 0.001 && available.includes('eighth')) {
                    const eighthFreq = getUserFrequency('rhythm', 'eighth');
                    if (eighthFreq > 0) {
                        // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆ0, 1, 2, 3æ‹ï¼‰
                        const beatPosition = Math.round(currentBeat * 10000) / 10000;
                        const isOnQuarterBeat = Math.abs(beatPosition % 1) < 0.001;

                        if (isOnQuarterBeat) {
                            selectedDuration = 'eighth';
                            console.log(`ğŸ¯ 4/4æ‹å…«åˆ†éŸ³ç¬¦é…å¯¹è§„åˆ™ï¼šä½ç½®${currentBeat}å‰©ä½™1æ‹ï¼Œé€‰æ‹©å…«åˆ†éŸ³ç¬¦ä¿ƒè¿›è¿æ†ï¼ˆç”¨æˆ·é¢‘ç‡: ${eighthFreq}%ï¼‰`);
                        }
                    }
                }
            }
        }

        // æ ‡è®°éœ€è¦åç»­é…å¯¹çš„å…«åˆ†éŸ³ç¬¦
        if (this.timeSignature === '4/4' && selectedDuration === 'eighth' && Math.abs(remainingBeats - 1) < 0.001) {
            console.log(`ğŸ¯ [å…«åˆ†éŸ³ç¬¦é…å¯¹] å½“å‰é€‰æ‹©å…«åˆ†éŸ³ç¬¦ï¼Œå‰©ä½™1æ‹ï¼Œä¸‹æ¬¡ç”Ÿæˆæ—¶åº”ä¼˜å…ˆé…å¯¹`);
            this._expectEighthNotePair = true;
        }

        // ğŸ”¥ 6/8æ‹ç‰¹æ®Šå¤„ç†ï¼šç¡®ä¿ä¸è¿åæ‹ç‚¹ç»“æ„
        if (this.timeSignature === '6/8') {
            const selectedBeats = this.durationToBeats(selectedDuration);
            const noteEndPosition = currentBeat + selectedBeats;

            // æ£€æŸ¥æ˜¯å¦ä¼šè·¨è¶Šä¸åˆé€‚çš„æ‹ç‚¹è¾¹ç•Œ
            // 6/8æ‹çš„å…³é”®è¾¹ç•Œæ˜¯ 0, 1.5, 3ï¼ˆä¸¤ä¸ªå¤§æ‹ç‚¹ï¼‰
            const criticalBoundaries = [0, 1.5, 3];
            let crossesBoundary = false;
            let boundaryPosition = 0;

            for (const boundary of criticalBoundaries) {
                if (currentBeat < boundary && noteEndPosition > boundary) {
                    crossesBoundary = true;
                    boundaryPosition = boundary;
                    break;
                }
            }

            if (crossesBoundary) {
                // è®¡ç®—åˆ°è¾¹ç•Œçš„å‰©ä½™æ‹æ•°
                const beatsToBoundary = boundaryPosition - currentBeat;
                console.log(`âš ï¸ 6/8æ‹è¾¹ç•Œæ£€æŸ¥ï¼šé€‰æ‹©çš„æ—¶å€¼${selectedDuration}(${selectedBeats}æ‹)ä¼šä»ä½ç½®${currentBeat}è·¨è¶Šè¾¹ç•Œ${boundaryPosition}ï¼Œè°ƒæ•´ä¸º${beatsToBoundary}æ‹`);

                // é€‰æ‹©ä¸ä¼šè·¨è¶Šè¾¹ç•Œçš„æ—¶å€¼
                const safeDuration = this.beatsToNoteDuration(beatsToBoundary);
                if (available.includes(safeDuration)) {
                    selectedDuration = safeDuration;
                    console.log(`âœ… 6/8æ‹è¾¹ç•Œä¿®æ­£ï¼šæ”¹ç”¨${safeDuration}`);
                } else {
                    // å¦‚æœå®‰å…¨æ—¶å€¼ä¸åœ¨å¯ç”¨åˆ—è¡¨ä¸­ï¼Œé€‰æ‹©æœ€æ¥è¿‘ä¸”ä¸è¶…è¿‡çš„æ—¶å€¼
                    const safeAvailable = available.filter(d => {
                        const dBeats = this.durationToBeats(d);
                        return dBeats <= beatsToBoundary + 0.001;
                    });

                    if (safeAvailable.length > 0) {
                        // é€‰æ‹©æœ€æ¥è¿‘çš„å®‰å…¨æ—¶å€¼
                        selectedDuration = safeAvailable.reduce((best, current) => {
                            const bestBeats = this.durationToBeats(best);
                            const currentBeats = this.durationToBeats(current);
                            return Math.abs(currentBeats - beatsToBoundary) < Math.abs(bestBeats - beatsToBoundary) ? current : best;
                        });
                        console.log(`âœ… 6/8æ‹è¾¹ç•Œä¿®æ­£ï¼šä»å®‰å…¨åˆ—è¡¨é€‰æ‹©${selectedDuration}`);
                    }
                }
            }
        }

        // ğŸ”¥ é™åˆ¶ä½é¢‘ç‡ä¸‹çš„16åˆ†éŸ³ç¬¦è¿å‘ï¼Œé¿å…å‡ºç°ä¸€é•¿ä¸²16åˆ†éŸ³ç¬¦
        if (this.timeSignature !== '6/8') {
            const isSixteenth = selectedDuration === '16th' || selectedDuration === '16th.';
            if (isSixteenth) {
                const sixteenthFreq = getUserFrequency('rhythm', '16th');
                let maxRun;
                if (sixteenthFreq <= 10) maxRun = 2;
                else if (sixteenthFreq <= 25) maxRun = 3;
                else if (sixteenthFreq <= 50) maxRun = 4;
                else maxRun = 6;

                const nextRun = (this._sixteenthRun || 0) + 1;
                if (nextRun > maxRun) {
                    const alternatives = available.filter(d => d !== '16th' && d !== '16th.');
                    if (alternatives.length > 0) {
                        const fallback = selectDurationByPreciseFrequency(alternatives, this.random);
                        console.log(`ğŸ¯ [16åˆ†éŸ³ç¬¦æŠ‘åˆ¶] é¢‘ç‡${sixteenthFreq}% è¿ç»­${nextRun}è¶…é™(${maxRun})ï¼Œæ”¹é€‰${fallback}`);
                        selectedDuration = fallback;
                        this._sixteenthRun = (fallback === '16th' || fallback === '16th.') ? 1 : 0;
                    } else {
                        this._sixteenthRun = nextRun;
                    }
                } else {
                    this._sixteenthRun = nextRun;
                }
            } else {
                this._sixteenthRun = 0;
            }
        }

        // ğŸ”¥ æœ€ç»ˆéªŒè¯ï¼šç¡®ä¿é€‰æ‹©çš„æ—¶å€¼ä¸ä¼šå¯¼è‡´å°èŠ‚å¡«å……é—®é¢˜
        const finalBeats = this.durationToBeats(selectedDuration);
        const remainingAfterNote = remainingBeats - finalBeats;

        // æ£€æŸ¥å‰©ä½™ç©ºé—´æ˜¯å¦å¯ä»¥åˆç†å¡«å……
        if (remainingAfterNote > 0.001) {
            // ç¡®ä¿å‰©ä½™ç©ºé—´è‡³å°‘èƒ½æ”¾ä¸‹ä¸€ä¸ªåå…­åˆ†éŸ³ç¬¦æˆ–åˆç†çš„ä¼‘æ­¢ç¬¦
            if (remainingAfterNote < 0.24 && remainingAfterNote > 0.001) {
                console.log(`âš ï¸ æ—¶å€¼éªŒè¯ï¼šé€‰æ‹©${selectedDuration}(${finalBeats}æ‹)åå‰©ä½™${remainingAfterNote}æ‹ï¼Œç©ºé—´è¿‡å°éš¾ä»¥å¡«å……`);

                // å°è¯•é€‰æ‹©æ›´å°çš„æ—¶å€¼ä»¥ç•™å‡ºåˆç†ç©ºé—´
                const saferOptions = available.filter(d => {
                    const dBeats = this.durationToBeats(d);
                    const wouldRemain = remainingBeats - dBeats;
                    return wouldRemain === 0 || wouldRemain >= 0.25; // è¦ä¹ˆæ­£å¥½å¡«æ»¡ï¼Œè¦ä¹ˆè‡³å°‘ç•™ä¸‹åå…­åˆ†éŸ³ç¬¦çš„ç©ºé—´
                });

                if (saferOptions.length > 0) {
                    // ä¼˜å…ˆé€‰æ‹©èƒ½æ­£å¥½å¡«æ»¡çš„æ—¶å€¼
                    const perfectFit = saferOptions.find(d => Math.abs(remainingBeats - this.durationToBeats(d)) < 0.001);
                    if (perfectFit) {
                        selectedDuration = perfectFit;
                        console.log(`âœ… é€‰æ‹©å®Œç¾åŒ¹é…æ—¶å€¼: ${selectedDuration}`);
                    } else {
                        // å¦åˆ™é€‰æ‹©æœ€å¤§çš„å®‰å…¨æ—¶å€¼
                        selectedDuration = saferOptions.reduce((best, current) =>
                            this.durationToBeats(current) > this.durationToBeats(best) ? current : best
                        );
                        console.log(`âœ… é€‰æ‹©æ›´å®‰å…¨çš„æ—¶å€¼: ${selectedDuration}`);
                    }
                }
            }
        }

        console.log(`ğŸ¯ æœ€ç»ˆé€‰æ‹©çš„èŠ‚å¥æ—¶å€¼: ${selectedDuration}(${this.durationToBeats(selectedDuration)}æ‹)`);

        // é‡ç½®å…«åˆ†éŸ³ç¬¦é…å¯¹æ ‡è®°ï¼ˆå½“é€‰æ‹©çš„ä¸æ˜¯å…«åˆ†éŸ³ç¬¦æ—¶ï¼‰
        if (selectedDuration !== 'eighth') {
            this._expectEighthNotePair = false;
        }

        return selectedDuration;
    }

    /**
     * å¼ºåˆ¶éªŒè¯å¹¶ä¿®æ­£éŸ³ç¬¦åˆ°éŸ³åŸŸèŒƒå›´å†…
     */
    validateAndCorrectMidi(midi, source = "unknown") {
        // ç‰¹æ®Šæ£€æŸ¥ï¼šæ€»æ˜¯è¿½è¸ª MIDI 72 (B#4 åœ¨ C# å¤§è°ƒ)
        if (midi === 72) {
            console.error(`ğŸ¯ğŸ¯ğŸ¯ [${source}] æ£€æµ‹åˆ° MIDI 72 (B#4)! å½“å‰éŸ³åŸŸ: ${this.rules.range.min}-${this.rules.range.max}`);
            console.error(`ğŸ¯ è°ƒå·: ${this.keySignature}`);
            console.error(`ğŸ¯ å¦‚æœæ˜¯ C3-C4 éŸ³åŸŸ (48-60)ï¼Œè¿™æ˜¯é”™è¯¯çš„!`);
            console.error(`ğŸ¯ æ ˆè¿½è¸ª:`, new Error().stack.split('\n').slice(1, 6).join('\n'));
        }
        
        if (midi < this.rules.range.min || midi > this.rules.range.max) {
            const originalMidi = midi;
            midi = Math.max(this.rules.range.min, Math.min(this.rules.range.max, midi));
            console.error(`ğŸš¨ [${source}] éŸ³ç¬¦è¶…å‡ºéŸ³åŸŸ: ${originalMidi} -> ${midi} (éŸ³åŸŸ: ${this.rules.range.min}-${this.rules.range.max})`);
            
            // ç‰¹æ®Šæ£€æŸ¥ï¼šå¦‚æœåŸå§‹éŸ³ç¬¦æ˜¯72ï¼ˆC5ä½†å¯èƒ½æ˜¾ç¤ºä¸ºB#4ï¼‰
            if (originalMidi === 72) {
                console.error(`ğŸš¨ [${source}] ç‰¹åˆ«æ³¨æ„ï¼šMIDI 72 (C5/B#4) è¢«ä¿®æ­£ä¸º ${midi}`);
                console.error(`ğŸš¨ [${source}] åœ¨C#å¤§è°ƒä¸­ï¼Œè¿™ä¸ªéŸ³ç¬¦å¯èƒ½æ˜¾ç¤ºä¸ºB#4`);
            }
        }
        return midi;
    }

    getClimaxWindow() {
        if (!this.cfConfig.climaxWindow) {
            const total = this.measures;
            const minStart = Math.max(0, Math.floor(total * 0.2));
            const maxStart = Math.max(minStart, total - 2);
            const start = this.random.nextInt(minStart, maxStart + 1);
            const end = Math.max(start, total - 2);
            this.cfConfig.climaxWindow = { start, end };
            console.log(`ğŸ¯ æ—‹å¾‹climaxçª—å£: ${start + 1}-${end + 1}å°èŠ‚`);
        }
        return this.cfConfig.climaxWindow;
    }

    getLargeLeapTargetByMeasures(totalMeasures) {
        const total = Number(totalMeasures);
        if (!Number.isFinite(total)) return null;
        if (total === 12) return { min: 2, max: 3 };
        if (total === 16) return { min: 3, max: 4 };
        return null;
    }

    tryGeneratePlannedLargeLeap(lastMidi, context = {}, consecutiveJumps = 0) {
        if (lastMidi === null || lastMidi === undefined) return null;
        const target = this.cfConfig.largeLeapTarget;
        if (!target) return null;
        if (consecutiveJumps > 0) return null;

        const measureIndex = typeof context.measureIndex === 'number' ? context.measureIndex : null;
        if (measureIndex === null) return null;

        const currentCount = this.cfState.largeLeapCount || 0;
        if (currentCount >= target.max) return null;

        const totalMeasures = this.measures || context.totalMeasures || 0;
        const remainingMeasures = Math.max(0, totalMeasures - measureIndex - 1);
        const leapNeed = Math.max(0, target.min - currentCount);
        const forceNow = leapNeed > 0 && remainingMeasures < leapNeed;

        if (!forceNow) {
            if (measureIndex === 0) return null;
            if (context.isCadence) return null;
            const inMiddleWindow = totalMeasures > 0
                ? (measureIndex >= Math.floor(totalMeasures * 0.2) && measureIndex <= Math.ceil(totalMeasures * 0.85))
                : true;
            let chance = currentCount < target.min ? 0.34 : 0.16;
            if (inMiddleWindow) chance += 0.08;
            if (context.isMeasureStart) chance += 0.06;
            if (this.random.nextFloat() > chance) return null;
        }

        const threshold = this.cfConfig.largeLeapThreshold || 5;
        const maxJump = this.rules.maxJump || 12;
        const currentMin = this.cfState.minMidi ?? lastMidi;
        const currentMax = this.cfState.maxMidi ?? lastMidi;

        let candidates = this.getScaleNotesInRange().filter((midi) => {
            if (midi === lastMidi) return false;
            const interval = Math.abs(midi - lastMidi);
            if (interval < threshold || interval > maxJump) return false;
            if (this.cfConfig.maxSpan) {
                const nextMin = Math.min(currentMin, midi);
                const nextMax = Math.max(currentMax, midi);
                if (nextMax - nextMin > this.cfConfig.maxSpan) return false;
            }
            return true;
        });

        if (!candidates.length) {
            if (forceNow) {
                console.warn(`âš ï¸ å¼ºåˆ¶å¤§è·³è¿›å¤±è´¥ï¼šå½“å‰æ— å¯ç”¨å€™é€‰ï¼ˆé˜ˆå€¼${threshold}åŠéŸ³ï¼‰`);
            }
            return null;
        }

        if (this.cfConfig.peakOnce && this.cfState.peakCount >= 1) {
            const nonHigherCandidates = candidates.filter((midi) => midi <= currentMax);
            if (nonHigherCandidates.length) candidates = nonHigherCandidates;
        }

        if (this.cfState.climaxLeapDone) {
            const downCandidates = candidates.filter((midi) => midi < lastMidi);
            if (downCandidates.length) candidates = downCandidates;
        }

        const weights = candidates.map((midi) => {
            const interval = Math.abs(midi - lastMidi);
            let weight = interval >= (threshold + 2) ? 1.4 : 1;
            if (forceNow) weight *= 1.2;
            return weight;
        });
        const selected = this.random.weighted(candidates, weights);
        if (forceNow) {
            console.log(`ğŸ¯ å¼ºåˆ¶è¡¥è¶³å¤§è·³è¿›: ${lastMidi} -> ${selected} (é—´éš”${Math.abs(selected - lastMidi)}åŠéŸ³)`);
        } else {
            console.log(`ğŸ¯ è®¡åˆ’å¤§è·³è¿›å€™é€‰: ${lastMidi} -> ${selected} (é—´éš”${Math.abs(selected - lastMidi)}åŠéŸ³)`);
        }
        return selected;
    }

    updateRepeatState(lastMidi, nextMidi) {
        if (typeof nextMidi !== 'number') return;
        const previousMidi = this.cfState.prevMidi ?? null;
        this.cfState.prevPrevMidi = previousMidi;
        this.cfState.prevMidi = typeof lastMidi === 'number' ? lastMidi : null;
        this.cfState.lastInterval = typeof lastMidi === 'number' ? (nextMidi - lastMidi) : null;
        if (lastMidi !== null && nextMidi === lastMidi) {
            this.cfState.repeatCount = Math.min(3, (this.cfState.repeatCount || 0) + 1);
        } else {
            this.cfState.repeatCount = 0;
        }
        this.cfState.lastMidi = nextMidi;
        if (!Array.isArray(this.cfState.midiHistory)) {
            this.cfState.midiHistory = [];
        }
        this.cfState.midiHistory.push(nextMidi);
        if (this.cfState.midiHistory.length > 6) {
            this.cfState.midiHistory.shift();
        }
    }

    getScaleNotesInRange() {
        const notes = [];
        const range = this.rules.range || { min: 48, max: 72 };
        const scale = Array.isArray(this.scale) ? this.scale : [0, 2, 4, 5, 7, 9, 11];
        const minOct = Math.floor(range.min / 12);
        const maxOct = Math.floor(range.max / 12);
        for (let octave = minOct; octave <= maxOct; octave++) {
            for (const degree of scale) {
                const midi = octave * 12 + degree;
                if (midi >= range.min && midi <= range.max) {
                    notes.push(midi);
                }
            }
        }
        return notes;
    }

    tryGenerateClimaxLeap(lastMidi, context = {}, consecutiveJumps = 0) {
        if (lastMidi === null || lastMidi === undefined) return null;
        if (this.cfState.climaxLeapDone) return null;

        const measureIndex = typeof context.measureIndex === 'number' ? context.measureIndex : null;
        if (measureIndex === null) return null;

        const { start, end } = this.getClimaxWindow();
        if (measureIndex < start) return null;

        const lastChance = measureIndex >= end;
        if ((context.isCadence || context.isPhrasEnd) && !lastChance) return null;
        if (consecutiveJumps > 0 && !lastChance) return null;

        const maxJump = this.rules.maxJump || 12;
        const minLeap = Math.min(this.cfConfig.climaxMinLeap || 4, maxJump);
        if (minLeap <= 0) return null;

        const possibleNotes = this.getScaleNotesInRange();
        const currentMin = this.cfState.minMidi ?? lastMidi;
        const currentMax = this.cfState.maxMidi ?? lastMidi;
        const baseCandidates = possibleNotes.filter((midi) => {
            if (midi === lastMidi) return false;
            const interval = Math.abs(midi - lastMidi);
            if (interval < minLeap || interval > maxJump) return false;
            if (this.cfConfig.maxSpan) {
                const nextMin = Math.min(currentMin, midi);
                const nextMax = Math.max(currentMax, midi);
                if (nextMax - nextMin > this.cfConfig.maxSpan) return false;
            }
            return true;
        });

        if (!baseCandidates.length) return null;

        const upward = baseCandidates.filter((midi) => midi > lastMidi);
        const upwardNewPeak = upward.filter((midi) => midi > (this.cfState.maxMidi ?? -Infinity));
        let candidates = upwardNewPeak.length ? upwardNewPeak : upward;

        if (!candidates.length && lastChance) {
            candidates = baseCandidates;
        } else if (!candidates.length) {
            return null;
        }

        let selected = null;
        if (this.isJianpuTool) {
            const intervalBuckets = new Map();
            candidates.forEach((midi) => {
                const interval = Math.abs(midi - lastMidi);
                if (!intervalBuckets.has(interval)) intervalBuckets.set(interval, []);
                intervalBuckets.get(interval).push(midi);
            });
            const intervals = Array.from(intervalBuckets.keys());
            const weights = intervals.map((interval) => {
                const ratio = interval / maxJump;
                let weight = 1;
                if (ratio >= 0.85) {
                    weight = 3;
                } else if (ratio >= 0.7) {
                    weight = 2.5;
                } else if (ratio >= 0.55) {
                    weight = 2;
                }
                if (interval === maxJump) weight *= 0.85;
                return weight;
            });
            const targetInterval = this.random.weighted(intervals, weights);
            const bucket = intervalBuckets.get(targetInterval) || candidates;
            selected = this.random.choice(bucket);
        } else {
            const maxInterval = Math.max(...candidates.map((m) => Math.abs(m - lastMidi)));
            const strongest = candidates.filter((m) => Math.abs(m - lastMidi) === maxInterval);
            selected = this.random.choice(strongest);
        }
        console.log(`ğŸ¯ è§¦å‘é«˜æ½®è·³è¿›å€™é€‰: ${lastMidi} -> ${selected} (é—´éš”${Math.abs(selected - lastMidi)}åŠéŸ³)`);
        return selected;
    }

    /**
     * ç”Ÿæˆä¸‹ä¸€ä¸ªéŸ³ç¬¦
     */
    generateNextNote(lastMidi, lastDirection, consecutiveJumps, isEnding, context = {}) {
        if (lastMidi === null) {
            const firstNote = this.generateInScaleNote(null);
            const validatedFirstNote = this.validateAndCorrectMidi(firstNote, "generateNextNote-é¦–éŸ³ç¬¦");
            const cfNote = this.applyCantusFirmusGuards(null, validatedFirstNote, "generateNextNote-é¦–éŸ³ç¬¦", context);
            console.log(`ğŸµ [generateNextNote] ç”Ÿæˆé¦–éŸ³ç¬¦: MIDI ${firstNote} -> ${validatedFirstNote} -> CF ${cfNote}`);
            return cfNote;
        }
        
        // ç»“å°¾éŸ³ç¬¦ç‰¹æ®Šå¤„ç† - ä¸¥æ ¼æ‰§è¡ŒéŸ³ç¨‹çº¦æŸ
        if (isEnding && this.rules.preferredEnds) {
            let endingNotes = this.rules.preferredEnds.filter(midi => {
                // æ£€æŸ¥éŸ³åŸŸèŒƒå›´
                if (midi < this.rules.range.min || midi > this.rules.range.max) {
                    return false;
                }
                // æ£€æŸ¥éŸ³ç¨‹è·³åº¦
                if (lastMidi !== null) {
                    const interval = Math.abs(midi - lastMidi);
                    if (interval > this.rules.maxJump) {
                        return false;
                    }
                }
                return true;
            });
            const avoidRepeat = this.cfState.repeatCount >= 1;
            if (avoidRepeat) {
                const noRepeat = endingNotes.filter(midi => midi !== lastMidi);
                if (noRepeat.length > 0) endingNotes = noRepeat;
            }
            if (endingNotes.length > 0) {
                const selectedNote = this.random.choice(endingNotes);
                const validatedEndingNote = this.validateAndCorrectMidi(selectedNote, "generateNextNote-ç»“æŸéŸ³ç¬¦");
                const actualInterval = Math.abs(validatedEndingNote - lastMidi);
                const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedEndingNote, "generateNextNote-ç»“æŸéŸ³ç¬¦", context);
                console.log(`ğŸµ [generateNextNote] é€‰æ‹©ç»“æŸéŸ³ç¬¦: MIDI ${selectedNote} -> ${validatedEndingNote} -> CF ${cfNote}, ä¸å‰éŸ³é—´éš”: ${actualInterval}åŠéŸ³`);
                return cfNote;
            }
        }
        
        // å¤§è·³åå¿…é¡»å›å½’
        if (this.rules.jumpMustReturn && consecutiveJumps > 0) {
            const returnNote = this.generateStepwiseReturn(lastMidi, lastDirection);
            const validatedReturnNote = this.validateAndCorrectMidi(returnNote, "generateNextNote-å¤§è·³å›å½’");
            const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedReturnNote, "generateNextNote-å¤§è·³å›å½’", context);
            console.log(`ğŸµ [generateNextNote] å¤§è·³å›å½’: MIDI ${returnNote} -> ${validatedReturnNote} -> CF ${cfNote}`);
            return cfNote;
        }

        const climaxCandidate = this.tryGenerateClimaxLeap(lastMidi, context, consecutiveJumps);
        if (climaxCandidate !== null) {
            const prevMax = this.cfState.maxMidi;
            const validatedClimax = this.validateAndCorrectMidi(climaxCandidate, "generateNextNote-é«˜æ½®è·³è¿›");
            const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedClimax, "generateNextNote-é«˜æ½®è·³è¿›", context);
            const actualInterval = Math.abs(cfNote - lastMidi);
            if (!this.cfState.climaxLeapDone && actualInterval >= (this.cfConfig.climaxMinLeap || 4)) {
                this.cfState.climaxLeapDone = true;
                if (prevMax === null || cfNote > prevMax) {
                    this.cfState.peakCount = 1;
                }
            }
            console.log(`ğŸµ [generateNextNote] é«˜æ½®è·³è¿›: MIDI ${climaxCandidate} -> ${validatedClimax} -> CF ${cfNote}`);
            return cfNote;
        }

        const plannedLargeLeap = this.tryGeneratePlannedLargeLeap(lastMidi, context, consecutiveJumps);
        if (plannedLargeLeap !== null) {
            const validatedLargeLeap = this.validateAndCorrectMidi(plannedLargeLeap, "generateNextNote-è®¡åˆ’å¤§è·³è¿›");
            const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedLargeLeap, "generateNextNote-è®¡åˆ’å¤§è·³è¿›", context);
            console.log(`ğŸµ [generateNextNote] è®¡åˆ’å¤§è·³è¿›: MIDI ${plannedLargeLeap} -> ${validatedLargeLeap} -> CF ${cfNote}`);
            return cfNote;
        }
        
        // çº§è¿›ä¼˜å…ˆï¼šæé«˜æ¦‚ç‡ï¼Œä¿æŒCFçº§è¿›ä¸»å¯¼
        const stepwiseChance = this.isJianpuTool ? 0.55 : 0.7;
        if (this.rules.stepwisePreferred && this.random.nextFloat() < stepwiseChance) {
            const stepwiseNote = this.generateStepwiseNote(lastMidi, lastDirection);
            const validatedStepwiseNote = this.validateAndCorrectMidi(stepwiseNote, "generateNextNote-çº§è¿›ä¼˜å…ˆ");
            const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedStepwiseNote, "generateNextNote-çº§è¿›ä¼˜å…ˆ", context);
            console.log(`ğŸµ [generateNextNote] çº§è¿›ä¼˜å…ˆ: MIDI ${stepwiseNote} -> ${validatedStepwiseNote} -> CF ${cfNote}`);
            return cfNote;
        }
        
        // æ­£å¸¸ç”Ÿæˆï¼ˆä¼ é€’ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼‰
        const normalNote = this.generateInScaleNote(lastMidi, context);
        const validatedNormalNote = this.validateAndCorrectMidi(normalNote, "generateNextNote-æ­£å¸¸ç”Ÿæˆ");
        const cfNote = this.applyCantusFirmusGuards(lastMidi, validatedNormalNote, "generateNextNote-æ­£å¸¸ç”Ÿæˆ", context);
        console.log(`ğŸµ [generateNextNote] æ­£å¸¸ç”Ÿæˆ: MIDI ${normalNote} -> ${validatedNormalNote} -> CF ${cfNote}`);
        return cfNote;
    }

    /**
     * Cantus firmus é£æ ¼çš„æ”¶æ•›çº¦æŸï¼šé™åˆ¶å…¨æ›²è·¨åº¦ã€å•ä¸€å³°å€¼ã€å¼ºåˆ¶å›æ”¶å¤§è·³
     */
    applyCantusFirmusGuards(lastMidi, candidate, label = "cf-guard", context = {}) {
        if (candidate === null || candidate === undefined) return candidate;

        // åˆå§‹åŒ–çŠ¶æ€
        if (this.cfState.minMidi === null) this.cfState.minMidi = candidate;
        if (this.cfState.maxMidi === null) this.cfState.maxMidi = candidate;
        if (this.cfState.peakMidi === null) this.cfState.peakMidi = candidate;
        const prevMax = this.cfState.maxMidi;

        let adjusted = candidate;
        const leapTarget = this.cfConfig.largeLeapTarget;
        const leapThreshold = this.cfConfig.largeLeapThreshold || 5;

        if (typeof context.measureIndex === 'number' && !this.cfState.climaxLeapDone) {
            const { start } = this.getClimaxWindow();
            if (context.measureIndex < start) {
                const rangeSpan = this.rules.range.max - this.rules.range.min;
                const headroomBase = Math.max(3, Math.round((this.rules.maxJump || 12) * 0.4));
                const headroom = Math.min(headroomBase, Math.max(2, Math.floor(rangeSpan * 0.5)));
                const ceiling = this.rules.range.max - headroom;
                if (adjusted > ceiling) {
                    const fallback = lastMidi !== null ? Math.min(lastMidi + 2, ceiling) : ceiling;
                    adjusted = this.validateAndCorrectMidi(fallback, `${label}-preclimax-cap`);
                }
            }
        }

        if (lastMidi !== null && leapTarget) {
            const interval = Math.abs(adjusted - lastMidi);
            const reachedLargeLeapCap = (this.cfState.largeLeapCount || 0) >= leapTarget.max;
            if (interval >= leapThreshold && reachedLargeLeapCap) {
                const fallbackNote = this.generateStepwiseReturn(
                    lastMidi,
                    this.cfState.lastInterval ? Math.sign(this.cfState.lastInterval) : 0
                );
                const fallbackInterval = Math.abs(fallbackNote - lastMidi);
                adjusted = this.validateAndCorrectMidi(fallbackNote, `${label}-large-leap-cap`);
                console.log(`ğŸš§ å¤§è·³è¿›ä¸Šé™ä¿æŠ¤: å·²è¾¾${this.cfState.largeLeapCount}/${leapTarget.max}æ¬¡ï¼Œ${interval}åŠéŸ³ -> ${fallbackInterval}åŠéŸ³`);
            }
        }

        // æ§åˆ¶æ€»è·¨åº¦ï¼ˆä¸è¶…è¿‡ååº¦ï¼‰ï¼šè‹¥è¶…å‡ºåˆ™å¾€ä¸­é—´æ”¶æ‹¢ä¸€æ­¥çº§è¿›
        const nextMin = Math.min(this.cfState.minMidi, adjusted);
        const nextMax = Math.max(this.cfState.maxMidi, adjusted);
        if (nextMax - nextMin > this.cfConfig.maxSpan) {
            const midpoint = Math.round((this.cfState.minMidi + this.cfState.maxMidi) / 2);
            // ä»¥çº§è¿›æ–¹å¼å‘ä¸­è½´é æ‹¢
            if (adjusted > midpoint) adjusted = Math.max(lastMidi !== null ? Math.min(adjusted, lastMidi + 2) : adjusted - 2, midpoint);
            else adjusted = Math.min(lastMidi !== null ? Math.max(adjusted, lastMidi - 2) : adjusted + 2, midpoint);
            adjusted = this.validateAndCorrectMidi(adjusted, `${label}-span`);
        }

        // å•ä¸€å³°å€¼ï¼šåªå…è®¸ä¸€æ¬¡æ–°çš„æœ€é«˜éŸ³ï¼Œåç»­ä¸å†æŠ¬é«˜å³°å€¼
        if (this.cfConfig.peakOnce) {
            if (adjusted > this.cfState.peakMidi) {
                if (this.cfState.peakCount >= 1) {
                    // æœ‰å³°å€¼åï¼Œé¿å…å†æŠ¬é«˜ï¼Œæ”¹ç”¨ç›¸é‚»çº§è¿›
                    adjusted = lastMidi !== null ? this.generateStepwiseNote(lastMidi, 0) : this.cfState.peakMidi;
                    adjusted = this.validateAndCorrectMidi(adjusted, `${label}-peak-guard`);
                } else {
                    this.cfState.peakMidi = adjusted;
                }
            } else if (adjusted === this.cfState.peakMidi && this.cfState.peakCount >= 1) {
                // é¿å…å¤šæ¬¡è§¦é¡¶ï¼šè½»å¾®ä¸‹è°ƒä¸€çº§
                adjusted = this.validateAndCorrectMidi(adjusted - 2, `${label}-peak-flatten`);
            }
        }

        // æ›´æ–°ç»Ÿè®¡çª—å£
        this.cfState.minMidi = Math.min(this.cfState.minMidi, adjusted);
        this.cfState.maxMidi = Math.max(this.cfState.maxMidi, adjusted);

        if (!this.cfState.climaxLeapDone && lastMidi !== null) {
            const interval = Math.abs(adjusted - lastMidi);
            const isNewPeak = prevMax === null || adjusted > prevMax;
            if (adjusted > lastMidi && isNewPeak && interval >= (this.cfConfig.climaxMinLeap || 4)) {
                this.cfState.climaxLeapDone = true;
                this.cfState.peakCount = 1;
                console.log(`ğŸ¯ CFæ ‡è®°é«˜æ½®è·³è¿›: ${lastMidi} -> ${adjusted} (${interval}åŠéŸ³)`);
            }
        }

        const avoidRepeatAggressive = this.isJianpuTool &&
            Array.isArray(this.rules?.allowedDurations) &&
            this.rules.allowedDurations.includes('16th');
        const lastNoteBeats = typeof this.cfState?.lastNoteBeats === 'number' ? this.cfState.lastNoteBeats : null;
        const currentBeats = typeof context?.beats === 'number' ? context.beats : null;
        const crossBarShortRepeat = avoidRepeatAggressive &&
            context?.isMeasureStart &&
            lastMidi !== null &&
            adjusted === lastMidi &&
            lastNoteBeats !== null &&
            currentBeats !== null &&
            lastNoteBeats <= 0.25 &&
            currentBeats <= 0.25;
        if (crossBarShortRepeat) {
            const stepNote = this.generateStepwiseNote(lastMidi, 0);
            if (stepNote !== lastMidi) {
                adjusted = this.validateAndCorrectMidi(stepNote, `${label}-avoid-repeat-crossbar`);
            }
        }
        if (avoidRepeatAggressive && lastMidi !== null && adjusted === lastMidi) {
            const stepNote = this.generateStepwiseNote(lastMidi, 0);
            if (stepNote !== lastMidi) {
                adjusted = this.validateAndCorrectMidi(stepNote, `${label}-avoid-repeat`);
            }
        }

        const history = Array.isArray(this.cfState.midiHistory) ? this.cfState.midiHistory : [];
        const hLen = history.length;
        const h1 = hLen >= 1 ? history[hLen - 1] : null;
        const h2 = hLen >= 2 ? history[hLen - 2] : null;
        const h3 = hLen >= 3 ? history[hLen - 3] : null;
        const wouldTripleRepeat = h2 !== null && h1 !== null && h2 === h1 && adjusted === h1;
        const wouldAlternate = h3 !== null && h2 !== null && h3 === h1 && h2 !== h1 && adjusted === h2;
        const repeatCount = this.cfState.repeatCount || 0;
        if (lastMidi !== null && (wouldTripleRepeat || wouldAlternate || (repeatCount >= 1 && adjusted === lastMidi))) {
            const avoid = new Set([lastMidi]);
            if (wouldAlternate && h2 !== null) avoid.add(h2);
            const alt = this.pickAlternateMelodyNote(lastMidi, { avoid, preferThird: true });
            if (alt !== null && alt !== adjusted) {
                adjusted = this.validateAndCorrectMidi(alt, `${label}-avoid-pattern`);
            }
        }

        if (lastMidi !== null && leapTarget) {
            let finalInterval = Math.abs(adjusted - lastMidi);
            const reachedCap = (this.cfState.largeLeapCount || 0) >= leapTarget.max;
            if (finalInterval >= leapThreshold && reachedCap) {
                const fallbackNote = this.generateStepwiseReturn(
                    lastMidi,
                    this.cfState.lastInterval ? Math.sign(this.cfState.lastInterval) : 0
                );
                adjusted = this.validateAndCorrectMidi(fallbackNote, `${label}-large-leap-final-cap`);
                finalInterval = Math.abs(adjusted - lastMidi);
                console.log(`ğŸš§ æœ€ç»ˆå¤§è·³è¿›ä¸Šé™ä¿æŠ¤: ç›®æ ‡ä¸Šé™${leapTarget.max}æ¬¡ï¼Œæ”¹å†™ä¸º${finalInterval}åŠéŸ³`);
            }
            if (finalInterval >= leapThreshold) {
                this.cfState.largeLeapCount = (this.cfState.largeLeapCount || 0) + 1;
                this.stats.largeLeapCount = this.cfState.largeLeapCount;
                console.log(`ğŸ¯ å¤§è·³è¿›è®¡æ•°: ${this.cfState.largeLeapCount}/${leapTarget.max} (é˜ˆå€¼${leapThreshold}åŠéŸ³, å®é™…${finalInterval}åŠéŸ³)`);
            }
        }

        this.updateRepeatState(lastMidi, adjusted);

        return adjusted;
    }

    /**
     * ç¡®ä¿ç»ˆæ­¢è½åœ¨ä¸»å’Œå¼¦å†…éŸ³ï¼ˆè°ƒçš„ I ä¸‰å’Œå¼¦ 1/3/5ï¼‰
     */
    enforceFinalChordTone(melody) {
        if (!Array.isArray(melody) || melody.length === 0) return melody;
        const lastMeasure = melody[melody.length - 1];
        if (!lastMeasure || !Array.isArray(lastMeasure.notes)) return melody;

        // æ‰¾åˆ°æœ€åä¸€ä¸ªéŸ³ç¬¦åŠå…¶å‰ä¸€ä¸ªéŸ³ç¬¦
        let lastNoteIndex = -1;
        for (let i = lastMeasure.notes.length - 1; i >= 0; i--) {
            if (lastMeasure.notes[i].type === 'note') {
                lastNoteIndex = i;
                break;
            }
        }
        if (lastNoteIndex === -1) return melody;

        const lastNote = lastMeasure.notes[lastNoteIndex];

        // è·å–å‰ä¸€éŸ³ç¬¦ï¼ˆè·¨å°èŠ‚å‘å‰æ‰¾ï¼‰
        let prevMidi = null;
        for (let m = melody.length - 1; m >= 0; m--) {
            const notes = melody[m].notes || [];
            for (let n = (m === melody.length - 1 ? lastNoteIndex - 1 : notes.length - 1); n >= 0; n--) {
                if (notes[n].type === 'note' && typeof notes[n].midi === 'number') {
                    prevMidi = notes[n].midi;
                    m = -1; // break outer
                    break;
                }
            }
        }

        const chordDegrees = getTonicChordTones(this.keySignature) || [0, 4, 7];
        const candidates = [];
        for (let octave = Math.floor(this.rules.range.min / 12) - 1; octave <= Math.floor(this.rules.range.max / 12) + 1; octave++) {
            for (const deg of chordDegrees) {
                const midi = octave * 12 + deg;
                if (midi >= this.rules.range.min && midi <= this.rules.range.max) {
                    candidates.push(midi);
                }
            }
        }
        if (!candidates.length) return melody;

        const maxJump = this.rules.maxJump || 12;
        const filtered = candidates.filter((m) => {
            if (prevMidi === null) return true;
            return Math.abs(m - prevMidi) <= maxJump;
        });
        const usable = filtered.length ? filtered : candidates;

        // é€‰æ‹©æœ€æ¥è¿‘å½“å‰å°¾éŸ³çš„ä¸»å’Œå¼¦å†…éŸ³
        const target = usable.reduce((best, m) => {
            const dist = Math.abs(m - lastNote.midi);
            if (!best || dist < best.dist) return { midi: m, dist };
            return best;
        }, null)?.midi;

        if (typeof target === 'number') {
            const noteInfo = this.midiToMusicXML(target);
            lastNote.midi = target;
            lastNote.step = noteInfo.step;
            lastNote.octave = noteInfo.octave;
            lastNote.alter = noteInfo.alter;
            lastNote.tied = false;
            lastNote.tieType = null;
            console.log(`ğŸ¯ ç»ˆæ­¢å¯¹é½ä¸»å’Œå¼¦: MIDI ${target} (${noteInfo.step}${noteInfo.alter || ''}${noteInfo.octave})`);
        }

        return melody;
    }

    /**
     * ç”Ÿæˆè°ƒå†…éŸ³ç¬¦ - ä¸¥æ ¼éµå¾ªæœ€å¤§éŸ³ç¨‹è·¨åº¦é™åˆ¶
     */
    generateInScaleNote(lastMidi, context = {}) {
        const maxAttempts = 100; // å¢åŠ é‡è¯•æ¬¡æ•°
        let attempts = 0;
        const isMinorKey = (this.keySignature || '').toLowerCase().endsWith('m');
        
        while (attempts < maxAttempts) {
            const possibleNotes = [];
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è°ƒå†…éŸ³ç¬¦
            if (Array.isArray(this.scale)) {
                for (let octave = Math.floor(this.rules.range.min / 12); octave <= Math.floor(this.rules.range.max / 12); octave++) {
                    for (const scaleDegree of this.scale) {
                        const midi = octave * 12 + scaleDegree;
                        if (midi >= this.rules.range.min && midi <= this.rules.range.max) {
                            possibleNotes.push(midi);
                        }
                    }
                }
            } else {
                // å¦‚æœscaleæ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤çš„Cå¤§è°ƒéŸ³é˜¶
                console.warn('âš ï¸ this.scaleæ— æ•ˆï¼Œä½¿ç”¨Cå¤§è°ƒä½œä¸ºå¤‡ç”¨');
                const defaultScale = [0, 2, 4, 5, 7, 9, 11];
                for (let octave = Math.floor(this.rules.range.min / 12); octave <= Math.floor(this.rules.range.max / 12); octave++) {
                    for (const scaleDegree of defaultScale) {
                        const midi = octave * 12 + scaleDegree;
                        if (midi >= this.rules.range.min && midi <= this.rules.range.max) {
                            possibleNotes.push(midi);
                        }
                    }
                }
            }
            
            // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼Œç›´æ¥é€‰æ‹©
            if (lastMidi === null) {
                const selectedNote = this.random.choice(possibleNotes);
                console.log(`ğŸµ [generateInScaleNote] é¦–éŸ³ç¬¦å€™é€‰: [${possibleNotes.join(',')}], é€‰æ‹©: ${selectedNote}`);
                if (selectedNote < 50) {
                    console.error(`ğŸš¨ [generateInScaleNote] é¦–éŸ³ç¬¦å¼‚å¸¸ä½éŸ³: MIDI ${selectedNote}, possibleNotes: [${possibleNotes.join(',')}]`);
                    console.error(`ğŸš¨ éŸ³åŸŸè®¾ç½®: ${this.rules.range.min}-${this.rules.range.max}`);
                }
                // éªŒè¯éŸ³ç¬¦åœ¨è°ƒå†…
                const pitchClass = selectedNote % 12;
                if (!this.scale.includes(pitchClass)) {
                    console.error(`âŒâŒâŒ ç¬¬ä¸€ä¸ªéŸ³ç¬¦é”™è¯¯ï¼šMIDI ${selectedNote}, pitchClass ${pitchClass} ä¸åœ¨ ${this.keySignature} éŸ³é˜¶ä¸­`);
                }

                // å¦‚æœä¸´æ—¶è®°å·æ¦‚ç‡ä¸º0ï¼šå¤§è°ƒç›´æ¥è¿”å›ï¼Œå°è°ƒä»…å…è®¸å˜åŒ–éŸ³
                if (this.rules.accidentalRate === 0) {
                    if (isMinorKey) {
                        const ctx = {
                            isMeasureStart: true,
                            isMeasureEnd: false,
                            isPhrasEnd: false,
                            isCadence: false
                        };
                        const altered = applyMinorScaleAlterations(selectedNote, null, 'neutral', this.keySignature, this.random, this.rules, ctx);
                        if (altered !== selectedNote) {
                            console.log(`ğŸµ [é¦–éŸ³ç¬¦å˜åŒ–éŸ³-å°è°ƒ] MIDI ${selectedNote} -> ${altered}`);
                            return this.validateAndCorrectMidi(altered, "generateInScaleNote-é¦–éŸ³ç¬¦-å°è°ƒå˜åŒ–éŸ³");
                        }
                    }
                    return this.validateAndCorrectMidi(selectedNote, "generateInScaleNote-é¦–éŸ³ç¬¦-æ— ä¸´æ—¶è®°å·");
                }
                const noteWithAccidental = this.addAccidentalIfNeeded(selectedNote, null);
                return this.validateAndCorrectMidi(noteWithAccidental, "generateInScaleNote-é¦–éŸ³ç¬¦-å«ä¸´æ—¶è®°å·");
            }
            
            // ä¸¥æ ¼è¿‡æ»¤ï¼šåªä¿ç•™æ»¡è¶³æœ€å¤§éŸ³ç¨‹è·¨åº¦çš„éŸ³ç¬¦
            const validNotes = possibleNotes.filter(midi => {
                const interval = Math.abs(midi - lastMidi);
                const isValid = interval <= this.rules.maxJump;
                if (!isValid) {
                    console.log(`ğŸš« éŸ³ç¬¦MIDI ${midi}è¢«è¿‡æ»¤ï¼ŒéŸ³ç¨‹${interval}åŠéŸ³ > é™åˆ¶${this.rules.maxJump}åŠéŸ³`);
                }
                return isValid;
            });
            
            console.log(`ğŸ¯ çº¦æŸæ£€æŸ¥: å€™é€‰${possibleNotes.length}ä¸ªéŸ³ç¬¦ï¼Œé€šè¿‡çº¦æŸ${validNotes.length}ä¸ªéŸ³ç¬¦ (é™åˆ¶:${this.rules.maxJump}åŠéŸ³)`);

            const avoidRepeat = this.cfState.repeatCount >= 1;
            const noRepeatNotes = avoidRepeat ? validNotes.filter(midi => midi !== lastMidi) : validNotes;
            let candidateNotes = noRepeatNotes.length ? noRepeatNotes : validNotes;
            const avoidRepeatAggressive = this.isJianpuTool &&
                Array.isArray(this.rules?.allowedDurations) &&
                this.rules.allowedDurations.includes('16th');
            if (avoidRepeatAggressive && lastMidi !== null && candidateNotes.length > 1) {
                const allowRepeatChance = 0.01;
                if (this.random.nextFloat() > allowRepeatChance) {
                    const filtered = candidateNotes.filter(midi => midi !== lastMidi);
                    if (filtered.length) candidateNotes = filtered;
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ»¡è¶³æ¡ä»¶çš„éŸ³ç¬¦ï¼Œè®°å½•è­¦å‘Šä½†ç»§ç»­å°è¯•
            if (validNotes.length === 0) {
                console.warn(`âš ï¸ å°è¯• ${attempts + 1}: åœ¨æœ€å¤§éŸ³ç¨‹${this.rules.maxJump}åŠéŸ³é™åˆ¶ä¸‹æ‰¾ä¸åˆ°åˆé€‚éŸ³ç¬¦`);
                attempts++;
                continue;
            }
            
        // é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆéŸ³ç¬¦ï¼š4/4 ç­‰å¸¸è§„æ‹éµå¾ªæ›´æ¥è¿‘ Cantus Firmus çš„åå¥½
        // ä¼˜å…ˆçº§ï¼šé¿å…é‡å¤éŸ³ã€å‡å°‘å¤§è·³ã€å€¾å‘çº§è¿›ï¼ˆ1-2 åŠéŸ³ï¼‰ï¼Œé™åˆ¶æç«¯è·³è¿›
        const prevMidi = this.cfState.prevMidi;
        const prevPrevMidi = this.cfState.prevPrevMidi;
        const lastInterval = this.cfState.lastInterval;
        const rankedNotes = candidateNotes
            .filter(midi => {
                if (lastMidi === null) return true;
                const interval = Math.abs(midi - lastMidi);
                // ç¡¬é™åˆ¶ï¼šé¿å…è¶…å¤§è·³è¿›ï¼ˆ> 8 åŠéŸ³ï¼‰
                return interval <= Math.max(8, this.rules.maxJump || 12);
            })
            .map(midi => {
                if (lastMidi === null) return { midi, score: 0 };
                const interval = Math.abs(midi - lastMidi);
                const isRepeat = midi === lastMidi;
                const isBacktrack = prevPrevMidi !== null && midi === prevPrevMidi && prevPrevMidi !== lastMidi;
                const newInterval = midi - lastMidi;
                let score = interval;
                if (isRepeat) score += 50;           // å¼ºçƒˆé¿å…è¿ç»­é‡å¤
                if (isBacktrack) score += 12;        // å‡å°‘ ABAB å¼æ¥å›æ‘†åŠ¨
                if (interval >= 5) score += (interval - 4) * 6; // å¤§è·³é‡ç½š
                if (interval <= 2) score -= 2;       // çº§è¿›å¥–åŠ±
                if (interval === 3 || interval === 4) score -= 1; // ä¸‰åº¦é€‚åº¦å¥–åŠ±
                if (lastInterval && newInterval === -lastInterval && interval <= 2) score += 6; // é¿å…çŸ­è·ç¦»åå¤æŠ˜è¿”
                return { midi, score };
            });
        let selectedNote = null;
        if (rankedNotes.length) {
            if (lastMidi !== null) {
                const avoidRepeatAggressive = this.isJianpuTool &&
                    Array.isArray(this.rules?.allowedDurations) &&
                    this.rules.allowedDurations.includes('16th');
                const hasAlternatives = rankedNotes.some(({ midi }) => midi !== lastMidi);
                let usableNotes = rankedNotes;
                if (avoidRepeatAggressive && hasAlternatives) {
                    const allowRepeatChance = 0.12;
                    if (this.random.nextFloat() > allowRepeatChance) {
                        usableNotes = rankedNotes.filter(({ midi }) => midi !== lastMidi);
                    }
                }
                const weightedPool = [];
                usableNotes.forEach(({ midi }) => {
                    const interval = Math.abs(midi - lastMidi);
                    let weight = 1;
                    if (interval <= 2) {
                        weight = 6;
                    } else if (interval === 3 || interval === 4) {
                        weight = 6;
                    } else if (interval === 5) {
                        weight = 2;
                    } else if (interval <= 7) {
                        weight = 0.8;
                    } else {
                        weight = 0.4;
                    }
                    if (avoidRepeatAggressive && interval === 0) {
                        weight = 0.3;
                    }
                    if (prevPrevMidi !== null && midi === prevPrevMidi && prevPrevMidi !== lastMidi) {
                        weight = Math.max(0.2, weight * 0.4);
                    }
                    if (lastInterval && (midi - lastMidi) === -lastInterval && interval <= 2) {
                        weight = Math.max(0.2, weight * 0.5);
                    }
                    const count = Math.max(1, Math.round(weight * 2));
                    for (let i = 0; i < count; i++) {
                        weightedPool.push(midi);
                    }
                });
                selectedNote = this.random.choice(weightedPool);
            } else {
                const minScore = Math.min(...rankedNotes.map(n => n.score));
                const best = rankedNotes.filter(n => n.score === minScore);
                selectedNote = this.random.choice(best).midi;
            }
        } else {
            // é€€åŒ–åˆ°åŸæœ‰é€‰æ‹©æ–¹æ³•
            selectedNote = this.selectNoteWithIntervalPreference(candidateNotes, lastMidi);
        }
            
            // 6/8æ‹çš„é¢å¤–æ£€æŸ¥ï¼šä¸¥æ ¼éµå¾ªCantus FirmusåŸåˆ™å’Œç”¨æˆ·è®¾ç½®
            if (this.timeSignature === '6/8' && lastMidi !== null) {
                const interval = Math.abs(selectedNote - lastMidi);
                if (interval > this.rules.maxJump) {
                    console.log(`âš ï¸ 6/8æ‹è¶…å‡ºç”¨æˆ·é™åˆ¶: ${interval}åŠéŸ³ > ${this.rules.maxJump}åŠéŸ³`);
                } else if (interval > Math.floor(this.rules.maxJump / 2)) { // ğŸ”¥ ä¿®å¤ç¡¬ç¼–ç ï¼šåŸºäºç”¨æˆ·maxJumpåŠ¨æ€åˆ¤æ–­ä¸­ç­‰è·³è¿›
                    console.log(`â„¹ï¸ 6/8æ‹ä¸­ç­‰è·³è¿›: ${interval}åŠéŸ³é—´è· (ç”¨æˆ·æœ€å¤§é™åˆ¶: ${this.rules.maxJump}åŠéŸ³)`);
                }
            }
            
            // éªŒè¯é€‰æ‹©çš„éŸ³ç¬¦ç¡®å®åœ¨è°ƒå†…
            const pitchClass = selectedNote % 12;
            if (!this.scale.includes(pitchClass)) {
                console.error(`âŒâŒâŒ é”™è¯¯ï¼šç”Ÿæˆäº†è°ƒå¤–éŸ³ç¬¦ï¼MIDI ${selectedNote}, pitchClass ${pitchClass} ä¸åœ¨ ${this.keySignature} éŸ³é˜¶ [${this.scale.join(',')}] ä¸­`);
            }
            
            // å¦‚æœä¸´æ—¶è®°å·æ¦‚ç‡ä¸º0ï¼Œå…ˆå¤„ç†å°è°ƒå˜åŒ–éŸ³å†è¿”å›
            if (this.rules.accidentalRate === 0) {
                if (isMinorKey) {
                    // å°è°ƒå…è®¸å˜åŒ–éŸ³
                    const direction = getMelodicDirection(lastMidi, selectedNote);
                    const context = {
                        isMeasureStart: false,
                        isMeasureEnd: false,
                        isPhrasEnd: false,
                        isCadence: false,
                        nextNote: null // è¿™é‡Œå¯ä»¥ä¼ å…¥ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„é¢„æµ‹
                    };
                    const alteredNote = applyMinorScaleAlterations(selectedNote, lastMidi, direction, this.keySignature, this.random, this.rules, context);
                    if (alteredNote !== selectedNote) {
                        console.log(`ğŸµ [å°è°ƒå˜åŒ–éŸ³] MIDI ${selectedNote} -> ${alteredNote}`);
                        return this.validateAndCorrectMidi(alteredNote, "generateInScaleNote-å˜åŒ–éŸ³-å°è°ƒ");
                    }
                }
                console.log(`âœ“ ç”Ÿæˆè°ƒå†…éŸ³ç¬¦: MIDI ${selectedNote}, ä¸å‰éŸ³é—´éš”: ${Math.abs(selectedNote - lastMidi)}åŠéŸ³`);
                return this.validateAndCorrectMidi(selectedNote, "generateInScaleNote-è°ƒå†…éŸ³ç¬¦");
            }
            
            // å°è¯•æ·»åŠ ä¸´æ—¶è®°å·ï¼ˆå°è°ƒä¼šåœ¨æ–¹æ³•å†…è¿‡æ»¤éæ³•éŸ³ï¼‰
            const finalNote = this.addAccidentalIfNeeded(selectedNote, lastMidi);
            
            // æ£€æŸ¥åŠ äº†ä¸´æ—¶è®°å·åæ˜¯å¦ä»ç„¶æ»¡è¶³éŸ³ç¨‹é™åˆ¶ï¼Œä¸”å°è°ƒä¸è¶…å‡ºå…è®¸é›†åˆ
            const finalInterval = Math.abs(finalNote - lastMidi);
            const minorAllowed = this.getAllowedMinorPitchClasses(this.keySignature);
            const minorSafe = !minorAllowed || minorAllowed.has(finalNote % 12);
            if (finalInterval <= this.rules.maxJump && minorSafe) {
                // éªŒè¯é€šè¿‡ï¼Œå…ˆå¤„ç†å°è°ƒå˜åŒ–éŸ³ - å¢å¼ºç‰ˆ
                const direction = getMelodicDirection(lastMidi, finalNote);
                const context = {
                    isMeasureStart: false,
                    isMeasureEnd: false,
                    isPhrasEnd: false,
                    isCadence: false,
                    nextNote: null
                };
                const alteredFinalNote = applyMinorScaleAlterations(finalNote, lastMidi, direction, this.keySignature, this.random, this.rules, context);
                if (alteredFinalNote !== finalNote) {
                    console.log(`ğŸµ [å°è°ƒå˜åŒ–éŸ³-ä¸´æ—¶è®°å·] MIDI ${finalNote} -> ${alteredFinalNote}`);
                    return this.validateAndCorrectMidi(alteredFinalNote, "generateInScaleNote-å˜åŒ–éŸ³-ä¸´æ—¶è®°å·");
                }
                console.log(`âœ“ ç”ŸæˆéŸ³ç¬¦: MIDI ${finalNote}, ä¸å‰éŸ³é—´éš”: ${finalInterval}åŠéŸ³`);
                return this.validateAndCorrectMidi(finalNote, "generateInScaleNote-å«ä¸´æ—¶è®°å·");
            }
            
            // å¦‚æœæ·»åŠ ä¸´æ—¶è®°å·åè¶…å‡ºé™åˆ¶ï¼Œå…ˆå¤„ç†å°è°ƒå˜åŒ–éŸ³å†è¿”å›åŸå§‹éŸ³ç¬¦
            const direction = getMelodicDirection(lastMidi, selectedNote);
            const context = {
                isMeasureStart: false,
                isMeasureEnd: false,
                isPhrasEnd: false,
                isCadence: false,
                nextNote: null
            };
            const alteredSelectedNote = applyMinorScaleAlterations(selectedNote, lastMidi, direction, this.keySignature, this.random, this.rules, context);
            if (alteredSelectedNote !== selectedNote) {
                console.log(`ğŸµ [å°è°ƒå˜åŒ–éŸ³-åŸå§‹] MIDI ${selectedNote} -> ${alteredSelectedNote}`);
                return this.validateAndCorrectMidi(alteredSelectedNote, "generateInScaleNote-å˜åŒ–éŸ³-åŸå§‹");
            }
            console.log(`âœ“ ç”ŸæˆéŸ³ç¬¦: MIDI ${selectedNote}, ä¸å‰éŸ³é—´éš”: ${Math.abs(selectedNote - lastMidi)}åŠéŸ³`);
            return this.validateAndCorrectMidi(selectedNote, "generateInScaleNote-åŸå§‹éŸ³ç¬¦");
        }
        
        // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œå¼ºåˆ¶è¿”å›ä¸€ä¸ªæ»¡è¶³åŸºæœ¬æ¡ä»¶çš„éŸ³ç¬¦
        console.error(`âŒ ${maxAttempts}æ¬¡å°è¯•åä»æ— æ³•ç”Ÿæˆæ»¡è¶³æ¡ä»¶çš„éŸ³ç¬¦ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ`);
        
        // å¤‡ç”¨æ–¹æ¡ˆï¼šä»å½“å‰éŸ³ç¬¦å¼€å§‹ï¼Œåœ¨å…è®¸çš„è·³åº¦èŒƒå›´å†…é€‰æ‹©æœ€æ¥è¿‘çš„è°ƒå†…éŸ³ç¬¦
        if (lastMidi !== null) {
            const minMidi = Math.max(this.rules.range.min, lastMidi - this.rules.maxJump);
            const maxMidi = Math.min(this.rules.range.max, lastMidi + this.rules.maxJump);
            
            for (let midi = minMidi; midi <= maxMidi; midi++) {
                const noteClass = midi % 12;
                if (Array.isArray(this.scale) && this.scale.includes(noteClass)) {
                    console.log(`âœ“ å¤‡ç”¨æ–¹æ¡ˆé€‰æ‹©: MIDI ${midi}`);
                    return this.validateAndCorrectMidi(midi, "generateInScaleNote-å¤‡ç”¨æ–¹æ¡ˆ");
                }
            }
        }
        
        // æœ€ç»ˆå¤‡ç”¨ï¼šåœ¨éŸ³ç¨‹è·³åº¦é™åˆ¶å†…é€‰æ‹©ä¸€ä¸ªå®‰å…¨éŸ³ç¬¦
        console.error(`âŒ æ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œå¯ç”¨ç´§æ€¥å®‰å…¨éŸ³ç¬¦ç”Ÿæˆ`);
        
        if (lastMidi !== null) {
            // å¦‚æœæœ‰å‰ä¸€éŸ³ç¬¦ï¼Œä¸¥æ ¼åœ¨éŸ³ç¨‹è·³åº¦èŒƒå›´å†…é€‰æ‹©
            const safeMinMidi = Math.max(this.rules.range.min, lastMidi - this.rules.maxJump);
            const safeMaxMidi = Math.min(this.rules.range.max, lastMidi + this.rules.maxJump);
            
            console.error(`ğŸ”§ ç´§æ€¥èŒƒå›´: ${safeMinMidi}-${safeMaxMidi} (åŸºäºå‰éŸ³${lastMidi}Â±${this.rules.maxJump}åŠéŸ³)`);
            
            // åœ¨å®‰å…¨èŒƒå›´å†…æ‰¾è°ƒå†…éŸ³ç¬¦
            for (let midi = safeMinMidi; midi <= safeMaxMidi; midi++) {
                const pitchClass = midi % 12;
                if (this.scale.includes(pitchClass)) {
                    console.error(`ğŸ”§ ç´§æ€¥é€‰æ‹©è°ƒå†…éŸ³ç¬¦: MIDI ${midi}`);
                    return midi;
                }
            }
            
            // å¦‚æœè¿è°ƒå†…éŸ³ç¬¦éƒ½æ‰¾ä¸åˆ°ï¼Œé€‰æ‹©æœ€æ¥è¿‘çš„éŸ³ç¬¦ï¼ˆä»åœ¨è·³åº¦é™åˆ¶å†…ï¼‰
            const closestToLast = Math.round((safeMinMidi + safeMaxMidi) / 2);
            console.error(`ğŸ”§ æœ€ç»ˆç´§æ€¥é€‰æ‹©: MIDI ${closestToLast} (èŒƒå›´ä¸­ç‚¹)`);
            return this.validateAndCorrectMidi(closestToLast, "generateInScaleNote-ç´§æ€¥ä¸­ç‚¹");
        }
        
        // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼Œä½¿ç”¨éŸ³åŸŸä¸­ç‚¹çš„è°ƒå†…éŸ³ç¬¦
        const midPoint = Math.floor((this.rules.range.min + this.rules.range.max) / 2);
        console.error(`ğŸ”§ é¦–éŸ³ç¬¦ç´§æ€¥é€‰æ‹©ä¸­ç‚¹: MIDI ${midPoint}`);
        
        // ç¡®ä¿ä¸­ç‚¹æ˜¯è°ƒå†…éŸ³ç¬¦
        const pitchClass = midPoint % 12;
        if (this.scale.includes(pitchClass)) {
            return this.validateAndCorrectMidi(midPoint, "generateInScaleNote-é¦–éŸ³ç¬¦ä¸­ç‚¹");
        }
        
        // åœ¨ä¸­ç‚¹é™„è¿‘æ‰¾è°ƒå†…éŸ³ç¬¦
        for (let i = 0; i <= 6; i++) {
            const upNote = midPoint + i;
            const downNote = midPoint - i;
            
            if (upNote <= this.rules.range.max && this.scale.includes(upNote % 12)) {
                console.error(`ğŸ”§ é¦–éŸ³ç¬¦å‘ä¸Šæ‰¾åˆ°è°ƒå†…éŸ³ç¬¦: MIDI ${upNote}`);
                return this.validateAndCorrectMidi(upNote, "generateInScaleNote-é¦–éŸ³ç¬¦å‘ä¸Š");
            }
            if (downNote >= this.rules.range.min && this.scale.includes(downNote % 12)) {
                console.error(`ğŸ”§ é¦–éŸ³ç¬¦å‘ä¸‹æ‰¾åˆ°è°ƒå†…éŸ³ç¬¦: MIDI ${downNote}`);
                return this.validateAndCorrectMidi(downNote, "generateInScaleNote-é¦–éŸ³ç¬¦å‘ä¸‹");
            }
        }
        
        console.error(`ğŸ”§ æ‰€æœ‰æ–¹æ¡ˆéƒ½å¤±è´¥ï¼Œå¼ºåˆ¶è¿”å›ä¸­ç‚¹: MIDI ${midPoint}`);
        return this.validateAndCorrectMidi(midPoint, "generateInScaleNote-æœ€ç»ˆä¸­ç‚¹");
    }
    
    /**
     * ç”ŸæˆAcciaccaturaè£…é¥°éŸ³ç¬¦
     * é»˜è®¤ä»¥é¡ºé˜¶äºŒåº¦é è¿‘ç›®æ ‡éŸ³ç”Ÿæˆ
     */
    generateAcciaccaturaNote(targetNote) {
        console.log(`ğŸµ [generateAcciaccaturaNote] ä¸ºç›®æ ‡éŸ³ç¬¦ MIDI ${targetNote.midi} ç”ŸæˆçŸ­å€šéŸ³`);
        
        try {
            // è·å–å½“å‰è°ƒå·çš„éŸ³é˜¶
            const scale = this.getScaleForKey(this.keySignature);
            if (!scale) {
                console.error(`ğŸš¨ æ— æ³•è·å–è°ƒå· ${this.keySignature} çš„éŸ³é˜¶`);
                return null;
            }
            
            // å¯»æ‰¾æœ€è¿‘çš„é¡ºé˜¶äºŒåº¦éŸ³ç¬¦ï¼ˆä¼˜å…ˆä½¿ç”¨é¡ºé˜¶äºŒåº¦ï¼‰
            let acciaccaturaMidi = null;
            
            // è·å–ä¸Šæ–¹å’Œä¸‹æ–¹çš„é¡ºé˜¶äºŒåº¦
            const lowerDiatonicNote = this.findDiatonicStepFromMidi(targetNote.midi, -1, scale);
            const upperDiatonicNote = this.findDiatonicStepFromMidi(targetNote.midi, 1, scale);
            
            // æ”¶é›†å¯ç”¨çš„é¡ºé˜¶é€‰é¡¹
            const diatonicOptions = [];
            
            // æ£€æŸ¥ä¸‹æ–¹é¡ºé˜¶äºŒåº¦ï¼ˆå¿…é¡»æ˜¯1-2åŠéŸ³ï¼‰
            if (lowerDiatonicNote !== null) {
                const interval = targetNote.midi - lowerDiatonicNote;
                if (interval >= 1 && interval <= 2 && lowerDiatonicNote >= this.rules.range.min) {
                    diatonicOptions.push({
                        midi: lowerDiatonicNote, 
                        direction: 'ä¸‹æ–¹',
                        interval: interval,
                        type: 'é¡ºé˜¶äºŒåº¦'
                    });
                    console.log(`ğŸµ æ‰¾åˆ°ä¸‹æ–¹é¡ºé˜¶äºŒåº¦: MIDI ${lowerDiatonicNote} (é—´éš”${interval}åŠéŸ³)`);
                }
            }
            
            // æ£€æŸ¥ä¸Šæ–¹é¡ºé˜¶äºŒåº¦ï¼ˆå¿…é¡»æ˜¯1-2åŠéŸ³ï¼‰
            if (upperDiatonicNote !== null) {
                const interval = upperDiatonicNote - targetNote.midi;
                if (interval >= 1 && interval <= 2 && upperDiatonicNote <= this.rules.range.max) {
                    diatonicOptions.push({
                        midi: upperDiatonicNote, 
                        direction: 'ä¸Šæ–¹',
                        interval: interval,
                        type: 'é¡ºé˜¶äºŒåº¦'
                    });
                    console.log(`ğŸµ æ‰¾åˆ°ä¸Šæ–¹é¡ºé˜¶äºŒåº¦: MIDI ${upperDiatonicNote} (é—´éš”${interval}åŠéŸ³)`);
                }
            }
            
            // ä¼˜å…ˆä½¿ç”¨é¡ºé˜¶äºŒåº¦
            if (diatonicOptions.length > 0) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªé¡ºé˜¶é€‰é¡¹
                const selectedOption = diatonicOptions[Math.floor(this.random.nextFloat() * diatonicOptions.length)];
                acciaccaturaMidi = selectedOption.midi;
                console.log(`ğŸµ é€‰æ‹©${selectedOption.direction}${selectedOption.type}: MIDI ${acciaccaturaMidi}`);
            }
            
            // å¦‚æœæ²¡æœ‰åˆé€‚çš„é¡ºé˜¶äºŒåº¦ï¼Œä½¿ç”¨åŠéŸ³é‚»éŸ³ï¼ˆä½œä¸ºå¤‡é€‰æ–¹æ¡ˆï¼‰
            if (!acciaccaturaMidi) {
                console.log(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„é¡ºé˜¶äºŒåº¦ï¼Œä½¿ç”¨åŠéŸ³é‚»éŸ³`);
                
                const chromaticOptions = [];
                const lowerSemitone = targetNote.midi - 1;
                const upperSemitone = targetNote.midi + 1;
                
                if (lowerSemitone >= this.rules.range.min) {
                    chromaticOptions.push({midi: lowerSemitone, direction: 'ä¸‹æ–¹'});
                }
                if (upperSemitone <= this.rules.range.max) {
                    chromaticOptions.push({midi: upperSemitone, direction: 'ä¸Šæ–¹'});
                }
                
                if (chromaticOptions.length > 0) {
                    const selectedOption = chromaticOptions[Math.floor(this.random.nextFloat() * chromaticOptions.length)];
                    acciaccaturaMidi = selectedOption.midi;
                    console.log(`ğŸµ é€‰æ‹©${selectedOption.direction}åŠéŸ³: MIDI ${acciaccaturaMidi}`);
                }
            }
            
            // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œè¿”å›null
            if (!acciaccaturaMidi) {
                console.log(`ğŸµ æ— æ³•ä¸º MIDI ${targetNote.midi} ç”Ÿæˆåˆé€‚çš„çŸ­å€šéŸ³`);
                return null;
            }
            
            // ç”ŸæˆéŸ³ç¬¦å¯¹è±¡
            const { step, octave, alter } = this.midiToMusicXML(acciaccaturaMidi);
            
            const acciaccaturaNote = {
                type: 'note',
                duration: 'grace', // è£…é¥°éŸ³ç‰¹æ®Šæ—¶å€¼
                beats: 0, // è£…é¥°éŸ³ä¸å ç”¨æ—¶å€¼
                step: step,
                octave: octave,
                alter: alter,
                midi: acciaccaturaMidi,
                isAcciaccatura: true, // æ ‡è®°ä¸ºçŸ­å€šéŸ³
                slash: true // å¸¦æ–œçº¿çš„çŸ­å€šéŸ³
            };
            
            console.log(`ğŸµ [generateAcciaccaturaNote] ç”ŸæˆçŸ­å€šéŸ³æˆåŠŸ: MIDI ${acciaccaturaMidi} -> ${step}${octave}`);
            return acciaccaturaNote;
            
        } catch (error) {
            console.error(`ğŸš¨ [generateAcciaccaturaNote] ç”ŸæˆçŸ­å€šéŸ³å¤±è´¥:`, error.message);
            return null;
        }
    }
    
    /**
     * è·å–æŒ‡å®šè°ƒå·çš„éŸ³é˜¶
     * @param {string} keySignature - è°ƒå·
     * @returns {Array<number>} - éŸ³é˜¶çš„pitch classæ•°ç»„
     */
    getScaleForKey(keySignature) {
        // ä½¿ç”¨å…¨å±€å®šä¹‰çš„KEY_SCALES
        if (typeof KEY_SCALES !== 'undefined' && KEY_SCALES[keySignature]) {
            return KEY_SCALES[keySignature];
        }
        
        // å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¿”å›Cå¤§è°ƒä½œä¸ºé»˜è®¤
        console.warn(`âš ï¸ æ‰¾ä¸åˆ°è°ƒå· ${keySignature} çš„éŸ³é˜¶ï¼Œä½¿ç”¨Cå¤§è°ƒ`);
        return [0, 2, 4, 5, 7, 9, 11]; // Cå¤§è°ƒ
    }
    
    /**
     * ä»æŒ‡å®šMIDIéŸ³ç¬¦æ‰¾åˆ°é¡ºé˜¶çš„ä¸Šä¸€ä¸ªæˆ–ä¸‹ä¸€ä¸ªéŸ³
     * @param {number} targetMidi - ç›®æ ‡MIDIå€¼
     * @param {number} direction - æ–¹å‘ï¼š1ä¸ºå‘ä¸Šï¼Œ-1ä¸ºå‘ä¸‹
     * @param {Array<number>} scale - éŸ³é˜¶çš„pitch classæ•°ç»„
     * @returns {number|null} - é¡ºé˜¶éŸ³çš„MIDIå€¼
     */
    findDiatonicStepFromMidi(targetMidi, direction, scale) {
        const targetPc = targetMidi % 12;
        const targetOctave = Math.floor(targetMidi / 12);
        
        // æ‰¾åˆ°ç›®æ ‡éŸ³åœ¨éŸ³é˜¶ä¸­çš„ä½ç½®
        let scaleIndex = scale.indexOf(targetPc);
        
        // å¦‚æœç›®æ ‡éŸ³ä¸åœ¨éŸ³é˜¶ä¸­ï¼Œæ‰¾æœ€è¿‘çš„éŸ³é˜¶éŸ³
        if (scaleIndex === -1) {
            // æ‰¾æœ€è¿‘çš„éŸ³é˜¶éŸ³
            let minDistance = 12;
            for (let i = 0; i < scale.length; i++) {
                const distance = Math.min(
                    Math.abs(scale[i] - targetPc),
                    Math.abs(scale[i] + 12 - targetPc),
                    Math.abs(scale[i] - 12 - targetPc)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    scaleIndex = i;
                }
            }
        }
        
        // è®¡ç®—ä¸‹ä¸€ä¸ªéŸ³é˜¶ä½ç½®
        let nextIndex = scaleIndex + direction;
        let octaveShift = 0;
        
        // å¤„ç†éŸ³é˜¶è¾¹ç•Œ
        if (nextIndex < 0) {
            nextIndex = scale.length - 1;
            octaveShift = -1;
        } else if (nextIndex >= scale.length) {
            nextIndex = 0;
            octaveShift = 1;
        }
        
        // è®¡ç®—ç»“æœMIDIå€¼
        const resultMidi = (targetOctave + octaveShift) * 12 + scale[nextIndex];
        
        return resultMidi;
    }
    
    /**
     * å¯»æ‰¾æœ€è¿‘çš„é¡ºé˜¶éŸ³çº§ï¼ˆä¿ç•™æ—§å‡½æ•°ä»¥å…¼å®¹ï¼‰
     * @param {number} targetMidi - ç›®æ ‡éŸ³ç¬¦çš„MIDIå€¼
     * @param {number} direction - æ–¹å‘ï¼š1ä¸ºå‘ä¸Šï¼Œ-1ä¸ºå‘ä¸‹
     * @returns {number|null} - æ‰¾åˆ°çš„é¡ºé˜¶éŸ³çº§MIDIå€¼
     */
    findNearestDiatonicStep(targetMidi, direction) {
        // å°†MIDIè½¬æ¢ä¸ºéŸ³é«˜ç±»ï¼ˆpitch classï¼‰
        const targetPc = targetMidi % 12;
        const targetOctave = Math.floor(targetMidi / 12);
        
        // åœ¨è°ƒæ€§éŸ³é˜¶ä¸­æ‰¾åˆ°å½“å‰éŸ³ç¬¦çš„ä½ç½®
        let currentScaleIndex = -1;
        for (let i = 0; i < this.scale.length; i++) {
            if (this.scale[i] === targetPc) {
                currentScaleIndex = i;
                break;
            }
        }
        
        // å¦‚æœå½“å‰éŸ³ç¬¦ä¸åœ¨è°ƒæ€§ä¸­ï¼Œæ‰¾æœ€è¿‘çš„è°ƒæ€§éŸ³ç¬¦
        if (currentScaleIndex === -1) {
            for (let i = 0; i < this.scale.length; i++) {
                if (Math.abs(this.scale[i] - targetPc) <= 1 || 
                    Math.abs(this.scale[i] - targetPc + 12) <= 1 ||
                    Math.abs(this.scale[i] - targetPc - 12) <= 1) {
                    currentScaleIndex = i;
                    break;
                }
            }
        }
        
        if (currentScaleIndex === -1) {
            return null; // æ— æ³•æ‰¾åˆ°åˆé€‚çš„è°ƒæ€§éŸ³ç¬¦
        }
        
        // è®¡ç®—ä¸‹ä¸€ä¸ªé¡ºé˜¶éŸ³çº§
        let nextScaleIndex = currentScaleIndex + direction;
        let octaveAdjustment = 0;
        
        // å¤„ç†éŸ³é˜¶è¾¹ç•Œ
        if (nextScaleIndex < 0) {
            nextScaleIndex = this.scale.length - 1;
            octaveAdjustment = -1;
        } else if (nextScaleIndex >= this.scale.length) {
            nextScaleIndex = 0;
            octaveAdjustment = 1;
        }
        
        // è®¡ç®—ç»“æœMIDIå€¼
        const resultMidi = (targetOctave + octaveAdjustment) * 12 + this.scale[nextScaleIndex];
        
        // éªŒè¯éŸ³åŸŸ
        if (resultMidi < this.rules.range.min || resultMidi > this.rules.range.max) {
            return null;
        }
        
        return resultMidi;
    }
    
    /**
     * æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦æ·»åŠ ä¸´æ—¶è®°å·
     */
    addAccidentalIfNeeded(midi, lastMidi = null) {
        if (!this.rules.accidentalRate || this.rules.accidentalRate <= 0) {
            this.resetChromaticRun();
            return midi;
        }
        if (typeof lastMidi !== 'number') {
            this.resetChromaticRun();
            return midi;
        }

        const interval = Math.abs(midi - lastMidi);
        const allowStepwiseRun = interval <= 2;

        if (this.chromaticState.active && this.chromaticState.remaining > 0) {
            if (!allowStepwiseRun) {
                this.resetChromaticRun();
                return midi;
            }
            const nextMidi = lastMidi + this.chromaticState.direction;
            if (this.isChromaticStepValid(nextMidi)) {
                this.chromaticState.remaining -= 1;
                if (this.chromaticState.remaining <= 0) {
                    this.resetChromaticRun();
                }
                this.queueAccidentalPreference(nextMidi, this.chromaticState.direction);
                return nextMidi;
            }
            this.resetChromaticRun();
            return midi;
        }

        if (!allowStepwiseRun || this.random.nextFloat() >= this.rules.accidentalRate) {
            return midi;
        }

        const direction = this.determineChromaticDirection(lastMidi, midi);
        const nextMidi = lastMidi + direction;
        if (!this.isChromaticStepValid(nextMidi)) {
            return midi;
        }

        const runLength = this.getChromaticRunLength();
        this.chromaticState.active = runLength > 1;
        this.chromaticState.remaining = Math.max(0, runLength - 1);
        this.chromaticState.direction = direction;
        this.queueAccidentalPreference(nextMidi, direction);
        return nextMidi;
    }

    resetChromaticRun() {
        this.chromaticState.active = false;
        this.chromaticState.remaining = 0;
        this.chromaticState.direction = 0;
    }

    getChromaticRunLength() {
        const rate = this.rules.accidentalRate || 0;
        let maxLen = 2;
        if (rate >= 0.75) {
            maxLen = 4;
        } else if (rate >= 0.45) {
            maxLen = 3;
        }
        return this.random.nextInt(2, maxLen + 1);
    }

    determineChromaticDirection(lastMidi, targetMidi) {
        if (typeof lastMidi !== 'number') return 1;
        if (typeof targetMidi !== 'number') {
            return this.random.nextFloat() < 0.5 ? 1 : -1;
        }
        const direction = Math.sign(targetMidi - lastMidi);
        if (direction === 0) {
            return this.random.nextFloat() < 0.5 ? 1 : -1;
        }
        return direction > 0 ? 1 : -1;
    }

    isChromaticStepValid(midi) {
        if (midi < this.rules.range.min || midi > this.rules.range.max) {
            return false;
        }
        const minorAllowed = this.getAllowedMinorPitchClasses(this.keySignature);
        if (minorAllowed && !minorAllowed.has(midi % 12)) {
            return false;
        }
        return true;
    }

    queueAccidentalPreference(midi, direction) {
        const preference = direction > 0 ? '#' : 'b';
        this._pendingAccidentalPreference = { midi, preference };
    }

    consumeAccidentalPreference(midi) {
        if (this._pendingAccidentalPreference) {
            if (this._pendingAccidentalPreference.midi === midi) {
                const preference = this._pendingAccidentalPreference.preference;
                this._pendingAccidentalPreference = null;
                return preference;
            }
            this._pendingAccidentalPreference = null;
        }
        return null;
    }
    
    /**
     * æ·»åŠ ä¸´æ—¶è®°å·ï¼ˆå‡å·æˆ–é™å·ï¼‰- é¿å…é‡å¤è°ƒå·æ ‡è®°
     */
    addAccidental(midi) {
        const accidentalChoices = [];
        const noteClass = midi % 12;
        const keySignatureInfo = isNoteAffectedByKeySignature(noteClass, this.keySignature);
        const minorAllowed = this.getAllowedMinorPitchClasses(this.keySignature);
        
        // å°è¯•æ·»åŠ å‡å·ï¼ˆ+1åŠéŸ³ï¼‰
        const sharpNote = midi + 1;
        const sharpNoteClass = sharpNote % 12;
        
        // åªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ‰æ·»åŠ å‡å·ï¼š
        // 1. å‡å·åçš„éŸ³ç¬¦ä¸è¶…å‡ºéŸ³åŸŸ
        if (sharpNote <= this.rules.range.max) {
            accidentalChoices.push(sharpNote);
        }
        
        // å°è¯•æ·»åŠ é™å·ï¼ˆ-1åŠéŸ³ï¼‰  
        const flatNote = midi - 1;
        const flatNoteClass = flatNote % 12;
        
        // åªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ‰æ·»åŠ é™å·ï¼š
        // 1. é™å·åçš„éŸ³ç¬¦ä¸è¶…å‡ºéŸ³åŸŸ
        if (flatNote >= this.rules.range.min) {
            accidentalChoices.push(flatNote);
        }

        // å¦‚æœæ˜¯å°è°ƒï¼Œè¿‡æ»¤æ‰ä¸åœ¨æœ¬è°ƒè‡ªç„¶/å’Œå£°/æ—‹å¾‹å…è®¸é›†åˆå†…çš„éŸ³
        const filteredChoices = minorAllowed
            ? accidentalChoices.filter((n) => minorAllowed.has(n % 12))
            : accidentalChoices;

        const finalChoices = filteredChoices.length ? filteredChoices : accidentalChoices;
        if (!finalChoices.length) {
            console.log(`ğŸ¯ éŸ³ç¬¦MIDI ${midi}æ— éœ€æ·»åŠ ä¸´æ—¶è®°å·ï¼ˆé¿å…ä¸${this.keySignature}è°ƒå·é‡å¤ï¼‰`);
            return midi;
        }
        
        // éšæœºé€‰æ‹©å‡å·æˆ–é™å·
        const selectedNote = this.random.choice(finalChoices);

        // å°è°ƒå†æ¬¡æ ¡éªŒï¼Œä¸å…è®¸è¶…å‡ºé›†åˆ
        if (minorAllowed && !minorAllowed.has(selectedNote % 12)) {
            console.log(`âš ï¸ å°è°ƒ ${this.keySignature} æ‹’ç»éå…è®¸ä¸´æ—¶è®°å·: ${selectedNote}`);
            return midi;
        }

        console.log(`ğŸ¯ ä¸ºMIDI ${midi}æ·»åŠ ä¸´æ—¶è®°å·å˜ä¸ºMIDI ${selectedNote}`);
        return selectedNote;
    }

    /**
     * å°è°ƒå…è®¸çš„éŸ³çº§é›†åˆï¼ˆè‡ªç„¶ + å½“å‰æ¨¡å¼çš„6ã€7çº§ï¼‰ï¼Œç”¨äºé˜»æ­¢ A#ã€D# ç­‰éæ³•éŸ³
     */
    getAllowedMinorPitchClasses(keySignature) {
        const minorAlterations = (typeof MINOR_SCALE_ALTERATIONS !== 'undefined') ? MINOR_SCALE_ALTERATIONS : (globalThis.MINOR_SCALE_ALTERATIONS);
        const noteToMidi = (typeof NOTE_TO_MIDI !== 'undefined') ? NOTE_TO_MIDI : (globalThis.NOTE_TO_MIDI);
        if (!minorAlterations || !KEY_SIGNATURES) return null;
        if (!keySignature || !keySignature.endsWith('m') || !minorAlterations[keySignature]) return null;
        const keyInfo = KEY_SIGNATURES[keySignature];
        if (!keyInfo || typeof keyInfo.tonic !== 'number') return null;
        const tonic = keyInfo.tonic;
        const steps = [0, 2, 3, 5, 7, 8, 10]; // è‡ªç„¶å°è°ƒ
        const allowed = new Set(steps.map((s) => (tonic + s) % 12));

        const alt = minorAlterations[keySignature];
        const pushNote = (noteName) => {
            if (!noteName || !noteToMidi) return;
            const pc = noteToMidi[noteName];
            if (typeof pc === 'number') allowed.add(pc % 12);
        };
        // ä»…å–å½“å‰æ¨¡å¼çš„å˜åŒ–éŸ³ï¼Œé¿å…æ··ç”¨
        // é»˜è®¤å…è®¸è‡ªç„¶ + å’Œå£°/æ—‹å¾‹å°è°ƒå˜åŒ–éŸ³
        if (alt.harmonic) {
            pushNote(alt.harmonic.seventh);
        }
        if (alt.melodic) {
            pushNote(alt.melodic.sixth);
            pushNote(alt.melodic.seventh);
        }
        return allowed;
    }

    /**
     * é€‰æ‹©éŸ³ç¬¦æ—¶åå¥½éŸ³ä¹æ€§éŸ³ç¨‹ï¼ˆä¸‰åº¦ã€äº”åº¦ç­‰ï¼‰
     * 6/8æ‹ä½¿ç”¨Cantus Firmusé£æ ¼çš„çº§è¿›åå¥½
     */
    selectNoteWithIntervalPreference(validNotes, lastMidi) {
        if (validNotes.length === 0) {
            return null;
        }
        
        if (lastMidi === null) {
            return this.random.choice(validNotes);
        }
        
        // 6/8æ‹ä½¿ç”¨Cantus Firmusé£æ ¼ï¼šå¼ºçƒˆåå¥½çº§è¿›è¿åŠ¨
        if (this.timeSignature === '6/8') {
            return this.selectNoteCantusFirmusStyle(validNotes, lastMidi);
        }
        
        // å…¶ä»–æ‹å·ä¿æŒåŸæœ‰é€»è¾‘
        const weightedNotes = [];
        
        validNotes.forEach(note => {
            const interval = Math.abs(note - lastMidi);
            let weight = 1; // åŸºç¡€æƒé‡
            
            // å¢åŠ éŸ³ä¹æ€§éŸ³ç¨‹çš„æƒé‡
            if (interval === 3 || interval === 4) {        // å°ä¸‰åº¦å’Œå¤§ä¸‰åº¦
                weight = 4; // 4å€æƒé‡ï¼Œè¿›ä¸€æ­¥å¢åŠ ä¸‰åº¦å‡ºç°é¢‘ç‡
            } else if (interval === 7) {                   // å®Œå…¨äº”åº¦
                weight = 2; // 2å€æƒé‡
            } else if (interval === 1 || interval === 2) { // çº§è¿›ï¼ˆå°äºŒåº¦ã€å¤§äºŒåº¦ï¼‰
                weight = 2; // ä¿æŒä¸€å®šçš„çº§è¿›æƒé‡
            } else if (interval === 5 || interval === 6) { // å®Œå…¨å››åº¦å’Œä¸‰å…¨éŸ³
                weight = 1.5; // è½»å¾®å¢åŠ æƒé‡
            }
            
            // æ ¹æ®æƒé‡æ·»åŠ éŸ³ç¬¦ï¼ˆæ·»åŠ å¤šæ¬¡ä»¥å¢åŠ è¢«é€‰ä¸­æ¦‚ç‡ï¼‰
            for (let i = 0; i < weight; i++) {
                weightedNotes.push(note);
            }
        });
        
        // ä»åŠ æƒåçš„æ•°ç»„ä¸­éšæœºé€‰æ‹©
        return this.random.choice(weightedNotes);
    }
    
    /**
     * 6/8æ‹çš„Cantus Firmusé£æ ¼éŸ³ç¬¦é€‰æ‹©
     * åŸºäºä¼ ç»Ÿå¯¹ä½æ³•çš„çº§è¿›åŸåˆ™
     */
    selectNoteCantusFirmusStyle(validNotes, lastMidi) {
        const weightedNotes = [];
        
        validNotes.forEach(note => {
            const interval = Math.abs(note - lastMidi);
            let weight = 1; // åŸºç¡€æƒé‡
            
            // Cantus FirmusåŸåˆ™ï¼šå¼ºçƒˆåå¥½çº§è¿›è¿åŠ¨ï¼Œä½†æ ¹æ®ç”¨æˆ·maxJumpè®¾ç½®è°ƒæ•´
            if (interval === 1 || interval === 2) {        // çº§è¿›ï¼ˆå°äºŒåº¦ã€å¤§äºŒåº¦ï¼‰
                weight = 10; // æé«˜æƒé‡ - çº§è¿›æ˜¯ä¸»è¦è¿åŠ¨æ–¹å¼
            } else if (interval === 3) {                   // å°ä¸‰åº¦
                weight = 3; // é€‚åº¦æƒé‡ - å°è·³æ˜¯å…è®¸çš„
            } else if (interval === 4) {                   // å¤§ä¸‰åº¦
                weight = 2; // è¾ƒä½æƒé‡ - å‡å°‘å¤§è·³
            } else if (interval === 5) {                   // å®Œå…¨å››åº¦
                weight = 1.5; // å¶å°”å…è®¸
            } else if (interval >= 6) {                    // ä¸‰å…¨éŸ³åŠæ›´å¤§éŸ³ç¨‹
                // ğŸ”¥ ä¿®å¤ï¼šæ ¹æ®ç”¨æˆ·maxJumpè®¾ç½®åŠ¨æ€è°ƒæ•´æƒé‡ï¼Œä¸å†ä¸€å¾‹è®¾ç½®æä½æƒé‡
                const relativeLarge = interval / this.rules.maxJump;
                if (relativeLarge <= 0.5) {
                    weight = 1.2; // ç”¨æˆ·èŒƒå›´å†…çš„ä¸­ç­‰éŸ³ç¨‹ï¼Œåˆç†æƒé‡
                } else if (relativeLarge <= 0.8) {
                    weight = 0.8; // è¾ƒå¤§ä½†ä»åœ¨ç”¨æˆ·èŒƒå›´å†…ï¼Œé€‚å½“é™ä½æƒé‡
                } else {
                    weight = 0.5; // æ¥è¿‘ç”¨æˆ·ä¸Šé™çš„éŸ³ç¨‹ï¼Œä½æƒé‡ä½†ä»ä¿ç•™
                }
                console.log(`ğŸ¯ 6/8æ‹æƒé‡è°ƒæ•´: ${interval}åŠéŸ³ (${(relativeLarge*100).toFixed(1)}% of maxJump) -> æƒé‡${weight}`);
            }
            
            // ä¸¥æ ¼åº”ç”¨ç”¨æˆ·çš„æœ€å¤§éŸ³ç¨‹é™åˆ¶ï¼ˆCantus Firmusé£æ ¼æ›´åŠ ä¸¥æ ¼ï¼‰
            if (interval > this.rules.maxJump) {
                weight = 0; // è¶…å‡ºç”¨æˆ·è®¾ç½®çš„é™åˆ¶ï¼Œå®Œå…¨ç¦æ­¢
                console.log(`â„¹ï¸ 6/8æ‹è¿‡æ»¤å¤§è·³: ${interval}åŠéŸ³ > ç”¨æˆ·é™åˆ¶${this.rules.maxJump}åŠéŸ³`);
            }
            
            // æ ¹æ®æƒé‡æ·»åŠ éŸ³ç¬¦
            for (let i = 0; i < Math.round(weight * 2); i++) {
                weightedNotes.push(note);
            }
        });
        
        if (weightedNotes.length === 0) {
            // å¦‚æœæƒé‡è¿‡æ»¤åæ²¡æœ‰éŸ³ç¬¦ï¼Œé€‰æ‹©æœ€æ¥è¿‘çš„ä¸€ä¸ª
            return validNotes.reduce((closest, current) => 
                Math.abs(current - lastMidi) < Math.abs(closest - lastMidi) ? current : closest
            );
        }
        
        return this.random.choice(weightedNotes);
    }

    /**
     * ç”Ÿæˆçº§è¿›éŸ³ç¬¦
     */
    generateStepwiseNote(lastMidi, lastDirection) {
        const candidates = [];
        
        // ä¸Šè¡Œçº§è¿›ï¼ˆä¸¥æ ¼é™åˆ¶åœ¨æœ€å¤§éŸ³ç¨‹å†…ï¼‰
        for (let i = 1; i <= Math.min(2, this.rules.maxJump); i++) {
            const upNote = lastMidi + i;
            if (upNote <= this.rules.range.max && this.isInScale(upNote)) {
                candidates.push(upNote);
            }
        }
        
        // ä¸‹è¡Œçº§è¿›ï¼ˆä¸¥æ ¼é™åˆ¶åœ¨æœ€å¤§éŸ³ç¨‹å†…ï¼‰
        for (let i = 1; i <= Math.min(2, this.rules.maxJump); i++) {
            const downNote = lastMidi - i;
            if (downNote >= this.rules.range.min && this.isInScale(downNote)) {
                candidates.push(downNote);
            }
        }
        
        if (candidates.length === 0) {
            return this.generateInScaleNote(lastMidi);
        }
        const prevMidi = this.cfState.prevMidi;
        const weighted = [];
        candidates.forEach((candidate) => {
            let weight = 2;
            const direction = Math.sign(candidate - lastMidi);
            if (lastDirection && direction === lastDirection) {
                weight += 2;
            }
            if (prevMidi !== null && candidate === prevMidi && prevMidi !== lastMidi) {
                weight -= 1;
            }
            const count = Math.max(1, Math.round(weight * 2));
            for (let i = 0; i < count; i++) weighted.push(candidate);
        });
        
        const selected = this.random.choice(weighted.length ? weighted : candidates);
        return this.addAccidentalIfNeeded(selected, lastMidi);
    }

    pickAlternateMelodyNote(lastMidi, options = {}) {
        if (lastMidi === null || lastMidi === undefined) return null;
        const avoid = options.avoid instanceof Set ? options.avoid : new Set();
        const preferThird = !!options.preferThird;
        const maxJump = this.rules.maxJump || 12;
        const candidates = [];
        for (let midi = this.rules.range.min; midi <= this.rules.range.max; midi++) {
            if (!this.isInScale(midi)) continue;
            if (Math.abs(midi - lastMidi) > maxJump) continue;
            if (avoid.has(midi)) continue;
            candidates.push(midi);
        }
        if (!candidates.length) return null;
        const prevInterval = typeof this.cfState.lastInterval === 'number' ? this.cfState.lastInterval : null;
        const weighted = [];
        candidates.forEach((midi) => {
            const interval = Math.abs(midi - lastMidi);
            let weight = 1;
            if (interval <= 2) weight = 5;
            if (interval === 3 || interval === 4) weight = preferThird ? 6 : 4;
            if (interval === 0) weight = 0.2;
            if (interval > 7) weight = 0.6;
            if (prevInterval && (midi - lastMidi) === -prevInterval && interval <= 2) {
                weight *= 0.5;
            }
            const count = Math.max(1, Math.round(weight * 2));
            for (let i = 0; i < count; i++) weighted.push(midi);
        });
        return this.random.choice(weighted.length ? weighted : candidates);
    }

    /**
     * ç”Ÿæˆçº§è¿›å›å½’éŸ³ç¬¦ - éµå¾ªæœ€å¤§éŸ³ç¨‹è·¨åº¦é™åˆ¶
     */
    generateStepwiseReturn(lastMidi, lastDirection) {
        const returnDirection = -lastDirection;
        const candidates = [];
        
        for (let i = 1; i <= 3; i++) {
            const returnNote = lastMidi + (returnDirection * i);
            const interval = Math.abs(returnNote - lastMidi);
            
            // ä¸¥æ ¼æ£€æŸ¥ï¼šéŸ³ç¨‹è·¨åº¦ã€éŸ³åŸŸèŒƒå›´ã€è°ƒå†…éŸ³ç¬¦
            if (interval <= this.rules.maxJump &&
                returnNote >= this.rules.range.min && 
                returnNote <= this.rules.range.max && 
                this.isInScale(returnNote)) {
                candidates.push(returnNote);
            }
        }
        
        if (candidates.length > 0) {
            const selectedNote = candidates[0]; // é€‰æ‹©æœ€è¿‘çš„å›å½’éŸ³
            console.log(`âœ“ çº§è¿›å›å½’éŸ³ç¬¦: MIDI ${selectedNote}, ä¸å‰éŸ³é—´éš”: ${Math.abs(selectedNote - lastMidi)}åŠéŸ³`);
            return this.addAccidentalIfNeeded(selectedNote, lastMidi);
        }
        
        // å¦‚æœçº§è¿›å›å½’å¤±è´¥ï¼Œå›é€€åˆ°æ™®é€šçº§è¿›ç”Ÿæˆ
        return this.generateStepwiseNote(lastMidi, lastDirection);
    }

    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥æ”¾ç½®ä¼‘æ­¢ç¬¦
     */
    shouldPlaceRest(remainingBeats, noteCount, measureIndex) {
        // æ ¹æ®è®¾ç½®çš„ä¼‘æ­¢ç¬¦æ¯”ä¾‹æ§åˆ¶
        const targetRatio = this.rules.restRatio || 0.15;
        const currentRatio = this.stats.restCount / Math.max(1, this.stats.noteCount + this.stats.restCount);
        
        // å¦‚æœå½“å‰ä¼‘æ­¢ç¬¦æ¯”ä¾‹ä½äºç›®æ ‡æ¯”ä¾‹ï¼Œå¢åŠ ä¼‘æ­¢ç¬¦æ¦‚ç‡
        if (currentRatio < targetRatio) {
            return this.random.nextFloat() < 0.2;
        }
        
        // é¿å…è¿ç»­å¤ªå¤šä¼‘æ­¢ç¬¦
        if (noteCount === 0) {
            return this.random.nextFloat() < 0.1;
        }
        
        return false;
    }

    /**
     * ç”Ÿæˆbeamåˆ†ç»„ - å¼ºè¡Œå®ç°ç”¨æˆ·è§„åˆ™
     * æ ¸å¿ƒè§„åˆ™ï¼šåŒä¸€å››åˆ†éŸ³ç¬¦æ‹å†…çš„å…«åˆ†éŸ³ç¬¦å¿…é¡»è¿æ†
     */
    generateBeams(notes, currentBeatLevel = null, timeSignatureOverride = null) {
        const rawTimeSignature = timeSignatureOverride || this.rules.timeSignature || '4/4';
        if (!isBuiltInTimeSignature(rawTimeSignature) && rawTimeSignature !== 'multi') {
            console.log(`ğŸ¼ generateBeams è¢«è°ƒç”¨ - è‡ªå®šä¹‰æ‹å·: ${rawTimeSignature}, éŸ³ç¬¦æ•°: ${notes.length}`);
            return this.generateBeamsForCustomTimeSignature(notes, rawTimeSignature);
        }
        const timeSignature = getBeamingReferenceTimeSignature(rawTimeSignature);
        console.log(`ğŸ¼ generateBeams è¢«è°ƒç”¨ - æ‹å·: ${rawTimeSignature} (beamingä½¿ç”¨ ${timeSignature}), éŸ³ç¬¦æ•°: ${notes.length}`);

        // æ ¹æ®æ‹å·é€‰æ‹©åˆé€‚çš„beamingæ–¹æ³•
        if (timeSignature === '4/4') {
            console.log(`ä½¿ç”¨4/4æ‹ä¸“ç”¨beamingé€»è¾‘`);
            return this.generateBeamsFor4_4(notes);
        } else if (timeSignature === '3/4') {
            console.log(`ä½¿ç”¨3/4æ‹ä¸“ç”¨beamingé€»è¾‘`);
            return this.generateBeamsFor3_4(notes);
        } else if (timeSignature === '2/4') {
            console.log(`ä½¿ç”¨2/4æ‹legacy beamingé€»è¾‘`);
            return this.generateBeamsLegacy(notes, currentBeatLevel, timeSignature);
        } else {
            console.log(`ä½¿ç”¨é€šç”¨legacy beamingé€»è¾‘`);
            return this.generateBeamsLegacy(notes, currentBeatLevel, timeSignature);
        }
    }

    /**
     * è‡ªå®šä¹‰æ‹å· beaming è§„åˆ™ï¼š
     * åŒä¸€æ‹ç‚¹å†…çš„ç¬¦å°¾å¿…é¡»æ•´ä½“è¿åœ¨ä¸€èµ·ï¼Œä¼‘æ­¢ç¬¦/æ‹ç‚¹è¾¹ç•Œä¸­æ–­
     */
    generateBeamsForCustomTimeSignature(notes, timeSignature) {
        const parsed = parseTimeSignatureString(timeSignature);
        if (!parsed) return [];

        const unit = 4 / parsed.beatType; // æ‹å·åˆ†æ¯å•ä½å¯¹åº”çš„æ‹å€¼ï¼ˆä»¥å››åˆ†éŸ³ç¬¦ä¸º1æ‹ï¼‰
        const isCompound = isCompoundTimeSignature(timeSignature);
        const groupSize = unit * (isCompound ? 3 : 1);
        const tolerance = 0.0001;

        console.log(`ğŸ¼ è‡ªå®šä¹‰æ‹å·beaming: ${timeSignature} ${isCompound ? 'compound' : 'simple'}, åˆ†ç»„å¤§å°=${groupSize}æ‹`);

        const beamGroups = [];
        const noteMeta = [];
        let position = 0;

        // é¢„è®¡ç®—éŸ³ç¬¦ä½ç½®ä¸å¯beamå±æ€§
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const start = position;
            const end = position + note.beats;
            const beamLevel = BEAMING_RULES.basicRules.beamLevels[note.duration] || 0;
            const isBeamable = note.type === 'note' && !note.isTriplet &&
                note.duration !== 'whole' && note.duration !== 'half' && note.duration !== 'half.' &&
                beamLevel >= 1;

            noteMeta.push({
                index: i,
                note,
                start,
                end,
                beamLevel,
                isBeamable
            });
            position = end;
        }

        let currentGroup = [];
        let currentGroupStart = null;

        const finalizeGroup = () => {
            if (currentGroup.length < 2) {
                currentGroup = [];
                return;
            }
            const groupIndices = currentGroup.map(meta => meta.index);
            const beamMap = {};

            currentGroup.forEach((meta, idx) => {
                const isFirst = idx === 0;
                const isLast = idx === currentGroup.length - 1;
                beamMap[meta.index] = { 1: isFirst ? 'begin' : isLast ? 'end' : 'continue' };
            });

            // å¤æ‹å­ + 16åˆ†éŸ³ç¬¦ï¼šæ¬¡çº§beamåœ¨å…«åˆ†éŸ³ç¬¦å±‚çº§å†…æ–­å¼€
            if (isCompound && currentGroup.some(meta => meta.beamLevel >= 2)) {
                const subSize = unit;
                currentGroup.forEach((meta, idx) => {
                    if (meta.beamLevel < 2) return;
                    const localPos = meta.start - (currentGroupStart || 0);
                    const subGroup = Math.floor((localPos + tolerance) / subSize);
                    const prevMeta = idx > 0 ? currentGroup[idx - 1] : null;
                    const nextMeta = idx < currentGroup.length - 1 ? currentGroup[idx + 1] : null;

                    const prevIsSameSub = prevMeta && prevMeta.beamLevel >= 2 &&
                        Math.floor(((prevMeta.start - (currentGroupStart || 0)) + tolerance) / subSize) === subGroup;
                    const nextIsSameSub = nextMeta && nextMeta.beamLevel >= 2 &&
                        Math.floor(((nextMeta.start - (currentGroupStart || 0)) + tolerance) / subSize) === subGroup;

                    let beam2;
                    if (!prevIsSameSub && !nextIsSameSub) {
                        beam2 = 'backward hook';
                    } else if (!prevIsSameSub && nextIsSameSub) {
                        beam2 = 'begin';
                    } else if (prevIsSameSub && !nextIsSameSub) {
                        beam2 = 'end';
                    } else {
                        beam2 = 'continue';
                    }

                    if (!beamMap[meta.index]) beamMap[meta.index] = {};
                    beamMap[meta.index][2] = beam2;
                });
            }

            beamGroups.push({
                start: groupIndices[0],
                end: groupIndices[groupIndices.length - 1],
                notes: groupIndices,
                beamMap,
                stemDirection: 'up'
            });

            currentGroup = [];
        };

        noteMeta.forEach(meta => {
            const groupIndex = Math.floor((meta.start + tolerance) / groupSize);
            const groupStart = groupIndex * groupSize;

            if (currentGroupStart === null) {
                currentGroupStart = groupStart;
            }

            if (Math.abs(groupStart - currentGroupStart) > tolerance) {
                finalizeGroup();
                currentGroupStart = groupStart;
            }

            if (!meta.isBeamable) {
                finalizeGroup();
                return;
            }

            currentGroup.push(meta);
        });

        finalizeGroup();

        console.log(`ğŸ¼ è‡ªå®šä¹‰æ‹å·beamingå®Œæˆ: ${beamGroups.length}ä¸ªbeamç»„`);
        return beamGroups;
    }
    
    /**
     * 4/4æ‹è¶…çº§ç®€å•æµ‹è¯•æ–¹æ³• - ç›´æ¥è¿æ¥æ‰€æœ‰å¯è¿æ†éŸ³ç¬¦
     */
    generateBeamsFor4_4(notes) {
        console.log(`ğŸ”¥ ä½¿ç”¨è¶…çº§ç®€å•çš„beamingé€»è¾‘ - ç›´æ¥è¿æ¥æ‰€æœ‰å¯è¿æ†éŸ³ç¬¦`);
        console.log(`ğŸ” ä¼ å…¥çš„éŸ³ç¬¦æ•°æ®æ€»æ•°: ${notes.length}`);
        const normalizePosition = (pos) => {
            const rounded = Math.round(pos * 10000) / 10000;
            const nearest = Math.round(rounded);
            return Math.abs(rounded - nearest) < 0.001 ? nearest : rounded;
        };

        // è¯¦ç»†æ‰“å°æ‰€æœ‰éŸ³ç¬¦æ•°æ®
        notes.forEach((note, i) => {
            console.log(`  éŸ³ç¬¦${i}: type=${note.type}, duration=${note.duration}, beats=${note.beats}, pitch=${note.pitch || 'æ— '}`);
        });

        const beamGroups = [];
        let currentGroup = [];
        let position = 0;
        let currentBeat = -1;

        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const cleanPosition = normalizePosition(position);
            const beatNumber = Math.floor(cleanPosition) % 4;

            console.log(`ğŸ” å¤„ç†éŸ³ç¬¦${i}: ${note.type}/${note.duration}, æ‹${beatNumber}, ä½ç½®${position.toFixed(3)} -> ${cleanPosition.toFixed(3)}`);

            // æœ€ç®€å•çš„è¿æ†æ£€æŸ¥
            let canBeam = false;
            if (note.type === 'note') {
                // åªè¦ä¸æ˜¯å…¨éŸ³ç¬¦æˆ–äºŒåˆ†éŸ³ç¬¦ï¼Œéƒ½å¯ä»¥è¿æ†
                canBeam = !note.isTriplet &&
                    note.duration !== 'whole' &&
                    note.duration !== 'half' &&
                    note.duration !== 'half.';
                console.log(`  ğŸ” éŸ³ç¬¦${i}(${note.duration}): å¯è¿æ†=${canBeam}`);
            }

            if (canBeam) {
                // æ£€æŸ¥æ˜¯å¦æ¢æ‹
                if (currentBeat !== -1 && beatNumber !== currentBeat) {
                    console.log(`  ğŸ“ æ¢æ‹(ä»æ‹${currentBeat}åˆ°æ‹${beatNumber})ï¼Œç»“æŸå½“å‰ç»„`);
                    if (currentGroup.length >= 2) {
                        console.log(`    âœ… åˆ›å»ºè¿æ†ç»„: éŸ³ç¬¦[${currentGroup.map(idx => idx+1).join(', ')}]`);
                        beamGroups.push({
                            start: currentGroup[0],
                            end: currentGroup[currentGroup.length - 1],
                            notes: [...currentGroup],
                            beamLevels: [[...currentGroup]], // ç®€å•çš„beamçº§åˆ«
                            stemDirection: 'up'
                        });
                    }
                    currentGroup = [];
                }

                currentBeat = beatNumber;
                currentGroup.push(i);
                console.log(`  âœ… åŠ å…¥æ‹${beatNumber}è¿æ†ç»„ï¼Œç»„å¤§å°: ${currentGroup.length}`);

            } else {
                // ä¼‘æ­¢ç¬¦æˆ–ä¸å¯è¿æ†éŸ³ç¬¦ï¼Œç»“æŸå½“å‰ç»„
                console.log(`  âŒ ä¸è¿æ†/ä¸­æ–­è¿æ†ç»„`);
                if (currentGroup.length >= 2) {
                    console.log(`    âœ… åˆ›å»ºè¿æ†ç»„: éŸ³ç¬¦[${currentGroup.map(idx => idx+1).join(', ')}]`);
                    beamGroups.push({
                        start: currentGroup[0],
                        end: currentGroup[currentGroup.length - 1],
                        notes: [...currentGroup],
                        beamLevels: [[...currentGroup]], // ç®€å•çš„beamçº§åˆ«
                        stemDirection: 'up'
                    });
                }
                currentGroup = [];
                currentBeat = -1;
            }

            position += note.beats;
        }

        // å¤„ç†æœ€åä¸€ç»„
        if (currentGroup.length >= 2) {
            console.log(`  âœ… åˆ›å»ºæœ€ç»ˆè¿æ†ç»„: éŸ³ç¬¦[${currentGroup.map(idx => idx+1).join(', ')}]`);
            beamGroups.push({
                start: currentGroup[0],
                end: currentGroup[currentGroup.length - 1],
                notes: [...currentGroup],
                beamLevels: [[...currentGroup]], // ç®€å•çš„beamçº§åˆ«
                stemDirection: 'up'
            });
        }

        console.log(`ğŸ”¥ è¶…ç®€å•beamingå®Œæˆ: å…±${beamGroups.length}ä¸ªbeamç»„`);
        beamGroups.forEach((group, i) => {
            console.log(`  è¿æ†ç»„${i+1}: éŸ³ç¬¦[${group.notes.map(n => n+1).join(',')}]`);
        });
        return beamGroups;
    }

    /**
     * åŸæœ‰å¤æ‚çš„æ–¹æ³•ä¿ç•™ä½œä¸ºå¤‡ç”¨
     */
    generateBeamsFor4_4_Complex(notes) {
        console.log(`ğŸµ ä½¿ç”¨4/4æ‹ä¸“ç”¨beamç”Ÿæˆé€»è¾‘ - ä¸¥æ ¼æŒ‰æ‹ç‚¹åˆ†ç»„`);

        const beamGroups = [];
        let currentPosition = 0;

        // å°†éŸ³ç¬¦æŒ‰ç…§ä¸¥æ ¼çš„æ‹ç‚¹åˆ†ç»„ - ç¬¬1æ‹[0-1), ç¬¬2æ‹[1-2), ç¬¬3æ‹[2-3), ç¬¬4æ‹[3-4)
        const beatGroups = [[], [], [], []]; // 4ä¸ªå››åˆ†éŸ³ç¬¦æ‹

        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteStart = currentPosition;
            const noteEnd = currentPosition + note.beats;

            // è®¡ç®—åœ¨å½“å‰å°èŠ‚å†…çš„ä½ç½®
            const measurePosition = noteStart % 4;
            const measureEnd = noteEnd % 4;

            console.log(`ğŸµ åˆ†æéŸ³ç¬¦${i+1}: ${note.duration}, ç»å¯¹ä½ç½®${noteStart.toFixed(3)}-${noteEnd.toFixed(3)}, å°èŠ‚å†…ä½ç½®${measurePosition.toFixed(3)}-${(measureEnd || 4).toFixed(3)}`);

            // ç®€åŒ–çš„è¾¹ç•Œæ£€æŸ¥ï¼šå¦‚æœéŸ³ç¬¦è·¨è¶Šä»»ä½•æ•´æ•°æ‹ç‚¹è¾¹ç•Œï¼Œåˆ™ä¸èƒ½beam
            let crossesBeat = false;

            // æ£€æŸ¥æ˜¯å¦è·¨è¶Šä»»ä½•æ‹ç‚¹è¾¹ç•Œ (1.0, 2.0, 3.0)
            for (let boundary = 1; boundary <= 3; boundary++) {
                if (measurePosition < boundary && measureEnd > boundary) {
                    console.log(`  âŒ è·¨è¶Šç¬¬${boundary}æ‹è¾¹ç•Œï¼Œä¸èƒ½beam`);
                    crossesBeat = true;
                    break;
                }
            }

            if (!crossesBeat) {
                // ç¡®å®šéŸ³ç¬¦å±äºå“ªä¸ªæ‹
                let beatIndex = -1;

                if (measurePosition >= 0 && measurePosition < 1) {
                    beatIndex = 0; // ç¬¬1æ‹
                } else if (measurePosition >= 1 && measurePosition < 2) {
                    beatIndex = 1; // ç¬¬2æ‹
                } else if (measurePosition >= 2 && measurePosition < 3) {
                    beatIndex = 2; // ç¬¬3æ‹
                } else if (measurePosition >= 3 && measurePosition < 4) {
                    beatIndex = 3; // ç¬¬4æ‹
                }

                if (beatIndex >= 0) {
                    beatGroups[beatIndex].push(i);
                    console.log(`  âœ… éŸ³ç¬¦${i+1}åˆ†é…åˆ°æ‹${beatIndex+1}`);
                } else {
                    console.log(`  âŒ éŸ³ç¬¦${i+1}ä½ç½®å¼‚å¸¸ï¼Œæ— æ³•åˆ†é…åˆ°ä»»ä½•æ‹`);
                }
            }

            currentPosition += note.beats;
        }

        // ä¸ºæ¯ä¸ªæ‹å†…çš„éŸ³ç¬¦ç”Ÿæˆbeamç»„ - ä¸¥æ ¼é™åˆ¶åœ¨å•ä¸ªå››åˆ†éŸ³ç¬¦æ‹å†…ï¼Œä¼‘æ­¢ç¬¦ä¸­æ–­beam
        for (let beatIndex = 0; beatIndex < 4; beatIndex++) {
            const beatNotes = beatGroups[beatIndex];
            console.log(`ğŸµ æ‹${beatIndex+1}çš„éŸ³ç¬¦: [${beatNotes.map(idx => idx+1).join(', ')}]`);

            if (beatNotes.length >= 2) {
                // æ£€æŸ¥è¯¥æ‹æ˜¯å¦æœ‰åå…­åˆ†éŸ³ç¬¦
                const hasSixteenth = beatNotes.some(idx => {
                    const note = notes[idx];
                    return note.type === 'note' && (note.duration === '16th' || Math.abs(note.beats - 0.25) < 0.01);
                });

                console.log(`  ğŸ” æ‹${beatIndex+1}æœ‰åå…­åˆ†éŸ³ç¬¦: ${hasSixteenth}`);

                // åœ¨åŒä¸€æ‹å†…ï¼ŒæŒ‰è¿ç»­æ€§åˆ†ç»„ï¼Œä¼‘æ­¢ç¬¦ä¼šä¸­æ–­beamè¿æ¥
                let currentGroup = [];

                for (let i = 0; i < beatNotes.length; i++) {
                    const noteIndex = beatNotes[i];
                    const note = notes[noteIndex];

                    // ç›´æ¥æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦å¯è¿æ† - ä½¿ç”¨æœ€ç®€å•çš„è§„åˆ™
                    let canBeBeamed = false;
                    if (note.type === 'note') {
                        if (hasSixteenth) {
                            // æœ‰åå…­åˆ†éŸ³ç¬¦æ—¶ï¼šå››åˆ†ã€å…«åˆ†ã€åå…­åˆ†éƒ½å¯è¿æ†
                            canBeBeamed = note.duration === 'quarter' ||
                                        note.duration === 'quarter.' ||
                                        note.duration === 'eighth' ||
                                        note.duration === 'eighth.' ||
                                        note.duration === '16th' ||
                                        note.duration === '16th.' ||
                                        note.duration === '32nd';
                        } else {
                            // æ²¡æœ‰åå…­åˆ†éŸ³ç¬¦æ—¶ï¼šåªæœ‰å…«åˆ†åŠä»¥ä¸‹å¯è¿æ†
                            canBeBeamed = note.duration === 'eighth' ||
                                        note.duration === 'eighth.' ||
                                        note.duration === '16th' ||
                                        note.duration === '16th.' ||
                                        note.duration === '32nd';
                        }

                        console.log(`    ğŸ” éŸ³ç¬¦${noteIndex+1}(${note.duration}): å¯è¿æ†=${canBeBeamed}, æœ‰åå…­åˆ†=${hasSixteenth}`);
                    }

                    if (canBeBeamed) {
                        // è¿™æ˜¯ä¸€ä¸ªå¯ beaming çš„éŸ³ç¬¦
                        currentGroup.push(noteIndex);
                    } else {
                        // è¿™æ˜¯ä¼‘æ­¢ç¬¦æˆ–ä¸å¯ beam çš„éŸ³ç¬¦ï¼Œä¸­æ–­å½“å‰ç»„
                        if (currentGroup.length >= 2) {
                            this.addBeamGroup(beamGroups, currentGroup, notes);
                            console.log(`  âœ… æ‹${beatIndex+1}åˆ›å»ºbeamç»„(${currentGroup.length}éŸ³ç¬¦): [${currentGroup.map(idx => idx+1).join(', ')}] - è¢«ä¼‘æ­¢ç¬¦ä¸­æ–­`);
                        }
                        currentGroup = [];
                        console.log(`  ğŸ”„ æ‹${beatIndex+1}é‡åˆ°${note.type === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'ä¸å¯beaméŸ³ç¬¦'}ï¼Œé‡ç½®beamç»„`);
                    }
                }

                // å¤„ç†æœ€åä¸€ä¸ªç»„
                if (currentGroup.length >= 2) {
                    this.addBeamGroup(beamGroups, currentGroup, notes);
                    console.log(`  âœ… æ‹${beatIndex+1}åˆ›å»ºæœ€ç»ˆbeamç»„(${currentGroup.length}éŸ³ç¬¦): [${currentGroup.map(idx => idx+1).join(', ')}]`);
                }
            } else if (beatNotes.length === 1) {
                console.log(`  â„¹ï¸ æ‹${beatIndex+1}åªæœ‰1ä¸ªéŸ³ç¬¦ï¼Œæ— éœ€beam`);
            }
        }

        console.log(`ğŸµ 4/4æ‹å¤æ‚beamç”Ÿæˆå®Œæˆ: å…±${beamGroups.length}ä¸ªbeamç»„`);
        return beamGroups;
    }

    /**
     * åŸæœ‰çš„å¼ºåˆ¶æ–¹æ³•ä¿ç•™ä½œä¸ºå¤‡ç”¨
     */
    forceBeamsFor44(notes) {
        console.log(`ğŸ’¥ğŸ’¥ğŸ’¥ åå…­åˆ†éŸ³ç¬¦è§¦å‘å…¨æ‹è¿æ†è§„åˆ™ ğŸ’¥ğŸ’¥ğŸ’¥`);
        console.log(`è¾“å…¥éŸ³ç¬¦æ€»æ•°: ${notes.length}`);

        // æ­¥éª¤1: åˆ†ææ¯ä¸ªæ‹ç‚¹ï¼Œæ£€æµ‹æ˜¯å¦åŒ…å«åå…­åˆ†éŸ³ç¬¦
        const beatAnalysis = this.analyzeBeatContents(notes);
        console.log(`ğŸ” æ‹ç‚¹åˆ†æç»“æœ:`, beatAnalysis);

        // æ­¥éª¤2: æ ¹æ®åˆ†æç»“æœåˆ›å»ºè¿æ†ç»„
        const beamGroups = [];
        let position = 0;
        let currentGroup = [];
        let currentBeat = -1;

        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];

            // ä¿®å¤æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼šå››èˆäº”å…¥åˆ°å°æ•°ç‚¹å4ä½ï¼Œç„¶åå–æ•´
            const cleanPosition = Math.round(position * 10000) / 10000;
            const noteBeat = Math.floor(cleanPosition) % 4; // ç¡®ä¿æ‹å·åœ¨0-3èŒƒå›´å†…
            const beatInfo = beatAnalysis.get(noteBeat);

            console.log(`ğŸ” å¤„ç†éŸ³ç¬¦${i}: ${note.type}/${note.duration}, æ‹${noteBeat}, ä½ç½®${position.toFixed(4)} -> æ¸…ç†å${cleanPosition.toFixed(4)}`);

            // å¼ºåˆ¶å°èŠ‚è¾¹ç•Œæ£€æŸ¥ - å¦‚æœè·¨è¶Šå°èŠ‚ï¼Œç«‹å³ç»ˆæ­¢å½“å‰è¿æ†ç»„
            const measureNumber = Math.floor(cleanPosition / 4);
            const beatInMeasure = noteBeat; // noteBeatå·²ç»æ˜¯0-3èŒƒå›´å†…çš„æ‹å·
            const currentMeasure = currentBeat !== -1 ? Math.floor((position - note.beats) / 4) : measureNumber;

            // è°ƒè¯•ï¼šç‰¹åˆ«å…³æ³¨ç¬¬3å’Œç¬¬4æ‹çš„è¿æ†é—®é¢˜
            if (noteBeat >= 2) {
                console.log(`  ğŸ¯ [ç¬¬${noteBeat+1}æ‹è°ƒè¯•] éŸ³ç¬¦${i}: ${note.duration}, åŸå§‹ä½ç½®: ${position.toFixed(6)}, æ¸…ç†ä½ç½®: ${cleanPosition.toFixed(6)}, æ‹: ${noteBeat}`);
                console.log(`  ğŸ¯ [ç¬¬${noteBeat+1}æ‹è°ƒè¯•] å½“å‰è¿æ†ç»„å¤§å°: ${currentGroup.length}, å½“å‰æ‹: ${currentBeat}`);
                console.log(`  ğŸ¯ [ç¬¬${noteBeat+1}æ‹è°ƒè¯•] éŸ³ç¬¦ç±»å‹: ${note.type}, æ˜¯å¦å…«åˆ†éŸ³ç¬¦: ${note.duration === 'eighth'}`);
            }

            if (currentGroup.length > 0 && measureNumber !== currentMeasure) {
                console.log(`  ğŸš« æ£€æµ‹åˆ°å°èŠ‚è¾¹ç•Œï¼ˆå°èŠ‚${currentMeasure}â†’${measureNumber}ï¼‰ï¼Œå¼ºåˆ¶ç»ˆæ­¢è¿æ†ç»„`);
                this.finalizeBeamGroup(beamGroups, currentGroup, notes, currentBeat);
                currentGroup = [];
                currentBeat = -1;
            }

            // æ£€æŸ¥è¯¥æ‹æ˜¯å¦éœ€è¦å…¨æ‹è¿æ†
            const shouldBeamAllInBeat = beatInfo && beatInfo.hasSixteenth;

            // ç¡®å®šéŸ³ç¬¦æ˜¯å¦åº”è¯¥è¿æ†
            let shouldBeam = false;
            if (note.type === 'rest') {
                // ä¼‘æ­¢ç¬¦ç»ˆæ­¢è¿æ†
                shouldBeam = false;
                console.log(`  âŒ ä¼‘æ­¢ç¬¦ï¼Œç»ˆæ­¢è¿æ†`);
            } else if (note.type === 'note') {
                if (shouldBeamAllInBeat) {
                    // è¯¥æ‹æœ‰åå…­åˆ†éŸ³ç¬¦ï¼Œæ‰€æœ‰éŸ³ç¬¦éƒ½è¿æ†
                    const isBeamableNote = this.isBeamableNote(note);
                    shouldBeam = isBeamableNote;
                    console.log(`  ğŸ¯ æ‹${noteBeat}æœ‰åå…­åˆ†éŸ³ç¬¦ï¼Œ${isBeamableNote ? 'åŠ å…¥' : 'è·³è¿‡'}è¿æ†: ${note.duration}`);
                } else {
                    // è¯¥æ‹æ²¡æœ‰åå…­åˆ†éŸ³ç¬¦ï¼Œä½¿ç”¨æ ‡å‡†è¿æ†è§„åˆ™
                    shouldBeam = this.isStandardBeamable(note);
                    console.log(`  ğŸ“ æ‹${noteBeat}æ ‡å‡†è¿æ†è§„åˆ™: ${shouldBeam ? 'è¿æ†' : 'ä¸è¿æ†'}`);

                    // ç¬¬4æ‹è°ƒè¯•ï¼šè¯¦ç»†æ£€æŸ¥isStandardBeamableçš„ç»“æœ
                    if (noteBeat === 3) {
                        console.log(`  ğŸ¯ [ç¬¬4æ‹æ ‡å‡†è¿æ†] éŸ³ç¬¦${i}: type=${note.type}, duration=${note.duration}, beats=${note.beats}, shouldBeam=${shouldBeam}`);
                    }
                }
            }

            if (shouldBeam) {
                // ä¸¥æ ¼æ£€æŸ¥æ˜¯å¦æ¢æ‹ - ä¿®å¤è¾¹ç•Œæ£€æŸ¥é€»è¾‘
                const shouldTerminateGroup = (currentBeat !== -1 && noteBeat !== currentBeat);

                if (shouldTerminateGroup) {
                    const reason1 = (currentBeat !== -1 && noteBeat !== currentBeat);
                    const reason2 = (currentGroup.length > 0 && noteBeat >= 4);
                    console.log(`  ğŸ“ å¼ºåˆ¶ç»“æŸè¿æ†ç»„ - æ¢æ‹: ${reason1}, è·¨å°èŠ‚: ${reason2}, å½“å‰æ‹: ${currentBeat}â†’${noteBeat}, ä½ç½®: ${cleanPosition.toFixed(4)}`);

                    // ç¬¬4æ‹è°ƒè¯•
                    if (noteBeat === 3) {
                        console.log(`  ğŸš¨ [ç¬¬4æ‹ç»ˆæ­¢] ç¬¬4æ‹è¿æ†ç»„è¢«æ„å¤–ç»ˆæ­¢! åŸå› : æ¢æ‹=${reason1}, è·¨å°èŠ‚=${reason2}`);
                        console.log(`  ğŸš¨ [ç¬¬4æ‹ç»ˆæ­¢] å½“å‰ç»„å¤§å°: ${currentGroup.length}, currentBeat: ${currentBeat}, noteBeat: ${noteBeat}`);
                    }

                    this.finalizeBeamGroup(beamGroups, currentGroup, notes, currentBeat);
                    currentGroup = [];
                    currentBeat = -1;
                }

                // é‡æ–°æ£€æŸ¥æ˜¯å¦åº”è¯¥å¼€å§‹æ–°ç»„
                if (currentBeat === -1 || noteBeat !== currentBeat) {
                    currentBeat = noteBeat;
                }

                currentGroup.push(i);
                console.log(`  âœ… åŠ å…¥æ‹${noteBeat}è¿æ†ç»„ï¼Œç»„å¤§å°: ${currentGroup.length}`);

                // ç¬¬4æ‹è°ƒè¯•
                if (noteBeat === 3) {
                    console.log(`  ğŸ¯ [ç¬¬4æ‹è¿æ†] æˆåŠŸåŠ å…¥ç¬¬4æ‹è¿æ†ç»„: éŸ³ç¬¦${i} (${note.duration}), ç»„å¤§å°: ${currentGroup.length}`);
                }
            } else {
                console.log(`  âŒ ä¸è¿æ†/ä¸­æ–­è¿æ†ç»„`);

                // ç¬¬4æ‹è°ƒè¯•
                if (noteBeat === 3) {
                    console.log(`  ğŸš¨ [ç¬¬4æ‹è­¦å‘Š] ç¬¬4æ‹éŸ³ç¬¦${i} (${note.duration}) è¢«æ‹’ç»è¿æ†! shouldBeam=${shouldBeam}`);
                }

                this.finalizeBeamGroup(beamGroups, currentGroup, notes, currentBeat);
                currentGroup = [];
                currentBeat = -1;
            }

            position += note.beats;
            // ä¿®å¤ç´¯è®¡æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            position = Math.round(position * 10000) / 10000;
        }

        // å¤„ç†æœ€åä¸€ç»„
        this.finalizeBeamGroup(beamGroups, currentGroup, notes, currentBeat);

        console.log(`ğŸ’¥ æœ€ç»ˆè¿æ†ç»“æœ: ${beamGroups.length}ä¸ªè¿æ†ç»„`);
        beamGroups.forEach((group, i) => {
            const noteTypes = group.notes.map(idx => notes[idx].duration).join(',');
            console.log(`  è¿æ†ç»„${i+1}: æ‹${group.beat}, éŸ³ç¬¦[${group.notes.map(n => n+1).join(',')}] (${noteTypes})`);
        });

        return beamGroups;
    }
    
    /**
     * åˆ†ææ¯ä¸ªæ‹ç‚¹çš„å†…å®¹ï¼Œæ£€æµ‹æ˜¯å¦åŒ…å«åå…­åˆ†éŸ³ç¬¦
     */
    analyzeBeatContents(notes) {
        console.log(`ğŸ” å¼€å§‹åˆ†ææ‹ç‚¹å†…å®¹`);
        const beatAnalysis = new Map();
        let position = 0;
        
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            // ä¿®å¤æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼šå››èˆäº”å…¥åˆ°å°æ•°ç‚¹å4ä½ï¼Œç„¶åå–æ•´
            const cleanPosition = Math.round(position * 10000) / 10000;
            const beatNumber = Math.floor(cleanPosition) % 4; // ç¡®ä¿æ‹å·åœ¨0-3èŒƒå›´å†…
            
            if (!beatAnalysis.has(beatNumber)) {
                beatAnalysis.set(beatNumber, {
                    hasSixteenth: false,
                    hasEighth: false,
                    hasRest: false,
                    notes: []
                });
            }
            
            const beatInfo = beatAnalysis.get(beatNumber);
            beatInfo.notes.push({index: i, note: note});
            
            // æ£€æµ‹åå…­åˆ†éŸ³ç¬¦
            if (note.type === 'note' && (note.duration === '16th' || Math.abs(note.beats - 0.25) < 0.01)) {
                beatInfo.hasSixteenth = true;
                console.log(`  ğŸ¯ æ‹${beatNumber}å‘ç°åå…­åˆ†éŸ³ç¬¦: éŸ³ç¬¦${i} (${note.duration})`);
            }
            
            // æ£€æµ‹å…«åˆ†éŸ³ç¬¦ï¼ˆåŒ…æ‹¬é™„ç‚¹å…«åˆ†éŸ³ç¬¦ï¼‰
            if (note.type === 'note' && (
                note.duration === 'eighth' || Math.abs(note.beats - 0.5) < 0.01 ||
                note.duration === 'eighth.' || Math.abs(note.beats - 0.75) < 0.01
            )) {
                beatInfo.hasEighth = true;
                if (note.duration === 'eighth.' || Math.abs(note.beats - 0.75) < 0.01) {
                    console.log(`  ğŸµ æ‹${beatNumber}å‘ç°é™„ç‚¹å…«åˆ†éŸ³ç¬¦: éŸ³ç¬¦${i} (${note.duration}, ${note.beats}æ‹)`);
                }
            }
            
            // æ£€æµ‹ä¼‘æ­¢ç¬¦
            if (note.type === 'rest') {
                beatInfo.hasRest = true;
            }

            position += note.beats;
            // ä¿®å¤ç´¯è®¡æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            position = Math.round(position * 10000) / 10000;
        }
        
        // æ‰“å°åˆ†æç»“æœ
        for (const [beat, info] of beatAnalysis) {
            console.log(`  æ‹${beat}: åå…­åˆ†=${info.hasSixteenth}, å…«åˆ†=${info.hasEighth}, ä¼‘æ­¢=${info.hasRest}, éŸ³ç¬¦æ•°=${info.notes.length}`);
        }
        
        return beatAnalysis;
    }
    
    /**
     * æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦å¯è¿æ†ï¼ˆåŒ…æ‹¬å››åˆ†éŸ³ç¬¦åœ¨åå…­åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ï¼‰
     */
    isBeamableNote(note) {
        if (note.type !== 'note') return false;
        if (note.isTriplet) return false;
        
        console.log(`    ğŸ” æ£€æŸ¥è¿æ†èƒ½åŠ›: ${note.duration}, beats=${note.beats}`);
        
        // åå…­åˆ†éŸ³ç¬¦åœºæ™¯ä¸‹ï¼Œå››åˆ†éŸ³ç¬¦ã€å…«åˆ†éŸ³ç¬¦ã€åå…­åˆ†éŸ³ç¬¦ã€é™„ç‚¹éŸ³ç¬¦éƒ½å¯è¿æ†
        const isBeamable = 
               note.duration === 'quarter' || Math.abs(note.beats - 1) < 0.01 ||        // å››åˆ†éŸ³ç¬¦
               note.duration === 'eighth' || Math.abs(note.beats - 0.5) < 0.01 ||       // å…«åˆ†éŸ³ç¬¦
               note.duration === 'eighth.' || Math.abs(note.beats - 0.75) < 0.01 ||     // é™„ç‚¹å…«åˆ†éŸ³ç¬¦
               note.duration === 'quarter.' || Math.abs(note.beats - 1.5) < 0.01 ||     // é™„ç‚¹å››åˆ†éŸ³ç¬¦
               note.duration === '16th' || Math.abs(note.beats - 0.25) < 0.01 ||        // åå…­åˆ†éŸ³ç¬¦
               note.duration === '16th.' || Math.abs(note.beats - 0.375) < 0.01 ||      // é™„ç‚¹åå…­åˆ†éŸ³ç¬¦
               note.duration === '32nd' || Math.abs(note.beats - 0.125) < 0.01;         // ä¸‰åäºŒåˆ†éŸ³ç¬¦
        
        console.log(`    â†’ ç»“æœ: ${isBeamable}`);
        return isBeamable;
    }
    
    /**
     * æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦ç¬¦åˆæ ‡å‡†è¿æ†è§„åˆ™ï¼ˆåªæœ‰å…«åˆ†éŸ³ç¬¦åŠä»¥ä¸‹ï¼ŒåŒ…å«é™„ç‚¹ï¼‰
     */
    isStandardBeamable(note) {
        if (note.type !== 'note') return false;
        if (note.isTriplet) return false;

        console.log(`    ğŸ“ æ ‡å‡†è¿æ†æ£€æŸ¥: duration=${note.duration}, beats=${note.beats}, tied=${note.tied}, tieType=${note.tieType}`);

        // æ ‡å‡†è§„åˆ™ï¼šåªæœ‰å…«åˆ†éŸ³ç¬¦åŠä»¥ä¸‹å¯è¿æ†ï¼ˆåŒ…æ‹¬é™„ç‚¹ï¼‰
        const isEighth = note.duration === 'eighth' || Math.abs(note.beats - 0.5) < 0.01;
        const isDottedEighth = note.duration === 'eighth.' || Math.abs(note.beats - 0.75) < 0.01;
        const isSixteenth = note.duration === '16th' || Math.abs(note.beats - 0.25) < 0.01;
        const isDottedSixteenth = note.duration === '16th.' || Math.abs(note.beats - 0.375) < 0.01;
        const isThirtySecond = note.duration === '32nd' || Math.abs(note.beats - 0.125) < 0.01;

        const isStandardBeamable = isEighth || isDottedEighth || isSixteenth || isDottedSixteenth || isThirtySecond;

        console.log(`    â†’ è¯¦ç»†æ£€æŸ¥: eighth=${isEighth}, eighth.=${isDottedEighth}, 16th=${isSixteenth}, 16th.=${isDottedSixteenth}, 32nd=${isThirtySecond}`);
        console.log(`    â†’ æ ‡å‡†è¿æ†ç»“æœ: ${isStandardBeamable}`);
        return isStandardBeamable;
    }
    
    /**
     * å®Œæˆè¿æ†ç»„åˆ›å»º
     */
    finalizeBeamGroup(beamGroups, currentGroup, notes, currentBeat) {
        if (currentGroup.length >= 2) {
            console.log(`  ğŸ¼ åˆ›å»ºæ‹${currentBeat}çš„è¿æ†ç»„: éŸ³ç¬¦[${currentGroup.join(',')}]`);

            // åˆ›å»ºå¤šçº§è¿æ†ç»„
            const groupNotes = currentGroup.map(idx => notes[idx]);
            const beamLevels = this.calculateBeamLevels(groupNotes, currentGroup);

            const beamGroup = {
                start: currentGroup[0],
                end: currentGroup[currentGroup.length - 1],
                notes: [...currentGroup],
                beamLevels: beamLevels,
                stemDirection: 'up', // é»˜è®¤å‘ä¸Š
                beat: currentBeat // è®°å½•æ‹å·ç”¨äºè°ƒè¯•
            };

            beamGroups.push(beamGroup);
            console.log(`    âœ… æˆåŠŸåˆ›å»ºè¿æ†ç»„: éŸ³ç¬¦${currentGroup.map(n => n+1).join(',')}`);
        } else if (currentGroup.length === 1) {
            console.log(`  âš ï¸ æ‹${currentBeat}åªæœ‰1ä¸ªå¯è¿æ†éŸ³ç¬¦ï¼Œä¸è¶³ä»¥è¿æ†`);
        }
    }
    
    /**
     * è®¡ç®—å¤šçº§è¿æ† - å¤„ç†æ··åˆéŸ³ç¬¦ç±»å‹
     */
    calculateBeamLevels(groupNotes, noteIndices) {
        console.log(`ğŸ” è®¡ç®—è¿æ†çº§åˆ«ï¼ŒéŸ³ç¬¦ç±»å‹: [${groupNotes.map(n => n.duration).join(', ')}]`);
        
        const beamLevels = [];
        
        // ç¬¬ä¸€çº§è¿æ†ï¼šæ‰€æœ‰éŸ³ç¬¦éƒ½å‚ä¸ï¼ˆå…«åˆ†éŸ³ç¬¦åŠä»¥ä¸‹ï¼‰
        beamLevels.push([...noteIndices]);
        console.log(`  Level 1 (å…«åˆ†éŸ³ç¬¦çº§): [${noteIndices.join(', ')}]`);
        
        // ç¬¬äºŒçº§è¿æ†ï¼šåªæœ‰åå…­åˆ†éŸ³ç¬¦åŠä»¥ä¸‹å‚ä¸
        const sixteenthNotes = [];
        for (let i = 0; i < groupNotes.length; i++) {
            const note = groupNotes[i];
            if (note.duration === '16th' || note.beats <= 0.25) {
                sixteenthNotes.push(noteIndices[i]);
            }
        }
        
        if (sixteenthNotes.length >= 2) {
            beamLevels.push(sixteenthNotes);
            console.log(`  Level 2 (åå…­åˆ†éŸ³ç¬¦çº§): [${sixteenthNotes.join(', ')}]`);
        }
        
        // ç¬¬ä¸‰çº§è¿æ†ï¼šåªæœ‰ä¸‰åäºŒåˆ†éŸ³ç¬¦åŠä»¥ä¸‹å‚ä¸
        const thirtySecondNotes = [];
        for (let i = 0; i < groupNotes.length; i++) {
            const note = groupNotes[i];
            if (note.duration === '32nd' || note.beats <= 0.125) {
                thirtySecondNotes.push(noteIndices[i]);
            }
        }
        
        if (thirtySecondNotes.length >= 2) {
            beamLevels.push(thirtySecondNotes);
            console.log(`  Level 3 (ä¸‰åäºŒåˆ†éŸ³ç¬¦çº§): [${thirtySecondNotes.join(', ')}]`);
        }
        
        console.log(`ğŸ¼ æœ€ç»ˆè¿æ†çº§åˆ«: ${beamLevels.length}çº§`);
        return beamLevels;
    }
    
    /**
     * VexFlowé£æ ¼çš„4/4æ‹è¿æ†ç”Ÿæˆ
     * è§„åˆ™ï¼šåŒæ‹å†…çš„è¿ç»­å¯è¿æ†éŸ³ç¬¦å¿…é¡»è¿æ†ï¼ˆè¢«ä¼‘æ­¢ç¬¦æˆ–éè¿æ†éŸ³ç¬¦ä¸­æ–­æ—¶åˆ†ç»„ï¼‰
     */
    generateBeamsVexFlowStyle(notes) {
        console.log(`ğŸ¯ 4/4æ‹è¿æ†ï¼šåŒæ‹å†…è¿ç»­å¯è¿æ†éŸ³ç¬¦è¿æ†ï¼Œä¼‘æ­¢ç¬¦ä¸­æ–­åˆ†ç»„`);
        
        const beamGroups = [];
        let currentPosition = 0;
        
        // æŒ‰é¡ºåºå¤„ç†ï¼Œæ„å»ºè¿ç»­çš„è¿æ†ç»„
        let currentGroup = [];
        let currentBeat = -1;
        
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteBeat = Math.floor(currentPosition);
            
            console.log(`éŸ³ç¬¦${i}: ${note.duration}, ä½ç½®${currentPosition.toFixed(3)}, æ‹${noteBeat}, type=${note.type}`);
            
            // æ£€æŸ¥æ˜¯å¦å¯è¿æ†
            if (this.canNoteBeBeamed(note)) {
                console.log(`  âœ… å¯è¿æ†éŸ³ç¬¦`);
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»“æŸå½“å‰ç»„ï¼ˆæ¢æ‹äº†ï¼‰
                if (currentBeat !== -1 && noteBeat !== currentBeat) {
                    console.log(`  ğŸ“ æ¢æ‹äº†ï¼ˆä»æ‹${currentBeat}åˆ°æ‹${noteBeat}ï¼‰ï¼Œç»“æŸå½“å‰ç»„`);
                    if (currentGroup.length >= 2) {
                        this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
                        console.log(`    ğŸ¼ åˆ›å»ºè¿æ†ç»„: éŸ³ç¬¦${currentGroup.map(n => n+1).join(',')}`);
                    }
                    currentGroup = [];
                }
                
                // æ·»åŠ åˆ°å½“å‰ç»„
                currentGroup.push(i);
                currentBeat = noteBeat;
                console.log(`  â• åŠ å…¥å½“å‰ç»„ï¼Œç»„å¤§å°: ${currentGroup.length}`);
                
            } else {
                console.log(`  âŒ ä¸å¯è¿æ†éŸ³ç¬¦ï¼ˆ${note.type}ï¼‰ï¼Œä¸­æ–­è¿æ†ç»„`);
                
                // ç»“æŸå½“å‰ç»„
                if (currentGroup.length >= 2) {
                    this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
                    console.log(`    ğŸ¼ åˆ›å»ºè¿æ†ç»„: éŸ³ç¬¦${currentGroup.map(n => n+1).join(',')} (è¢«${note.type}ä¸­æ–­)`);
                }
                currentGroup = [];
                currentBeat = -1;
            }
            
            currentPosition += note.beats;
        }
        
        // å¤„ç†æœ€åä¸€ç»„
        if (currentGroup.length >= 2) {
            this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
            console.log(`  ğŸ¼ åˆ›å»ºæœ€åè¿æ†ç»„: éŸ³ç¬¦${currentGroup.map(n => n+1).join(',')}`);
        }
        
        console.log(`ğŸ¼ 4/4æ‹è¿æ†å®Œæˆ: ${beamGroups.length}ä¸ªè¿æ†ç»„`);
        return beamGroups;
    }
    
    /**
     * ä¼ ç»Ÿè¿æ†ç”Ÿæˆé€»è¾‘ï¼ˆç”¨äºé4/4æ‹å·ï¼‰
     */
    generateBeamsLegacy(notes, currentBeatLevel = null, timeSignatureOverride = null) {
        const beamGroups = [];
        let currentGroup = [];
        let currentPosition = 0;
        const rawTimeSignature = timeSignatureOverride || this.rules.timeSignature || '4/4';
        const timeSignature = getBeamingReferenceTimeSignature(rawTimeSignature);
        
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            
            const canBeBeamed = this.canNoteBeBeamed(note);
            
            if (canBeBeamed) {
                if (currentGroup.length > 0) {
                    const shouldStartNew = this.shouldStartNewBeamGroup(
                        currentPosition, 
                        currentPosition + note.beats, 
                        timeSignature, 
                        notes, 
                        currentGroup,
                        currentBeatLevel
                    );
                    
                    if (shouldStartNew) {
                        this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
                        currentGroup = [];
                    }
                }
                
                currentGroup.push(i);
            } else {
                if (currentGroup.length > 0) {
                    this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
                    currentGroup = [];
                }
            }
            
            currentPosition += note.beats;
        }
        
        if (currentGroup.length > 0) {
            this.endCurrentBeamGroup(beamGroups, currentGroup, notes);
        }
        
        return beamGroups;
    }

    /**
     * ä¸“é—¨ä¸º3/4æ‹ç”Ÿæˆbeamåˆ†ç»„ - ä¸¥æ ¼ä¸è·¨æ‹è¿æ¥
     */
    generateBeamsFor3_4(notes) {
        console.log(`ğŸµ ä½¿ç”¨3/4æ‹ä¸“ç”¨beamç”Ÿæˆé€»è¾‘ - ä¸¥æ ¼æŒ‰æ‹ç‚¹åˆ†ç»„`);
        
        const beamGroups = [];
        let currentPosition = 0;
        
        // å°†éŸ³ç¬¦æŒ‰ç…§ä¸¥æ ¼çš„æ‹ç‚¹åˆ†ç»„ - ç¬¬1æ‹[0-1), ç¬¬2æ‹[1-2), ç¬¬3æ‹[2-3)
        const beatGroups = [[], [], []]; // 3ä¸ªå››åˆ†éŸ³ç¬¦æ‹
        
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteStart = currentPosition;
            const noteEnd = currentPosition + note.beats;
            
            // è®¡ç®—åœ¨å½“å‰å°èŠ‚å†…çš„ä½ç½®
            const measurePosition = noteStart % 3;
            const measureEnd = noteEnd % 3;
            
            console.log(`ğŸµ åˆ†æéŸ³ç¬¦${i+1}: ${note.duration}, ç»å¯¹ä½ç½®${noteStart.toFixed(3)}-${noteEnd.toFixed(3)}, å°èŠ‚å†…ä½ç½®${measurePosition.toFixed(3)}-${(measureEnd || 3).toFixed(3)}`);
            
            // æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦è·¨è¶Šæ‹ç‚¹è¾¹ç•Œï¼ˆåœ¨å°èŠ‚å†…ï¼‰
            let crossesBeat = false;
            
            // æ£€æŸ¥æ˜¯å¦è·¨è¶Šæ‹1è¾¹ç•Œ (1.0)
            if (measurePosition < 1 && (measureEnd > 1 || (measureEnd === 0 && noteEnd % 3 !== noteStart % 3))) {
                console.log(`  âŒ è·¨è¶Šç¬¬1æ‹è¾¹ç•Œï¼Œä¸èƒ½beam`);
                crossesBeat = true;
            }
            // æ£€æŸ¥æ˜¯å¦è·¨è¶Šæ‹2è¾¹ç•Œ (2.0)  
            else if (measurePosition < 2 && (measureEnd > 2 || (measureEnd <= 1 && noteEnd > noteStart + 1))) {
                console.log(`  âŒ è·¨è¶Šç¬¬2æ‹è¾¹ç•Œï¼Œä¸èƒ½beam`);
                crossesBeat = true;
            }
            
            if (!crossesBeat) {
                // ç¡®å®šéŸ³ç¬¦å±äºå“ªä¸ªæ‹
                let beatIndex = -1;
                
                if (measurePosition >= 0 && measurePosition < 1) {
                    beatIndex = 0; // ç¬¬1æ‹
                } else if (measurePosition >= 1 && measurePosition < 2) {
                    beatIndex = 1; // ç¬¬2æ‹  
                } else if (measurePosition >= 2 && measurePosition < 3) {
                    beatIndex = 2; // ç¬¬3æ‹
                }
                
                if (beatIndex >= 0) {
                    beatGroups[beatIndex].push(i);
                    console.log(`  âœ… éŸ³ç¬¦${i+1}åˆ†é…åˆ°æ‹${beatIndex+1}`);
                } else {
                    console.log(`  âŒ éŸ³ç¬¦${i+1}ä½ç½®å¼‚å¸¸ï¼Œæ— æ³•åˆ†é…åˆ°ä»»ä½•æ‹`);
                }
            }
            
            currentPosition += note.beats;
        }
        
        // ä¸ºæ¯ä¸ªæ‹å†…çš„éŸ³ç¬¦ç”Ÿæˆbeamç»„ - ä¸¥æ ¼é™åˆ¶åœ¨å•ä¸ªå››åˆ†éŸ³ç¬¦æ‹å†…ï¼Œä¼‘æ­¢ç¬¦ä¸­æ–­beam
        for (let beatIndex = 0; beatIndex < 3; beatIndex++) {
            const beatNotes = beatGroups[beatIndex];
            console.log(`ğŸµ æ‹${beatIndex+1}çš„éŸ³ç¬¦: [${beatNotes.map(idx => idx+1).join(', ')}]`);
            
            if (beatNotes.length >= 2) {
                // åœ¨åŒä¸€æ‹å†…ï¼ŒæŒ‰è¿ç»­æ€§åˆ†ç»„ï¼Œä¼‘æ­¢ç¬¦ä¼šä¸­æ–­beamè¿æ¥
                let currentGroup = [];
                
                for (let i = 0; i < beatNotes.length; i++) {
                    const noteIndex = beatNotes[i];
                    const note = notes[noteIndex];
                    
                    if (note.type === 'note' && this.canNoteBeBeamed(note)) {
                        // è¿™æ˜¯ä¸€ä¸ªå¯beamingçš„éŸ³ç¬¦
                        currentGroup.push(noteIndex);
                    } else {
                        // è¿™æ˜¯ä¼‘æ­¢ç¬¦æˆ–ä¸å¯beamçš„éŸ³ç¬¦ï¼Œä¸­æ–­å½“å‰ç»„
                        if (currentGroup.length >= 2) {
                            this.addBeamGroup(beamGroups, currentGroup, notes);
                            console.log(`  âœ… æ‹${beatIndex+1}åˆ›å»ºbeamç»„(${currentGroup.length}éŸ³ç¬¦): [${currentGroup.map(idx => idx+1).join(', ')}] - è¢«ä¼‘æ­¢ç¬¦ä¸­æ–­`);
                        }
                        currentGroup = [];
                        console.log(`  ğŸ”„ æ‹${beatIndex+1}é‡åˆ°${note.type === 'rest' ? 'ä¼‘æ­¢ç¬¦' : 'ä¸å¯beaméŸ³ç¬¦'}ï¼Œé‡ç½®beamç»„`);
                    }
                }
                
                // å¤„ç†æœ€åä¸€ä¸ªç»„
                if (currentGroup.length >= 2) {
                    this.addBeamGroup(beamGroups, currentGroup, notes);
                    console.log(`  âœ… æ‹${beatIndex+1}åˆ›å»ºæœ€ç»ˆbeamç»„(${currentGroup.length}éŸ³ç¬¦): [${currentGroup.map(idx => idx+1).join(', ')}]`);
                }
            } else if (beatNotes.length === 1) {
                console.log(`  â„¹ï¸ æ‹${beatIndex+1}åªæœ‰1ä¸ªéŸ³ç¬¦ï¼Œæ— éœ€beam`);
            }
        }
        
        console.log(`ğŸµ 3/4æ‹beamç”Ÿæˆå®Œæˆ: å…±${beamGroups.length}ä¸ªbeamç»„`);
        return beamGroups;
    }

    /**
     * æ·»åŠ beamç»„çš„è¾…åŠ©æ–¹æ³•
     */
    addBeamGroup(beamGroups, noteIndices, allNotes) {
        if (noteIndices.length < 2) return;
        
        const groupNotes = noteIndices.map(index => allNotes[index]);
        const beamLevels = BEAMING_RULES.generateBeamLevels(groupNotes);
        const stemDirection = BEAMING_RULES.stemDirectionRules.implementation.calculateDirection(groupNotes);
        
        const beamGroup = {
            start: noteIndices[0],
            end: noteIndices[noteIndices.length - 1],
            notes: noteIndices.slice(),
            beamLevels: beamLevels,
            stemDirection: stemDirection
        };
        
        beamGroups.push(beamGroup);
        console.log(`    æ·»åŠ beamç»„: éŸ³ç¬¦${noteIndices[0]+1}-${noteIndices[noteIndices.length-1]+1} (${noteIndices.length}ä¸ªéŸ³ç¬¦)`);
    }
    
    /**
     * æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦å¯ä»¥è¿æ¥ç¬¦æ§“ - ä½¿ç”¨è¯¦ç»†è§„åˆ™
     */
    canNoteBeBeamed(note) {
        // åŸºç¡€æ£€æŸ¥ï¼šå¿…é¡»æ˜¯éŸ³ç¬¦ä¸”æœ‰ç¬¦å°¾
        if (note.type !== 'note') return false;
        if (!BEAMING_RULES.basicRules.beamableNotes.includes(note.duration)) return false;
        
        // ä¸‰è¿éŸ³å•ç‹¬å¤„ç†ï¼Œä¸ä¸æ™®é€šéŸ³ç¬¦æ··åˆè¿æ¥
        if (note.isTriplet) return false;
        
        return true;
    }
    
    /**
     * ç»“æŸå½“å‰beamåˆ†ç»„ - ä½¿ç”¨è¯¦ç»†è§„åˆ™éªŒè¯
     */
    endCurrentBeamGroup(beamGroups, currentGroup, allNotes) {
        if (currentGroup.length < BEAMING_RULES.basicRules.minimumGroupSize) {
            return; // ä¸æ»¡è¶³æœ€å°‘è¿æ¥æ•°é‡
        }
        
        // è·å–åˆ†ç»„ä¸­çš„éŸ³ç¬¦ä¿¡æ¯
        const groupNotes = currentGroup.map(index => allNotes[index]);
        
        // ç”Ÿæˆç¬¦æ§“çº§åˆ«ä¿¡æ¯ï¼ˆç”¨äºæ··åˆéŸ³å€¼ï¼‰
        const beamLevels = BEAMING_RULES.generateBeamLevels(groupNotes);
        
        // è®¡ç®—ç¬¦å¹²æ–¹å‘
        const stemDirection = BEAMING_RULES.stemDirectionRules.implementation.calculateDirection(groupNotes);
        
        const beamGroup = {
            start: currentGroup[0],
            end: currentGroup[currentGroup.length - 1],
            notes: currentGroup.slice(),
            beamLevels: beamLevels, // å¤šçº§ç¬¦æ§“ä¿¡æ¯
            stemDirection: stemDirection // ç¬¦å¹²æ–¹å‘
        };
        
        beamGroups.push(beamGroup);
        
        console.log(`    ç¬¦æ§“ç»„: éŸ³ç¬¦${currentGroup.map(n => n + 1).join('-')}, ` +
                   `ç¬¦å¹²æ–¹å‘: ${stemDirection}, ç¬¦æ§“çº§åˆ«: ${beamLevels.length}`);
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦åº”è¯¥å¼€å§‹æ–°çš„beamåˆ†ç»„ - ä½¿ç”¨è¯¦ç»†ç¬¦æ§“è§„åˆ™
     */
    shouldStartNewBeamGroup(noteStart, noteEnd, timeSignature, allNotes, currentGroup, currentBeatLevel = null) {
        if (currentGroup.length === 0) {
            return false; // æ²¡æœ‰ç°æœ‰åˆ†ç»„ï¼Œä¸éœ€è¦å¼€å§‹æ–°åˆ†ç»„
        }
        
        // 4/4æ‹ç®€åŒ–è§„åˆ™ï¼šåŒä¸€å››åˆ†æ‹å†…çš„å…«åˆ†éŸ³ç¬¦å¿…é¡»è¿æ†
        if (timeSignature === '4/4') {
            // è®¡ç®—å½“å‰ç»„çš„èµ·å§‹æ‹å’Œæ–°éŸ³ç¬¦çš„æ‹
            let groupStartPosition = 0;
            for (let i = 0; i < currentGroup[0]; i++) {
                groupStartPosition += allNotes[i].beats;
            }
            
            const groupBeat = Math.floor(groupStartPosition);
            const newNoteBeat = Math.floor(noteStart);
            
            console.log(`    ğŸ” 4/4æ‹åˆ†ç»„å†³ç­–: å½“å‰ç»„èµ·å§‹ä½ç½®=${groupStartPosition}, ç»„æ‰€åœ¨æ‹=${groupBeat}, æ–°éŸ³ç¬¦ä½ç½®=${noteStart}, æ–°éŸ³ç¬¦æ‹=${newNoteBeat}`);
            
            // å¦‚æœæ–°éŸ³ç¬¦ä¸å½“å‰ç»„åœ¨ä¸åŒçš„å››åˆ†æ‹ï¼Œå¼€å§‹æ–°ç»„
            if (groupBeat !== newNoteBeat) {
                console.log(`    4/4æ‹ï¼šæ–°éŸ³ç¬¦åœ¨æ‹${newNoteBeat}ï¼Œå½“å‰ç»„åœ¨æ‹${groupBeat}ï¼Œå¼€å§‹æ–°ç¬¦æ§“ç»„`);
                return true;
            }
            
            console.log(`    4/4æ‹ï¼šæ–°éŸ³ç¬¦ä¸å½“å‰ç»„åœ¨åŒä¸€æ‹${groupBeat}ï¼Œç»§ç»­å½“å‰ç»„`);
            // åŒä¸€æ‹å†…ï¼Œç»§ç»­æ·»åŠ åˆ°å½“å‰ç»„
            return false;
        }
        
        // 3/4æ‹ä¿æŒåŸæœ‰é€»è¾‘
        if (timeSignature === '3/4') {
            const beatsPerMeasure = 3;
            const startInMeasure = noteStart % beatsPerMeasure;
            
            for (const boundary of [0, 1, 2]) {
                if (Math.abs(startInMeasure - boundary) < 0.001 && currentGroup.length > 0) {
                    console.log(`    ğŸµ 3/4æ‹ä¸¥æ ¼beamè§„åˆ™: å››åˆ†éŸ³ç¬¦æ‹ç‚¹${boundary}ï¼Œå¼ºåˆ¶å¼€å§‹æ–°ç¬¦æ§“ç»„`);
                    return true;
                }
            }
        }
        
        // å…¶ä»–æ‹å·ä½¿ç”¨åŸæ¥çš„å¤æ‚é€»è¾‘
        const groupStartIndex = currentGroup[0];
        const groupEndIndex = currentGroup[currentGroup.length - 1];
        
        // è®¡ç®—åˆ†ç»„å¼€å§‹ä½ç½®
        let groupStartPosition = 0;
        for (let i = 0; i < groupStartIndex; i++) {
            groupStartPosition += allNotes[i].beats;
        }
        
        // åˆ›å»ºåŒ…å«å½“å‰éŸ³ç¬¦çš„æµ‹è¯•åˆ†ç»„
        const testGroup = allNotes.slice(groupStartIndex, groupEndIndex + 2); // +2 åŒ…å«ä¸‹ä¸€ä¸ªéŸ³ç¬¦
        
        // æ£€æŸ¥æ˜¯å¦è·¨è¶Šå…³é”®è¾¹ç•Œï¼ˆä½¿ç”¨åŠ¨æ€ç»†åˆ†è¾¹ç•Œï¼‰
        const allowedRhythms = this.rules?.allowedDurations || [];
        const crossesBoundary = BEAMING_RULES.crossesCriticalBoundary(testGroup, groupStartPosition, timeSignature, currentBeatLevel, allowedRhythms);
        
        if (crossesBoundary) {
            console.log(`    è·¨è¶Šå…³é”®æ‹ç‚¹è¾¹ç•Œï¼Œå¼€å§‹æ–°ç¬¦æ§“ç»„ @ ä½ç½®${noteStart}`);
            return true;
        }
        
        // æ£€æŸ¥æ‹å·ç‰¹å®šè§„åˆ™
        const timeSignatureRules = BEAMING_RULES.timeSignatureRules[timeSignature];
        if (timeSignatureRules) {
            // æ£€æŸ¥ä¸»è¦è¾¹ç•Œï¼ˆå¼ºæ‹ï¼‰
            const beatsPerMeasure = parseInt(timeSignature.split('/')[0]);
            const startInMeasure = noteStart % beatsPerMeasure;
            
            for (const boundary of timeSignatureRules.primaryBoundaries) {
                if (Math.abs(startInMeasure - boundary) < 0.001) {
                    console.log(`    åˆ°è¾¾ä¸»è¦è¾¹ç•Œç‚¹ ${boundary}ï¼Œå¼€å§‹æ–°ç¬¦æ§“ç»„`);
                    return true;
                }
            }
        }
        
        return false;
    }

    /**
     * æ£€æŸ¥ç‰¹æ®Šbeamingæ¨¡å¼ï¼ˆ3/4çš„ä¸¤ä¸ªä¸¤ä¸ªï¼Œ6/8çš„ä¸‰ä¸ªä¸‰ä¸ªï¼‰
     */
    checkBeamingPattern(pattern, currentGroup, allNotes, timeSignature) {
        if (!currentGroup || currentGroup.length === 0) {
            return false;
        }

        // åªå¯¹å…«åˆ†éŸ³ç¬¦åº”ç”¨ç‰¹æ®Šåˆ†ç»„æ¨¡å¼
        const groupNotes = currentGroup.map(i => allNotes[i]);
        const hasOnlyEighthNotes = groupNotes.every(note => 
            note.duration === 'eighth' && note.type === 'note'
        );
        
        if (!hasOnlyEighthNotes) {
            return false; // åªæœ‰çº¯å…«åˆ†éŸ³ç¬¦æ‰åº”ç”¨ç‰¹æ®Šæ¨¡å¼
        }

        switch (pattern) {
            case "two-by-two":
                // 3/4æ‹ï¼šå…«åˆ†éŸ³ç¬¦ä¸¤ä¸ªä¸¤ä¸ªè¿æ¥
                if (currentGroup.length >= 2) {
                    console.log(`    3/4æ‹ä¸¤ä¸ªä¸¤ä¸ªæ¨¡å¼ï¼šå½“å‰ç»„å·²æœ‰${currentGroup.length}ä¸ªå…«åˆ†éŸ³ç¬¦ï¼Œå¼€å§‹æ–°ç»„`);
                    return true;
                }
                break;
                
            case "three-by-three":
                // 6/8æ‹ï¼šä¸¥æ ¼æŒ‰ä½ç½®åˆ†ç»„ - æ¯ç»„3ä¸ªå…«åˆ†éŸ³ç¬¦
                return this.check6_8BeamingPosition(currentGroup, allNotes);
        }

        return false;
    }

    /**
     * 6/8æ‹çš„ä¸¥æ ¼ä½ç½®åˆ†ç»„æ£€æŸ¥
     * å¼ºåˆ¶åœ¨1.5æ‹å¤„åˆ†ç»„ï¼Œç¡®ä¿ä¸¤å¤§ç»„ç»“æ„
     */
    check6_8BeamingPosition(currentGroup, allNotes) {
        if (currentGroup.length === 0) {
            return false;
        }

        // è®¡ç®—å½“å‰ç»„çš„èµ·å§‹ä½ç½®
        const firstNoteIndex = currentGroup[0];
        const groupStartPosition = this.calculateNotePosition(allNotes, firstNoteIndex);
        const measurePosition = groupStartPosition % 3; // åœ¨3æ‹å°èŠ‚å†…çš„ä½ç½®
        
        // ğŸ”¥ 6/8æ‹å…³é”®æ£€æŸ¥ï¼šä½ç½®1.5çš„éŸ³ç¬¦å¿…é¡»å¼ºåˆ¶å¼€å§‹æ–°beamç»„
        if (Math.abs(measurePosition - 1.5) < 0.001 && currentGroup.length > 0) {
            console.log(`    ğŸš« 6/8æ‹å¼ºåˆ¶è§„åˆ™ï¼šä½ç½®1.5å¤„å¼ºåˆ¶ç»“æŸç¬¬ä¸€ç»„ï¼Œå¼€å§‹ç¬¬äºŒç»„`);
            return true;
        }

        // æ£€æŸ¥æ˜¯å¦è·¨è¶Š6/8æ‹çš„ä¸»æ‹è¾¹ç•Œï¼ˆ1.5æ‹å¤„ï¼‰
        const currentGroupEndPos = measurePosition + (currentGroup.length * 0.5);
        if (measurePosition < 1.5 && currentGroupEndPos > 1.5) {
            console.log(`    6/8æ‹è·¨è¶Šä¸»æ‹è¾¹ç•Œ(1.5æ‹)ï¼Œå¼€å§‹æ–°ç»„`);
            return true;
        }

        // é™åˆ¶æ¯ç»„æœ€å¤š3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼ˆä¸€ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦çš„æ—¶å€¼ï¼‰
        if (currentGroup.length >= 3) {
            console.log(`    6/8æ‹ä¸¥æ ¼åˆ†ç»„ï¼šå½“å‰ç»„å·²æœ‰${currentGroup.length}ä¸ªå…«åˆ†éŸ³ç¬¦ï¼Œç»“æŸå½“å‰ç»„`);
            return true;
        }

        return false;
    }

    /**
     * å…¨æ–°çš„6/8æ‹beamåˆ†ç»„é€»è¾‘ - ä¸¥æ ¼ä¸¤å¤§ç»„
     * 6/8æ‹æ˜¯å¤åˆäºŒæ‹å­ï¼šä¸¤ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ‹ï¼Œæ¯æ‹ç»†åˆ†ä¸ºä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦
     */
    build68BeamGroups(notes) {
        console.log(`ğŸ¼ [6/8ä¸“ç”¨] å¼€å§‹æ„å»º6/8æ‹beamç»„ - ä¸¥æ ¼ä¸¤å¤§ç»„æ¨¡å¼`);
        console.log(`  è¾“å…¥: ${notes.length}ä¸ªéŸ³ç¬¦`);
        
        const beamGroups = [];
        let position = 0;
        
        // ç¬¬ä¸€å¤§ç»„ï¼šä½ç½®0.0-1.5ï¼ˆå‰ä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦æ—¶å€¼ï¼‰
        const firstGroupNotes = [];
        // ç¬¬äºŒå¤§ç»„ï¼šä½ç½®1.5-3.0ï¼ˆåä¸‰ä¸ªå…«åˆ†éŸ³ç¬¦æ—¶å€¼ï¼‰
        const secondGroupNotes = [];
        
        // éå†æ‰€æœ‰éŸ³ç¬¦ï¼Œæ ¹æ®ä½ç½®åˆ†é…åˆ°ä¸¤å¤§ç»„
        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteStart = position;
            const noteEnd = position + note.beats;
            
            // åªæœ‰å¯ä»¥beamingçš„éŸ³ç¬¦æ‰åŠ å…¥ç»„
            if (note.type === 'note' && this.canNoteBeBeamed(note)) {
                // åˆ¤æ–­éŸ³ç¬¦å±äºå“ªä¸ªå¤§ç»„
                if (noteStart < 1.5) {
                    // ç¬¬ä¸€å¤§ç»„ï¼ˆ0-1.5ï¼‰
                    // ä½†å¦‚æœéŸ³ç¬¦ä¼šè·¨è¶Š1.5è¾¹ç•Œï¼Œåˆ™ä¸åŠ å…¥ä»»ä½•ç»„
                    if (noteEnd <= 1.5 + 0.001) {
                        firstGroupNotes.push(i);
                        console.log(`    éŸ³ç¬¦${i}: â†’ åŠ å…¥ç¬¬ä¸€å¤§ç»„`);
                    } else {
                        console.log(`    éŸ³ç¬¦${i}: âš ï¸ è·¨è¶Š1.5è¾¹ç•Œï¼Œä¸åŠ å…¥beamç»„`);
                    }
                } else if (noteStart >= 1.5 - 0.001) {
                    // ç¬¬äºŒå¤§ç»„ï¼ˆ1.5-3.0ï¼‰
                    secondGroupNotes.push(i);
                    console.log(`    éŸ³ç¬¦${i}: â†’ åŠ å…¥ç¬¬äºŒå¤§ç»„`);
                }
            } else if (note.type === 'rest') {
                console.log(`    éŸ³ç¬¦${i}: â†’ ä¼‘æ­¢ç¬¦ï¼Œä¸­æ–­beamè¿æ¥`);
            }
            
            position = noteEnd;
        }
        
        // å¤„ç†ä¼‘æ­¢ç¬¦ä¸­æ–­ï¼šå°†æ¯ä¸ªå¤§ç»„æŒ‰ä¼‘æ­¢ç¬¦ä½ç½®è¿›ä¸€æ­¥åˆ†å‰²
        const processGroupWithRests = (groupNotes, groupName) => {
            if (groupNotes.length < 2) {
                console.log(`  ${groupName}éŸ³ç¬¦å¤ªå°‘ï¼Œä¸åˆ›å»ºbeamç»„`);
                return [];
            }
            
            const subGroups = [];
            let currentSubGroup = [];
            
            for (let i = 0; i < groupNotes.length; i++) {
                const noteIndex = groupNotes[i];
                currentSubGroup.push(noteIndex);
                
                // æ£€æŸ¥è¿™ä¸ªéŸ³ç¬¦å’Œä¸‹ä¸€ä¸ªéŸ³ç¬¦ä¹‹é—´æ˜¯å¦æœ‰ä¼‘æ­¢ç¬¦
                let hasRestBetween = false;
                if (i < groupNotes.length - 1) {
                    const nextNoteIndex = groupNotes[i + 1];
                    // æ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰ä¼‘æ­¢ç¬¦
                    for (let j = noteIndex + 1; j < nextNoteIndex; j++) {
                        if (notes[j].type === 'rest') {
                            hasRestBetween = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœæœ‰ä¼‘æ­¢ç¬¦æˆ–è€…åˆ°äº†æœ€åä¸€ä¸ªéŸ³ç¬¦ï¼Œç»“æŸå½“å‰å­ç»„
                if (hasRestBetween || i === groupNotes.length - 1) {
                    if (currentSubGroup.length >= 2) {
                        subGroups.push([...currentSubGroup]);
                        console.log(`    ${groupName}å­ç»„: [${currentSubGroup.join(', ')}]`);
                    }
                    currentSubGroup = [];
                }
            }
            
            return subGroups;
        };

        const firstGroupSubGroups = processGroupWithRests(firstGroupNotes, "ç¬¬ä¸€å¤§ç»„");
        const secondGroupSubGroups = processGroupWithRests(secondGroupNotes, "ç¬¬äºŒå¤§ç»„");

        // ä¸ºæ¯ä¸ªå­ç»„åˆ›å»ºbeamç»„å¯¹è±¡
        [...firstGroupSubGroups, ...secondGroupSubGroups].forEach(subGroup => {
            if (subGroup.length >= 2) {
                const groupNotes = subGroup.map(i => notes[i]);
                const beamLevels = this.generateBeamLevels(groupNotes);
                const stemDirection = this.calculateStemDirection(groupNotes);
                
                const beamGroup = {
                    notes: subGroup,
                    beamLevels: beamLevels,
                    stemDirection: stemDirection,
                    type: 'beam'
                };
                
                beamGroups.push(beamGroup);
            }
        });
        
        console.log(`âœ… 6/8æ‹beamç»„æ„å»ºå®Œæˆ: æ€»å…±${beamGroups.length}ä¸ªbeamç»„`);
        return beamGroups;
    }

    /**
     * è®¡ç®—éŸ³ç¬¦åœ¨å°èŠ‚ä¸­çš„ä½ç½®
     */
    calculateNotePosition(noteIndex, allNotes) {
        let position = 0;
        for (let i = 0; i < noteIndex; i++) {
            position += allNotes[i].beats;
        }
        return position;
    }

    /**
     * åˆ¤æ–­éŸ³ç¬¦æ˜¯å¦å¯ä»¥è¿beam
     */
    canBeBeamed(duration) {
        return ['eighth', '16th', '32nd'].includes(duration);
    }

    /**
     * åˆ¤æ–­æ˜¯å¦å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³
     */
    canGenerateTriplet(remainingBeats) {
        // åªæœ‰å½“è®¾ç½®ä¸­å…è®¸ä¸‰è¿éŸ³æ—¶æ‰ç”Ÿæˆ
        if (!Array.isArray(this.rules.allowedDurations) || !this.rules.allowedDurations.includes('triplet')) {
            console.log(`ğŸš« ä¸‰è¿éŸ³è¢«ç¦ç”¨: allowedDurations=[${this.rules.allowedDurations?.join(',')}]`);
            console.log(`ğŸ” ç”¨æˆ·åŸå§‹è®¾ç½®: allowedRhythms=[${userSettings?.allowedRhythms?.join(',')}]`);
            return false;
        }

        // æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„ä¸‰è¿éŸ³é¢‘ç‡
        if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.triplet !== undefined) {
            const tripletFrequency = userSettings.rhythmFrequencies.triplet;
            if (tripletFrequency === 0) {
                console.log(`ğŸš« ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šä¸‰è¿éŸ³é¢‘ç‡ä¸º 0%ï¼Œå®Œå…¨ç¦ç”¨`);
                return false;
            }

            // æ ¹æ®ç”¨æˆ·è®¾ç½®çš„é¢‘ç‡æ¥å†³å®šæ˜¯å¦ç”Ÿæˆä¸‰è¿éŸ³
            const randomValue = this.random.nextFloat() * 100;
            const shouldGenerate = randomValue < tripletFrequency;
            console.log(`ğŸ¯ ä¸‰è¿éŸ³é¢‘ç‡æ£€æŸ¥ï¼šéšæœºå€¼ ${randomValue.toFixed(1)} vs ç”¨æˆ·é¢‘ç‡ ${tripletFrequency}% = ${shouldGenerate ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'}`);

            if (!shouldGenerate) {
                return false;
            }
        }

        // ç²¾ç¡®æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´ç”Ÿæˆä¸‰è¿éŸ³
        // å…«åˆ†éŸ³ç¬¦ä¸‰è¿éŸ³éœ€è¦è‡³å°‘1æ‹ï¼Œå››åˆ†éŸ³ç¬¦ä¸‰è¿éŸ³éœ€è¦è‡³å°‘2æ‹
        if (remainingBeats < 0.999) { // ä½¿ç”¨æ›´ç²¾ç¡®çš„è¾¹ç•Œ
            console.log(`å‰©ä½™æ‹æ•°${remainingBeats}ä¸è¶³ï¼Œæ— æ³•ç”Ÿæˆä¸‰è¿éŸ³ (éœ€è¦â‰¥1æ‹)`);
            return false;
        }
        
        // ç¡®ä¿æˆ‘ä»¬æœ‰æœ‰æ•ˆçš„éŸ³ç¬¦ç”Ÿæˆèƒ½åŠ›
        if (!this.rules.range || this.rules.range.min >= this.rules.range.max) {
            console.log(`éŸ³åŸŸè®¾ç½®æ— æ•ˆï¼Œæ— æ³•ç”Ÿæˆä¸‰è¿éŸ³`);
            return false;
        }
        
        // å¦‚æœå‰©ä½™æ‹æ•°åˆšå¥½æ˜¯æ•´æ•°æ‹ï¼Œä¼˜å…ˆç”Ÿæˆä¸‰è¿éŸ³ä»¥é¿å…é›¶æ•£çš„å°æ—¶å€¼
        const isNearWholeBeat = Math.abs(remainingBeats - Math.round(remainingBeats)) < 0.001;
        if (isNearWholeBeat && remainingBeats >= 1) {
            console.log(`ğŸ¯ æ•´æ•°æ‹æ•°${remainingBeats}ï¼Œè€ƒè™‘ä¸‰è¿éŸ³`);
            const wholeBeatsChance = this.random.nextFloat() < 0.15; // é™ä½æ•´æ•°æ‹ä¸‰è¿éŸ³æ¦‚ç‡
            console.log(`   æ•´æ•°æ‹ä¸‰è¿éŸ³å†³ç­–: ${wholeBeatsChance ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'} (15%æ¦‚ç‡)`);
            return wholeBeatsChance;
        }
        
        // æ­£å¸¸æ¦‚ç‡ç”Ÿæˆä¸‰è¿éŸ³ - é€‚åº¦æ¦‚ç‡é¿å…è¿‡äºé¢‘ç¹
        const normalTripletChance = this.random.nextFloat() < 0.08; // é™ä½åŸºç¡€æ¦‚ç‡åˆ°åˆç†èŒƒå›´
        console.log(`ğŸ² æ­£å¸¸ä¸‰è¿éŸ³éšæœºå†³ç­–: ${normalTripletChance ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'} (8%æ¦‚ç‡, å‰©ä½™${remainingBeats}æ‹)`);
        return normalTripletChance;
    }

    /**
     * è¿éŸ³ç±»ç”Ÿæˆè§„åˆ™ - åŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³å’Œå››è¿éŸ³
     * ä¸º6/8æ‹æ·»åŠ äº†dupletå’Œquadrupletæ”¯æŒ
     */
    get TRIPLET_RULES() {
        return {
        // è¿éŸ³åŸºæœ¬åŸåˆ™
        basicPrinciple: "è¿éŸ³å¿…é¡»ç‹¬å æ‹ç‚¹ï¼Œä¸èƒ½ä¸æ™®é€šéŸ³ç¬¦æ··åˆ",
        
        // è¿éŸ³ç±»å‹åŠå…¶æ‹ç‚¹å ç”¨è§„åˆ™
        types: {
            // ä¼ ç»Ÿä¸‰è¿éŸ³ï¼ˆç”¨äºæ‰€æœ‰æ‹å·ï¼‰
            eighth: {
                duration: 'eighth',        // å…«åˆ†ä¸‰è¿éŸ³
                totalBeats: 1,            // å ç”¨1æ‹ï¼ˆ4/4æ‹ä¸­çš„1ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 1/3,     // æ¯ä¸ªéŸ³ç¬¦1/3æ‹
                preferredPositions: [0, 1, 2, 3], // å¿…é¡»å‡ºç°åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆæ­£æ‹ï¼‰
                description: "å…«åˆ†ä¸‰è¿éŸ³ï¼š3ä¸ªå…«åˆ†éŸ³ç¬¦å 1æ‹æ—¶å€¼ï¼Œå¿…é¡»åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š",
                tupletCount: 3,
                tupletType: 'triplet'
            },
            quarter: {
                duration: 'quarter',      // å››åˆ†ä¸‰è¿éŸ³
                totalBeats: 2,           // å ç”¨2æ‹ï¼ˆ4/4æ‹ä¸­çš„2ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 2/3,    // æ¯ä¸ªéŸ³ç¬¦2/3æ‹
                preferredPositions: [0, 2], // å¿…é¡»å‡ºç°åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆ1ï¼Œ3æ‹ï¼‰
                description: "å››åˆ†ä¸‰è¿éŸ³ï¼š3ä¸ªå››åˆ†éŸ³ç¬¦å 2æ‹æ—¶å€¼ï¼Œå¿…é¡»åœ¨äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š",
                tupletCount: 3,
                tupletType: 'triplet'
            },
            sixteenth: {
                duration: '16th',         // åå…­åˆ†ä¸‰è¿éŸ³
                totalBeats: 0.5,         // å ç”¨0.5æ‹ï¼ˆåŠä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 1/6,    // æ¯ä¸ªéŸ³ç¬¦1/6æ‹
                preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5], // å¿…é¡»å‡ºç°åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆ1, +, 2, +, 3, +, 4, +ï¼‰
                description: "åå…­åˆ†ä¸‰è¿éŸ³ï¼š3ä¸ªåå…­åˆ†éŸ³ç¬¦å 0.5æ‹æ—¶å€¼ï¼Œå¿…é¡»åœ¨å…«åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Š",
                tupletCount: 3,
                tupletType: 'triplet'
            },

            // ğŸ”¥ é€šç”¨äºŒè¿éŸ³ï¼ˆdupletsï¼‰- é€‚ç”¨äº4/4æ‹ç­‰
            duplet_eighth: {
                duration: 'eighth',       // å…«åˆ†äºŒè¿éŸ³
                totalBeats: 1,           // å ç”¨1æ‹ï¼ˆ4/4æ‹ä¸­çš„1ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 0.5,    // æ¯ä¸ªéŸ³ç¬¦0.5æ‹
                preferredPositions: [0, 1, 2, 3], // å››åˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "å…«åˆ†äºŒè¿éŸ³ï¼š2ä¸ªå…«åˆ†éŸ³ç¬¦å 1æ‹æ—¶å€¼",
                tupletCount: 2,
                tupletType: 'duplet'
            },
            duplet_quarter: {
                duration: 'quarter',      // å››åˆ†äºŒè¿éŸ³
                totalBeats: 2,           // å ç”¨2æ‹ï¼ˆ4/4æ‹ä¸­çš„2ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 1,      // æ¯ä¸ªéŸ³ç¬¦1æ‹
                preferredPositions: [0, 2], // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "å››åˆ†äºŒè¿éŸ³ï¼š2ä¸ªå››åˆ†éŸ³ç¬¦å 2æ‹æ—¶å€¼",
                tupletCount: 2,
                tupletType: 'duplet'
            },
            duplet_sixteenth: {
                duration: '16th',         // åå…­åˆ†äºŒè¿éŸ³
                totalBeats: 0.5,         // å ç”¨0.5æ‹ï¼ˆåŠä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 0.25,   // æ¯ä¸ªéŸ³ç¬¦0.25æ‹
                preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5], // å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "åå…­åˆ†äºŒè¿éŸ³ï¼š2ä¸ªåå…­åˆ†éŸ³ç¬¦å 0.5æ‹æ—¶å€¼",
                tupletCount: 2,
                tupletType: 'duplet'
            },

            // ğŸ”¥ é€šç”¨å››è¿éŸ³ï¼ˆquadrupletsï¼‰- é€‚ç”¨äº4/4æ‹ç­‰
            quadruplet_eighth: {
                duration: 'eighth',       // å…«åˆ†å››è¿éŸ³
                totalBeats: 1,           // å ç”¨1æ‹ï¼ˆ4/4æ‹ä¸­çš„1ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 0.25,   // æ¯ä¸ªéŸ³ç¬¦0.25æ‹
                preferredPositions: [0, 1, 2, 3], // å››åˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "å…«åˆ†å››è¿éŸ³ï¼š4ä¸ªå…«åˆ†éŸ³ç¬¦å 1æ‹æ—¶å€¼",
                tupletCount: 4,
                tupletType: 'quadruplet'
            },
            quadruplet_quarter: {
                duration: 'quarter',      // å››åˆ†å››è¿éŸ³
                totalBeats: 2,           // å ç”¨2æ‹ï¼ˆ4/4æ‹ä¸­çš„2ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 0.5,    // æ¯ä¸ªéŸ³ç¬¦0.5æ‹
                preferredPositions: [0, 2], // äºŒåˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "å››åˆ†å››è¿éŸ³ï¼š4ä¸ªå››åˆ†éŸ³ç¬¦å 2æ‹æ—¶å€¼",
                tupletCount: 4,
                tupletType: 'quadruplet'
            },
            quadruplet_sixteenth: {
                duration: '16th',         // åå…­åˆ†å››è¿éŸ³
                totalBeats: 0.5,         // å ç”¨0.5æ‹ï¼ˆåŠä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
                individualBeats: 0.125,  // æ¯ä¸ªéŸ³ç¬¦0.125æ‹
                preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5], // å…«åˆ†éŸ³ç¬¦æ‹ç‚¹
                description: "åå…­åˆ†å››è¿éŸ³ï¼š4ä¸ªåå…­åˆ†éŸ³ç¬¦å 0.5æ‹æ—¶å€¼",
                tupletCount: 4,
                tupletType: 'quadruplet'
            },

            // 6/8æ‹ä¸“ç”¨ï¼šäºŒè¿éŸ³ï¼ˆdupletsï¼‰
            duplet_eighth_6_8: {
                duration: 'eighth',       // å…«åˆ†äºŒè¿éŸ³
                totalBeats: 1.5,         // å ç”¨1.5æ‹ï¼ˆä¸€ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦çš„æ—¶å€¼ï¼‰
                individualBeats: 0.75,   // æ¯ä¸ªéŸ³ç¬¦0.75æ‹
                preferredPositions: [0, 1.5], // åªèƒ½åœ¨6/8æ‹çš„å¼ºæ‹ä½ç½®
                description: "6/8æ‹å…«åˆ†äºŒè¿éŸ³ï¼š2ä¸ªå…«åˆ†éŸ³ç¬¦å é™„ç‚¹å››åˆ†éŸ³ç¬¦æ—²å€¼ï¼Œåˆ›é€ ç®€å•æ‹å­æ„Ÿè§‰",
                allowedTimeSignatures: ['6/8'],
                tupletCount: 2,
                tupletType: 'duplet'
            },
            
            // 6/8æ‹ä¸“ç”¨ï¼šå››è¿éŸ³ï¼ˆquadrupletsï¼‰
            quadruplet_eighth_6_8: {
                duration: 'eighth',       // å…«åˆ†å››è¿éŸ³
                totalBeats: 1.5,         // å ç”¨1.5æ‹ï¼ˆä¸€ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦çš„æ—¶å€¼ï¼‰
                individualBeats: 0.375,  // æ¯ä¸ªéŸ³ç¬¦0.375æ‹
                preferredPositions: [0, 1.5], // åªèƒ½åœ¨6/8æ‹çš„å¼ºæ‹ä½ç½®
                description: "6/8æ‹å…«åˆ†å››è¿éŸ³ï¼š4ä¸ªå…«åˆ†éŸ³ç¬¦å é™„ç‚¹å››åˆ†éŸ³ç¬¦æ—²å€¼ï¼Œåˆ›é€ å¸¸ç”¨æ‹å­æ„Ÿè§‰",
                allowedTimeSignatures: ['6/8'],
                tupletCount: 4,
                tupletType: 'quadruplet'
            }
        },
        
        // ä½ç½®è§„åˆ™ï¼šä¸‰è¿éŸ³å¿…é¡»å®Œæ•´å ç”¨å…¶å¯¹åº”çš„æ—¶å€¼ç©ºé—´
        placementRules: {
            principle: "ä¸‰è¿éŸ³å¿…é¡»ç‹¬å å…¶æ—¶å€¼ç©ºé—´ï¼Œä¸èƒ½ä¸æ™®é€šéŸ³ç¬¦å…±å­˜åœ¨åŒä¸€æ‹ç‚¹åˆ†å‰²ä¸­",
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦é€‚åˆæ”¾ç½®ä¸‰è¿éŸ³
            canPlaceTriplet: function(position, tripletType, timeSignature, remainingBeats) {
                // ğŸ”¥ ä¿®å¤ï¼šé€šè¿‡getterè®¿é—®TRIPLET_RULES.typesï¼Œæ”¯æŒæ‰€æœ‰è¿éŸ³ç±»å‹
                // è¿™ä¸ªå‡½æ•°åœ¨IntelligentMelodyGeneratorçš„ä¸Šä¸‹æ–‡ä¸­è¢«è°ƒç”¨
                // éœ€è¦é€šè¿‡é€‚å½“çš„è·¯å¾„è®¿é—®types
                const types = {
                    // ä¸‰è¿éŸ³
                    eighth: { totalBeats: 1, preferredPositions: [0, 1, 2, 3] },
                    quarter: { totalBeats: 2, preferredPositions: [0, 2] },
                    sixteenth: { totalBeats: 0.5, preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
                    // ğŸ”¥ æ–°å¢ï¼šäºŒè¿éŸ³
                    duplet_eighth: { totalBeats: 1, preferredPositions: [0, 1, 2, 3] },
                    duplet_quarter: { totalBeats: 2, preferredPositions: [0, 2] },
                    duplet_sixteenth: { totalBeats: 0.5, preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
                    // ğŸ”¥ æ–°å¢ï¼šå››è¿éŸ³
                    quadruplet_eighth: { totalBeats: 1, preferredPositions: [0, 1, 2, 3] },
                    quadruplet_quarter: { totalBeats: 2, preferredPositions: [0, 2] },
                    quadruplet_sixteenth: { totalBeats: 0.5, preferredPositions: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
                    // 6/8æ‹ä¸“ç”¨
                    duplet_eighth_6_8: { totalBeats: 1.5, preferredPositions: [0, 1.5] },
                    quadruplet_eighth_6_8: { totalBeats: 1.5, preferredPositions: [0, 1.5] }
                };
                const tripletInfo = types[tripletType];
                if (!tripletInfo) {
                    console.log(`âŒ æœªçŸ¥çš„è¿éŸ³ç±»å‹: ${tripletType}`);
                    return false;
                }
                const beatsPerMeasure = parseInt(timeSignature.split('/')[0]);
                
                // æ£€æŸ¥å‰©ä½™ç©ºé—´æ˜¯å¦è¶³å¤Ÿ
                if (remainingBeats < tripletInfo.totalBeats) {
                    console.log(`âŒ ç©ºé—´ä¸è¶³: éœ€è¦${tripletInfo.totalBeats}æ‹ï¼Œå‰©ä½™${remainingBeats}æ‹`);
                    return false;
                }
                
                // ç®€åŒ–ä½ç½®æ£€æŸ¥ï¼šåªè¦ä¸æ˜¯æ˜æ˜¾é”™è¯¯çš„ä½ç½®å°±å…è®¸
                const positionInMeasure = position % beatsPerMeasure;
                
                // æ‰€æœ‰ä¸‰è¿éŸ³éƒ½å¿…é¡»éµå¾ªä¸¥æ ¼çš„ä½ç½®è§„åˆ™
                
                // ä¸¥æ ¼çš„ä½ç½®æ£€æŸ¥ï¼šä¸‰è¿éŸ³å¿…é¡»å‡ºç°åœ¨æ­£æ‹ä¸Š
                const tolerance = 0.01; // ä¸¥æ ¼çš„å®¹å·®ï¼Œç¡®ä¿åœ¨æ­£æ‹ä¸Š
                const isPositionAllowed = tripletInfo.preferredPositions.some(allowedPos => 
                    Math.abs(positionInMeasure - allowedPos) < tolerance
                );
                
                if (!isPositionAllowed) {
                    console.log(`âŒ ${tripletType}ä¸‰è¿éŸ³ä½ç½®${positionInMeasure.toFixed(3)}ä¸åœ¨å…è®¸ä½ç½®åˆ—è¡¨${tripletInfo.preferredPositions}ä¸­`);
                    return false;
                } else {
                    console.log(`âœ… ${tripletType}ä¸‰è¿éŸ³å¯åœ¨ä½ç½®${positionInMeasure.toFixed(3)}ç”Ÿæˆ`);
                }
                
                // æ£€æŸ¥ä¸‰è¿éŸ³ç»“æŸä½ç½®æ˜¯å¦è·¨è¶Šä¸åº”è·¨è¶Šçš„è¾¹ç•Œ
                const endPosition = position + tripletInfo.totalBeats;
                const endInMeasure = endPosition % beatsPerMeasure;
                
                // å››åˆ†ä¸‰è¿éŸ³ä¸åº”è·¨è¶Šå°èŠ‚ä¸­å¿ƒçº¿ï¼ˆ4/4æ‹çš„ç¬¬2-3æ‹ä¹‹é—´ï¼‰
                if (tripletType === 'quarter' && timeSignature === '4/4') {
                    if (positionInMeasure < 2 && endInMeasure > 2) {
                        return false; // è·¨è¶Šä¸­å¿ƒçº¿
                    }
                }
                
                return true;
            }
        },
        
        // ä¸‰è¿éŸ³å†…éƒ¨ç»“æ„è§„åˆ™ï¼ˆç®€åŒ–ç‰ˆï¼Œæ”¯æŒä¼‘æ­¢ç¬¦ï¼‰
        internalStructureRules: {
            // ä¸‰è¿éŸ³å¯ä»¥åŒ…å«çš„å…ƒç´ ç±»å‹
            allowedElements: ['note', 'rest'],
            
            // ç®€åŒ–çš„ä¸‰è¿éŸ³å†…éƒ¨æ¨¡å¼ - æ›´é€‚åˆåˆå­¦è€…
            commonPatterns: [
                { pattern: ['note', 'note', 'note'], weight: 0.65, description: "ä¸‰ä¸ªéŸ³ç¬¦" },
                { pattern: ['note', 'note', 'rest'], weight: 0.12, description: "ä¸¤éŸ³ç¬¦+ä¼‘æ­¢ç¬¦" },
                { pattern: ['note', 'rest', 'note'], weight: 0.10, description: "éŸ³ç¬¦+ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                { pattern: ['rest', 'note', 'note'], weight: 0.06, description: "ä¼‘æ­¢ç¬¦+ä¸¤éŸ³ç¬¦" },
                { pattern: ['note', 'rest', 'rest'], weight: 0.03, description: "éŸ³ç¬¦+ä¸¤ä¼‘æ­¢ç¬¦" },
                { pattern: ['rest', 'rest', 'note'], weight: 0.02, description: "ä¸¤ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                { pattern: ['rest', 'note', 'rest'], weight: 0.02, description: "ä¼‘æ­¢ç¬¦+éŸ³ç¬¦+ä¼‘æ­¢ç¬¦" }
            ],
            
            // é€‰æ‹©è¿éŸ³å†…éƒ¨æ¨¡å¼ï¼ˆæ”¯æŒä¸åŒè¿éŸ³ç±»å‹ï¼‰
            selectPattern: function(random, tupletType = 'triplet') {
                let patterns;
                
                // æ ¹æ®è¿éŸ³ç±»å‹é€‰æ‹©é€‚åˆçš„æ¨¡å¼
                switch(tupletType) {
                    case 'duplet':
                        patterns = [
                            { pattern: ['note', 'note'], weight: 0.70, description: "ä¸¤ä¸ªéŸ³ç¬¦" },
                            { pattern: ['note', 'rest'], weight: 0.15, description: "éŸ³ç¬¦+ä¼‘æ­¢ç¬¦" },
                            { pattern: ['rest', 'note'], weight: 0.10, description: "ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                            { pattern: ['rest', 'rest'], weight: 0.05, description: "ä¸¤ä¸ªä¼‘æ­¢ç¬¦" }
                        ];
                        break;
                    case 'quadruplet':
                        patterns = [
                            { pattern: ['note', 'note', 'note', 'note'], weight: 0.50, description: "å››ä¸ªéŸ³ç¬¦" },
                            { pattern: ['note', 'rest', 'note', 'note'], weight: 0.15, description: "éŸ³ç¬¦+ä¼‘æ­¢ç¬¦+ä¸¤éŸ³ç¬¦" },
                            { pattern: ['note', 'note', 'rest', 'note'], weight: 0.12, description: "ä¸¤éŸ³ç¬¦+ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                            { pattern: ['note', 'note', 'note', 'rest'], weight: 0.08, description: "ä¸‰éŸ³ç¬¦+ä¼‘æ­¢ç¬¦" },
                            { pattern: ['rest', 'note', 'note', 'note'], weight: 0.06, description: "ä¼‘æ­¢ç¬¦+ä¸‰éŸ³ç¬¦" },
                            { pattern: ['note', 'rest', 'rest', 'note'], weight: 0.04, description: "éŸ³ç¬¦+ä¸¤ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                            { pattern: ['rest', 'note', 'rest', 'note'], weight: 0.03, description: "ä¼‘æ­¢ç¬¦+éŸ³ç¬¦+ä¼‘æ­¢ç¬¦+éŸ³ç¬¦" },
                            { pattern: ['note', 'rest', 'note', 'rest'], weight: 0.02, description: "éŸ³ç¬¦+ä¼‘æ­¢ç¬¦+éŸ³ç¬¦+ä¼‘æ­¢ç¬¦" }
                        ];
                        break;
                    case 'triplet':
                    default:
                        patterns = this.commonPatterns; // ä½¿ç”¨ä¼ ç»Ÿä¸‰è¿éŸ³æ¨¡å¼
                        break;
                }
                
                const totalWeight = patterns.reduce((sum, p) => sum + p.weight, 0);
                const randomValue = random.nextFloat() * totalWeight;
                
                let currentWeight = 0;
                for (const pattern of patterns) {
                    currentWeight += pattern.weight;
                    if (randomValue <= currentWeight) {
                        return pattern;
                    }
                }
                
                return patterns[0]; // é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ªæ¨¡å¼
            }
        }
        };
    }

    /**
     * è®¡ç®—ä¸‰è¿éŸ³ç¬¦æ è¿æ¥ä¿¡æ¯
     * ä¼‘æ­¢ç¬¦ä¼šæ‰“æ–­ç¬¦æ è¿æ¥ï¼Œåªè¿æ¥è¿ç»­çš„éŸ³ç¬¦æ®µ
     */
    calculateTripletBeamConnections(tripletElements, duration) {
        // åªå¤„ç†éœ€è¦ç¬¦æ çš„éŸ³ç¬¦ï¼ˆå…«åˆ†éŸ³ç¬¦åŠæ›´å°æ—¶å€¼ï¼‰
        if (!['eighth', '16th', '32nd'].includes(duration)) {
            return;
        }
        
        console.log(`ğŸµ ä¸‰è¿éŸ³ç¬¦æ è®¡ç®—: æ¨¡å¼=[${tripletElements.map(e => e.type).join(', ')}]`);
        
        // å°†ä¸‰è¿éŸ³åˆ†æˆç”±ä¼‘æ­¢ç¬¦åˆ†éš”çš„è¿ç»­éŸ³ç¬¦æ®µ
        const noteGroups = [];
        let currentGroup = [];
        
        tripletElements.forEach((element, index) => {
            if (element.type === 'note') {
                // éŸ³ç¬¦ï¼šæ·»åŠ åˆ°å½“å‰ç»„
                currentGroup.push(index);
            } else {
                // ä¼‘æ­¢ç¬¦ï¼šç»“æŸå½“å‰ç»„ï¼ˆå¦‚æœæœ‰éŸ³ç¬¦çš„è¯ï¼‰ï¼Œå¼€å§‹æ–°ç»„
                if (currentGroup.length > 0) {
                    noteGroups.push([...currentGroup]);
                    currentGroup = [];
                }
            }
        });
        
        // å¤„ç†æœ€åä¸€ç»„
        if (currentGroup.length > 0) {
            noteGroups.push(currentGroup);
        }
        
        console.log(`  è¿ç»­éŸ³ç¬¦ç»„: ${noteGroups.map(group => `[${group.join(',')}]`).join(' ')}`);
        
        // ä¸ºæ¯ä¸ªè¿ç»­éŸ³ç¬¦ç»„è®¾ç½®ç¬¦æ è¿æ¥
        noteGroups.forEach((group, groupIndex) => {
            if (group.length === 1) {
                // å•ä¸ªéŸ³ç¬¦ï¼šæ— ç¬¦æ è¿æ¥
                const noteIndex = group[0];
                tripletElements[noteIndex].tripletBeamInfo = null;
                console.log(`  ç»„${groupIndex + 1}ä½ç½®${noteIndex}: å•ç‹¬éŸ³ç¬¦ï¼Œæ— ç¬¦æ è¿æ¥`);
            } else if (group.length >= 2) {
                // å¤šä¸ªéŸ³ç¬¦ï¼šè¿æ¥ç¬¦æ 
                group.forEach((noteIndex, posInGroup) => {
                    if (posInGroup === 0) {
                        tripletElements[noteIndex].tripletBeamInfo = 'begin';
                        console.log(`  ç»„${groupIndex + 1}ä½ç½®${noteIndex}: begin`);
                    } else if (posInGroup === group.length - 1) {
                        tripletElements[noteIndex].tripletBeamInfo = 'end';
                        console.log(`  ç»„${groupIndex + 1}ä½ç½®${noteIndex}: end`);
                    } else {
                        tripletElements[noteIndex].tripletBeamInfo = 'continue';
                        console.log(`  ç»„${groupIndex + 1}ä½ç½®${noteIndex}: continue`);
                    }
                });
            }
        });
    }

    /**
     * ç”Ÿæˆå”¯ä¸€çš„ä¸‰è¿éŸ³IDï¼ˆé¿å…ç›¸é‚»ä¸‰è¿éŸ³æ‹¬å¼§é‡å ï¼‰
     */
    generateTripletId() {
        if (!this.tripletIdCounter) {
            this.tripletIdCounter = 0;
        }
        return ++this.tripletIdCounter;
    }

    /**
     * æ”¹è¿›çš„ä¸‰è¿éŸ³ç”Ÿæˆå‡½æ•° - åŸºäºéŸ³ä¹ç†è®ºè§„åˆ™
     */
    generateTriplet(currentMidi, currentDirection, remainingBeats = null, currentPosition = 0, measureIndex = null) {
        const timeSignature = this.rules.timeSignature || '4/4';
        
        // æ­¥éª¤1: é€‰æ‹©åˆé€‚çš„ä¸‰è¿éŸ³ç±»å‹
        const tripletType = this.selectTripletType(remainingBeats, currentPosition, timeSignature);
        if (!tripletType) {
            console.log('âŒ æ— æ³•åœ¨å½“å‰ä½ç½®æ”¾ç½®ä¸‰è¿éŸ³');
            return null;
        }
        
        const tripletInfo = this.TRIPLET_RULES.types[tripletType];
        console.log(`ğŸµ ç”Ÿæˆ${tripletInfo.description} @ ä½ç½®${currentPosition}, å‰©ä½™${remainingBeats}æ‹`);
        
        // æ­¥éª¤2: é€‰æ‹©è¿éŸ³å†…éƒ¨ç»“æ„æ¨¡å¼ï¼ˆæ”¯æŒä¸åŒè¿éŸ³ç±»å‹ï¼‰
        const pattern = this.TRIPLET_RULES.internalStructureRules.selectPattern(this.random, tripletInfo.tupletType || 'triplet');
        console.log(`   æ¨¡å¼: ${pattern.description} [${pattern.pattern.join(', ')}]`);
        
        // æ­¥éª¤3: ç”Ÿæˆä¸‰è¿éŸ³å…ƒç´ 
        const tripletElements = [];
        let lastMidi = currentMidi;
        let lastDirection = currentDirection;
        
        const tupletCount = tripletInfo.tupletCount || 3; // æ”¯æŒä¸åŒè¿éŸ³æ•°é‡
        for (let i = 0; i < tupletCount; i++) {
            const elementType = pattern.pattern[i % pattern.pattern.length]; // å¾ªç¯ä½¿ç”¨æ¨¡å¼
            
            if (elementType === 'note') {
                // ç”ŸæˆéŸ³ç¬¦
                let nextMidi;
                try {
                    // ä¸‰è¿éŸ³ä¸­çš„éŸ³ç¬¦ä¸Šä¸‹æ–‡
                    const tripletContext = {
                        isMeasureStart: false,
                        isMeasureEnd: false,
                        isPhrasEnd: false,
                        isCadence: false,
                        inTriplet: true,
                        measureIndex: typeof measureIndex === 'number' ? measureIndex : null,
                        totalMeasures: this.measures
                    };
                    nextMidi = this.generateNextNote(lastMidi, lastDirection, 0, false, tripletContext);
                } catch (error) {
                    console.error(`ä¸‰è¿éŸ³éŸ³ç¬¦ç”Ÿæˆå¤±è´¥: ${error.message}`);
                    nextMidi = lastMidi !== null ? lastMidi + (lastDirection || 1) * 2 : 60;
                    nextMidi = Math.max(this.rules.range.min, Math.min(this.rules.range.max, nextMidi));
                }
                
                let preferredAccidental = this.consumeAccidentalPreference(nextMidi);
                if (typeof lastMidi === 'number' && Math.abs(nextMidi - lastMidi) === 1) {
                    const directionPreference = nextMidi > lastMidi ? '#' : 'b';
                    if (!preferredAccidental || preferredAccidental !== directionPreference) {
                        preferredAccidental = directionPreference;
                    }
                }
                const { step, octave, alter } = this.midiToMusicXML(nextMidi, preferredAccidental);
                
                tripletElements.push({
                    type: 'note',
                    duration: tripletInfo.duration,
                    beats: tripletInfo.individualBeats,
                    step: step,
                    octave: octave,
                    alter: alter,
                    midi: nextMidi,
                    isTriplet: true,
                    tripletType: tripletType,
                    tripletPosition: i, // 0=begin, 1=continue, 2=end, etc.
                    tripletTotal: tupletCount
                });
                
                // æ›´æ–°æ–¹å‘å’ŒéŸ³é«˜
                if (lastMidi !== null) {
                    const interval = nextMidi - lastMidi;
                    lastDirection = interval > 0 ? 1 : (interval < 0 ? -1 : 0);
                }
                lastMidi = nextMidi;
                
            } else if (elementType === 'rest') {
                // ç”Ÿæˆä¼‘æ­¢ç¬¦
                tripletElements.push({
                    type: 'rest',
                    duration: tripletInfo.duration,
                    beats: tripletInfo.individualBeats,
                    isTriplet: true,
                    tripletType: tripletType,
                    tripletPosition: i,
                    tripletTotal: tupletCount
                });
            }
        }
        
        // ğŸµ æ­¥éª¤4: ä¸ºä¸‰è¿éŸ³åˆ†é…å”¯ä¸€IDï¼ˆé¿å…ç›¸é‚»ä¸‰è¿éŸ³æ‹¬å¼§é‡å ï¼‰
        const tripletId = this.generateTripletId();
        tripletElements.forEach(element => {
            element.tripletId = tripletId;
        });
        
        // ğŸµ æ­¥éª¤5: æ ¹æ®ä¼‘æ­¢ç¬¦ä½ç½®è®¡ç®—ç¬¦æ è¿æ¥ä¿¡æ¯
        this.calculateTripletBeamConnections(tripletElements, tripletInfo.duration);
        
        // éªŒè¯ä¸‰è¿éŸ³æ—¶å€¼
        const calculatedBeats = tripletElements.reduce((sum, element) => sum + element.beats, 0);
        if (Math.abs(calculatedBeats - tripletInfo.totalBeats) > 0.01) {
            console.error(`âš ï¸ ä¸‰è¿éŸ³æ—¶å€¼ä¸åŒ¹é…: æœŸæœ›${tripletInfo.totalBeats}æ‹, å®é™…${calculatedBeats}æ‹`);
        }
        
        console.log(`âœ… ä¸‰è¿éŸ³ç”Ÿæˆå®Œæˆ: ${tripletElements.length}ä¸ªå…ƒç´ , æ€»æ—¶å€¼${tripletInfo.totalBeats}æ‹`);
        
        return {
            notes: tripletElements,
            totalBeats: tripletInfo.totalBeats,
            lastMidi: lastMidi,
            lastDirection: lastDirection,
            type: tripletType
        };
    }
    
    /**
     * é€‰æ‹©åˆé€‚çš„ä¸‰è¿éŸ³ç±»å‹
     */
    selectTripletType(remainingBeats, currentPosition, timeSignature) {
        const availableTypes = [];
        
        console.log(`ğŸ” é€‰æ‹©ä¸‰è¿éŸ³ç±»å‹: å‰©ä½™${remainingBeats}æ‹, ä½ç½®${currentPosition}, æ‹å·${timeSignature}`);
        const isCustomTimeSignature = !isBuiltInTimeSignature(timeSignature);
        const isCompoundCustom = isCustomTimeSignature && isCompoundTimeSignature(timeSignature);
        const isSimpleCustom = isCustomTimeSignature && !isCompoundCustom;
        const tupletGroupTolerance = 0.0001;
        const parsedTimeSignature = isCustomTimeSignature ? parseTimeSignatureString(timeSignature) : null;
        const groupUnit = parsedTimeSignature ? (4 / parsedTimeSignature.beatType) : null;
        const groupSize = (parsedTimeSignature && groupUnit)
            ? (groupUnit * (isCompoundCustom ? 3 : 1))
            : null;
        
        // æ£€æŸ¥æ¯ç§è¿éŸ³ç±»å‹æ˜¯å¦å¯ä»¥ä½¿ç”¨
        for (const [typeName, typeInfo] of Object.entries(this.TRIPLET_RULES.types)) {
            // æ£€æŸ¥æ˜¯å¦ä¸º6/8æ‹ä¸“ç”¨è¿éŸ³ç±»å‹
            if (typeInfo.allowedTimeSignatures && !typeInfo.allowedTimeSignatures.includes(timeSignature)) {
                console.log(`   æ£€æŸ¥${typeName}: âŒä¸å…è®¸åœ¨${timeSignature}æ‹ä¸­ä½¿ç”¨`);
                continue;
            }
            // ğŸ”¥ è‡ªå®šä¹‰æ‹å·ä¸¥æ ¼é™åˆ¶è¿éŸ³ç±»å‹ï¼šå•æ‹å­ä»…ä¸‰è¿éŸ³ï¼Œå¤æ‹å­ä»…äºŒ/å››è¿éŸ³
            if (isCustomTimeSignature) {
                if (isSimpleCustom && typeInfo.tupletType !== 'triplet') {
                    console.log(`   æ£€æŸ¥${typeName}: âŒè‡ªå®šä¹‰å•æ‹å­ç¦æ­¢äºŒ/å››è¿éŸ³`);
                    continue;
                }
                if (isCompoundCustom && !(typeInfo.tupletType === 'duplet' || typeInfo.tupletType === 'quadruplet')) {
                    console.log(`   æ£€æŸ¥${typeName}: âŒè‡ªå®šä¹‰å¤æ‹å­ç¦æ­¢ä¸‰è¿éŸ³`);
                    continue;
                }
            }

            if (typeInfo.tupletType === 'triplet' &&
                typeInfo.duration === '16th' &&
                this.rules.allowedDurations.includes('16th') &&
                this.rules.allowedDurations.includes('triplet')) {
                console.log(`   æ£€æŸ¥${typeName}: âŒç”¨æˆ·åŒæ—¶å¯ç”¨16åˆ†éŸ³ç¬¦ä¸ä¸‰è¿éŸ³ï¼Œç¦ç”¨16åˆ†ä¸‰è¿éŸ³`);
                continue;
            }
            
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ç”¨äº†å¯¹åº”çš„åŸºç¡€éŸ³ç¬¦ç±»å‹
            const baseNoteType = typeInfo.duration; // 'eighth', 'quarter', '16th'
            const isNoteTypeAllowed = this.rules.allowedDurations.includes(baseNoteType);
            
            if (!isNoteTypeAllowed) {
                console.log(`   æ£€æŸ¥${typeName}: âŒè¢«ç¦ç”¨ (åŸºç¡€éŸ³ç¬¦${baseNoteType}æœªå¯ç”¨)`);
                continue;
            }
            
            const canPlace = this.TRIPLET_RULES.placementRules.canPlaceTriplet(
                currentPosition, 
                typeName, 
                timeSignature, 
                remainingBeats
            );
            
            console.log(`   æ£€æŸ¥${typeName}: ${canPlace ? 'âœ…å¯ç”¨' : 'âŒä¸å¯ç”¨'} (éœ€è¦${typeInfo.totalBeats}æ‹, åŸºç¡€éŸ³ç¬¦${baseNoteType}å·²å¯ç”¨)`);
            
            if (canPlace) {
                // ğŸ”¥ è‡ªå®šä¹‰æ‹å·ï¼šè¿éŸ³å¿…é¡»å®Œæ•´è½åœ¨åˆ†ç»„è¾¹ç•Œå†…ï¼ˆé˜²æ­¢è·¨æ‹ç‚¹ï¼‰
                if (isCustomTimeSignature && groupSize && Number.isFinite(groupSize)) {
                    const localPos = ((currentPosition % groupSize) + groupSize) % groupSize;
                    if (localPos + typeInfo.totalBeats > groupSize + tupletGroupTolerance) {
                        console.log(`   æ£€æŸ¥${typeName}: âŒè‡ªå®šä¹‰æ‹å·è¿éŸ³è·¨è¶Šåˆ†ç»„è¾¹ç•Œ (ä½ç½®${localPos.toFixed(3)} + ${typeInfo.totalBeats} > ${groupSize})`);
                        continue;
                    }
                }
                const weight = this.calculateTripletTypeWeight(typeName, remainingBeats, currentPosition, timeSignature);
                availableTypes.push({
                    name: typeName,
                    info: typeInfo,
                    weight: weight
                });
                console.log(`     æƒé‡: ${weight.toFixed(2)}`);
            }
        }
        
        if (availableTypes.length === 0) {
            console.log(`âŒ æ²¡æœ‰å¯ç”¨çš„ä¸‰è¿éŸ³ç±»å‹ï¼`);
            return null; // æ²¡æœ‰å¯ç”¨çš„ä¸‰è¿éŸ³ç±»å‹
        }
        
        console.log(`âœ… æ‰¾åˆ°${availableTypes.length}ç§å¯ç”¨ä¸‰è¿éŸ³ç±»å‹`);
        
        // æ ¹æ®æƒé‡éšæœºé€‰æ‹©
        const totalWeight = availableTypes.reduce((sum, type) => sum + type.weight, 0);
        const randomValue = this.random.nextFloat() * totalWeight;
        
        let currentWeight = 0;
        for (const type of availableTypes) {
            currentWeight += type.weight;
            if (randomValue <= currentWeight) {
                console.log(`   é€‰æ‹©ä¸‰è¿éŸ³ç±»å‹: ${type.name} (æƒé‡: ${type.weight.toFixed(2)})`);
                return type.name;
            }
        }
        
        return availableTypes[0].name; // é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨ç±»å‹
    }
    
    /**
     * è®¡ç®—ä¸‰è¿éŸ³ç±»å‹çš„æƒé‡
     */
    calculateTripletTypeWeight(typeName, remainingBeats, currentPosition, timeSignature) {
        const typeInfo = this.TRIPLET_RULES.types[typeName];
        let weight = 1.0;
        
        // åŸºç¡€æƒé‡ï¼šå…«åˆ†ä¸‰è¿éŸ³æœ€å¸¸è§
        if (typeName === 'eighth') weight = 3.0;
        else if (typeName === 'quarter') weight = 1.5;
        else if (typeName === 'sixteenth') weight = 0.8;
        // ğŸ”¥ æ–°å¢ï¼šäºŒè¿éŸ³å’Œå››è¿éŸ³æƒé‡
        else if (typeName === 'duplet_eighth') weight = 2.0;
        else if (typeName === 'duplet_quarter') weight = 1.2;
        else if (typeName === 'duplet_sixteenth') weight = 0.6;
        else if (typeName === 'quadruplet_eighth') weight = 1.8;
        else if (typeName === 'quadruplet_quarter') weight = 1.0;
        else if (typeName === 'quadruplet_sixteenth') weight = 0.5;
        // 6/8æ‹ä¸“ç”¨ç±»å‹
        else if (typeName === 'duplet_eighth_6_8') weight = 2.0;
        else if (typeName === 'quadruplet_eighth_6_8') weight = 1.8;
        
        // ä½ç½®æƒé‡ï¼šå¼ºæ‹ä½ç½®æ›´é€‚åˆè¾ƒé•¿çš„ä¸‰è¿éŸ³
        const beatsPerMeasure = parseInt(timeSignature.split('/')[0]);
        const positionInMeasure = currentPosition % beatsPerMeasure;
        
        if (typeName === 'quarter' && [0, 2].includes(positionInMeasure)) {
            weight *= 1.5; // å››åˆ†ä¸‰è¿éŸ³åœ¨å¼ºæ‹ä½ç½®åŠ æƒ
        }
        
        // ç©ºé—´æƒé‡ï¼šå‰©ä½™ç©ºé—´å½±å“é€‰æ‹©
        const spaceRatio = remainingBeats / typeInfo.totalBeats;
        if (spaceRatio >= 2) weight *= 1.2; // å……è¶³ç©ºé—´åŠ æƒ
        else if (spaceRatio < 1.2) weight *= 0.7; // ç©ºé—´ç´§å¼ é™æƒ
        
        return weight;
    }

    /**
     * æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦åœ¨è°ƒå†…
     */
    isInScale(midi) {
        const pitchClass = midi % 12;
        return Array.isArray(this.scale) && this.scale.includes(pitchClass);
    }

    /**
     * è®¡ç®—æ–¹å‘å˜åŒ–æ¬¡æ•°
     */
    countDirectionChanges(notes) {
        let changes = 0;
        let lastMidi = null;
        let lastDirection = 0;
        
        for (const note of notes) {
            if (note.type === 'note' && note.midi !== undefined) {
                if (lastMidi !== null) {
                    const interval = note.midi - lastMidi;
                    const direction = interval > 0 ? 1 : (interval < 0 ? -1 : 0);
                    
                    if (direction !== lastDirection && direction !== 0 && lastDirection !== 0) {
                        changes++;
                    }
                    
                    lastDirection = direction;
                }
                lastMidi = note.midi;
            }
        }
        
        return changes;
    }

    /**
     * è·å–å°èŠ‚ä¸­æœ€åä¸€ä¸ªéŸ³ç¬¦
     */
    getLastNote(notes) {
        for (let i = notes.length - 1; i >= 0; i--) {
            if (notes[i].type === 'note') {
                return notes[i];
            }
        }
        return null;
    }

    /**
     * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
     */
    updateStats(measureData) {
        for (const note of measureData.notes) {
            if (note.type === 'note') {
                this.stats.noteCount++;
                if (note.midi !== undefined) {
                    this.stats.minMidi = Math.min(this.stats.minMidi, note.midi);
                    this.stats.maxMidi = Math.max(this.stats.maxMidi, note.midi);
                }
            } else {
                this.stats.restCount++;
            }
        }
        
        this.stats.beamCount += measureData.beams.length;
        
        // è®¡ç®—æœ€å¤§è·³è¿›
        let lastMidi = null;
        for (const note of measureData.notes) {
            if (note.type === 'note' && note.midi !== undefined) {
                if (lastMidi !== null) {
                    const interval = Math.abs(note.midi - lastMidi);
                    this.stats.maxInterval = Math.max(this.stats.maxInterval, interval);
                }
                lastMidi = note.midi;
            }
        }
    }

    /**
     * æ—¶å€¼è½¬æ‹æ•°
     */
    durationToBeats(duration) {
        const map = {
            'whole': 4,
            'half': 2,
            'half.': 3,           // äºŒåˆ†é™„ç‚¹éŸ³ç¬¦ = 3æ‹
            'quarter': 1,
            'quarter.': 1.5,      // å››åˆ†é™„ç‚¹éŸ³ç¬¦ = 1.5æ‹
            'eighth': 0.5,
            'eighth.': 0.75,      // å…«åˆ†é™„ç‚¹éŸ³ç¬¦ = 0.75æ‹
            '16th': 0.25,
            '32nd': 0.125
        };
        
        // æ ¹æ®æ‹å·è°ƒæ•´
        if (this.timeSignature === '6/8') {
            return map[duration] || 1;
        }
        
        return map[duration] || 1;
    }

    /**
     * æ‹æ•°è½¬æ—¶å€¼
     */
    beatsToNoteDuration(beats) {
        // å¤„ç†ä¸‰è¿éŸ³çš„ç‰¹æ®Šbeatså€¼
        const tolerance = 0.01; // æµ®ç‚¹æ•°å®¹å·®

        // ä¸‰è¿éŸ³ç‰¹æ®Šå€¼æ£€æµ‹
        if (Math.abs(beats - 2/3) < tolerance) {
            console.log(`ğŸµ æ£€æµ‹åˆ°å››åˆ†ä¸‰è¿éŸ³æ‹æ•°: ${beats} â‰ˆ ${2/3}`);
            return 'quarter';
        }
        if (Math.abs(beats - 1/3) < tolerance) {
            console.log(`ğŸµ æ£€æµ‹åˆ°å…«åˆ†ä¸‰è¿éŸ³æ‹æ•°: ${beats} â‰ˆ ${1/3}`);
            return 'eighth';
        }
        if (Math.abs(beats - 1/6) < tolerance) {
            console.log(`ğŸµ æ£€æµ‹åˆ°åå…­åˆ†ä¸‰è¿éŸ³æ‹æ•°: ${beats} â‰ˆ ${1/6}`);
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ç”¨äº†16åˆ†éŸ³ç¬¦
            if (!this.rules.allowedDurations.includes('16th')) {
                console.log(`âš ï¸ åå…­åˆ†ä¸‰è¿éŸ³è¢«ç¦ç”¨ï¼Œæ”¹ç”¨å…«åˆ†éŸ³ç¬¦`);
                return 'eighth';
            }
            return '16th';
        }

        // ğŸ”¥ é™„ç‚¹å…«åˆ†éŸ³ç¬¦ç²¾ç¡®å¤„ç†ï¼šæ£€æµ‹å¸¸è§çš„åˆ†æ•°æ‹å¹¶è¿”å›æœ€æ¥è¿‘çš„æ ‡å‡†æ—¶å€¼
        const preciseTolerances = [
            { beats: 3.25, duration: 'half.' },     // 3.25æ‹æ¥è¿‘3æ‹ï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼‰
            { beats: 2.5, duration: 'half' },       // 2.5æ‹æ¥è¿‘2æ‹ï¼ˆäºŒåˆ†éŸ³ç¬¦ï¼‰
            { beats: 1.75, duration: 'quarter.' },  // 1.75æ‹æ¥è¿‘1.5æ‹ï¼ˆé™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰
            { beats: 1.25, duration: 'quarter' },   // 1.25æ‹æ¥è¿‘1æ‹ï¼ˆå››åˆ†éŸ³ç¬¦ï¼‰
            { beats: 0.875, duration: 'eighth.' },  // 0.875æ‹æ¥è¿‘0.75æ‹ï¼ˆé™„ç‚¹å…«åˆ†éŸ³ç¬¦ï¼‰
            { beats: 0.625, duration: 'eighth' },   // 0.625æ‹æ¥è¿‘0.5æ‹ï¼ˆå…«åˆ†éŸ³ç¬¦ï¼‰
            { beats: 0.375, duration: '16th' },     // 0.375æ‹æ¥è¿‘0.25æ‹ï¼ˆåå…­åˆ†éŸ³ç¬¦ï¼‰
            { beats: 0.125, duration: '16th' }      // 0.125æ‹ï¼ˆåå…­åˆ†éŸ³ç¬¦ï¼‰
        ];

        // æ£€æŸ¥æ˜¯å¦åŒ¹é…ç²¾ç¡®åˆ†æ•°æ‹
        for (const precise of preciseTolerances) {
            if (Math.abs(beats - precise.beats) < tolerance) {
                console.log(`ğŸ”§ [ç²¾ç¡®ä¿®å¤] åˆ†æ•°æ‹${beats}æ‹ -> ${precise.duration}(${this.durationToBeats(precise.duration)}æ‹)`);
                // ç¡®ä¿è¿”å›çš„æ—¶å€¼åœ¨ç”¨æˆ·å…è®¸çš„èŒƒå›´å†…
                if (precise.duration === '16th' && !this.rules.allowedDurations.includes('16th')) {
                    console.log(`âš ï¸ 16åˆ†éŸ³ç¬¦è¢«ç¦ç”¨ï¼Œæ”¹ç”¨å…«åˆ†éŸ³ç¬¦ä»£æ›¿${beats}æ‹`);
                    return 'eighth';
                }
                return precise.duration;
            }
        }

        // æ ‡å‡†æ—¶å€¼ - æ£€æŸ¥ç”¨æˆ·è®¾ç½®
        if (beats >= 4) return 'whole';
        if (beats >= 3) return 'half.';      // ğŸ”¥ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ - 3æ‹
        if (beats >= 2) return 'half';
        if (beats >= 1.5) return 'quarter.';
        if (beats >= 1) return 'quarter';
        if (beats >= 0.75) return 'eighth.';
        if (beats >= 0.5) return 'eighth';
        if (beats >= 0.25) {
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ç”¨äº†16åˆ†éŸ³ç¬¦
            if (this.rules.allowedDurations.includes('16th')) {
                return '16th';
            } else {
                console.log(`âš ï¸ 16åˆ†éŸ³ç¬¦è¢«ç¦ç”¨ï¼Œæ”¹ç”¨å…«åˆ†éŸ³ç¬¦ä»£æ›¿${beats}æ‹`);
                return 'eighth';
            }
        }

        console.warn(`âš ï¸ æå°æ‹æ•°å€¼ ${beats}ï¼Œè¿”å›å…è®¸çš„æœ€å°æ—¶å€¼`);
        // è¿”å›ç”¨æˆ·å…è®¸çš„æœ€å°æ—¶å€¼
        if (this.rules.allowedDurations.includes('16th')) return '16th';
        return 'eighth';
    }

    /**
     * æ™ºèƒ½æ‹†åˆ†åˆ†æ•°æ‹ä¸ºå¤šä¸ªç²¾ç¡®çš„æ ‡å‡†æ—¶å€¼
     * @param {number} beats - éœ€è¦æ‹†åˆ†çš„æ‹æ•°
     * @returns {Array<number>} - æ‹†åˆ†åçš„æ‹æ•°æ•°ç»„
     */
    splitFractionalBeats(beats) {
        console.log(`ğŸ”§ [åˆ†æ•°æ‹æ‹†åˆ†] å¼€å§‹æ‹†åˆ†${beats}æ‹`);

        const segments = [];
        let remaining = beats;
        const tolerance = 0.001;

        // å®šä¹‰æ ‡å‡†æ—¶å€¼çš„æ‹æ•°ï¼ˆä»å¤§åˆ°å°æ’åºï¼‰
        const standardBeats = [
            4,     // whole
            3,     // half.
            2,     // half
            1.5,   // quarter.
            1,     // quarter
            0.75,  // eighth.
            0.5,   // eighth
            0.25,  // 16th
            0.125  // 32nd
        ];

        // è´ªå¿ƒç®—æ³•ï¼šå°½é‡ä½¿ç”¨å¤§çš„æ—¶å€¼
        while (remaining > tolerance) {
            let foundMatch = false;

            for (const beatValue of standardBeats) {
                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…è®¸è¿™ä¸ªæ—¶å€¼
                const duration = this.beatsToNoteDuration(beatValue);
                if (beatValue === 0.25 && !this.rules.allowedDurations.includes('16th')) {
                    continue; // è·³è¿‡16åˆ†éŸ³ç¬¦å¦‚æœç”¨æˆ·ä¸å…è®¸
                }

                if (remaining >= beatValue - tolerance) {
                    segments.push(beatValue);
                    remaining -= beatValue;
                    console.log(`  âœ… æ·»åŠ ${beatValue}æ‹æ®µï¼Œå‰©ä½™${remaining.toFixed(3)}æ‹`);
                    foundMatch = true;
                    break;
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ ‡å‡†æ—¶å€¼ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ€å°å…è®¸çš„æ—¶å€¼
            if (!foundMatch) {
                const minBeat = this.rules.allowedDurations.includes('16th') ? 0.25 : 0.5;
                if (remaining > tolerance) {
                    segments.push(minBeat);
                    remaining -= minBeat;
                    console.log(`  âš ï¸ å¼ºåˆ¶æ·»åŠ æœ€å°æ—¶å€¼${minBeat}æ‹ï¼Œå‰©ä½™${remaining.toFixed(3)}æ‹`);
                } else {
                    break; // å‰©ä½™æ‹æ•°å¤ªå°ï¼Œå¿½ç•¥
                }
            }

            // é˜²æ­¢æ— é™å¾ªç¯
            if (segments.length > 10) {
                console.warn(`âš ï¸ æ‹†åˆ†è¿‡ç¨‹ä¸­æ£€æµ‹åˆ°å¯èƒ½çš„æ— é™å¾ªç¯ï¼Œåœæ­¢æ‹†åˆ†`);
                break;
            }
        }

        console.log(`ğŸ”§ [åˆ†æ•°æ‹æ‹†åˆ†] å®Œæˆï¼š${beats}æ‹ -> [${segments.join(', ')}]æ‹`);
        return segments;
    }

    /**
     * æ‹æ•°è½¬ä¼‘æ­¢ç¬¦æ—¶å€¼
     */
    beatsToRestDuration(beats) {
        // ğŸ”¥ 6/8æ‹ç‰¹æ®Šå¤„ç†ï¼šç¡®ä¿ä¼‘æ­¢ç¬¦ä¹Ÿéµå¾ªæ‹ç‚¹ç»“æ„
        let adjustedBeats = beats;

        if (this.timeSignature === '6/8') {
            // åœ¨6/8æ‹ä¸­ï¼Œä¼‘æ­¢ç¬¦ä¸èƒ½è·¨è¶Šå…³é”®è¾¹ç•Œ
            // å¦‚æœè¶…è¿‡1.5æ‹ï¼Œé™åˆ¶ä¸º1.5æ‹ï¼ˆé™„ç‚¹å››åˆ†éŸ³ç¬¦ä¼‘æ­¢ç¬¦ï¼‰
            if (beats > 1.5 && beats < 3.0) {
                adjustedBeats = 1.5;
                console.log(`âš ï¸ 6/8æ‹ä¼‘æ­¢ç¬¦è°ƒæ•´ï¼š${beats}æ‹ -> ${adjustedBeats}æ‹ï¼ˆé™åˆ¶åˆ°é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰`);
            }
            // å¦‚æœæ˜¯2æ‹ï¼Œåœ¨6/8æ‹ä¸­æ˜¯ä¸åˆæ³•çš„ï¼Œè°ƒæ•´ä¸º1.5æ‹
            else if (Math.abs(beats - 2.0) < 0.01) {
                adjustedBeats = 1.5;
                console.log(`âš ï¸ 6/8æ‹ä¼‘æ­¢ç¬¦è°ƒæ•´ï¼š${beats}æ‹ -> ${adjustedBeats}æ‹ï¼ˆ2æ‹åœ¨6/8æ‹ä¸­ä¸åˆæ³•ï¼‰`);
            }
            // å¦‚æœæ˜¯1æ‹ï¼Œæ£€æŸ¥æ˜¯å¦ä¼šè¿åæ‹ç‚¹ç»“æ„ï¼ˆä¿æŒ1æ‹æ˜¯å¯ä»¥çš„ï¼‰
        }

        const duration = this.beatsToNoteDuration(adjustedBeats);
        console.log(`æ‹æ•°è½¬ä¼‘æ­¢ç¬¦: ${beats}æ‹ -> ${duration}ï¼ˆå®é™…ä½¿ç”¨${adjustedBeats}æ‹ï¼‰`);
        return duration;
    }

    /**
     * æ£€æŸ¥ä¸¤ä¸ªéŸ³ç¬¦æ˜¯å¦æ„æˆäºŒåº¦ï¼ˆ1-2ä¸ªåŠéŸ³ï¼‰
     * hammer-onåªèƒ½ç”¨äºä¸Šè¡ŒäºŒåº¦ï¼Œpull-offåªèƒ½ç”¨äºä¸‹è¡ŒäºŒåº¦
     */
    isSecondInterval(midi1, midi2) {
        // è®¡ç®—éŸ³ç¨‹çš„åŠéŸ³æ•°
        const interval = midi2 - midi1;
        const absInterval = Math.abs(interval);
        
        // äºŒåº¦éŸ³ç¨‹å¿…é¡»æ˜¯1æˆ–2ä¸ªåŠéŸ³
        const isSecond = absInterval === 1 || absInterval === 2;
        
        if (isSecond) {
            console.log(`âœ… äºŒåº¦éŸ³ç¨‹: MIDI ${midi1} -> ${midi2}, é—´éš”${interval}åŠéŸ³`);
        }
        
        return isSecond;
    }

    /**
     * è®¡ç®—éŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘
     * æ ¹æ®éŸ³ç¬¦åœ¨äº”çº¿è°±ä¸Šçš„ä½ç½®å†³å®šç¬¦å¹²æ–¹å‘
     * @param {number|Array} octaveOrNotes - å…«åº¦æ•°æˆ–éŸ³ç¬¦æ•°ç»„
     * @param {string} step - éŸ³ç¬¦åï¼ˆå½“ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å…«åº¦æ•°æ—¶ï¼‰
     * @returns {string} 'up' æˆ– 'down'
     */
    calculateStemDirection(octaveOrNotes, step) {
        // å¦‚æœä¼ å…¥çš„æ˜¯éŸ³ç¬¦æ•°ç»„ï¼ˆç”¨äºbeamç»„ï¼‰
        if (Array.isArray(octaveOrNotes)) {
            const notes = octaveOrNotes;
            // è®¡ç®—ç»„å†…æ‰€æœ‰éŸ³ç¬¦çš„å¹³å‡ä½ç½®
            let totalMidi = 0;
            let count = 0;
            for (const note of notes) {
                if (note.midi) {
                    totalMidi += note.midi;
                    count++;
                }
            }
            if (count === 0) return 'up';
            const avgMidi = totalMidi / count;
            // ä¸­å¤®C (C4) çš„MIDIå€¼æ˜¯60ï¼ŒB4æ˜¯71
            // B4åŠä»¥ä¸‹ç¬¦å¹²å‘ä¸Šï¼ŒC5åŠä»¥ä¸Šç¬¦å¹²å‘ä¸‹
            return avgMidi <= 71 ? 'up' : 'down';
        }
        
        // å¦‚æœä¼ å…¥çš„æ˜¯å•ä¸ªéŸ³ç¬¦çš„å…«åº¦å’ŒéŸ³å
        const octave = octaveOrNotes;
        if (!octave || !step) return 'up';
        
        // è®¡ç®—MIDIå€¼
        const noteToMidi = {
            'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11
        };
        const baseMidi = noteToMidi[step];
        if (baseMidi === undefined) return 'up';
        
        const midi = (octave + 1) * 12 + baseMidi;
        
        // B4 (MIDI 71) åŠä»¥ä¸‹ç¬¦å¹²å‘ä¸Šï¼ŒC5 (MIDI 72) åŠä»¥ä¸Šç¬¦å¹²å‘ä¸‹
        return midi <= 71 ? 'up' : 'down';
    }

    /**
     * ä¸ºéŸ³ç¬¦æ™ºèƒ½é€‰æ‹©articulation
     * åŸºäºéŸ³ä¹ç†è®ºè§„åˆ™ï¼Œæ ¹æ®éŸ³ç¬¦ä½ç½®ã€æ—¶å€¼å’Œæ—‹å¾‹ç‰¹å¾é€‰æ‹©åˆé€‚çš„articulation
     */
    selectArticulation(note, noteIndex, measureNotes, measureIndex, clef) {
        if (!userSettings.articulations.enabled) {
            return null;
        }
        
        const articulations = [];
        const artSettings = userSettings.articulations;
        const allArticulations = [
            ...artSettings.basic,
            ...artSettings.guitar
        ];
        
        if (allArticulations.length === 0) {
            return null;
        }
        
        const isFirstNote = noteIndex === 0;
        const isLastNote = noteIndex === measureNotes.length - 1;
        const isStrongBeat = noteIndex % 2 === 0; // ç®€åŒ–çš„å¼ºæ‹åˆ¤æ–­
        const isWeakBeat = !isStrongBeat;
        
        // è®¡ç®—å‰åéŸ³ç¨‹å…³ç³»ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        let prevInterval = null;
        let nextInterval = null;
        if (noteIndex > 0) {
            prevInterval = note.midi - measureNotes[noteIndex-1].midi;
        }
        if (noteIndex < measureNotes.length - 1) {
            nextInterval = measureNotes[noteIndex+1].midi - note.midi;
        }
        
        // ğŸ”¥ æ£€æŸ¥éŸ³ç¬¦æ˜¯å¦å·²ç»æœ‰slurè¿æ¥
        // å¦‚æœéŸ³ç¬¦å·²ç»æ˜¯slurçš„ä¸€éƒ¨åˆ†ï¼Œåˆ™ä¸åº”è¯¥æ·»åŠ ä»»ä½•å…¶ä»–articulation
        let hasSlurConnection = false;
        
        // æ£€æŸ¥å½“å‰éŸ³ç¬¦æ˜¯å¦æ˜¯å‰ä¸€ä¸ªéŸ³ç¬¦slurçš„ç»“æŸç‚¹
        if (noteIndex > 0) {
            const prevNote = measureNotes[noteIndex - 1];
            if (prevNote && prevNote.articulation &&
                ['hammer-on', 'pull-off', 'glissando'].includes(prevNote.articulation)) {
                hasSlurConnection = true;
                console.log(`ğŸš« éŸ³ç¬¦${noteIndex}å·²å‚ä¸å‰ä¸€ä¸ªéŸ³ç¬¦${prevNote.articulation}çš„åŒéŸ³æŠ€å·§ï¼Œè·³è¿‡articulationé€‰æ‹©`);
            }
        }
        
        // æ£€æŸ¥å½“å‰éŸ³ç¬¦æ˜¯å¦ä¼šäº§ç”Ÿsluråˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„é€»è¾‘å°†åœ¨articulationé€‰æ‹©è¿‡ç¨‹ä¸­å¤„ç†
        const previousNoteHasSlide =
            noteIndex > 0 && isSlideArticulationType(measureNotes[noteIndex - 1]?.articulation);
        
        // === åŸºæœ¬æ¼”å¥æ³•è§„åˆ™ ===
        // ğŸ”¥ ä½¿ç”¨ä¼˜å…ˆçº§ç³»ç»Ÿï¼šä¸€æ—¦é€‰æ‹©äº†ä¸€ä¸ªarticulationï¼Œå°±åœæ­¢æ£€æŸ¥å…¶ä»–
        // ğŸ”¥ å¦‚æœéŸ³ç¬¦å·²ç»æœ‰slurè¿æ¥ï¼Œåˆ™ä¸é€‰æ‹©ä»»ä½•articulation
        
        let selectedArticulation = null;
        
        if (hasSlurConnection) {
            console.log(`ğŸš« è·³è¿‡articulationé€‰æ‹©ï¼šéŸ³ç¬¦${noteIndex}å·²ç»æœ‰slurè¿æ¥`);
            return null;
        }
        
        // ğŸ”¥ é¢„æ£€æŸ¥ï¼šå¦‚æœå½“å‰éŸ³ç¬¦ç¬¦åˆå‰ä»–æŠ€å·§æ¡ä»¶ï¼Œä¼˜å…ˆé€‰æ‹©å‰ä»–æŠ€å·§å¹¶æ’é™¤åŸºæœ¬æ¼”å¥æ³•
        let willSelectGuitarTechnique = false;
        
        if (clef === 'treble' && artSettings.guitar.length > 0 && noteIndex > 0 && !isFirstNote && !isLastNote) {
            const hammerOnAllowed = artSettings.guitar.includes('hammer-on');
            const pullOffAllowed = artSettings.guitar.includes('pull-off');
            const prevNote = measureNotes[noteIndex - 1];
            
            if (prevNote && prevNote.type === 'note' && prevNote.midi) {
                const interval = note.midi - prevNote.midi;
                const isValidHammerOn = (interval === 1 || interval === 2);
                const isValidPullOff = (interval === -1 || interval === -2);
                const prevHasHammerOn = prevNote.articulation === 'hammer-on';
                const prevHasPullOff = prevNote.articulation === 'pull-off';
                
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šé¢„æ£€æŸ¥ä¹Ÿå¿…é¡»åº”ç”¨é¢‘ç‡æ§åˆ¶
                const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, this.random);
                
                if (((hammerOnAllowed && isValidHammerOn && !prevHasHammerOn) || 
                     (pullOffAllowed && isValidPullOff && !prevHasPullOff)) && shouldGenerateSlur) {
                    willSelectGuitarTechnique = true;
                    console.log(`ğŸ¸ é¢„æ£€æŸ¥ï¼šéŸ³ç¬¦${noteIndex}å°†é€‰æ‹©å‰ä»–æŠ€å·§ï¼Œè·³è¿‡åŸºæœ¬æ¼”å¥æ³•æ£€æŸ¥ (é¢‘ç‡æ§åˆ¶é€šè¿‡)`);
                } else if ((hammerOnAllowed && isValidHammerOn && !prevHasHammerOn) || 
                          (pullOffAllowed && isValidPullOff && !prevHasPullOff)) {
                    console.log(`ğŸ¸ é¢„æ£€æŸ¥ï¼šéŸ³ç¬¦${noteIndex}å‰ä»–æŠ€å·§è¢«é¢‘ç‡æ§åˆ¶é˜»æ­¢ (é¢‘ç‡æ§åˆ¶æœªé€šè¿‡)`);
                }
            }
        }
        
        // Staccatoï¼ˆæ–­éŸ³ï¼‰- ç»è¿‡éŸ³ã€å¼±æ‹ã€å¿«é€ŸéŸ³å‹ (ä¼˜å…ˆçº§è¾ƒä½)
        if (!selectedArticulation && !willSelectGuitarTechnique && artSettings.basic.includes('staccato')) {
            // ğŸ”¥ ä½¿ç”¨æ–°çš„ç²¾å‡†é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
            if (shouldGenerateArticulation('staccato', this.random)) {
                const isPassingNote = noteIndex > 0 && noteIndex < measureNotes.length - 1 &&
                                     Math.abs(prevInterval) <= 2 && Math.abs(nextInterval) <= 2;
                const isFastNote = ['eighth', '16th'].includes(note.duration);
                
                // åªåœ¨åˆé€‚çš„éŸ³ä¹ä¸Šä¸‹æ–‡ä¸­ç”Ÿæˆstaccato
                if (isPassingNote || (isWeakBeat && isFastNote) || isLastNote) {
                    selectedArticulation = 'staccato';
                    console.log(`âœ… é€‰æ‹©åŸºæœ¬æ¼”å¥æ³•: staccato`);
                }
            }
        }
        
        // Accentï¼ˆé‡éŸ³ï¼‰- èµ·å§‹éŸ³ã€å¼ºæ‹ã€è½¬æŠ˜ç‚¹ã€é•¿éŸ³å‰ (ä¼˜å…ˆçº§ä¸­ç­‰)
        if (!selectedArticulation && !willSelectGuitarTechnique && artSettings.basic.includes('accent')) {
            // ğŸ”¥ ä½¿ç”¨æ–°çš„ç²¾å‡†é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
            if (shouldGenerateArticulation('accent', this.random)) {
                const isMelodyTurningPoint = prevInterval && nextInterval && 
                                           ((prevInterval > 0 && nextInterval < 0) || (prevInterval < 0 && nextInterval > 0));
                const beforeLongNote = nextInterval !== null && 
                                     ['half', 'quarter', 'quarter.'].includes(note.duration);
                
                // åªåœ¨åˆé€‚çš„éŸ³ä¹ä¸Šä¸‹æ–‡ä¸­ç”Ÿæˆaccent
                if (isFirstNote || isStrongBeat || isMelodyTurningPoint || beforeLongNote) {
                    selectedArticulation = 'accent';
                    console.log(`âœ… é€‰æ‹©åŸºæœ¬æ¼”å¥æ³•: accent`);
                }
            }
        }
        
        // Acciaccaturaï¼ˆçŸ­å€šéŸ³ï¼‰- é‡è¦éŸ³ç¬¦å‰çš„è£…é¥° (ä¼˜å…ˆçº§è¾ƒé«˜)
        if (!selectedArticulation && !willSelectGuitarTechnique && artSettings.basic.includes('acciaccatura')) {
            // ğŸ”¥ ä½¿ç”¨æ–°çš„ç²¾å‡†é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
            if (shouldGenerateArticulation('acciaccatura', this.random)) {
                const isImportantNote = isStrongBeat || (note.duration === 'quarter' || note.duration === 'half');
                
                // åªåœ¨åˆé€‚çš„éŸ³ä¹ä¸Šä¸‹æ–‡ä¸­ç”Ÿæˆacciaccatura
                if (isImportantNote && !['16th'].includes(note.duration)) {
                    selectedArticulation = 'acciaccatura';
                    console.log(`âœ… é€‰æ‹©åŸºæœ¬æ¼”å¥æ³•: acciaccatura`);
                }
            }
        }
        
        // === å‰ä»–æŠ€å·§è§„åˆ™ ===
        
        console.log(`ğŸ”§ å¸¸è§„articulationç”¨æˆ·è®¾ç½®æ£€æŸ¥:`);
        console.log(`  - enabled: ${userSettings.articulations.enabled}`);
        console.log(`  - guitaræŠ€å·§: [${artSettings.guitar.join(', ')}]`);
        console.log(`  - basicæŠ€å·§: [${artSettings.basic.join(', ')}]`);
        
        // === å‰ä»–æŠ€å·§è§„åˆ™ (æœ€é«˜ä¼˜å…ˆçº§) ===
        if (!selectedArticulation && clef === 'treble' && artSettings.guitar.length > 0) {
            
            // ğŸ”¥ å®Œå…¨ç‹¬ç«‹çš„å‰ä»–æŠ€å·§æ£€æŸ¥ - ä¸¥æ ¼æŒ‰ç…§ç”¨æˆ·é€‰æ‹©
            const hammerOnAllowed = artSettings.guitar.includes('hammer-on');
            const pullOffAllowed = artSettings.guitar.includes('pull-off');
            
            console.log(`ğŸ”’ ç‹¬ç«‹æŠ€å·§æ£€æŸ¥: hammer-on=${hammerOnAllowed}, pull-off=${pullOffAllowed}`);
            
            // ğŸ¸ HAMMER-ON (H) - å®Œå…¨ç‹¬ç«‹å®šä¹‰ (æœ€é«˜ä¼˜å…ˆçº§)
            // å®šä¹‰ï¼šè¿æ¥åˆ°æ›´é«˜éŸ³çš„slurï¼Œä»…ç”¨äºä¸Šè¡ŒéŸ³ç¨‹
            // æ¡ä»¶ï¼šå‰ä¸€ä¸ªéŸ³ç¬¦å­˜åœ¨ + éŸ³ç¨‹ä¸ºä¸Šè¡Œ1-2åŠéŸ³ + ç”¨æˆ·æ˜ç¡®é€‰æ‹©äº†hammer-on
            if (!selectedArticulation && hammerOnAllowed && noteIndex > 0 && !isFirstNote && !isLastNote) {
                const prevNote = measureNotes[noteIndex - 1];
                if (prevNote && prevNote.type === 'note' && prevNote.midi) {
                    const interval = note.midi - prevNote.midi;
                    
                    // ğŸ”¥ ä¸¥æ ¼å®šä¹‰ï¼šhammer-onåªèƒ½ç”¨äºä¸Šè¡ŒäºŒåº¦ï¼ˆ+1æˆ–+2åŠéŸ³ï¼‰
                    const isValidHammerOn = (interval === 1 || interval === 2);
                    
                    // é¿å…è¿ç»­hammer-on
                    const prevHasHammerOn = prevNote.articulation === 'hammer-on';
                    
                    // ğŸ¯ æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸Šè¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                    const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, this.random);
                    
                    if (isValidHammerOn && !prevHasHammerOn && shouldGenerateSlur) {
                        selectedArticulation = 'hammer-on';
                        console.log(`âœ… é€‰æ‹©å‰ä»–æŠ€å·§: HAMMER-ONç”Ÿæˆ: ${prevNote.midi} -> ${note.midi} (+${interval}åŠéŸ³ï¼Œä¸Šè¡Œ)`);
                    } else {
                        console.log(`âŒ HAMMER-ONè·³è¿‡: interval=${interval}, å‰éŸ³æœ‰H=${prevHasHammerOn}, é¢‘ç‡æ§åˆ¶=${!shouldGenerateSlur}`);
                    }
                }
            } else if (hammerOnAllowed) {
                console.log(`ğŸš« HAMMER-ONç¦æ­¢: ç”¨æˆ·æœªé€‰æ‹©hammer-onæŠ€å·§`);
            }
            
            // ğŸ¸ PULL-OFF (P) - å®Œå…¨ç‹¬ç«‹å®šä¹‰ (æœ€é«˜ä¼˜å…ˆçº§)
            // å®šä¹‰ï¼šè¿æ¥åˆ°æ›´ä½éŸ³çš„slurï¼Œä»…ç”¨äºä¸‹è¡ŒéŸ³ç¨‹
            // æ¡ä»¶ï¼šå‰ä¸€ä¸ªéŸ³ç¬¦å­˜åœ¨ + éŸ³ç¨‹ä¸ºä¸‹è¡Œ1-2åŠéŸ³ + ç”¨æˆ·æ˜ç¡®é€‰æ‹©äº†pull-off
            if (!selectedArticulation && pullOffAllowed && noteIndex > 0 && !isFirstNote && !isLastNote) {
                const prevNote = measureNotes[noteIndex - 1];
                if (prevNote && prevNote.type === 'note' && prevNote.midi) {
                    const interval = note.midi - prevNote.midi;
                    
                    // ğŸ”¥ ä¸¥æ ¼å®šä¹‰ï¼špull-offåªèƒ½ç”¨äºä¸‹è¡ŒäºŒåº¦ï¼ˆ-1æˆ–-2åŠéŸ³ï¼‰
                    const isValidPullOff = (interval === -1 || interval === -2);
                    
                    // é¿å…è¿ç»­pull-off
                    const prevHasPullOff = prevNote.articulation === 'pull-off';
                    
                    // ğŸ¯ æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸‹è¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                    const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, this.random);
                    
                    if (isValidPullOff && !prevHasPullOff && shouldGenerateSlur) {
                        selectedArticulation = 'pull-off';
                        console.log(`âœ… é€‰æ‹©å‰ä»–æŠ€å·§: PULL-OFFç”Ÿæˆ: ${prevNote.midi} -> ${note.midi} (${interval}åŠéŸ³ï¼Œä¸‹è¡Œ)`);
                    } else {
                        console.log(`âŒ PULL-OFFè·³è¿‡: interval=${interval}, å‰éŸ³æœ‰P=${prevHasPullOff}, é¢‘ç‡æ§åˆ¶=${!shouldGenerateSlur}`);
                    }
                }
            } else if (pullOffAllowed) {
                console.log(`ğŸš« PULL-OFFç¦æ­¢: ç”¨æˆ·æœªé€‰æ‹©pull-offæŠ€å·§`);
            }
            
            const noteBeatsForSlide = typeof note.beats === 'number' ? note.beats : this.durationToBeats(note.duration || 'quarter');
            const isEighthOrLonger = noteBeatsForSlide >= MIN_SLIDE_NOTE_BEATS;
            const isLongNote = noteBeatsForSlide > 1;

            const slideFrequency = this.slideAssignmentState?.slideFrequency ?? getUserFrequency('articulation', 'slide');

            // Slide å®¶æ—ï¼ˆglissando / slide-in / slide-outï¼‰ç»Ÿä¸€åŠ æƒé€‰æ‹©ï¼š
            // é»˜è®¤æƒé‡ä¿è¯æ™®é€šslide > slide-in + slide-out
            if (!selectedArticulation && !previousNoteHasSlide && isEighthOrLonger) {
                const slideCandidates = [];

                // Glissando (/) - è¿æ¥å½“å‰éŸ³ç¬¦åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦
                if (artSettings.guitar.includes('glissando') && this.canAssignSlideArticulation('glissando') && !isLastNote && noteIndex < measureNotes.length - 1) {
                    const nextNote = measureNotes[noteIndex + 1];
                    if (nextNote && nextNote.type === 'note' && nextNote.midi) {
                        const interval = Math.abs(nextNote.midi - note.midi);
                        const isDifferentPitch = interval >= 1;
                        const isReasonableRange = interval <= 12;
                        if (isDifferentPitch && isReasonableRange) {
                            const glissChance = interval <= 2 ? 0.55 : 0.9;
                            slideCandidates.push({
                                type: 'glissando',
                                chance: glissChance,
                                interval,
                                targetMidi: nextNote.midi
                            });
                        }
                    }
                }

                // Slide In (/â†—) - ä¹å¥å¼€å¤´æˆ–é‡æ‹
                if (artSettings.guitar.includes('slide-in') && this.canAssignSlideArticulation('slide-in')) {
                    const isEntryPoint = isFirstNote || (isStrongBeat && this.random.nextFloat() < 0.5);
                    if (isEntryPoint) {
                        slideCandidates.push({
                            type: 'slide-in',
                            chance: getSlideInOutChance(slideFrequency, isLongNote, 'slide-in'),
                            beats: noteBeatsForSlide
                        });
                    }
                }

                // Slide Out (â†˜\) - ä¹å¥ç»“å°¾
                if (artSettings.guitar.includes('slide-out') && this.canAssignSlideArticulation('slide-out')) {
                    const isEndingPoint = isLastNote || (noteIndex >= measureNotes.length - 2);
                    if (isEndingPoint) {
                        slideCandidates.push({
                            type: 'slide-out',
                            chance: getSlideInOutChance(slideFrequency, isLongNote, 'slide-out'),
                            beats: noteBeatsForSlide
                        });
                    }
                }

                const selectedSlide = chooseWeightedSlideType(slideCandidates, this.random);
                if (selectedSlide) {
                    selectedArticulation = selectedSlide.type;
                    if (selectedSlide.type === 'glissando') {
                        console.log(`âœ… é€‰æ‹©å‰ä»–æŠ€å·§: Glissando: ${note.midi} -> ${selectedSlide.targetMidi} (éŸ³ç¨‹ï¼š${selectedSlide.interval}åŠéŸ³, æƒé‡=${selectedSlide.weight.toFixed(2)})`);
                    } else {
                        console.log(`âœ… é€‰æ‹©å‰ä»–æŠ€å·§: ${selectedSlide.type} (beats=${noteBeatsForSlide}, æƒé‡=${selectedSlide.weight.toFixed(2)})`);
                    }
                }
            }
        }
        
        // ğŸ”¥ å…¨å±€é¢‘ç‡æ§åˆ¶ - æ¯ä¸¤å°èŠ‚å†…æœ€å¤š2ä¸ªarticulation
        
        if (selectedArticulation) {
            // æ£€æŸ¥å…¨å±€articulationè®¡æ•°å™¨
            if (!window.articulationCounter) {
                window.articulationCounter = {
                    total: 0,
                    perTwoMeasures: 0,
                    currentMeasurePair: 0
                };
            }
            
            // è®¡ç®—å½“å‰æ˜¯å“ªä¸ªä¸¤å°èŠ‚ç»„ï¼ˆ0-1, 2-3, 4-5, ...ï¼‰
            const currentMeasurePair = Math.floor(measureIndex / 2);
            
            // å¦‚æœè¿›å…¥äº†æ–°çš„ä¸¤å°èŠ‚ç»„ï¼Œé‡ç½®è®¡æ•°å™¨
            if (currentMeasurePair !== window.articulationCounter.currentMeasurePair) {
                console.log(`ğŸ”„ è¿›å…¥æ–°çš„ä¸¤å°èŠ‚ç»„ ${currentMeasurePair*2+1}-${currentMeasurePair*2+2}ï¼Œé‡ç½®è®¡æ•°å™¨`);
                window.articulationCounter.perTwoMeasures = 0;
                window.articulationCounter.currentMeasurePair = currentMeasurePair;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é¢‘ç‡é™åˆ¶
            if (window.articulationCounter.perTwoMeasures >= 2) {
                console.log(`ğŸš« é¢‘ç‡é™åˆ¶: å°èŠ‚${measureIndex+1}çš„${selectedArticulation}è¢«é˜»æ­¢ - å½“å‰ä¸¤å°èŠ‚ç»„å·²æœ‰${window.articulationCounter.perTwoMeasures}ä¸ªarticulation`);
                selectedArticulation = null;
            } else {
                // å…è®¸ç”Ÿæˆï¼Œæ›´æ–°è®¡æ•°å™¨
                window.articulationCounter.total++;
                window.articulationCounter.perTwoMeasures++;
                console.log(`âœ… é¢‘ç‡å…è®¸: å°èŠ‚${measureIndex+1}æ·»åŠ ${selectedArticulation} - å½“å‰ä¸¤å°èŠ‚ç»„: ${window.articulationCounter.perTwoMeasures}/2`);
            }
        }
        if (selectedArticulation && isSlideArticulationType(selectedArticulation)) {
            if (!this.consumeSlideArticulation(selectedArticulation)) {
                console.log(`ğŸš« Slideé¢„ç®—é˜»æ­¢: ${selectedArticulation}`);
                selectedArticulation = null;
            }
        }
        if (selectedArticulation) {
            console.log(`ğŸ¸ é€‰ä¸­æ¼”å¥æ³•: ${selectedArticulation}, éŸ³ç¬¦: MIDI ${note.midi}, ä½ç½®: ${noteIndex}`);
            
            // ğŸ”¥ æ£€æŸ¥ï¼šå¦‚æœé€‰æ‹©äº†ä¼šäº§ç”Ÿslurçš„articulationï¼Œç¡®ä¿ä¸‹ä¸€ä¸ªéŸ³ç¬¦ä¸ä¼šå†æœ‰articulation
            if (['hammer-on', 'pull-off'].includes(selectedArticulation) && noteIndex < measureNotes.length - 1) {
                const nextNote = measureNotes[noteIndex + 1];
                if (nextNote && nextNote.type === 'note' && nextNote.articulation) {
                    console.log(`âš ï¸ è­¦å‘Šï¼šå½“å‰éŸ³ç¬¦${noteIndex}é€‰æ‹©${selectedArticulation}ä¼šäº§ç”Ÿslurï¼Œä½†ä¸‹ä¸€ä¸ªéŸ³ç¬¦${noteIndex + 1}å·²ç»æœ‰articulation: ${nextNote.articulation}`);
                    console.log(`ğŸ”§ æ¸…é™¤ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„articulationä»¥é¿å…å†²çª`);
                    nextNote.articulation = null;
                }
            }
        }
        
        // ğŸ”¥ æœ€ç»ˆå®‰å…¨æ£€æŸ¥ï¼šå¦‚æœé€‰æ‹©äº†ä¸è¢«å…è®¸çš„æŠ€å·§ï¼Œè¿”å›null
        if (clef === 'treble' && artSettings.guitar.length > 0) {
            const hammerOnAllowed = artSettings.guitar.includes('hammer-on');
            const pullOffAllowed = artSettings.guitar.includes('pull-off');
            
            if (selectedArticulation === 'hammer-on' && !hammerOnAllowed) {
                console.log(`ğŸš« æœ€ç»ˆå®‰å…¨æ£€æŸ¥: hammer-onä¸è¢«å…è®¸ï¼Œè¿”å›null`);
                return null;
            }
            if (selectedArticulation === 'pull-off' && !pullOffAllowed) {
                console.log(`ğŸš« æœ€ç»ˆå®‰å…¨æ£€æŸ¥: pull-offä¸è¢«å…è®¸ï¼Œè¿”å›null`);
                return null;
            }
        }

        if ((selectedArticulation === 'hammer-on' || selectedArticulation === 'pull-off') && noteIndex > 0) {
            const prevNote = measureNotes[noteIndex - 1];
            const prevType = typeof prevNote?.type === 'string' ? prevNote.type : '';
            const prevIsRest = prevNote?.isRest || prevNote?.type === 'rest' || prevType.includes('rest');
            if (prevNote && !prevIsRest && prevNote.articulation === 'staccato') {
                prevNote.articulation = null;
                console.log(`ğŸš« ç§»é™¤slurèµ·å§‹éŸ³çš„staccato: å°èŠ‚${measureIndex + 1}, éŸ³ç¬¦${noteIndex}`);
            }
        }
        
        return selectedArticulation;
    }
    
    /**
     * ğŸ”¥ å…¨å±€æ¼”å¥æ³•å®‰å…¨æ£€æŸ¥ - ä¸¥æ ¼è¿‡æ»¤ä¸è¢«å…è®¸çš„æŠ€å·§
     * è¿™æ˜¯æœ€åä¸€é“é˜²çº¿ï¼Œç¡®ä¿æ²¡æœ‰ä¸è¢«å…è®¸çš„å‰ä»–æŠ€å·§é€šè¿‡
     * æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°ä¹Ÿä¼šé—´æ¥é˜²æ­¢ä¸è¢«å…è®¸çš„slurï¼Œå› ä¸ºsluræ˜¯åŸºäºarticulationç”Ÿæˆçš„
     */
    sanitizeArticulations(measures) {
        const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
        const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
        
        console.log(`ğŸ”’ å…¨å±€æ¼”å¥æ³•æ¸…ç†å¼€å§‹:`);
        console.log(`  - hammer-onå…è®¸: ${hammerOnAllowed}`);
        console.log(`  - pull-offå…è®¸: ${pullOffAllowed}`);
        console.log(`  - ç”¨æˆ·é€‰æ‹©çš„å‰ä»–æŠ€å·§: [${userSettings.articulations.guitar.join(', ')}]`);
        
        let sanitizedCount = 0;
        let hammerOnRemoved = 0;
        let pullOffRemoved = 0;
        
        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const note = measure.notes[noteIndex];
                
                if (note.type === 'note' && note.articulation) {
                    let shouldRemove = false;
                    
                    // æ£€æŸ¥hammer-on
                    if (note.articulation === 'hammer-on' && !hammerOnAllowed) {
                        console.log(`ğŸš« å…¨å±€æ¸…ç†: ç§»é™¤ä¸è¢«å…è®¸çš„hammer-on (å°èŠ‚${measureIndex+1}, éŸ³ç¬¦${noteIndex+1}, MIDI ${note.midi})`);
                        shouldRemove = true;
                        hammerOnRemoved++;
                    }
                    
                    // æ£€æŸ¥pull-off
                    if (note.articulation === 'pull-off' && !pullOffAllowed) {
                        console.log(`ğŸš« å…¨å±€æ¸…ç†: ç§»é™¤ä¸è¢«å…è®¸çš„pull-off (å°èŠ‚${measureIndex+1}, éŸ³ç¬¦${noteIndex+1}, MIDI ${note.midi})`);
                        shouldRemove = true;
                        pullOffRemoved++;
                    }
                    
                    if (shouldRemove) {
                        const originalArticulation = note.articulation;
                        delete note.articulation;
                        sanitizedCount++;
                        console.log(`  âœ… å·²æ¸…é™¤: ${originalArticulation} -> null`);
                    }
                }
            }
        }
        
        console.log(`ğŸ”’ å…¨å±€æ¼”å¥æ³•æ¸…ç†å®Œæˆ:`);
        console.log(`  - æ€»å…±ç§»é™¤: ${sanitizedCount}ä¸ªä¸è¢«å…è®¸çš„æŠ€å·§`);
        console.log(`  - hammer-onç§»é™¤: ${hammerOnRemoved}ä¸ª`);
        console.log(`  - pull-offç§»é™¤: ${pullOffRemoved}ä¸ª`);
        console.log(`  - ç›¸å…³çš„slurè¿çº¿ä¹Ÿå°†ä¸ä¼šç”Ÿæˆï¼Œå› ä¸ºå®ƒä»¬ä¾èµ–äºè¿™äº›articulation`);
        
        return measures;
    }

    getTieAwareSlideTargetIndex(notes, index, articulation) {
        if (!Array.isArray(notes)) return index;
        const current = notes[index];
        if (!current || current.type !== 'note' || !current.tied) return index;

        const moveForward = articulation === 'glissando' || articulation === 'slide-out';
        const moveBackward = articulation === 'slide-in';
        if (!moveForward && !moveBackward) return index;

        if (moveForward) {
            let cursor = index;
            while (cursor + 1 < notes.length) {
                const from = notes[cursor];
                const next = notes[cursor + 1];
                if (!next || next.type !== 'note' || !next.tied) break;
                if (typeof from.midi === 'number' && typeof next.midi === 'number' && from.midi !== next.midi) break;
                if (next.tieType !== 'continue' && next.tieType !== 'stop') break;
                cursor += 1;
                if (next.tieType === 'stop') break;
            }
            return cursor;
        }

        let cursor = index;
        while (cursor - 1 >= 0) {
            const prev = notes[cursor - 1];
            const to = notes[cursor];
            if (!prev || prev.type !== 'note' || !prev.tied) break;
            if (typeof prev.midi === 'number' && typeof to.midi === 'number' && prev.midi !== to.midi) break;
            if (prev.tieType !== 'start' && prev.tieType !== 'continue') break;
            cursor -= 1;
            if (prev.tieType === 'start') break;
        }
        return cursor;
    }

    normalizeSlidePlacementOnTiedNotes(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let moved = 0;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            const notes = measure.notes;
            for (let noteIndex = 0; noteIndex < notes.length; noteIndex++) {
                const note = notes[noteIndex];
                if (!note || note.type !== 'note' || !isSlideArticulationType(note.articulation) || !note.tied) {
                    continue;
                }

                const targetIndex = this.getTieAwareSlideTargetIndex(notes, noteIndex, note.articulation);
                if (targetIndex === noteIndex) continue;

                const target = notes[targetIndex];
                if (!target || target.type !== 'note') continue;
                if (typeof note.midi === 'number' && typeof target.midi === 'number' && note.midi !== target.midi) {
                    continue;
                }

                const previousTargetArticulation = target.articulation;
                target.articulation = note.articulation;
                if (note.forceGlissandoStart) {
                    target.forceGlissandoStart = true;
                    note.forceGlissandoStart = false;
                }
                if (note.needsGlissandoStop) {
                    target.needsGlissandoStop = true;
                    note.needsGlissandoStop = false;
                }

                note.articulation = null;
                moved++;
                console.log(`ğŸ” è¿çº¿éŸ³ç¬¦slideé‡å®šä½: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 1} -> éŸ³ç¬¦${targetIndex + 1} (${target.articulation}${previousTargetArticulation && previousTargetArticulation !== target.articulation ? `, è¦†ç›–${previousTargetArticulation}` : ''})`);
            }
        }

        if (moved > 0) {
            console.log(`âœ… è¿çº¿éŸ³ç¬¦slideä½ç½®ä¿®æ­£å®Œæˆ: å…±é‡å®šä½${moved}ä¸ª`);
        }

        return measures;
    }

    removeStaccatoFromSlurStarts(measures) {
        let removed = 0;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!measure || !measure.notes) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length - 1; noteIndex++) {
                const note = measure.notes[noteIndex];
                const nextNote = measure.notes[noteIndex + 1];

                if (!note || !nextNote) continue;

                const noteType = typeof note.type === 'string' ? note.type : '';
                const noteIsRest = note.isRest || note.type === 'rest' || noteType.includes('rest');
                if (noteIsRest) continue;

                const nextIsSlurTarget = nextNote.articulation === 'hammer-on' || nextNote.articulation === 'pull-off';
                if (nextIsSlurTarget && note.articulation === 'staccato') {
                    note.articulation = null;
                    removed++;
                    console.log(`ğŸš« ç§»é™¤slurèµ·å§‹éŸ³çš„staccato: å°èŠ‚${measureIndex + 1}, éŸ³ç¬¦${noteIndex + 1}`);
                }
            }
        }

        if (removed > 0) {
            console.log(`âœ… å·²ç§»é™¤${removed}ä¸ªslurèµ·å§‹éŸ³çš„staccato`);
        }

        return measures;
    }

    ensureAtLeastOneGlissando(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        if (!userSettings?.articulations?.enabled) {
            return measures;
        }

        if (this.clef !== 'treble') {
            return measures;
        }

        const guitarTechniques = Array.isArray(userSettings?.articulations?.guitar)
            ? userSettings.articulations.guitar
            : [];

        if (!guitarTechniques.includes('glissando')) {
            return measures;
        }

        const hasSlide = measures.some(measure =>
            Array.isArray(measure?.notes) &&
            measure.notes.some(note => note?.type === 'note' && isSlideArticulationType(note.articulation))
        );

        if (hasSlide) {
            return measures;
        }

        if (!this.canAssignSlideArticulation('glissando')) {
            return measures;
        }

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length - 1; noteIndex++) {
                const current = measure.notes[noteIndex];
                const next = measure.notes[noteIndex + 1];
                const currentHasArticulation = !!current?.articulation;
                const nextHasArticulation = !!next?.articulation;

                if (
                    current?.type === 'note' &&
                    next?.type === 'note' &&
                    typeof current.midi === 'number' &&
                    typeof next.midi === 'number' &&
                    isSlideDurationAllowed(current, this.durationToBeats?.bind(this)) &&
                    isSlideDurationAllowed(next, this.durationToBeats?.bind(this)) &&
                    current.midi !== next.midi &&
                    Math.abs(next.midi - current.midi) <= 12 &&
                    !currentHasArticulation &&
                    !nextHasArticulation
                ) {
                    current.articulation = 'glissando';
                    this.consumeSlideArticulation('glissando');
                    console.log(`ğŸ¸ Glissandoä¿åº•è¡¥é½: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 1} (${current.midi} -> ${next.midi})`);
                    return measures;
                }
            }
        }

        return measures;
    }

    sanitizeGlissandoPairs(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let removed = 0;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const current = measure.notes[noteIndex];
                if (current?.type !== 'note' || current.articulation !== 'glissando') {
                    continue;
                }

                const next = measure.notes[noteIndex + 1];
                const isValid =
                    next?.type === 'note' &&
                    typeof current.midi === 'number' &&
                    typeof next.midi === 'number' &&
                    isSlideDurationAllowed(current, this.durationToBeats?.bind(this)) &&
                    isSlideDurationAllowed(next, this.durationToBeats?.bind(this)) &&
                    current.midi !== next.midi &&
                    Math.abs(next.midi - current.midi) <= 12;

                if (!isValid) {
                    current.articulation = null;
                    current.forceGlissandoStart = false;
                    if (next && next.type === 'note') {
                        next.needsGlissandoStop = false;
                    }
                    removed++;
                    console.log(`ğŸš« ç§»é™¤æ— æ•ˆglissando: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 1}`);
                }
            }
        }

        if (removed > 0) {
            console.log(`âœ… å·²æ¸…ç†${removed}ä¸ªæ— æ•ˆglissandoï¼ˆå¿…é¡»è¿æ¥ç›¸é‚»ä¸åŒéŸ³é«˜ï¼‰`);
        }

        return measures;
    }

    sanitizeTwoNoteArticulationConflicts(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let removed = 0;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length - 1; noteIndex++) {
                const current = measure.notes[noteIndex];
                const next = measure.notes[noteIndex + 1];
                if (current?.type !== 'note' || next?.type !== 'note') continue;

                const currentArt = current.articulation;
                const nextArt = next.articulation;
                const nextIsSlurType = nextArt === 'hammer-on' || nextArt === 'pull-off';
                const currentIsSlurType = currentArt === 'hammer-on' || currentArt === 'pull-off';

                // åŒä¸€å¯¹ç›¸é‚»éŸ³ç¬¦ä¸Šåªä¿ç•™ä¸€ç§åŒéŸ³æŠ€å·§ï¼Œé¿å…slideä¸hammer/pullå åŠ 
                if (currentArt === 'glissando' && nextIsSlurType) {
                    next.articulation = null;
                    removed++;
                    console.log(`ğŸš« æ¸…ç†å†²çªæŠ€å·§: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 2} çš„${nextArt}ä¸å‰ä¸€éŸ³glissandoå†²çª`);
                    continue;
                }

                if (currentIsSlurType && nextArt === 'glissando') {
                    next.articulation = null;
                    removed++;
                    console.log(`ğŸš« æ¸…ç†å†²çªæŠ€å·§: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 2} çš„glissandoä¸å‰ä¸€éŸ³${currentArt}å†²çª`);
                }
            }
        }

        if (removed > 0) {
            console.log(`âœ… åŒéŸ³æŠ€å·§å†²çªæ¸…ç†å®Œæˆ: ç§»é™¤${removed}ä¸ªå†²çªarticulation`);
        }

        return measures;
    }

    sanitizeConsecutiveSlides(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let removed = 0;
        let previousPlayableNote = null;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const current = measure.notes[noteIndex];
                if (!current || current.type !== 'note') {
                    previousPlayableNote = null;
                    continue;
                }

                const currentIsSlide = isSlideArticulationType(current.articulation);
                const prevIsSlide =
                    previousPlayableNote &&
                    previousPlayableNote.type === 'note' &&
                    isSlideArticulationType(previousPlayableNote.articulation);

                if (currentIsSlide && prevIsSlide) {
                    const removedType = current.articulation;
                    current.articulation = null;
                    current.forceGlissandoStart = false;
                    current.needsGlissandoStop = false;
                    removed++;
                    console.log(`ğŸš« ç§»é™¤è¿ç»­slide: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 1} çš„${removedType}`);
                }

                previousPlayableNote = current;
            }
        }

        if (removed > 0) {
            console.log(`âœ… è¿ç»­slideæ¸…ç†å®Œæˆ: ç§»é™¤${removed}ä¸ªè¿ç»­slideï¼ˆä¸å…è®¸ç›¸é‚»éŸ³ç¬¦è¿ç»­slideï¼‰`);
        }

        return measures;
    }

    sanitizeSingleTechniquePerNote(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let removed = 0;
        const hammerOnAllowed = !!userSettings?.articulations?.guitar?.includes('hammer-on');
        const pullOffAllowed = !!userSettings?.articulations?.guitar?.includes('pull-off');

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const current = measure.notes[noteIndex];
                if (current?.type !== 'note') continue;
                if (!isTwoNoteTechniqueType(current.articulation)) continue;

                const previous = noteIndex > 0 ? measure.notes[noteIndex - 1] : null;
                const next = noteIndex < measure.notes.length - 1 ? measure.notes[noteIndex + 1] : null;

                // åŒä¸€ä¸ªéŸ³ç¬¦ä¸èƒ½åŒæ—¶ä½œä¸ºå‰ä¸€ä¸ªæŠ€å·§çš„ç»ˆç‚¹ã€åˆä½œä¸ºå½“å‰æŠ€å·§çš„èµ·ç‚¹ã€‚
                if (previous?.type === 'note' && isTwoNoteTechniqueType(previous.articulation)) {
                    current.articulation = null;
                    removed++;
                    continue;
                }

                // ä¸¥æ ¼é™åˆ¶ï¼šä»…å…è®¸ç›¸é‚»ä¸¤ä¸ªéŸ³ç¬¦å½¢æˆåŒéŸ³æŠ€å·§ã€‚
                if (current.articulation === 'glissando') {
                    const validGliss =
                        next?.type === 'note' &&
                        typeof current.midi === 'number' &&
                        typeof next.midi === 'number' &&
                        isSlideDurationAllowed(current, this.durationToBeats?.bind(this)) &&
                        isSlideDurationAllowed(next, this.durationToBeats?.bind(this)) &&
                        current.midi !== next.midi &&
                        Math.abs(next.midi - current.midi) <= 12;
                    if (!validGliss) {
                        current.articulation = null;
                        current.forceGlissandoStart = false;
                        current.needsGlissandoStop = false;
                        removed++;
                        continue;
                    }
                } else if (current.articulation === 'hammer-on') {
                    const interval = (typeof next?.midi === 'number' && typeof current.midi === 'number')
                        ? next.midi - current.midi
                        : null;
                    const validHammer = hammerOnAllowed && (interval === 1 || interval === 2);
                    if (!validHammer) {
                        current.articulation = null;
                        removed++;
                        continue;
                    }
                } else if (current.articulation === 'pull-off') {
                    const interval = (typeof next?.midi === 'number' && typeof current.midi === 'number')
                        ? next.midi - current.midi
                        : null;
                    const validPull = pullOffAllowed && (interval === -1 || interval === -2);
                    if (!validPull) {
                        current.articulation = null;
                        removed++;
                        continue;
                    }
                }

                // å½“å‰éŸ³ç¬¦æ˜¯åŒéŸ³æŠ€å·§èµ·ç‚¹æ—¶ï¼Œä¸‹ä¸€éŸ³ç¬¦ä¸èƒ½å†å¸¦åŒéŸ³æŠ€å·§ï¼ˆé¿å…å•éŸ³å åŠ ä¸¤ç§æŠ€å·§ï¼‰ã€‚
                if (next?.type === 'note' && isTwoNoteTechniqueType(next.articulation)) {
                    next.articulation = null;
                    removed++;
                }
            }
        }

        if (removed > 0) {
            console.log(`âœ… å•éŸ³å•æŠ€å·§æ¸…ç†å®Œæˆ: ç§»é™¤${removed}ä¸ªå†²çªæˆ–æ— æ•ˆåŒéŸ³æŠ€å·§`);
        }

        return measures;
    }

    sanitizeSlideMinimumDuration(measures) {
        if (!Array.isArray(measures) || measures.length === 0) {
            return measures;
        }

        let removed = 0;

        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            if (!Array.isArray(measure?.notes)) continue;

            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const note = measure.notes[noteIndex];
                if (!note || note.type !== 'note' || !isSlideArticulationType(note.articulation)) continue;

                const durationAllowed = isSlideDurationAllowed(note, this.durationToBeats?.bind(this));
                if (durationAllowed) continue;

                const removedType = note.articulation;
                note.articulation = null;
                note.forceGlissandoStart = false;
                note.needsGlissandoStop = false;
                removed++;
                console.log(`ğŸš« ç§»é™¤è¿‡çŸ­æ—¶å€¼slide: å°èŠ‚${measureIndex + 1} éŸ³ç¬¦${noteIndex + 1} çš„${removedType}`);
            }
        }

        if (removed > 0) {
            console.log(`âœ… è¿‡çŸ­æ—¶å€¼slideæ¸…ç†å®Œæˆ: ç§»é™¤${removed}ä¸ªï¼ˆæœ€å°æ—¶å€¼=å…«åˆ†éŸ³ç¬¦ï¼‰`);
        }

        return measures;
    }

    /**
     * ğŸ” å®æ—¶userSettingsçŠ¶æ€æ£€æŸ¥ - ç”¨äºè°ƒè¯•æƒé™æ£€æŸ¥é—®é¢˜
     */
    debugUserSettingsState() {
        console.log(`\nğŸ”§ === å®æ—¶userSettingsçŠ¶æ€æ£€æŸ¥ ===`);
        console.log(`userSettingsç±»å‹: ${typeof userSettings}`);
        console.log(`userSettings.articulationsç±»å‹: ${typeof userSettings?.articulations}`);
        console.log(`userSettings.articulations.guitarç±»å‹: ${typeof userSettings?.articulations?.guitar}`);
        console.log(`userSettings.articulations.guitarå†…å®¹: [${userSettings?.articulations?.guitar?.join?.(', ') || 'undefined'}]`);
        console.log(`userSettings.articulations.enabled: ${userSettings?.articulations?.enabled}`);
        
        // æ£€æŸ¥å¤é€‰æ¡†çŠ¶æ€
        const hammerCheckboxDebug = document.getElementById('gtr-hammer');
        const pullCheckboxDebug = document.getElementById('gtr-pull');
        console.log(`UIå¤é€‰æ¡†çŠ¶æ€:`);
        console.log(`  - hammer-onå¤é€‰æ¡†å­˜åœ¨: ${!!hammerCheckboxDebug}`);
        console.log(`  - hammer-onå¤é€‰æ¡†å‹¾é€‰: ${hammerCheckboxDebug?.checked}`);
        console.log(`  - pull-offå¤é€‰æ¡†å­˜åœ¨: ${!!pullCheckboxDebug}`);
        console.log(`  - pull-offå¤é€‰æ¡†å‹¾é€‰: ${pullCheckboxDebug?.checked}`);
        
        // æƒé™æ£€æŸ¥ç»“æœ
        const hammerOnAllowed = userSettings?.articulations?.guitar?.includes?.('hammer-on');
        const pullOffAllowed = userSettings?.articulations?.guitar?.includes?.('pull-off');
        console.log(`æƒé™æ£€æŸ¥ç»“æœ:`);
        console.log(`  - hammer-onå…è®¸: ${hammerOnAllowed}`);
        console.log(`  - pull-offå…è®¸: ${pullOffAllowed}`);
        console.log(`ğŸ”§ === userSettingsçŠ¶æ€æ£€æŸ¥ç»“æŸ ===\n`);
        
        return {
            hammerOnAllowed,
            pullOffAllowed,
            settingsValid: !!(userSettings?.articulations?.guitar)
        };
    }

    /**
     * ğŸ” ç»¼åˆæ¼”å¥æ³•è°ƒè¯•æŠ¥å‘Š - è¿½è¸ªæ‰€æœ‰æ¼”å¥æ³•çš„åº”ç”¨æƒ…å†µ
     */
    generateArticulationDebugReport(measures) {
        const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
        const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
        
        console.log(`\nğŸ” === æ¼”å¥æ³•è°ƒè¯•æŠ¥å‘Š ===`);
        console.log(`ğŸ”’ ç”¨æˆ·è®¾ç½®: hammer-onå…è®¸=${hammerOnAllowed}, pull-offå…è®¸=${pullOffAllowed}`);
        console.log(`ğŸ”’ ç”¨æˆ·é€‰æ‹©çš„å‰ä»–æŠ€å·§: [${userSettings.articulations.guitar.join(', ')}]`);
        
        let totalHammerOn = 0;
        let totalPullOff = 0;
        let totalOther = 0;
        let expectedSlurs = 0; // é¢„æœŸçš„sluræ•°é‡
        
        for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
            const measure = measures[measureIndex];
            let measureHammerOn = 0;
            let measurePullOff = 0;
            let measureOther = 0;
            
            for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
                const note = measure.notes[noteIndex];
                
                if (note.type === 'note' && note.articulation) {
                    const nextNote = noteIndex < measure.notes.length - 1 ? measure.notes[noteIndex + 1] : null;
                    const isLastInMeasure = noteIndex === measure.notes.length - 1;
                    
                    if (note.articulation === 'hammer-on') {
                        measureHammerOn++;
                        totalHammerOn++;
                        
                        if (!isLastInMeasure && nextNote && nextNote.type === 'note') {
                            const interval = nextNote.midi - note.midi;
                            if (interval > 0 && interval <= 2) {
                                expectedSlurs++;
                                console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: hammer-on (MIDI ${note.midi} -> ${nextNote.midi}, +${interval}åŠéŸ³) âœ å°†ç”Ÿæˆä¸Šè¡Œslur`);
                            } else {
                                console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: hammer-on (MIDI ${note.midi}) âš ï¸ éŸ³ç¨‹ä¸åŒ¹é…ï¼Œå¯èƒ½ä¸ä¼šç”Ÿæˆslur`);
                            }
                        } else {
                            console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: hammer-on (MIDI ${note.midi}) âš ï¸ å°èŠ‚æœ«æˆ–åæ— éŸ³ç¬¦ï¼Œä¸ä¼šç”Ÿæˆslur`);
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¢«å…è®¸
                        if (!hammerOnAllowed) {
                            console.log(`âš ï¸ è­¦å‘Š: å‘ç°ä¸è¢«å…è®¸çš„hammer-on!`);
                        }
                    } else if (note.articulation === 'pull-off') {
                        measurePullOff++;
                        totalPullOff++;
                        
                        if (!isLastInMeasure && nextNote && nextNote.type === 'note') {
                            const interval = nextNote.midi - note.midi;
                            if (interval < 0 && interval >= -2) {
                                expectedSlurs++;
                                console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: pull-off (MIDI ${note.midi} -> ${nextNote.midi}, ${interval}åŠéŸ³) âœ å°†ç”Ÿæˆä¸‹è¡Œslur`);
                            } else {
                                console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: pull-off (MIDI ${note.midi}) âš ï¸ éŸ³ç¨‹ä¸åŒ¹é…ï¼Œå¯èƒ½ä¸ä¼šç”Ÿæˆslur`);
                            }
                        } else {
                            console.log(`ğŸ¸ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: pull-off (MIDI ${note.midi}) âš ï¸ å°èŠ‚æœ«æˆ–åæ— éŸ³ç¬¦ï¼Œä¸ä¼šç”Ÿæˆslur`);
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¢«å…è®¸
                        if (!pullOffAllowed) {
                            console.log(`âš ï¸ è­¦å‘Š: å‘ç°ä¸è¢«å…è®¸çš„pull-off!`);
                        }
                    } else {
                        measureOther++;
                        totalOther++;
                        console.log(`ğŸµ å°èŠ‚${measureIndex+1}éŸ³ç¬¦${noteIndex+1}: ${note.articulation} (MIDI ${note.midi})`);
                    }
                }
            }
            
            if (measureHammerOn > 0 || measurePullOff > 0) {
                console.log(`ğŸ“Š å°èŠ‚${measureIndex+1}æ±‡æ€»: hammer-on=${measureHammerOn}, pull-off=${measurePullOff}, å…¶ä»–=${measureOther}`);
            }
        }
        
        console.log(`\nğŸ“Š === å…¨æ›²æ±‡æ€» ===`);
        console.log(`ğŸ¸ Hammer-onæ€»æ•°: ${totalHammerOn} (å…è®¸: ${hammerOnAllowed})`);
        console.log(`ğŸ¸ Pull-offæ€»æ•°: ${totalPullOff} (å…è®¸: ${pullOffAllowed})`);
        console.log(`ğŸµ å…¶ä»–æ¼”å¥æ³•æ€»æ•°: ${totalOther}`);
        console.log(`ğŸ¼ é¢„æœŸslurè¿çº¿æ•°é‡: ${expectedSlurs}`);
        console.log(`\nğŸ” === Slurç”Ÿæˆè§„åˆ™æé†’ ===`);
        console.log(`â€¢ å½“åªå‹¾é€‰hammer-onæ—¶: åªåº”å‡ºç°è¿æ¥ä¸Šè¡ŒäºŒåº¦(+1æˆ–+2åŠéŸ³)çš„slur`);
        console.log(`â€¢ å½“åªå‹¾é€‰pull-offæ—¶: åªåº”å‡ºç°è¿æ¥ä¸‹è¡ŒäºŒåº¦(-1æˆ–-2åŠéŸ³)çš„slur`);
        console.log(`â€¢ å½“ä¸¤è€…éƒ½å‹¾é€‰æ—¶: ä¸Šè¡ŒäºŒåº¦å’Œä¸‹è¡ŒäºŒåº¦çš„sluréƒ½å¯èƒ½å‡ºç°`);
        console.log(`â€¢ å½“ä¸¤è€…éƒ½ä¸å‹¾é€‰æ—¶: ä¸åº”å‡ºç°ä»»ä½•å‰ä»–æŠ€å·§ç›¸å…³çš„slur`);
        console.log(`ğŸ” === è°ƒè¯•æŠ¥å‘Šç»“æŸ ===\n`);
        
        return {
            hammerOnCount: totalHammerOn,
            pullOffCount: totalPullOff,
            otherCount: totalOther,
            expectedSlurs,
            hammerOnAllowed,
            pullOffAllowed
        };
    }

    /**
     * MIDIè½¬MusicXMLéŸ³å - æ­£ç¡®å¤„ç†è°ƒå·å‡é™
     * æ ¸å¿ƒåŸåˆ™ï¼šåªæœ‰å½“éŸ³ç¬¦åç¦»è°ƒå·é»˜è®¤å€¼æ—¶æ‰å†™å…¥alter
     */
    midiToMusicXML(midi, preferredAccidental = null) {
        let octave = Math.floor(midi / 12) - 1;
        const pitchClass = midi % 12;
        
        // ğŸµ ä½¿ç”¨ä¸“ä¸šè®°è°±è§„åˆ™è·å–æ­£ç¡®çš„éŸ³åæ‹¼å†™
        const normalizedPreference = this.normalizeAccidentalPreference(preferredAccidental);
        const preferredSpelling = this.getPreferredSpelling(pitchClass, normalizedPreference);
        const forcePreferredSpelling = !!preferredSpelling;
        const correctSpelling = preferredSpelling || PROFESSIONAL_NOTATION_RULES.getCorrectSpelling(pitchClass, this.keySignature);
        
        // è·å–å½“å‰è°ƒå·çš„é»˜è®¤å‡é™è®°å·
        const keyDefaults = this.getKeyAccidentals(this.keySignature);
        
        // è§£ææ­£ç¡®æ‹¼å†™å¾—åˆ°çš„éŸ³åå’Œå‡é™å·
        let step, alter;
        if (correctSpelling.includes('##')) {
            step = correctSpelling.replace('##', '');
            alter = 2; // é‡å‡
        } else if (correctSpelling.includes('bb')) {
            step = correctSpelling.replace('bb', '');
            alter = -2; // é‡é™
        } else if (correctSpelling.includes('#')) {
            step = correctSpelling.replace('#', '');
            alter = 1; // å‡
        } else if (correctSpelling.includes('b')) {
            step = correctSpelling.replace('b', '');
            alter = -1; // é™
        } else {
            step = correctSpelling;
            alter = 0; // è‡ªç„¶éŸ³
        }
        
        // å¯¹äºå°è°ƒï¼Œç›´æ¥ä½¿ç”¨ä»æ‹¼å†™è¡¨è·å¾—çš„æ­£ç¡®éŸ³åï¼Œä¸è¦å†è¦†ç›–
        const keyInfo = KEY_SIGNATURES[this.keySignature];
        const isMinorKey = keyInfo && keyInfo.mode === 'minor';
        
        let actualAlter = alter; // è¿™ä¸ªéŸ³ç¬¦å®é™…çš„å‡é™å€¼
        
        // æ ¹æ®pitch classç¡®å®šå®é™…çš„å‡é™å€¼
        // å¯¹äºå°è°ƒï¼Œå·²ç»ä»æ‹¼å†™è¡¨è·å¾—äº†æ­£ç¡®çš„éŸ³åï¼Œä¸éœ€è¦å†å¤„ç†
        if (!isMinorKey && !forcePreferredSpelling) {
            switch (pitchClass) {
                case 0: 
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ­£ç¡®æ‹¼å†™å·²ç»ç¡®å®šä¸ºB#ï¼Œä¿æŒactualAlter=1
                    if (step === 'B' && alter === 1) {
                        actualAlter = 1; // ä¿æŒB#çš„å‡è®°å·
                    } else {
                        actualAlter = 0; // Cè‡ªç„¶éŸ³
                    }
                    break;  // C or B#
                case 1: // C# or Db
                    if (keyDefaults['C'] === 1) {
                        step = 'C'; actualAlter = 1;
                    } else if (keyDefaults['D'] === -1) {
                        step = 'D'; actualAlter = -1;
                    } else {
                        // ğŸ”¥ ä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼šæ ¹æ®è°ƒå·ç±»å‹å†³å®šé»˜è®¤æ‹¼å†™
                        if (this.isFlatKey(this.keySignature)) {
                            step = 'D'; actualAlter = -1; // é™å·è°ƒç”¨é™å·æ‹¼å†™
                        } else {
                            step = 'C'; actualAlter = 1; // å‡å·è°ƒç”¨å‡å·æ‹¼å†™
                        }
                    }
                    break;
                case 2: actualAlter = 0; break;  // D
                case 3: // Eb or D#
                    if (keyDefaults['E'] === -1) {
                        step = 'E'; actualAlter = -1;
                    } else if (keyDefaults['D'] === 1) {
                        step = 'D'; actualAlter = 1;
                    } else {
                        // ğŸ”¥ ä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼šæ ¹æ®è°ƒå·ç±»å‹å†³å®šé»˜è®¤æ‹¼å†™
                        if (this.isFlatKey(this.keySignature)) {
                            step = 'E'; actualAlter = -1; // é™å·è°ƒç”¨é™å·æ‹¼å†™
                        } else {
                            step = 'D'; actualAlter = 1; // å‡å·è°ƒç”¨å‡å·æ‹¼å†™
                        }
                    }
                    break;
                case 4: actualAlter = 0; break;  // E
                case 5: 
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ­£ç¡®æ‹¼å†™å·²ç»ç¡®å®šä¸ºE#ï¼Œä¿æŒactualAlter=1
                    if (step === 'E' && alter === 1) {
                        actualAlter = 1; // ä¿æŒE#çš„å‡è®°å·
                    } else {
                        actualAlter = 0; // Fè‡ªç„¶éŸ³
                    }
                    break;  // F or E#
                case 6: // F# or Gb
                    if (keyDefaults['F'] === 1) {
                        step = 'F'; actualAlter = 1;
                    } else if (keyDefaults['G'] === -1) {
                        step = 'G'; actualAlter = -1;
                    } else {
                        // ğŸ”¥ ä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼šæ ¹æ®è°ƒå·ç±»å‹å†³å®šé»˜è®¤æ‹¼å†™
                        if (this.isFlatKey(this.keySignature)) {
                            step = 'G'; actualAlter = -1; // é™å·è°ƒç”¨é™å·æ‹¼å†™
                        } else {
                            step = 'F'; actualAlter = 1; // å‡å·è°ƒç”¨å‡å·æ‹¼å†™
                        }
                    }
                    break;
                case 7: actualAlter = 0; break;  // G
                case 8: // Ab or G#
                    if (keyDefaults['A'] === -1) {
                        step = 'A'; actualAlter = -1;
                    } else if (keyDefaults['G'] === 1) {
                        step = 'G'; actualAlter = 1;
                    } else {
                        // ğŸ”¥ ä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼šæ ¹æ®è°ƒå·ç±»å‹å†³å®šé»˜è®¤æ‹¼å†™
                        if (this.isFlatKey(this.keySignature)) {
                            step = 'A'; actualAlter = -1; // é™å·è°ƒç”¨é™å·æ‹¼å†™
                        } else {
                            step = 'G'; actualAlter = 1; // å‡å·è°ƒç”¨å‡å·æ‹¼å†™
                        }
                    }
                    break;
                case 9: actualAlter = 0; break;  // A
                case 10: // Bb or A#
                    if (keyDefaults['B'] === -1) {
                        step = 'B'; actualAlter = -1;
                    } else if (keyDefaults['A'] === 1) {
                        step = 'A'; actualAlter = 1;
                    } else {
                        // ğŸ”¥ ä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼šæ ¹æ®è°ƒå·ç±»å‹å†³å®šé»˜è®¤æ‹¼å†™
                        if (this.isFlatKey(this.keySignature)) {
                            step = 'B'; actualAlter = -1; // é™å·è°ƒç”¨é™å·æ‹¼å†™
                        } else {
                            step = 'A'; actualAlter = 1; // å‡å·è°ƒç”¨å‡å·æ‹¼å†™
                        }
                    }
                    break;
                case 11: 
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ­£ç¡®æ‹¼å†™å·²ç»ç¡®å®šä¸ºCbï¼Œä¿æŒactualAlter=-1
                    if (step === 'C' && alter === -1) {
                        actualAlter = -1; // ä¿æŒCbçš„é™è®°å·
                    } else {
                        actualAlter = 0; // Bè‡ªç„¶éŸ³
                    }
                    break; // B or Cb
            }
        }
        
        // å…³é”®é€»è¾‘ï¼šå†³å®šæ˜¯å¦éœ€è¦å†™å…¥alteræ ‡ç­¾
        const keyDefaultForThisStep = keyDefaults[step];
        let xmlAlter = undefined;
        
        // ä¿®å¤OSMDæ¸²æŸ“é—®é¢˜ï¼šæ€»æ˜¯æ˜ç¡®å†™å…¥alteræ ‡ç­¾
        // OSMDéœ€è¦æ˜ç¡®çš„alterå€¼æ‰èƒ½æ­£ç¡®æ˜¾ç¤ºå‡é™éŸ³
        if (actualAlter !== 0) {
            // ä»»ä½•å‡é™éŸ³éƒ½æ˜ç¡®å†™å…¥
            xmlAlter = actualAlter;
        } else if (keyDefaultForThisStep !== undefined && keyDefaultForThisStep !== 0) {
            // å¦‚æœè°ƒå·è§„å®šäº†è¿™ä¸ªéŸ³åº”è¯¥å‡é™ï¼Œä½†å®é™…æ˜¯è‡ªç„¶éŸ³
            // éœ€è¦æ˜ç¡®å†™å…¥alter=0æ¥è¡¨ç¤ºè¿˜åŸè®°å·
            xmlAlter = 0;
        }
        
        // ç‰¹æ®Šå¤„ç†ï¼šB#å’ŒE#å¿…é¡»å†™å…¥alteræ ‡ç­¾æ‰èƒ½æ­£ç¡®æ¸²æŸ“
        // è™½ç„¶å®ƒä»¬ä¸è°ƒå·ä¸€è‡´ï¼Œä½†OSMDéœ€è¦æ˜ç¡®çš„alteræ¥åŒºåˆ†å¼‚ååŒéŸ³
        if (this.keySignature === 'C#' || this.keySignature === 'C#m') {
            if ((step === 'B' && actualAlter === 1) || (step === 'E' && actualAlter === 1)) {
                // B#å’ŒE#å¿…é¡»å†™å…¥alter=1æ‰èƒ½æ­£ç¡®æ¸²æŸ“ä¸ºå‡è®°å·
                xmlAlter = 1;
            }
        }
        
        // åªæœ‰å½“éŸ³ç¬¦æœ¬èº«æ˜¯è‡ªç„¶éŸ³ï¼Œä¸”è°ƒå·ä¹Ÿæ²¡æœ‰æ”¹å˜å®ƒæ—¶ï¼Œæ‰ä¸å†™alter
        
        // ç‰¹æ®Šå¤„ç†ï¼šB#, E# å’Œ Cb çš„å…«åº¦è°ƒæ•´
        if (step === 'B' && actualAlter === 1 && pitchClass === 0) {
            // B# å®é™…æ˜¯ C çš„å¼‚ååŒéŸ³ï¼Œéœ€è¦å°†å…«åº¦å‡ 1
            octave = octave - 1;
            console.log(`ğŸ” [B#æ£€æŸ¥] MIDI ${midi} -> B#${octave} (åŸå…«åº¦${octave + 1}å·²è°ƒæ•´)`);
            console.log(`ğŸ” [B#æ£€æŸ¥] å®é™…éŸ³é«˜: B#${octave} = C${octave + 1} (MIDI ${midi})`);
            if (midi > this.rules?.range?.max) {
                console.error(`ğŸš¨ [B#æ£€æŸ¥] B#${octave} (MIDI ${midi}) è¶…å‡ºéŸ³åŸŸ ${this.rules.range.min}-${this.rules.range.max}ï¼`);
            }
        }
        
        if (step === 'C' && actualAlter === -1 && pitchClass === 11) {
            // Cb å®é™…æ˜¯ B çš„å¼‚ååŒéŸ³ï¼Œéœ€è¦å°†å…«åº¦å¢åŠ  1
            octave = octave + 1;
            console.log(`ğŸ” [Cbæ£€æŸ¥] MIDI ${midi} -> Cb${octave} (åŸå…«åº¦${octave - 1}å·²è°ƒæ•´)`);
            console.log(`ğŸ” [Cbæ£€æŸ¥] å®é™…éŸ³é«˜: Cb${octave} = B${octave - 1} (MIDI ${midi})`);
            if (midi > this.rules?.range?.max) {
                console.error(`ğŸš¨ [Cbæ£€æŸ¥] Cb${octave} (MIDI ${midi}) è¶…å‡ºéŸ³åŸŸ ${this.rules.range.min}-${this.rules.range.max}ï¼`);
            }
        }
        
        if (step === 'E' && actualAlter === 1 && pitchClass === 5) {
            // E# å®é™…æ˜¯ F çš„å¼‚ååŒéŸ³ï¼Œéœ€è¦å°†å…«åº¦è°ƒæ•´
            // E#4 = F4ï¼Œä¸éœ€è¦è°ƒæ•´å…«åº¦
            console.log(`ğŸ” [E#æ£€æŸ¥] MIDI ${midi} -> E#${octave}`);
            console.log(`ğŸ” [E#æ£€æŸ¥] å®é™…éŸ³é«˜: E#${octave} = F${octave} (MIDI ${midi})`);
        }
        
        // æ‰©å±•è°ƒè¯•è¾“å‡º - è®°å½•æ‰€æœ‰éŸ³ç¬¦
        console.log(`ğŸ¹ [${this.keySignature}] MIDI ${midi} (pc=${pitchClass}) -> ${step}${actualAlter === 1 ? '#' : actualAlter === -1 ? 'b' : ''}${octave}`);
        console.log(`   è°ƒå·é»˜è®¤: ${step}=${keyDefaultForThisStep}, å®é™…alter: ${actualAlter}, XML alter: ${xmlAlter === undefined ? 'ä¸å†™å…¥' : xmlAlter}`);
        
        // ç‰¹åˆ«è­¦å‘Šï¼šæ£€æµ‹é—®é¢˜éŸ³ç¬¦
        if (this.keySignature === 'G' && pitchClass === 5) {
            console.warn(`âš ï¸ è­¦å‘Šï¼šGå¤§è°ƒä¸­å‡ºç°äº†Fè‡ªç„¶éŸ³(MIDI ${midi})ï¼è¿™ä¸åº”è¯¥å‡ºç°åœ¨Gå¤§è°ƒéŸ³é˜¶ä¸­ã€‚`);
        }
        
        return {
            step: step,
            octave: octave,
            alter: xmlAlter
        };
    }

    getPreferredSpelling(pitchClass, preferredAccidental) {
        if (!preferredAccidental) return null;
        if (preferredAccidental === '#') {
            const sharpMap = {
                1: 'C#',
                3: 'D#',
                6: 'F#',
                8: 'G#',
                10: 'A#'
            };
            return sharpMap[pitchClass] || null;
        }
        if (preferredAccidental === 'b') {
            const flatMap = {
                1: 'Db',
                3: 'Eb',
                6: 'Gb',
                8: 'Ab',
                10: 'Bb'
            };
            return flatMap[pitchClass] || null;
        }
        return null;
    }

    getKeyAccidentalBias(keySignature) {
        const keyInfo = KEY_SIGNATURES[keySignature];
        if (!keyInfo) return null;
        if (Array.isArray(keyInfo.sharps) && keyInfo.sharps.length > 0) return '#';
        if (Array.isArray(keyInfo.flats) && keyInfo.flats.length > 0) return 'b';
        return null;
    }

    normalizeAccidentalPreference(preferredAccidental) {
        if (!preferredAccidental) return null;
        const bias = this.getKeyAccidentalBias(this.keySignature);
        return bias || preferredAccidental;
    }
    
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ˜¯å¦ä¸ºé™å·è°ƒï¼ˆç”¨äºä¿®å¤åŒéŸ³å¼‚åæ‹¼å†™é—®é¢˜ï¼‰
     */
    isFlatKey(keySignature) {
        const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Dm', 'Gm', 'Cm', 'Fm', 'Bbm', 'Ebm'];
        return flatKeys.includes(keySignature);
    }
    
    /**
     * è·å–è°ƒå·çš„å‡é™è®°å·å®šä¹‰
     */
    getKeyAccidentals(keySignature) {
        const keyAccidentalMap = {
            // å¤§è°ƒ
            'C': {},
            'G': { 'F': 1 },                           // F#
            'D': { 'F': 1, 'C': 1 },                   // F#, C#
            'A': { 'F': 1, 'C': 1, 'G': 1 },           // F#, C#, G#
            'E': { 'F': 1, 'C': 1, 'G': 1, 'D': 1 },   // F#, C#, G#, D#
            'B': { 'F': 1, 'C': 1, 'G': 1, 'D': 1, 'A': 1 }, // F#, C#, G#, D#, A#
            'F#': { 'F': 1, 'C': 1, 'G': 1, 'D': 1, 'A': 1, 'E': 1 }, // F#, C#, G#, D#, A#, E#
            'F': { 'B': -1 },                          // Bb
            'Bb': { 'B': -1, 'E': -1 },                // Bb, Eb
            'Eb': { 'B': -1, 'E': -1, 'A': -1 },       // Bb, Eb, Ab
            'Ab': { 'B': -1, 'E': -1, 'A': -1, 'D': -1 }, // Bb, Eb, Ab, Db
            'Db': { 'B': -1, 'E': -1, 'A': -1, 'D': -1, 'G': -1 }, // Bb, Eb, Ab, Db, Gb
            'Gb': { 'B': -1, 'E': -1, 'A': -1, 'D': -1, 'G': -1, 'C': -1 }, // Bb, Eb, Ab, Db, Gb, Cb
            
            // å°è°ƒï¼ˆä½¿ç”¨ç›¸å¯¹å¤§è°ƒçš„è°ƒå·ï¼‰
            'Am': {},
            'Em': { 'F': 1 },
            'Bm': { 'F': 1, 'C': 1 },
            'F#m': { 'F': 1, 'C': 1, 'G': 1 },
            'C#m': { 'F': 1, 'C': 1, 'G': 1, 'D': 1 },
            'G#m': { 'F': 1, 'C': 1, 'G': 1, 'D': 1, 'A': 1 },
            'D#m': { 'F': 1, 'C': 1, 'G': 1, 'D': 1, 'A': 1, 'E': 1 },
            'A#m': { 'F': 1, 'C': 1, 'G': 1, 'D': 1, 'A': 1, 'E': 1, 'B': 1 },
            'Dm': { 'B': -1 },
            'Gm': { 'B': -1, 'E': -1 },
            'Cm': { 'B': -1, 'E': -1, 'A': -1 },
            'Fm': { 'B': -1, 'E': -1, 'A': -1, 'D': -1 },
            'Bbm': { 'B': -1, 'E': -1, 'A': -1, 'D': -1, 'G': -1 },
            'Ebm': { 'B': -1, 'E': -1, 'A': -1, 'D': -1, 'G': -1, 'C': -1 },
        };
        
        return keyAccidentalMap[keySignature] || {};
    }

    /**
     * ğŸ”¥ è®¡ç®—èŠ‚å¥ç±»å‹çš„æƒé‡ï¼ˆç”¨äºæµ‹è¯•é¢‘ç‡æ§åˆ¶ç³»ç»Ÿï¼‰
     * @param {Array} allowedDurations - å…è®¸çš„èŠ‚å¥ç±»å‹æ•°ç»„
     * @param {string} targetDuration - ç›®æ ‡èŠ‚å¥ç±»å‹
     * @param {number} remainingBeats - å‰©ä½™æ‹æ•°
     * @param {number} currentBeat - å½“å‰æ‹ä½ç½®
     * @returns {number} - è®¡ç®—å‡ºçš„æƒé‡å€¼
     */
    calculateDurationWeight(allowedDurations, targetDuration, remainingBeats, currentBeat) {
        console.log(`ğŸ¯ è®¡ç®—æƒé‡ - ç›®æ ‡: ${targetDuration}, å‰©ä½™æ‹æ•°: ${remainingBeats}, å½“å‰æ‹: ${currentBeat}`);
        
        // æ£€æŸ¥ç›®æ ‡èŠ‚å¥æ˜¯å¦åœ¨å…è®¸åˆ—è¡¨ä¸­
        if (!allowedDurations.includes(targetDuration)) {
            console.log(`âŒ ${targetDuration} ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­: [${allowedDurations.join(', ')}]`);
            return 0;
        }
        
        let weight = 10; // åŸºç¡€æƒé‡
        
        // ğŸ”¥ åº”ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼Œ6/8æ‹ä½¿ç”¨ç‰¹æ®Šæ˜ å°„
        if (userSettings && userSettings.rhythmFrequencies) {
            let freqKey = targetDuration;
            
            // æ ¹æ®æ‹å·é€‰æ‹©æ­£ç¡®çš„é¢‘ç‡æ˜ å°„
            if (this.timeSignature === '6/8') {
                // 6/8æ‹ç‰¹æ®Šæ˜ å°„ï¼šå¯¹åº”åˆ°4/4æ‹çš„èŠ‚å¥ç±»å‹
                if (targetDuration === 'quarter.') freqKey = 'half';        // 6/8æ‹é™„ç‚¹å››åˆ†éŸ³ç¬¦ -> 4/4æ‹äºŒåˆ†éŸ³ç¬¦
                else if (targetDuration === 'half.') freqKey = 'whole';     // 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ -> 4/4æ‹å…¨éŸ³ç¬¦
                else if (targetDuration === 'eighth.') freqKey = 'dotted-eighth'; // ä¿æŒåŸæ ·
                console.log(`ğŸµ 6/8æ‹é¢‘ç‡æ˜ å°„: ${targetDuration} -> ${freqKey}`);
            } else {
                // é6/8æ‹ä½¿ç”¨æ ‡å‡†æ˜ å°„
                if (targetDuration === 'quarter.') freqKey = 'dotted-quarter';
                else if (targetDuration === 'half.') freqKey = 'dotted-half';
                else if (targetDuration === 'eighth.') freqKey = 'dotted-eighth';
            }
            
            const userFreq = userSettings.rhythmFrequencies[freqKey];
            if (userFreq !== undefined) {
                if (userFreq === 0) {
                    console.log(`ğŸš« ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼š${targetDuration} (${freqKey}) è¢«è®¾ä¸º 0%ï¼Œæƒé‡ä¸º0`);
                    return 0;
                } else {
                    weight = userFreq; // ç›´æ¥ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„é¢‘ç‡ä½œä¸ºæƒé‡
                    console.log(`ğŸ¯ ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼š${targetDuration} (${freqKey}) = ${userFreq}%, æƒé‡: ${weight}`);
                }
            } else {
                console.log(`â„¹ï¸ ${targetDuration} (${freqKey}) æ²¡æœ‰ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤æƒé‡: ${weight}`);
            }
        } else {
            console.log(`â„¹ï¸ æ²¡æœ‰ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤æƒé‡: ${weight}`);
        }
        
        return weight;
    }
}

// ====== è·¨å°èŠ‚è¿çº¿æ¸…ç†å™¨ ======
/**
 * å½»åº•æ¸…ç†æ‰€æœ‰è·¨å°èŠ‚çš„tieå’Œå¯èƒ½å¯¼è‡´è·¨å°èŠ‚slurçš„articulation
 * åœ¨ä¼ ç»™MusicXMLBuilderä¹‹å‰è°ƒç”¨
 */
function cleanupCrossMeasureTies(melody) {
    console.log('ğŸ§¹ å¼€å§‹æ¸…ç†è·¨å°èŠ‚è¿çº¿...');
    let cleanupCount = 0;
    
    for (let measureIndex = 0; measureIndex < melody.length; measureIndex++) {
        const measure = melody[measureIndex];
        if (!measure || !measure.notes) continue;
        
        for (let noteIndex = 0; noteIndex < measure.notes.length; noteIndex++) {
            const note = measure.notes[noteIndex];
            if (note.type !== 'note') continue;
            
            // æ¸…ç†å°èŠ‚æœ€åä¸€ä¸ªéŸ³ç¬¦çš„tie start
            if (noteIndex === measure.notes.length - 1) {
                if (note.tied && note.tieType === 'start') {
                    console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}æœ€åéŸ³ç¬¦çš„tie start`);
                    note.tied = false;
                    note.tieType = null;
                    cleanupCount++;
                }
                // æ¸…ç†å¯èƒ½å¯¼è‡´è·¨å°èŠ‚slurçš„articulation
                // æ³¨æ„ï¼šglissandoä¸æ˜¯slurï¼Œè€Œä¸”åˆ†é…é€»è¾‘å·²ç»é¿å…äº†è·¨å°èŠ‚
                // æš‚æ—¶ç¦ç”¨æ­¤æ¸…ç†ä»¥æµ‹è¯•glissandoæ˜¾ç¤º
                /*
                if (note.articulation === 'glissando') {
                    console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}æœ€åéŸ³ç¬¦çš„glissando`);
                    note.articulation = null;
                    cleanupCount++;
                }
                */
            }
            
            // æ¸…ç†å°èŠ‚ç¬¬ä¸€ä¸ªéŸ³ç¬¦çš„tie stop
            if (noteIndex === 0) {
                if (note.tied && note.tieType === 'stop') {
                    console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}ç¬¬ä¸€ä¸ªéŸ³ç¬¦çš„tie stop`);
                    note.tied = false;
                    note.tieType = null;
                    cleanupCount++;
                }
                // æ¸…ç†ä¸åº”åœ¨ç¬¬ä¸€ä¸ªéŸ³ç¬¦å‡ºç°çš„articulation
                if (note.articulation === 'hammer-on' || note.articulation === 'pull-off') {
                    console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}ç¬¬ä¸€ä¸ªéŸ³ç¬¦çš„${note.articulation}`);
                    note.articulation = null;
                    cleanupCount++;
                }
            }
            
            // æ¸…ç†å°èŠ‚å€’æ•°ç¬¬äºŒä¸ªéŸ³ç¬¦çš„articulationï¼ˆå¦‚æœå®ƒä¼šå½±å“æœ€åä¸€ä¸ªéŸ³ç¬¦ï¼‰
            if (noteIndex === measure.notes.length - 2) {
                const nextNote = measure.notes[noteIndex + 1];
                if (nextNote && nextNote.type === 'note') {
                    // å¦‚æœå€’æ•°ç¬¬äºŒä¸ªéŸ³ç¬¦çš„articulationä¼šåœ¨æœ€åä¸€ä¸ªéŸ³ç¬¦äº§ç”Ÿslur
                    if (nextNote.articulation === 'hammer-on' || nextNote.articulation === 'pull-off') {
                        console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}æœ€åéŸ³ç¬¦çš„${nextNote.articulation}ï¼ˆé˜²æ­¢è·¨å°èŠ‚slurï¼‰`);
                        nextNote.articulation = null;
                        cleanupCount++;
                    }
                }
            }
            
            // æ¸…ç†è¾¹ç•Œä¸Šçš„tie continue
            if ((noteIndex === 0 || noteIndex === measure.notes.length - 1) && 
                note.tied && note.tieType === 'continue') {
                console.log(`âŒ æ¸…ç†å°èŠ‚${measureIndex + 1}è¾¹ç•Œçš„tie continue`);
                note.tied = false;
                note.tieType = null;
                cleanupCount++;
            }
        }
    }
    
    console.log(`âœ… è·¨å°èŠ‚è¿çº¿æ¸…ç†å®Œæˆï¼Œå…±æ¸…ç†${cleanupCount}å¤„`);
    return melody;
}

// ====== MusicXMLæ„å»ºå™¨ ======
class MusicXMLBuilder {
    constructor(melody, config) {
        // åœ¨æ„å»ºä¹‹å‰å…ˆæ¸…ç†è·¨å°èŠ‚è¿çº¿
        this.melody = cleanupCrossMeasureTies(melody);

        // ğŸµ æœ€é«˜æƒé™ï¼š4/4æ‹è¿çº¿å››åˆ†éŸ³ç¬¦åˆå¹¶
        this.melody = mergeTiedQuarterNotesIn44(this.melody, config.timeSignature);

        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåœ¨åˆå¹¶åé‡æ–°ç”Ÿæˆbeamingä¿¡æ¯
        if (config.timeSignature === '4/4') {
            this.melody = this.regenerateBeamingAfterMerge(this.melody, config.timeSignature);
        }

        this.config = config;
        this.divisions = 24;
    }

    /**
     * ğŸ”¥ åœ¨å››åˆ†éŸ³ç¬¦åˆå¹¶åé‡æ–°ç”Ÿæˆbeamingä¿¡æ¯
     */
    regenerateBeamingAfterMerge(melody, timeSignature) {
        console.log('ğŸ”¥ å¼€å§‹é‡æ–°ç”Ÿæˆbeamingä¿¡æ¯...');

        for (let measureIndex = 0; measureIndex < melody.length; measureIndex++) {
            const measure = melody[measureIndex];
            if (!measure || !measure.notes) continue;

            console.log(`ğŸ”¥ å¤„ç†å°èŠ‚${measureIndex + 1}: ${measure.notes.length}ä¸ªéŸ³ç¬¦`);

            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„NotationGeneratoræ¥é‡æ–°ç”Ÿæˆbeaming
            const tempGenerator = {
                timeSignature: timeSignature,
                generateBeams: function(notes) {
                    // ä½¿ç”¨ä¸IntelligentMelodyGeneratorç›¸åŒçš„beamingé€»è¾‘
                    console.log(`ğŸ¯ é‡æ–°ç”Ÿæˆbeaming: ${notes.length}ä¸ªéŸ³ç¬¦`);

                    if (timeSignature === '4/4') {
                        return this.forceBeamsFor44(notes);
                    } else {
                        return [];
                    }
                },

                forceBeamsFor44: function(notes) {
                    console.log(`ğŸ”¥ ä½¿ç”¨ä¿®å¤åçš„beamingé‡æ–°ç”Ÿæˆé€»è¾‘`);
                    console.log(`ğŸ” å¤„ç†${notes.length}ä¸ªéŸ³ç¬¦:`, notes.map((n, i) => `${i}:${n.duration}`).join(', '));
                    const normalizePosition = (pos) => {
                        const rounded = Math.round(pos * 10000) / 10000;
                        const nearest = Math.round(rounded);
                        return Math.abs(rounded - nearest) < 0.001 ? nearest : rounded;
                    };
                    const beamGroups = [];
                    let currentGroup = [];
                    let position = 0;
                    let currentBeat = -1;

                    for (let i = 0; i < notes.length; i++) {
                        const note = notes[i];
                        const cleanPosition = normalizePosition(position);
                        const noteBeat = Math.floor(cleanPosition) % 4; // ç¡®ä¿æ‹å·åœ¨0-3èŒƒå›´å†…

                        console.log(`  ğŸ” æ£€æŸ¥éŸ³ç¬¦${i}: ${note.type}/${note.duration}, æ‹${noteBeat}, ä½ç½®${position.toFixed(4)} -> ${cleanPosition.toFixed(4)}`);

                        // å¤„ç†æ‰€æœ‰å¯è¿æ†éŸ³ç¬¦ï¼ˆå…«åˆ†ã€åå…­åˆ†ã€å››åˆ†ç­‰ï¼‰
                        const canBeam = note.type === 'note' && !note.isTriplet && (
                            note.duration === 'quarter' || Math.abs(note.beats - 1.0) < 0.001 ||
                            note.duration === 'quarter.' || Math.abs(note.beats - 1.5) < 0.001 ||
                            note.duration === 'eighth' || Math.abs(note.beats - 0.5) < 0.001 ||
                            note.duration === 'eighth.' || Math.abs(note.beats - 0.75) < 0.001 ||
                            note.duration === '16th' || Math.abs(note.beats - 0.25) < 0.001 ||
                            note.duration === '16th.' || Math.abs(note.beats - 0.375) < 0.001 ||
                            note.duration === '32nd' || Math.abs(note.beats - 0.125) < 0.001
                        );

                        if (canBeam) {
                            console.log(`    ğŸ” éŸ³ç¬¦${i}(${note.duration})å¯ä»¥è¿æ†`);

                            // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹æ–°ç»„
                            if (currentBeat !== -1 && noteBeat !== currentBeat) {
                                // ç»“æŸå½“å‰ç»„
                                if (currentGroup.length >= 2) {
                                    console.log(`    âœ… åˆ›å»ºè¿æ†ç»„: æ‹${currentBeat}, éŸ³ç¬¦[${currentGroup.join(',')}]`);
                                    beamGroups.push({
                                        start: currentGroup[0],
                                        end: currentGroup[currentGroup.length - 1],
                                        notes: [...currentGroup],
                                        beamLevels: [{ level: 1, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] }],
                                        stemDirection: 'up',
                                        beat: currentBeat
                                    });
                                }
                                currentGroup = [];
                                currentBeat = -1;
                            }

                            // è®¾ç½®å½“å‰æ‹
                            if (currentBeat === -1) {
                                currentBeat = noteBeat;
                            }

                            currentGroup.push(i);
                            console.log(`    âœ… åŠ å…¥æ‹${noteBeat}è¿æ†ç»„ï¼Œç»„å¤§å°: ${currentGroup.length}`);
                        } else {
                            // ä¸å¯è¿æ†éŸ³ç¬¦ï¼ˆä¼‘æ­¢ç¬¦æˆ–é•¿éŸ³ç¬¦ï¼‰ï¼Œç»“æŸå½“å‰ç»„
                            console.log(`    âŒ éŸ³ç¬¦${i}(${note.type}/${note.duration})ä¸èƒ½è¿æ†`);
                            if (currentGroup.length >= 2) {
                                console.log(`    âœ… é‡åˆ°ä¸å¯è¿æ†éŸ³ç¬¦ï¼Œåˆ›å»ºè¿æ†ç»„: æ‹${currentBeat}, éŸ³ç¬¦[${currentGroup.join(',')}]`);
                                beamGroups.push({
                                    start: currentGroup[0],
                                    end: currentGroup[currentGroup.length - 1],
                                    notes: [...currentGroup],
                                    beamLevels: [{ level: 1, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] }],
                                    stemDirection: 'up',
                                    beat: currentBeat
                                });
                            }
                            currentGroup = [];
                            currentBeat = -1;
                        }

                        position += note.beats;
                        position = Math.round(position * 10000) / 10000;
                    }

                    // å¤„ç†æœ€åä¸€ç»„
                    if (currentGroup.length >= 2) {
                        console.log(`    âœ… åˆ›å»ºæœ€åè¿æ†ç»„: æ‹${currentBeat}, éŸ³ç¬¦[${currentGroup.join(',')}]`);
                        beamGroups.push({
                            start: currentGroup[0],
                            end: currentGroup[currentGroup.length - 1],
                            notes: [...currentGroup],
                            beamLevels: [{ level: 1, start: currentGroup[0], end: currentGroup[currentGroup.length - 1] }],
                            stemDirection: 'up',
                            beat: currentBeat
                        });
                    }

                    console.log(`ğŸ”¥ é‡æ–°ç”Ÿæˆçš„beamingç»“æœ: ${beamGroups.length}ä¸ªè¿æ†ç»„`);
                    return beamGroups;
                }
            };

            // é‡æ–°ç”Ÿæˆbeaming
            const newBeamGroups = tempGenerator.generateBeams(measure.notes);
            measure.beams = newBeamGroups;

            console.log(`ğŸ”¥ å°èŠ‚${measureIndex + 1}æ›´æ–°å: ${measure.beams.length}ä¸ªè¿æ†ç»„`);
        }

        console.log('ğŸ”¥ beamingé‡æ–°ç”Ÿæˆå®Œæˆ!');
        return melody;
    }

    /**
     * å›ºå®šæ¯è¡Œå°èŠ‚æ•°ä¸º4ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
     */
    getMeasuresPerLine() {
        const scoreContainer = document.getElementById('score');
        const containerWidth = scoreContainer ? scoreContainer.clientWidth : 1000;
        
        console.log(`ğŸ“ å®¹å™¨å®½åº¦: ${containerWidth}px`);
        
        // å¼ºåˆ¶æ¯è¡Œ4å°èŠ‚ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
        const measuresPerLine = 4;
        const layoutType = 'fixed-4-measures';
        
        console.log(`ğŸ“ å›ºå®šå¸ƒå±€: ${layoutType} - æ¯è¡Œ${measuresPerLine}å°èŠ‚ (åŸºäºå®½åº¦ ${containerWidth}px)`);
        
        // å­˜å‚¨å½“å‰å¸ƒå±€ä¿¡æ¯ï¼Œä¾›å…¶ä»–å‡½æ•°ä½¿ç”¨
        this.currentLayout = {
            containerWidth,
            measuresPerLine,
            layoutType
        };
        
        return measuresPerLine;
    }

    /**
     * ğŸ¯ é¢„å¤„ç†æ—‹å¾‹æ•°æ®ï¼Œåªæ‹†åˆ†ç¬¬äºŒæ‹åæ‹ï¼ˆä½ç½®1.5ï¼‰çš„å››åˆ†éŸ³ç¬¦
     * ä½ç½®è¯´æ˜ï¼š0=ç¬¬1æ‹, 1=ç¬¬2æ‹, 1.5=ç¬¬2æ‹åæ‹, 2=ç¬¬3æ‹, 3=ç¬¬4æ‹
     */
    preprocessMelodyForBeatClarity() {
        if (this.config.timeSignature !== '4/4') {
            return; // åªå¤„ç†4/4æ‹
        }
        
        console.log(`ğŸ¯ === XMLæ„å»ºå‰é¢„å¤„ç†ï¼šæ ¹æ®èŠ‚å¥å¤æ‚åº¦å¤„ç†æ‹ç‚¹æ¸…æ™°åº¦ ===`);
        const tolerance = 0.01;
        let totalSplits = 0;
        
        // éå†æ¯ä¸ªå°èŠ‚
        for (let measureIndex = 0; measureIndex < this.melody.length; measureIndex++) {
            const measure = this.melody[measureIndex];
            if (!measure || !measure.notes) continue;
            
            // ğŸ¼ å…ˆæ£€æŸ¥è¿™ä¸ªå°èŠ‚æ˜¯å¦æœ‰16åˆ†éŸ³ç¬¦
            let has16thNotes = false;
            for (const note of measure.notes) {
                if (note.type === 'note' && Math.abs(note.beats - 0.25) < tolerance && !note.isTriplet) {
                    has16thNotes = true;
                    break;
                }
            }
            
            const newNotes = [];
            let currentPosition = 0;
            
            // éå†å°èŠ‚ä¸­çš„æ¯ä¸ªéŸ³ç¬¦
            for (let i = 0; i < measure.notes.length; i++) {
                const note = measure.notes[i];
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦æ‹†åˆ†çš„å››åˆ†éŸ³ç¬¦
                const isQuarterNote = note.type === 'note' && Math.abs(note.beats - 1.0) < tolerance;
                // ğŸ¯ åªå¤„ç†ä½ç½®1.5ï¼ˆç¬¬äºŒæ‹çš„åæ‹ï¼‰
                const isAt1_5Position = Math.abs(currentPosition - 1.5) < tolerance;
                
                // å¦‚æœæœ‰16åˆ†éŸ³ç¬¦ï¼Œä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ä¸éœ€è¦æ‹†åˆ†
                // é˜²æ­¢å¯¹hammer-on/pull-offéŸ³ç¬¦è¿›è¡Œtieæ‹†åˆ†
                const hasGuitarTechnique = note.articulation === 'hammer-on' || note.articulation === 'pull-off';
                if (isQuarterNote && isAt1_5Position && !note.isTriplet && !note.tied && !hasGuitarTechnique) {
                    if (has16thNotes) {
                        console.log(`ğŸ¼ å°èŠ‚${measureIndex + 1}æœ‰16åˆ†éŸ³ç¬¦ï¼Œä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ä¸æ‹†åˆ†ï¼ˆä¸¤çº§è§„åˆ™ï¼šä¸æ˜¾ç¤ºå…«åˆ†éŸ³ç¬¦æ‹ç‚¹ï¼‰`);
                        // ä¸æ‹†åˆ†ï¼Œç›´æ¥æ·»åŠ 
                        newNotes.push(note);
                    } else {
                        console.log(`ğŸ¯ å‘ç°ç¬¬äºŒæ‹åæ‹çš„å››åˆ†éŸ³ç¬¦ï¼å°èŠ‚${measureIndex + 1}ï¼Œä½ç½®=1.5, éŸ³é«˜=${note.midi}`);
                        console.log(`ğŸ¯ æ­¤å››åˆ†éŸ³ç¬¦ä¼šä»1.5å»¶ç»­åˆ°2.5ï¼Œè·¨è¶Šç¬¬3æ‹ï¼ˆä½ç½®2ï¼‰ï¼Œéœ€è¦æ‹†åˆ†`);
                        
                        // åˆ›å»ºä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦å¹¶ç”¨tieè¿æ¥
                        const firstEighth = {
                            ...note,
                            duration: 'eighth',
                            beats: 0.5,
                            tied: true,
                            tieType: 'start'
                        };
                        
                        const secondEighth = {
                            ...note,
                            duration: 'eighth',
                            beats: 0.5,
                            tied: true,
                            tieType: 'stop'
                        };
                        
                        newNotes.push(firstEighth);
                        newNotes.push(secondEighth);
                        totalSplits++;
                        
                        console.log(`ğŸ¯ å·²æ‹†åˆ†: 1.5-2.0 (å…«åˆ†éŸ³ç¬¦+tie) + 2.0-2.5 (å…«åˆ†éŸ³ç¬¦)`);
                    }
                } else {
                    // ä¸éœ€è¦æ‹†åˆ†ï¼Œç›´æ¥æ·»åŠ 
                    newNotes.push(note);
                }
                
                currentPosition += note.beats;
            }
            
            // æ›¿æ¢åŸå°èŠ‚çš„éŸ³ç¬¦
            measure.notes = newNotes;
        }
        
        console.log(`ğŸ¯ é¢„å¤„ç†å®Œæˆï¼šå…±æ‹†åˆ†äº†${totalSplits}ä¸ªä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦`);
    }

    /**
     * ç¡®å®šæ˜¯å¦éœ€è¦åœ¨æŒ‡å®šå°èŠ‚å¼€å§‹æ–°è¡Œ
     */
    shouldStartNewSystem(measureIndex, measuresPerLine) {
        // ç¬¬ä¸€å°èŠ‚ä¸éœ€è¦æ¢è¡Œæ ‡è®°
        if (measureIndex === 0) return false;
        
        // å¦‚æœå°èŠ‚ç´¢å¼•æ˜¯measuresPerLineçš„å€æ•°ï¼Œåˆ™å¼€å§‹æ–°è¡Œ
        const shouldBreak = (measureIndex % measuresPerLine) === 0;
        
        console.log(`ğŸ“ æ¢è¡Œæ£€æŸ¥: å°èŠ‚${measureIndex + 1} (ç´¢å¼•${measureIndex}), æ¯è¡Œ${measuresPerLine}å°èŠ‚ -> ${shouldBreak ? 'âœ…å¼€å§‹æ–°è¡Œ' : 'âŒä¸æ¢è¡Œ'}`);
        
        return shouldBreak;
    }

    build(measuresPerLine = 4) {
        const { keySignature, timeSignature, clef, measures } = this.config;
        console.log(`ğŸ—ï¸ å¼€å§‹æ„å»ºMusicXMLï¼Œæ¯è¡Œ${measuresPerLine}å°èŠ‚`);
        
        // ğŸš¨ æ–°æ–¹æ¡ˆï¼šåœ¨æ„å»ºXMLä¹‹å‰é¢„å¤„ç†æ—‹å¾‹ï¼Œæ‹†åˆ†1.5å’Œ2.5ä½ç½®çš„å››åˆ†éŸ³ç¬¦
        this.preprocessMelodyForBeatClarity();
        
        const [beats, beatType] = timeSignature.split('/').map(Number);
        
        // è°ƒå·æ˜ å°„ï¼ˆäº”åº¦åœˆï¼Œå¤§è°ƒå’Œå°è°ƒï¼‰
        const keyMap = {
            // å¤§è°ƒ
            'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6, 'C#': 7,
            'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Gb': -6, 'Cb': -7,
            // å°è°ƒï¼ˆä½¿ç”¨ç›¸å¯¹å¤§è°ƒçš„è°ƒå·ï¼‰
            'Am': 0, 'Em': 1, 'Bm': 2, 'F#m': 3, 'C#m': 4, 'G#m': 5, 'D#m': 6, 'A#m': 7,
            'Dm': -1, 'Gm': -2, 'Cm': -3, 'Fm': -4, 'Bbm': -5, 'Ebm': -6
        };
        
        const keyFifths = keyMap[keySignature] || 0;
        const keyMode = keySignature.includes('m') ? 'minor' : 'major';
        
        console.log(`ğŸ”‘ è°ƒå·è®¾ç½®: ${keySignature} -> fifths=${keyFifths}, mode=${keyMode}`);
        
        let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1">
    </score-part>
  </part-list>
  <part id="P1">`;

        console.log(`ğŸ¼ æ€»å…±${measures}å°èŠ‚ï¼Œæ¯è¡Œ${measuresPerLine}å°èŠ‚ï¼Œé¢„è®¡${Math.ceil(measures / measuresPerLine)}è¡Œ`);
        // æ‰å¹³åŒ–å…¨å±€éŸ³ç¬¦åºåˆ—ï¼ˆæŒ‰æ¸²æŸ“é¡ºåºåŒ…å«ä¼‘æ­¢ç¬¦ï¼‰ï¼Œç”¨äºä¸¥æ ¼çš„tieé‚»æ¥æ ¡éªŒ
        const flatNotes = [];
        const indexMap = new Map(); // key: `${measureIndex}:${noteIndex}` -> flat index
        for (let mi = 0; mi < this.melody.length; mi++) {
            const m = this.melody[mi];
            if (!m || !m.notes) continue;
            for (let ni = 0; ni < m.notes.length; ni++) {
                flatNotes.push({ measureIndex: mi, noteIndex: ni, event: m.notes[ni] });
                indexMap.set(`${mi}:${ni}`, flatNotes.length - 1);
            }
        }
        const tieNumberByFlatIndex = {};
        let tieCounter = 1;
        const slurNumberByFlatIndex = {};
        let slurCounter = 1;
        
        // ç”Ÿæˆæ¯ä¸ªå°èŠ‚
        let prevNoteHadSlurStart = false; // è®°å½•å‰ä¸€ä¸ªéŸ³ç¬¦æ˜¯å¦å¼€å¯äº†slur
        let prevNoteStemDirection = null; // è®°å½•å‰ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦æ†æ–¹å‘
        let prevSlurPlacement = null; // è®°å½•å‰ä¸€ä¸ªslurçš„placementï¼Œç”¨äºslur stop
        
        for (let measureIndex = 0; measureIndex < measures; measureIndex++) {
            // æ¯ä¸ªæ–°å°èŠ‚å¼€å§‹æ—¶é‡ç½®articulationçŠ¶æ€ï¼Œé˜²æ­¢è·¨å°èŠ‚çš„slur
            prevNoteHadSlurStart = false;
            prevNoteStemDirection = null;
            prevSlurPlacement = null;
            const measureNumber = measureIndex + 1;
            // åªåœ¨ç¬¬3ã€5ã€7ç­‰å¥‡æ•°å°èŠ‚ï¼ˆä¸”å¤§äº1ï¼‰æ˜¾ç¤ºç¼–å·
            const shouldShowNumber = measureNumber > 2 && measureNumber % 2 === 1;
            const numberAttribute = shouldShowNumber ? ` number="${measureNumber}"` : '';
            xml += `\\n    <measure${numberAttribute}>`;
            
            // æ·»åŠ æ¢è¡Œæ ‡è®° - æ¯4å°èŠ‚å¼ºåˆ¶æ¢è¡Œ
            if (this.shouldStartNewSystem(measureIndex, 4)) {
                xml += `
      <print new-system="yes"/>`;
            }
            
            // ç¬¬ä¸€å°èŠ‚æ·»åŠ åŸºæœ¬å±æ€§ï¼ˆå¸ƒå±€ç”±OSMD APIæ§åˆ¶ï¼‰
            if (measureIndex === 0) {
                xml += `
      <attributes>
        <divisions>${this.divisions}</divisions>
        <key>
          <fifths>${keyFifths}</fifths>
          <mode>${keyMode}</mode>
        </key>
        <time>
          <beats>${beats}</beats>
          <beat-type>${beatType}</beat-type>
        </time>
        <clef>
          <sign>${clef === 'treble' ? 'G' : clef === 'alto' ? 'C' : 'F'}</sign>
          <line>${clef === 'treble' ? '2' : clef === 'alto' ? '3' : '4'}</line>
        </clef>
      </attributes>`;
            }
            
            // æ·»åŠ éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦
            const measureData = this.melody[measureIndex];
            
            // æ£€æŸ¥å°èŠ‚æ˜¯å¦ä¸ºç©ºæˆ–æ— æ•ˆ
            if (!measureData || !measureData.notes || measureData.notes.length === 0) {
                console.error(`ç©ºå°èŠ‚æ£€æµ‹: å°èŠ‚${measureIndex + 1}ä¸ºç©ºï¼Œæ·»åŠ å…¨ä¼‘æ­¢ç¬¦`);
                // æ·»åŠ å…¨å°èŠ‚ä¼‘æ­¢ç¬¦
                xml += this.buildRestXML({
                    type: 'rest',
                    duration: 'whole',
                    beats: this.beatsPerMeasure
                });
            } else {
                for (let i = 0; i < measureData.notes.length; i++) {
                    const note = measureData.notes[i];
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨beamä¸­
                    const beamInfo = this.getBeamInfo(measureData.beams, i);
                    
                    if (note.type === 'rest') {
                        console.log(`å¤„ç†ä¼‘æ­¢ç¬¦: duration=${note.duration}, beats=${note.beats}, isTriplet=${note.isTriplet}`);
                        const restResult = this.buildRestXML(note);
                        xml += typeof restResult === 'string' ? restResult : restResult.xml;
                        prevNoteHadSlurStart = false; // ä¼‘æ­¢ç¬¦é‡ç½®slurçŠ¶æ€
                        prevNoteStemDirection = null;
                        prevSlurPlacement = null; // ä¼‘æ­¢ç¬¦ä¹Ÿé‡ç½®slur placement
                    } else {
                        // è®¡ç®—å½“å‰éŸ³ç¬¦çš„ç¬¦æ†æ–¹å‘
                        const currentStemDirection = this.calculateStemDirection(note.octave, note.step);
                        
                        // æœ€ç»ˆå‘å°„å‰çš„tieåˆæ³•æ€§æ ¡éªŒ - å¼ºåˆ¶ç¦æ­¢è·¨å°èŠ‚
                        let emitNote = note;
                        if (note.tied && note.tieType) {
                            // å¼ºåˆ¶åªåœ¨å½“å‰å°èŠ‚å†…æŸ¥æ‰¾
                            const getPrevNoteInMeasure = () => {
                                if (i > 0) return measureData.notes[i - 1];
                                return null;
                            };
                            const getNextNoteInMeasure = () => {
                                if (i < measureData.notes.length - 1) return measureData.notes[i + 1];
                                return null;
                            };
                            const prev = getPrevNoteInMeasure();
                            const next = getNextNoteInMeasure();
                            let valid = true;
                            
                            if (note.tieType === 'start') {
                                // åªå…è®¸ç›¸é‚»ä¸¤éŸ³ tieï¼šstart åå¿…é¡»ç´§è·Ÿ stop
                                valid = !!(next && next.type === 'note' && next.tied && next.tieType === 'stop' && next.midi === note.midi);
                                
                                // å¦‚æœæ˜¯å°èŠ‚æœ€åä¸€ä¸ªéŸ³ç¬¦ï¼Œä¸€å®šæ— æ•ˆ
                                if (i === measureData.notes.length - 1) {
                                    console.log(`âŒ å¼ºåˆ¶ç§»é™¤è·¨å°èŠ‚tie: å°èŠ‚${measureIndex + 1}æœ€åéŸ³ç¬¦çš„tie start`);
                                    valid = false;
                                }
                            } else if (note.tieType === 'stop') {
                                // åªå…è®¸ç›¸é‚»ä¸¤éŸ³ tieï¼šstop å‰å¿…é¡»ç´§é‚» start
                                valid = !!(prev && prev.type === 'note' && prev.tied && prev.tieType === 'start' && prev.midi === note.midi);
                                
                                // å¦‚æœæ˜¯å°èŠ‚ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼Œä¸€å®šæ— æ•ˆ
                                if (i === 0) {
                                    console.log(`âŒ å¼ºåˆ¶ç§»é™¤è·¨å°èŠ‚tie: å°èŠ‚${measureIndex + 1}ç¬¬ä¸€éŸ³ç¬¦çš„tie stop`);
                                    valid = false;
                                }
                            } else if (note.tieType === 'continue') {
                                // æ˜ç¡®ç¦æ­¢è·¨è¶Šå¤šä¸ªéŸ³ç¬¦çš„tieé“¾
                                console.log(`âŒ å¼ºåˆ¶ç§»é™¤è·¨å¤šéŸ³ç¬¦tie: å°èŠ‚${measureIndex + 1} ä½ç½®${i} tie continue`);
                                valid = false;
                            }
                            if (!valid) {
                                console.warn(`âŒ ç§»é™¤æ— æ•ˆtie: å°èŠ‚${measureIndex + 1} ä½ç½®${i} tieType=${note.tieType}`);
                                emitNote = { ...note, tied: false, tieType: null };
                            }
                        }

                        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»“æŸsluræˆ–glissando
                        // ğŸ”¥ ä¸¥æ ¼æƒé™æ£€æŸ¥ï¼šåªæœ‰å½“å‰ä¸€ä¸ªéŸ³ç¬¦åˆæ³•å¼€å¯äº†sluræ—¶æ‰ç»“æŸ
                        // éœ€è¦æ£€æŸ¥å‰ä¸€ä¸ªéŸ³ç¬¦çš„articulationæ˜¯å¦è¢«å…è®¸
                        let needsSlurStop = false;
                        if (prevNoteHadSlurStart && i > 0) {
                            const prevNote = measureData.notes[i - 1];
                            if (prevNote && prevNote.type === 'note' && prevNote.articulation) {
                                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                                
                                if ((prevNote.articulation === 'hammer-on' && hammerOnAllowed) ||
                                    (prevNote.articulation === 'pull-off' && pullOffAllowed)) {
                                    needsSlurStop = true;
                                    console.log(`âœ… éœ€è¦ç»“æŸslur: å‰ä¸€ä¸ªéŸ³ç¬¦æœ‰è¢«å…è®¸çš„${prevNote.articulation}`);
                                } else {
                                    console.log(`ğŸ”’ ä¸éœ€è¦ç»“æŸslur: å‰ä¸€ä¸ªéŸ³ç¬¦çš„${prevNote.articulation}ä¸è¢«å…è®¸`);
                                }
                            }
                        }
                        let needsGlissandoStop = false;
                        
                        // æ£€æŸ¥å‰ä¸€ä¸ªéŸ³ç¬¦æ˜¯å¦æœ‰slideï¼Œå¦‚æœæœ‰ï¼Œå½“å‰éŸ³ç¬¦éœ€è¦ç»“æŸglissando
                        if (i > 0) {
                            const prevNote = measureData.notes[i - 1];
                            if (prevNote && prevNote.type === 'note' && prevNote.articulation === 'glissando') {
                                needsGlissandoStop = true;
                                console.log(`ğŸ¸ å‰ä¸€ä¸ªéŸ³ç¬¦æœ‰glissandoï¼Œå½“å‰éŸ³ç¬¦ç»“æŸglissando`);
                            }
                        }
                        
                        // æ£€æŸ¥å½“å‰éŸ³ç¬¦æ˜¯å¦éœ€è¦å¼€å¯sluræˆ–glissando
                        // å¯¹äºhammer-onå’Œpull-offï¼Œåªåœ¨å®ƒä»¬è‡ªå·±ä¸Šå¼€å¯slurï¼Œè¿æ¥åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦
                        let forceSlurStart = false;
                        let forceGlissandoStart = false; // ç”¨äºslide
                        let nextNoteStemDirection = null; // è®°å½•ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘ï¼Œç”¨äºåˆ¤æ–­slur placement
                        
                        // Slideå¤„ç†ï¼šå¦‚æœå½“å‰éŸ³ç¬¦æœ‰slide articulationï¼Œéœ€è¦å¼€å§‹glissandoè¿æ¥åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦
                        if (note.articulation === 'glissando') {
                            if (i < measureData.notes.length - 1) {
                                const nextNote = measureData.notes[i + 1];
                                const isValidGlissPair =
                                    nextNote &&
                                    nextNote.type === 'note' &&
                                    typeof note.midi === 'number' &&
                                    typeof nextNote.midi === 'number' &&
                                    isSlideDurationAllowed(note, this.durationToBeats?.bind(this)) &&
                                    isSlideDurationAllowed(nextNote, this.durationToBeats?.bind(this)) &&
                                    nextNote.midi !== note.midi &&
                                    Math.abs(nextNote.midi - note.midi) <= 12;

                                if (isValidGlissPair) {
                                    forceGlissandoStart = true;
                                    console.log(`ğŸ¸ å½“å‰éŸ³ç¬¦æœ‰glissandoï¼Œå¼€å§‹glissandoè¿æ¥åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦`);
                                } else {
                                    note.articulation = null;
                                    console.log(`ğŸš« æ¸…é™¤æ— æ•ˆglissandoï¼ˆå¿…é¡»è¿æ¥ç›¸é‚»ä¸åŒéŸ³é«˜ï¼‰`);
                                }
                            } else {
                                note.articulation = null;
                                console.log(`ğŸš« æ¸…é™¤æ— æ•ˆglissandoï¼ˆå°èŠ‚æœ«å°¾æ— åç»­éŸ³ç¬¦ï¼‰`);
                            }
                        }
                        
                        // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ï¼šåªä¸ºè¢«å…è®¸çš„æŠ€å·§ç”Ÿæˆslur
                        const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                        const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                        
                        console.log(`ğŸ” Slurç”Ÿæˆæ£€æŸ¥: éŸ³ç¬¦articulation=${note.articulation}, hammer-onå…è®¸=${hammerOnAllowed}, pull-offå…è®¸=${pullOffAllowed}`);
                        
                        if (note.articulation === 'hammer-on' || note.articulation === 'pull-off') {
                            // ğŸ”¥ é¦–å…ˆæ£€æŸ¥æŠ€å·§æ˜¯å¦è¢«ç”¨æˆ·å…è®¸
                            let articulationAllowed = false;
                            if (note.articulation === 'hammer-on' && hammerOnAllowed) {
                                articulationAllowed = true;
                            } else if (note.articulation === 'pull-off' && pullOffAllowed) {
                                articulationAllowed = true;
                            }
                            
                            if (!articulationAllowed) {
                                console.log(`ğŸ”’ Slurç”Ÿæˆ: ${note.articulation}ä¸è¢«å…è®¸ï¼Œæ¸…é™¤articulationå’Œslur`);
                                note.articulation = null;
                            } else {
                                // ğŸ”¥ æ–°å¢ï¼šåŸºäºç”¨æˆ·é€‰æ‹©çš„æ–¹å‘é™åˆ¶æ£€æŸ¥
                                if (i < measureData.notes.length - 1) {
                                    const nextNote = measureData.notes[i + 1];
                                    if (nextNote && nextNote.type === 'note' && nextNote.midi) {
                                        const intervalToNext = nextNote.midi - note.midi;
                                        
                                        // ğŸš« å…³é”®é™åˆ¶ï¼šåŸºäºç”¨æˆ·é€‰æ‹©é˜»æ­¢ç‰¹å®šæ–¹å‘çš„slur
                                        let shouldBlockSlur = false;
                                        
                                        if (hammerOnAllowed && !pullOffAllowed) {
                                            // åªé€‰æ‹©hammer-on: é˜»æ­¢æ‰€æœ‰ä¸‹è¡ŒäºŒåº¦çš„slur
                                            if (intervalToNext === -1 || intervalToNext === -2) {
                                                shouldBlockSlur = true;
                                                console.log(`ğŸš« DIRECTION BLOCK: ç”¨æˆ·åªé€‰æ‹©hammer-onï¼Œé˜»æ­¢ä¸‹è¡ŒäºŒåº¦slur (${intervalToNext}åŠéŸ³)`);
                                            }
                                        } else if (!hammerOnAllowed && pullOffAllowed) {
                                            // åªé€‰æ‹©pull-off: é˜»æ­¢æ‰€æœ‰ä¸Šè¡ŒäºŒåº¦çš„slur  
                                            if (intervalToNext === 1 || intervalToNext === 2) {
                                                shouldBlockSlur = true;
                                                console.log(`ğŸš« DIRECTION BLOCK: ç”¨æˆ·åªé€‰æ‹©pull-offï¼Œé˜»æ­¢ä¸Šè¡ŒäºŒåº¦slur (+${intervalToNext}åŠéŸ³)`);
                                            }
                                        }
                                        
                                        if (shouldBlockSlur) {
                                            console.log(`ğŸ”’ æ¸…é™¤è¢«æ–¹å‘é™åˆ¶é˜»æ­¢çš„articulation: ${note.articulation}`);
                                            note.articulation = null;
                                        }
                                    }
                                }
                                // ç¡®ä¿ä¸æ˜¯å°èŠ‚æœ€åä¸€ä¸ªéŸ³ç¬¦
                                if (i < measureData.notes.length - 1) {
                                    const nextNote = measureData.notes[i + 1];
                                    // ä¸‹ä¸€ä¸ªéŸ³ç¬¦å¿…é¡»æ˜¯éŸ³ç¬¦ï¼ˆä¸æ˜¯ä¼‘æ­¢ç¬¦ï¼‰ä¸”ç´§é‚»å½“å‰éŸ³ç¬¦
                                    if (nextNote && nextNote.type === 'note' && nextNote.midi && note.midi) {
                                        const intervalToNext = Math.abs(nextNote.midi - note.midi);
                                        // éªŒè¯éŸ³ç¨‹æ˜¯å¦åˆé€‚ï¼ˆ1-2åŠéŸ³ï¼‰
                                        if (intervalToNext === 1 || intervalToNext === 2) {
                                            forceSlurStart = true;
                                            // è®¡ç®—ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘
                                            nextNoteStemDirection = this.calculateStemDirection(nextNote.octave, nextNote.step);
                                            console.log(`âœ… ${note.articulation}: å¼€å¯slurè¿æ¥åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦ (${note.midi} -> ${nextNote.midi})`);
                                        } else {
                                            console.log(`âš ï¸ ${note.articulation}éŸ³ç¨‹ä¸é€‚åˆ(${intervalToNext}åŠéŸ³)ï¼Œä¸æ·»åŠ slur`);
                                            // æ¸…é™¤ä¸åˆé€‚çš„articulation
                                            note.articulation = null;
                                        }
                                    } else {
                                        console.log(`âŒ ${note.articulation}åé¢æ²¡æœ‰æœ‰æ•ˆéŸ³ç¬¦ï¼Œæ¸…é™¤articulation`);
                                        // æ¸…é™¤æ— æ•ˆçš„articulation
                                        note.articulation = null;
                                    }
                                } else {
                                    console.log(`âŒ ${note.articulation}åœ¨å°èŠ‚æœ€åï¼Œæ¸…é™¤articulation`);
                                    // æ¸…é™¤å°èŠ‚æœ€åçš„articulation
                                    note.articulation = null;
                                }
                            }
                        } else if (note.articulation === 'glissando') {
                            // slideä½¿ç”¨glissandoè€Œä¸æ˜¯slurï¼Œæ‰€ä»¥ä¸è®¾ç½®forceSlurStart
                            // glissandoä¼šåœ¨buildArticulationXMLä¸­å¤„ç†
                            forceSlurStart = false;
                            console.log(`ğŸ¸ Slide: ä½¿ç”¨glissandoè¿æ¥ï¼Œä¸ä½¿ç”¨slur`);
                        }

                        // slurå’Œtieæ˜¯ç‹¬ç«‹çš„ç³»ç»Ÿï¼Œå¯ä»¥åŒæ—¶å­˜åœ¨
                        // ä¸ºäº†å¤„ç†glissandoï¼Œæˆ‘ä»¬éœ€è¦åœ¨è¿™é‡Œç›´æ¥æ·»åŠ 
                        // å› ä¸ºglissando startéœ€è¦åœ¨å‰ä¸€ä¸ªéŸ³ç¬¦ä¸Š
                        emitNote.forceGlissandoStart = forceGlissandoStart;
                        emitNote.needsGlissandoStop = needsGlissandoStop;
                        
                        const flatIdx = indexMap.get(`${measureIndex}:${i}`);
                        const currentSlurNumber = (() => {
                            if (forceSlurStart) {
                                const num = slurCounter++;
                                slurNumberByFlatIndex[flatIdx] = num;
                                return num;
                            }
                            if (needsSlurStop && flatIdx > 0) {
                                return slurNumberByFlatIndex[flatIdx - 1] || null;
                            }
                            return null;
                        })();

                        const result = this.buildNoteXML(
                            emitNote,
                            beamInfo,
                            needsSlurStop,
                            prevNoteStemDirection,
                            prevSlurPlacement,
                            forceSlurStart,
                            nextNoteStemDirection, // ä¼ é€’ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘
                            (() => {
                                // ä¸ºæœ‰æ•ˆçš„ç›¸é‚»tieåˆ†é…å¹¶ä¼ é€’ä¸€ä¸ªä¸¥æ ¼é…å¯¹çš„ç¼–å·ï¼Œé¿å…OSMDé”™è¯¯é…å¯¹
                                if (!(emitNote.tied && emitNote.tieType)) return null;
                                if (emitNote.tieType === 'start') {
                                    const num = tieCounter++;
                                    tieNumberByFlatIndex[flatIdx] = num;
                                    return num;
                                }
                                if (emitNote.tieType === 'stop') {
                                    const num = flatIdx > 0 ? tieNumberByFlatIndex[flatIdx - 1] : null;
                                    if (num) {
                                        tieNumberByFlatIndex[flatIdx] = num;
                                    }
                                    return num || null;
                                }
                                return null;
                            })(),
                            currentSlurNumber
                        );
                        xml += result.xml;
                        
                        // ğŸ”¥ ä¸¥æ ¼æƒé™æ£€æŸ¥ï¼šåªæœ‰å½“articulationè¢«å…è®¸æ—¶æ‰æ›´æ–°slurçŠ¶æ€
                        let shouldUpdateSlurState = false;
                        if (forceSlurStart && note.articulation) {
                            const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                            const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                            
                            if ((note.articulation === 'hammer-on' && hammerOnAllowed) ||
                                (note.articulation === 'pull-off' && pullOffAllowed)) {
                                shouldUpdateSlurState = true;
                                console.log(`âœ… æ›´æ–°slurçŠ¶æ€: ${note.articulation}è¢«å…è®¸`);
                            } else {
                                console.log(`ğŸ”’ ä¸æ›´æ–°slurçŠ¶æ€: ${note.articulation}ä¸è¢«å…è®¸`);
                            }
                        }
                        
                        // æ›´æ–°slurçŠ¶æ€ï¼šåªæœ‰å½“å‰éŸ³ç¬¦åˆæ³•å¼€å¯äº†sluræ—¶æ‰è®¾ç½®ä¸ºtrue
                        prevNoteHadSlurStart = shouldUpdateSlurState;
                        prevNoteStemDirection = currentStemDirection;
                        
                        // å¦‚æœå½“å‰éŸ³ç¬¦å¼€å¯äº†slurï¼Œè®°å½•slur placement
                        if (shouldUpdateSlurState) {
                            // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ï¼šåªä¸ºè¢«å…è®¸çš„æŠ€å·§è®¾ç½®slur placement
                            const noteArticulation = note.articulation || (note.articulations && note.articulations[0]);
                            console.log(`ğŸ” Slur placementè®¾ç½®: noteArticulation=${noteArticulation}, forceSlurStart=${forceSlurStart}`);
                            
                            if (noteArticulation === 'hammer-on' && hammerOnAllowed) {
                                prevSlurPlacement = 'above'; // ä¸Šè¡Œæ—‹å¾‹ï¼Œsluråœ¨ä¸Šæ–¹
                                console.log(`ğŸ¸ è®¾ç½®hammer-on slur placement: above`);
                            } else if (noteArticulation === 'pull-off' && pullOffAllowed) {
                                prevSlurPlacement = 'below'; // ä¸‹è¡Œæ—‹å¾‹ï¼Œsluråœ¨ä¸‹æ–¹
                                console.log(`ğŸ¸ è®¾ç½®pull-off slur placement: below`);
                            } else {
                                prevSlurPlacement = 'above'; // é»˜è®¤
                                console.log(`ğŸ¸ è®¾ç½®é»˜è®¤slur placement: above`);
                            }
                        }
                    }
                }
            }
            
            // åœ¨æœ€åä¸€ä¸ªå°èŠ‚æ·»åŠ ç»ˆæ­¢çº¿
            if (measureIndex === measures - 1) {
                xml += `
      <barline location="right">
        <bar-style>light-heavy</bar-style>
      </barline>`;
            }
            
            xml += `
    </measure>`;
        }

        xml += `
  </part>
</score-partwise>`;

        // è°ƒè¯•ï¼šæ˜¾ç¤ºæ¢è¡ŒæŒ‡ä»¤çš„ä½ç½®å’Œç»Ÿè®¡
        const newSystemMatches = xml.match(/<print new-system="yes"/g);
        const newSystemCount = newSystemMatches ? newSystemMatches.length : 0;
        const expectedLines = Math.ceil(this.config.measures / measuresPerLine);
        console.log(`ğŸ“ æ¢è¡ŒæŒ‡ä»¤ç»Ÿè®¡: å…±${newSystemCount}ä¸ªæ¢è¡Œç‚¹ï¼Œé¢„æœŸè¡Œæ•°: ${expectedLines}ï¼Œæ¯è¡Œ${measuresPerLine}å°èŠ‚`);
        
        // æ˜¾ç¤ºå…·ä½“çš„æ¢è¡Œä½ç½®
        if (newSystemMatches) {
            const measureNumbers = [];
            let currentPos = 0;
            for (let i = 0; i < newSystemMatches.length; i++) {
                const matchPos = xml.indexOf('<print new-system="yes"', currentPos);
                const measureMatch = xml.substring(0, matchPos).match(/<measure[^>]*number="(\d+)"/g);
                if (measureMatch) {
                    const lastMeasure = measureMatch[measureMatch.length - 1];
                    const measureNum = lastMeasure.match(/number="(\d+)"/)[1];
                    measureNumbers.push(measureNum);
                }
                currentPos = matchPos + 1;
            }
            console.log(`ğŸ”„ æ¢è¡Œä½ç½®: ç¬¬${measureNumbers.join('ã€')}å°èŠ‚å¼€å§‹æ–°è¡Œ`);
        }

        return xml;
    }

    /**
     * æ ¹æ®å¸ƒå±€ç±»å‹è·å–ç³»ç»Ÿé—´è·
     */
    getSystemDistance(layoutType) {
        const distances = {
            'mobile': 100,   // ç§»åŠ¨ç«¯è¾ƒç´§å‡‘
            'tablet': 120,   // å¹³æ¿ç«¯é€‚ä¸­
            'desktop': 140   // æ¡Œé¢ç«¯è¾ƒå®½æ¾
        };
        return distances[layoutType] || 120;
    }

    /**
     * è·å–å°èŠ‚é—´è·ï¼ˆå›ºå®š4å°èŠ‚å¸ƒå±€ï¼‰
     */
    getMeasureDistance(layoutType, measuresPerLine) {
        if (!this.currentLayout || !this.currentLayout.containerWidth) {
            console.warn('Container width not available, using default spacing');
            return 120;
        }

        const containerWidth = this.currentLayout.containerWidth;
        
        // å›ºå®š4å°èŠ‚å¸ƒå±€ï¼šæ ¹æ®å®¹å™¨å®½åº¦åŠ¨æ€è®¡ç®—é—´è·
        const targetSpacing = Math.max(80, containerWidth * 0.15); // 15%çš„å®¹å™¨å®½åº¦ä½œä¸ºé—´è·åŸºå‡†
        
        // è®¾ç½®åˆç†çš„ä¸Šä¸‹é™
        const minSpacing = 60;  // é™ä½æœ€å°é—´è·ä»¥é€‚åº”å°å±å¹•
        const maxSpacing = containerWidth >= 1200 ? 200 : 150;
        
        const finalSpacing = Math.max(minSpacing, Math.min(maxSpacing, targetSpacing));
        
        console.log(`ğŸ“ å°èŠ‚é—´è·è®¡ç®—: å®¹å™¨=${containerWidth}px, å›ºå®š4å°èŠ‚/è¡Œ, é—´è·=${Math.round(finalSpacing)}`);
        
        return Math.round(finalSpacing);
    }

    /**
     * æ„å»ºéŸ³ç¬¦XML
     */
    getDurationDivisions(duration, beats) {
        const divisions = this.divisions || 24;
        if (Number.isFinite(beats) && beats > 0) {
            return Math.max(1, Math.round(beats * divisions));
        }
        const beatsMap = {
            'whole': 4,
            'half': 2,
            'half.': 3,
            'quarter': 1,
            'quarter.': 1.5,
            'eighth': 0.5,
            'eighth.': 0.75,
            '16th': 0.25,
            '32nd': 0.125
        };
        const fallbackBeats = beatsMap[duration] || 1;
        return Math.max(1, Math.round(fallbackBeats * divisions));
    }

    buildNoteXML(note, beamInfo, needsSlurStop = false, prevStemDirection = null, prevSlurPlacement = null, forceSlurStart = false, nextStemDirection = null, tieNumber = null, slurNumber = null) {
        const { duration, step, octave, alter, isTriplet, tripletType, tripletPosition, tied, tieType, articulation, isAcciaccatura, forceGlissandoStart, needsGlissandoStop, graceNote } = note;
        const slurNumberAttr = slurNumber ? ` number="${slurNumber}"` : ' number="2"';
        
        // æ„å»ºæœ€ç»ˆçš„XMLï¼Œå¯èƒ½åŒ…å«grace noteå’Œä¸»éŸ³ç¬¦
        let fullNoteXML = '';
        
        // å¦‚æœæœ‰grace noteï¼Œå…ˆç”Ÿæˆgrace noteçš„XML
        const isTiedContinuation = tied && (tieType === 'continue' || tieType === 'stop');
        const renderArticulation = articulation && !isTiedContinuation;
        if (graceNote && !isTiedContinuation) {
            console.log(`ğŸµ å¤„ç†é™„åŠ çš„grace note: ${graceNote.step}${graceNote.octave} -> ${step}${octave}`);
            fullNoteXML += `
      <note>
        <grace slash="yes"/>
        <pitch>
          <step>${graceNote.step}</step>`;
        
            // åªæœ‰åœ¨æ˜ç¡®éœ€è¦æ”¹å˜è°ƒå·é»˜è®¤å€¼æ—¶æ‰å†™å…¥alter
            if (graceNote.alter !== undefined && graceNote.alter !== null) {
                fullNoteXML += `
          <alter>${graceNote.alter}</alter>`;
            }
            
            fullNoteXML += `
          <octave>${graceNote.octave}</octave>
        </pitch>
        <type>eighth</type>
      </note>
`;
        }
        
        // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœè¿™ä¸ªéŸ³ç¬¦æœ¬èº«å°±æ˜¯acciaccaturaï¼ˆæ—§çš„å¤„ç†æ–¹å¼ï¼Œä¿ç•™å…¼å®¹æ€§ï¼‰
        if (isAcciaccatura) {
            console.log(`ğŸµ å¤„ç†ç‹¬ç«‹çš„ acciaccatura è£…é¥°éŸ³ç¬¦: MIDI ${note.midi} -> ${step}${octave}`);
            let graceNoteXML = `
      <note>
        <grace slash="yes"/>
        <pitch>
          <step>${step}</step>`;
        
            // åªæœ‰åœ¨æ˜ç¡®éœ€è¦æ”¹å˜è°ƒå·é»˜è®¤å€¼æ—¶æ‰å†™å…¥alter
            if (alter !== undefined && alter !== null) {
                graceNoteXML += `
          <alter>${alter}</alter>`;
            }
            
            graceNoteXML += `
          <octave>${octave}</octave>
        </pitch>
        <type>eighth</type>
      </note>`;
            
            return graceNoteXML;
        }
        
        // æ ‡å‡†æ—¶å€¼è®¡ç®—ï¼ˆä¸‰è¿éŸ³é€šè¿‡time-modificationå¤„ç†ï¼Œä¸ä¿®æ”¹durationï¼‰
        let durationValue = this.getDurationDivisions(duration, note.beats);
        
        // ä¸‰è¿éŸ³è°ƒè¯•ä¿¡æ¯
        if (isTriplet) {
            console.log(`ğŸµ ä¸‰è¿éŸ³éŸ³ç¬¦: ${duration}, æ ‡å‡†duration=${durationValue}, ä½ç½®=${tripletPosition}, ç±»å‹=${tripletType}`);
        }
        
        let noteXML = `
      <note>
        <pitch>
          <step>${step}</step>`;
        
        // åªæœ‰åœ¨æ˜ç¡®éœ€è¦æ”¹å˜è°ƒå·é»˜è®¤å€¼æ—¶æ‰å†™å…¥alter
        if (alter !== undefined && alter !== null) {
            noteXML += `
          <alter>${alter}</alter>`;
        }
        
        noteXML += `
          <octave>${octave}</octave>
        </pitch>
        <duration>${durationValue}</duration>`;
        
        // ğŸµ æ·»åŠ è¿éŸ³å¼§æ ‡è®°ï¼ˆtie elementï¼‰
        if (tied && tieType) {
            if (tieType === 'continue') {
                // ä¸­é—´éŸ³ç¬¦éœ€è¦åŒæ—¶æœ‰stopå’Œstart
                noteXML += `
        <tie type="stop"${tieNumber ? ` number="${tieNumber}"` : ''}/>
        <tie type="start"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
                console.log(`  ğŸ”— è¿ç»­tiedéŸ³ç¬¦: stop + start`);
            } else {
                noteXML += `
        <tie type="${tieType}"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
                console.log(`  ğŸ”— tiedéŸ³ç¬¦: ${tieType}`);
            }
        }
        
        noteXML += `
        <type>${duration.replace('.', '')}</type>`;
        
        // é™„ç‚¹å¤„ç†
        if (duration.includes('.')) {
            noteXML += `
        <dot/>`;
        }
        
        // ä¸´æ—¶è®°å·æ ‡è®°å¤„ç†
        // ä¸å†æ˜¾ç¤ºaccidentalæ ‡ç­¾ï¼Œè®©OSMDæ ¹æ®alterå€¼è‡ªåŠ¨å†³å®š
        // è¿™æ ·å¯ä»¥é¿å…é‡å¤æ˜¾ç¤ºä¸´æ—¶è®°å·
        // OSMDä¼šæ ¹æ®alterå€¼å’Œè°ƒå·è‡ªåŠ¨å¤„ç†ä¸´æ—¶è®°å·æ˜¾ç¤º
        
        // Beamæ ‡è®°ï¼ˆä»…é€‚ç”¨äºéä¸‰è¿éŸ³ï¼‰
        if (beamInfo && !isTriplet) {
            if (typeof beamInfo === 'string') {
                noteXML += `
        <beam number="1">${beamInfo}</beam>`;
            } else if (typeof beamInfo === 'object') {
                const levels = Object.keys(beamInfo)
                    .map(key => parseInt(key, 10))
                    .filter(level => Number.isFinite(level))
                    .sort((a, b) => a - b);
                levels.forEach(level => {
                    noteXML += `
        <beam number="${level}">${beamInfo[level]}</beam>`;
                });
            }
        }
        
        // è‡ªåŠ¨è®¡ç®—ç¬¦å¹²æ–¹å‘
        const stemDirection = this.calculateStemDirection(octave, step);
        if (stemDirection) {
            noteXML += `
        <stem>${stemDirection}</stem>`;
        }
        
        // ä¸‰è¿éŸ³æ ‡è®°å’Œè¿éŸ³çº¿
        if (isTriplet) {
            // å…ˆå¤„ç†beamï¼ˆä»…å¯¹éŸ³ç¬¦ä¸”å…«åˆ†éŸ³ç¬¦åŠæ›´å°æ—¶å€¼ï¼Œä¼‘æ­¢ç¬¦ä¸å‚ä¸ç¬¦æ è¿æ¥ï¼‰
            if (['eighth', '16th', '32nd'].includes(duration) && note.type === 'note') {
                // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨é¢„è®¡ç®—çš„ä¸‰è¿éŸ³ç¬¦æ ä¿¡æ¯
                if (note.tripletBeamInfo) {
                    noteXML += `
        <beam number="1">${note.tripletBeamInfo}</beam>`;
                    console.log(`  ğŸµ ä¸‰è¿éŸ³ç¬¦æ : ${duration} ä½ç½®${tripletPosition} â†’ ${note.tripletBeamInfo}`);
                } else {
                    console.log(`  ğŸµ ä¸‰è¿éŸ³æ— ç¬¦æ : ${duration} ä½ç½®${tripletPosition} (å•ç‹¬éŸ³ç¬¦æˆ–ä¼‘æ­¢ç¬¦å½±å“)`);
                }
            }
            
            // å…³é”®ï¼šæ·»åŠ  time-modification æ ‡ç­¾ï¼ˆæ‰€æœ‰è¿éŸ³éŸ³ç¬¦éƒ½éœ€è¦ï¼‰
            const normalType = duration.replace('.', ''); // ç§»é™¤é™„ç‚¹æ ‡è®°
            
            // æ ¹æ®è¿éŸ³ç±»å‹è®¾ç½®æ­£ç¡®çš„æ—¶å€¼æ”¹å˜æ¯”ä¾‹
            let actualNotes, normalNotes;
            if (tripletType === 'duplet_eighth') {
                // äºŒè¿éŸ³ï¼š2ä¸ªå…«åˆ†éŸ³ç¬¦å æ£3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´ (2:3)
                actualNotes = 2;
                normalNotes = 3;
            } else if (tripletType === 'quadruplet_eighth') {
                // å››è¿éŸ³ï¼š4ä¸ªå…«åˆ†éŸ³ç¬¦å æ£3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´ (4:3)
                actualNotes = 4;
                normalNotes = 3;
            } else {
                // ä¸‰è¿éŸ³ï¼š3ä¸ªéŸ³ç¬¦å æ£2ä¸ªéŸ³ç¬¦çš„æ—¶é—´ (3:2)
                actualNotes = 3;
                normalNotes = 2;
            }
            
            noteXML += `
        <time-modification>
          <actual-notes>${actualNotes}</actual-notes>
          <normal-notes>${normalNotes}</normal-notes>
          <normal-type>${normalType}</normal-type>
        </time-modification>`;
            
            // å†å¤„ç†tupletæ ‡è®°å’Œnotations
            const needsNotations = (tied && tieType) || tripletPosition === 0 || tripletPosition === 2 || needsSlurStop || renderArticulation || forceGlissandoStart || needsGlissandoStop;
            
            if (needsNotations) {
                noteXML += `
        <notations>`;
                
                // ğŸµ æ·»åŠ è¿éŸ³å¼§è§†è§‰æ ‡è®°ï¼ˆåœ¨ä¸‰è¿éŸ³æ ‡è®°ä¹‹å‰ï¼‰
                if (tied && tieType) {
                    if (tieType === 'continue') {
                        // ä¸­é—´éŸ³ç¬¦éœ€è¦åŒæ—¶æœ‰stopå’Œstartçš„è§†è§‰æ•ˆæœ
                        noteXML += `
          <tied type="stop"${tieNumber ? ` number="${tieNumber}"` : ''}/>
          <tied type="start"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
                    } else {
                        noteXML += `
          <tied type="${tieType}"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
                    }
                }
                
                const tripletNumber = note.tripletId || 1; // ä½¿ç”¨å”¯ä¸€çš„ä¸‰è¿éŸ³IDï¼Œé»˜è®¤ä¸º1
                // åŠ¨æ€è®¡ç®—è¿éŸ³çš„ç»“æŸä½ç½®
                const tupletEndPosition = (note.tripletTotal || 3) - 1;
                
                if (tripletPosition === 0) {
                    // è¿éŸ³å¼€å§‹ - æ˜¾ç¤ºå¯¹åº”æ•°å­—å’Œæ‹¬å·
                    const showNumber = tripletType === 'duplet_eighth' ? '2' : 
                                     tripletType === 'quadruplet_eighth' ? '4' : '3';
                    noteXML += `
          <tuplet type="start" number="${tripletNumber}" bracket="yes" show-number="${showNumber}" placement="above"/>`;
                    console.log(`  ğŸµ è¿éŸ³å¼€å§‹: ID=${tripletNumber}, ç±»å‹=${tripletType}, æ•°å­—=${showNumber}, ä½ç½®=${tripletPosition}`);
                } else if (tripletPosition === tupletEndPosition) {
                    // è¿éŸ³ç»“æŸï¼ˆæ”¯æŒä¸åŒè¿éŸ³æ•°é‡ï¼‰
                    noteXML += `
          <tuplet type="stop" number="${tripletNumber}"/>`;
                    console.log(`  ğŸµ è¿éŸ³ç»“æŸ: ID=${tripletNumber}, ç±»å‹=${tripletType}, ä½ç½®=${tripletPosition}`);
                }
                // ä¸­é—´çš„éŸ³ç¬¦ï¼ˆtripletPosition === 1ï¼‰ä¸éœ€è¦tupletæ ‡è®°
                
                // æ·»åŠ slurç»“æŸæ ‡è®°ï¼ˆå¦‚æœå‰ä¸€ä¸ªéŸ³ç¬¦æœ‰hammer-on/pull-off/slideï¼‰
                // å…è®¸slurä¸tieå…±å­˜ï¼Œä½¿ç”¨ä¸åŒçš„numberæ¥åŒºåˆ†
                if (needsSlurStop) {
                    // å¦‚æœæœ‰placementä¿¡æ¯ï¼Œæ·»åŠ åˆ°sluræ ‡ç­¾
                    const placementAttr = prevSlurPlacement ? ` placement="${prevSlurPlacement}"` : '';
                    noteXML += `
          <slur type="stop"${slurNumberAttr}${placementAttr}/>`;
                }
                
                // å¦‚æœå½“å‰éŸ³ç¬¦æœ‰slideï¼Œéœ€è¦å¼€å§‹glissando (ç°åœ¨åœ¨notationså†…å¤„ç†)
                if (forceGlissandoStart) {
                    noteXML += `
          <glissando type="start" line-type="solid" number="1"/>`;
                    console.log(`ğŸ¸ å¼€å§‹glissandoè¿æ¥åˆ°ä¸‹ä¸€ä¸ªéŸ³ç¬¦`);
                }
                
                // å¦‚æœå‰ä¸€ä¸ªéŸ³ç¬¦æœ‰slideï¼Œå½“å‰éŸ³ç¬¦éœ€è¦ç»“æŸglissando (ç°åœ¨åœ¨notationså†…å¤„ç†)
                if (needsGlissandoStop) {
                    noteXML += `
          <glissando type="stop" line-type="solid" number="1"/>`;
                    console.log(`ğŸ¸ ç»“æŸæ¥è‡ªå‰ä¸€ä¸ªéŸ³ç¬¦çš„glissandoè¿æ¥`);
                }
                
                // æ·»åŠ å…¶ä»–articulationæ ‡è®°ï¼ˆglissandoã€slide-inã€slide-outå·²ç»åœ¨notationsä¸­å¤„ç†äº†ï¼‰
                if (renderArticulation && articulation !== 'slide' && articulation !== 'glissando' && 
                    articulation !== 'slide-in' && articulation !== 'slide-out') {
                    // å¯¹äºéslide/glissandoçš„articulationï¼Œæ­£å¸¸å¤„ç†
                    noteXML += this.buildArticulationXML(articulation);
                    
                    // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ï¼šå¦‚æœéœ€è¦å¼ºåˆ¶åœ¨æ­¤éŸ³ç¬¦å¼€å¯æŠ€å·§slurï¼Œå¿…é¡»å†æ¬¡éªŒè¯æƒé™
                    // æ³¨æ„ï¼šslideä½¿ç”¨glissandoè€Œä¸æ˜¯slur
                    // ä½¿ç”¨number="2"é¿å…ä¸tieçš„numberå†²çª
                    
                    // å†æ¬¡æ£€æŸ¥ç”¨æˆ·æƒé™ï¼Œç¡®ä¿articulationè¢«å…è®¸
                    const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                    const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                    
                    let slurAllowed = false;
                    if (articulation === 'hammer-on' && hammerOnAllowed) {
                        slurAllowed = true;
                    } else if (articulation === 'pull-off' && pullOffAllowed) {
                        slurAllowed = true;
                    } else if (!['hammer-on', 'pull-off'].includes(articulation)) {
                        // åªå…è®¸hammer-on/pull-offç”Ÿæˆslurï¼Œå…¶ä»–æŠ€å·§ä¸€å¾‹ä¸ç”Ÿæˆ
                        slurAllowed = false;
                    }
                    
                    console.log(`ğŸ” buildNoteXMLå†…éƒ¨sluræƒé™æ£€æŸ¥: articulation=${articulation}, forceSlurStart=${forceSlurStart}, slurAllowed=${slurAllowed}`);
                    
                    // ğŸ”¥ æ·»åŠ å †æ ˆè¿½è¸ªä»¥æ‰¾å‡ºè°ƒç”¨æ¥æº
                    if (forceSlurStart && !slurAllowed) {
                        console.log(`âš ï¸ è­¦å‘Šï¼šå°è¯•ä¸ºä¸è¢«å…è®¸çš„${articulation}ç”Ÿæˆslurï¼`);
                        console.trace(`ğŸ“ è°ƒç”¨å †æ ˆè¿½è¸ª`);
                    }
                    
                    if (forceSlurStart && slurAllowed && articulation !== 'slide' && articulation !== 'glissando') {
                        // è®¡ç®—å½“å‰éŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘
                        const currentStemDirection = this.calculateStemDirection(octave, step);
                        let slurPlacement = '';

                        if (currentStemDirection && nextStemDirection) {
                            if (currentStemDirection === nextStemDirection) {
                                // ç¬¦å¹²æ–¹å‘ç›¸åŒï¼Œsluræ”¾åœ¨ç¬¦åº†çš„åæ–¹å‘
                                slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                            } else if (articulation === 'hammer-on') {
                                slurPlacement = ` placement="above"`;
                            } else if (articulation === 'pull-off') {
                                slurPlacement = ` placement="below"`;
                            } else {
                                slurPlacement = ` placement="above"`;
                            }
                        } else if (currentStemDirection) {
                            // å¦‚æœæ— æ³•ç¡®å®šä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦åº†æ–¹å‘ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™
                            slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                        } else {
                            // é»˜è®¤ä¸Šæ–¹
                            slurPlacement = ` placement="above"`;
                        }
                        
                        // ğŸ”¥ FORCED DEBUG: è®°å½•æ¯ä¸ªslurçš„ç”Ÿæˆ
                        console.log(`ğŸš¨ SLUR GENERATED at buildNoteXML-branch1: articulation=${articulation}, placement=${slurPlacement}`);
                        console.log(`ğŸš¨ User settings check: hammer-on allowed=${hammerOnAllowed}, pull-off allowed=${pullOffAllowed}`);
                        
                        // ğŸ”¥ æ–¹å‘é™åˆ¶æ£€æŸ¥ï¼šåŸºäºç”¨æˆ·é€‰æ‹©é˜»æ­¢ç‰¹å®šæ–¹å‘çš„slur
                        let shouldBlockByDirection = false;
                        
                        if (hammerOnAllowed && !pullOffAllowed) {
                            // åªé€‰æ‹©hammer-on: é˜»æ­¢æ‰€æœ‰ä¸‹è¡ŒäºŒåº¦çš„slur
                            if (interval < 0 && interval >= -2) {
                                shouldBlockByDirection = true;
                                console.log(`ğŸš« DIRECTION BLOCK (branch1): ç”¨æˆ·åªé€‰æ‹©hammer-onï¼Œé˜»æ­¢ä¸‹è¡ŒäºŒåº¦slur (${interval}åŠéŸ³)`);
                            }
                        } else if (!hammerOnAllowed && pullOffAllowed) {
                            // åªé€‰æ‹©pull-off: é˜»æ­¢æ‰€æœ‰ä¸Šè¡ŒäºŒåº¦çš„slur
                            if (interval > 0 && interval <= 2) {
                                shouldBlockByDirection = true;
                                console.log(`ğŸš« DIRECTION BLOCK (branch1): ç”¨æˆ·åªé€‰æ‹©pull-offï¼Œé˜»æ­¢ä¸Šè¡ŒäºŒåº¦slur (+${interval}åŠéŸ³)`);
                            }
                        }
                        
                        if (shouldBlockByDirection) {
                            console.log(`ğŸ”’ æ–¹å‘é™åˆ¶é˜»æ­¢slurç”Ÿæˆ: articulation=${articulation}, interval=${interval}`);
                            // å¼ºåˆ¶ä¸ç”Ÿæˆä»»ä½•slur XML
                        } else if (articulation === 'hammer-on' && hammerOnAllowed && interval > 0) {
                            // åªå…è®¸ä¸Šè¡Œhammer-onç”Ÿæˆslur
                            noteXML += `
          <slur type="start"${slurNumberAttr}${slurPlacement}/>`;
                            console.log(`âœ… ALLOWED: hammer-on slur generated for ascending interval ${interval}`);
                        } else if (articulation === 'pull-off' && pullOffAllowed && interval < 0) {
                            // åªå…è®¸ä¸‹è¡Œpull-offç”Ÿæˆslur
                            noteXML += `
          <slur type="start"${slurNumberAttr}${slurPlacement}/>`;
                            console.log(`âœ… ALLOWED: pull-off slur generated for descending interval ${interval}`);
                        } else {
                            console.log(`ğŸš« BLOCKED: slur blocked - articulation=${articulation}, interval=${interval}, hammerOnAllowed=${hammerOnAllowed}, pullOffAllowed=${pullOffAllowed}`);
                        }
                    }
                }
                
                noteXML += `
        </notations>`;
            }
        } else if (tied && tieType) {
            // ğŸµ éä¸‰è¿éŸ³ä½†æœ‰è¿éŸ³å¼§çš„éŸ³ç¬¦ï¼Œå•ç‹¬æ·»åŠ notations
            noteXML += `
        <notations>`;
            if (tieType === 'continue') {
                // ä¸­é—´éŸ³ç¬¦éœ€è¦åŒæ—¶æœ‰stopå’Œstartçš„è§†è§‰æ•ˆæœ
                noteXML += `
          <tied type="stop"${tieNumber ? ` number="${tieNumber}"` : ''}/>
          <tied type="start"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
            } else {
                noteXML += `
          <tied type="${tieType}"${tieNumber ? ` number="${tieNumber}"` : ''}/>`;
            }
            
            // æ·»åŠ slurç»“æŸæ ‡è®°ï¼ˆå¦‚æœå‰ä¸€ä¸ªéŸ³ç¬¦æœ‰hammer-on/pull-off/slideï¼‰
            // å…è®¸slurä¸tieå…±å­˜ï¼Œä½¿ç”¨ä¸åŒçš„numberæ¥åŒºåˆ†
            if (needsSlurStop) {
                // å¦‚æœæœ‰placementä¿¡æ¯ï¼Œæ·»åŠ åˆ°sluræ ‡ç­¾
                const placementAttr = prevSlurPlacement ? ` placement="${prevSlurPlacement}"` : '';
                noteXML += `
          <slur type="stop"${slurNumberAttr}${placementAttr}/>`;
            }
            
            // OSMDé™åˆ¶ï¼šglissandoä¸è¢«æ”¯æŒï¼Œä¿ç•™æ ‡ç­¾ç”¨äºæœªæ¥å…¼å®¹æ€§
            if (forceGlissandoStart) {
                noteXML += `
          <glissando type="start" line-type="solid" number="1"/>`;
                console.log(`âš ï¸ OSMDä¸ç¨³å®šæ”¯æŒglissandoï¼Œå·²ä¿ç•™glissandoæ ‡ç­¾`);
            }
            
            if (needsGlissandoStop) {
                noteXML += `
          <glissando type="stop" line-type="solid" number="1"/>`;
                console.log(`âš ï¸ glissando stopæ ‡ç­¾å·²æ·»åŠ ï¼ˆOSMDæš‚ä¸æ”¯æŒï¼‰`);
            }
            
            // OSMDä¸æ”¯æŒslide-in/slide-outçš„glissandoæ¸²æŸ“
            if (articulation === 'slide-in') {
                // Slide-inä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å±‚ï¼Œé¿å…å•ç«¯glissandoè§¦å‘è§£æå…¼å®¹é—®é¢˜
                console.log(`ğŸ¸ Slide-in: ç”±è‡ªå®šä¹‰æ¸²æŸ“å±‚ç»˜åˆ¶ï¼Œä¸å†™å…¥å•ç«¯glissandoæ ‡ç­¾`);
            } else if (articulation === 'slide-out') {
                // Slide-outä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å±‚ï¼Œé¿å…å•ç«¯glissandoè§¦å‘è§£æå…¼å®¹é—®é¢˜
                console.log(`ğŸ¸ Slide-out: ç”±è‡ªå®šä¹‰æ¸²æŸ“å±‚ç»˜åˆ¶ï¼Œä¸å†™å…¥å•ç«¯glissandoæ ‡ç­¾`);
            }
            
            // æ·»åŠ articulationæ ‡è®°ï¼ˆglissandoã€slide-inã€slide-outå·²ç»åœ¨notationsä¸­å¤„ç†äº†ï¼‰
            if (renderArticulation && articulation !== 'glissando' && 
                articulation !== 'slide-in' && articulation !== 'slide-out') {
                noteXML += this.buildArticulationXML(articulation);
                
                // ğŸ”¥ ç¬¬ä¸‰ä¸ªslurç”Ÿæˆåˆ†æ”¯ï¼šä¸¥æ ¼æƒé™æ£€æŸ¥
                // ä½¿ç”¨number="2"é¿å…ä¸tieçš„numberå†²çª
                
                // å†æ¬¡æ£€æŸ¥ç”¨æˆ·æƒé™ï¼Œç¡®ä¿articulationè¢«å…è®¸
                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                
                let slurAllowed = false;
                if (articulation === 'hammer-on' && hammerOnAllowed) {
                    slurAllowed = true;
                } else if (articulation === 'pull-off' && pullOffAllowed) {
                    slurAllowed = true;
                } else if (!['hammer-on', 'pull-off'].includes(articulation)) {
                    // åªå…è®¸hammer-on/pull-offç”Ÿæˆslurï¼Œå…¶ä»–æŠ€å·§ä¸€å¾‹ä¸ç”Ÿæˆ
                    slurAllowed = false;
                }
                
                console.log(`ğŸ” buildNoteXMLç¬¬ä¸‰åˆ†æ”¯sluræƒé™æ£€æŸ¥: articulation=${articulation}, forceSlurStart=${forceSlurStart}, slurAllowed=${slurAllowed}`);
                
                if (forceSlurStart && slurAllowed) {
                    // è®¡ç®—å½“å‰éŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘ï¼Œå†³å®šslur placement
                    const currentStemDirection = this.calculateStemDirection(octave, step);
                    let slurPlacement = '';

                    if (currentStemDirection && nextStemDirection) {
                        if (currentStemDirection === nextStemDirection) {
                            // ç¬¦å¹²æ–¹å‘ç›¸åŒï¼Œsluræ”¾åœ¨ç¬¦å¹²çš„åæ–¹å‘
                            slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                        } else {
                            // å…œåº•ï¼šæ–¹å‘ä¸ä¸€è‡´æ—¶ç»Ÿä¸€æ”¾åœ¨ä¸Šæ–¹
                            slurPlacement = ` placement="above"`;
                        }
                    } else if (currentStemDirection) {
                        // å¦‚æœæ— æ³•ç¡®å®šä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™
                        slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                    }
                    
                    // ğŸ”¥ FORCED DEBUG: è®°å½•æ¯ä¸ªslurçš„ç”Ÿæˆ
                    console.log(`ğŸš¨ SLUR GENERATED at buildNoteXML-branch3: articulation=${articulation}, placement=${slurPlacement}`);
                    console.log(`ğŸš¨ User settings check: hammer-on allowed=${hammerOnAllowed}, pull-off allowed=${pullOffAllowed}`);
                    
                    // ğŸ”¥ æ–¹å‘é™åˆ¶æ£€æŸ¥ï¼šåŸºäºç”¨æˆ·é€‰æ‹©é˜»æ­¢ç‰¹å®šæ–¹å‘çš„slur
                    let shouldBlockByDirection3 = false;
                    
                    if (hammerOnAllowed && !pullOffAllowed) {
                        // åªé€‰æ‹©hammer-on: é˜»æ­¢æ‰€æœ‰ä¸‹è¡ŒäºŒåº¦çš„slur
                        if (interval < 0 && interval >= -2) {
                            shouldBlockByDirection3 = true;
                            console.log(`ğŸš« DIRECTION BLOCK (branch3): ç”¨æˆ·åªé€‰æ‹©hammer-onï¼Œé˜»æ­¢ä¸‹è¡ŒäºŒåº¦slur (${interval}åŠéŸ³)`);
                        }
                    } else if (!hammerOnAllowed && pullOffAllowed) {
                        // åªé€‰æ‹©pull-off: é˜»æ­¢æ‰€æœ‰ä¸Šè¡ŒäºŒåº¦çš„slur
                        if (interval > 0 && interval <= 2) {
                            shouldBlockByDirection3 = true;
                            console.log(`ğŸš« DIRECTION BLOCK (branch3): ç”¨æˆ·åªé€‰æ‹©pull-offï¼Œé˜»æ­¢ä¸Šè¡ŒäºŒåº¦slur (+${interval}åŠéŸ³)`);
                        }
                    }
                    
                    if (shouldBlockByDirection3) {
                        console.log(`ğŸ”’ æ–¹å‘é™åˆ¶é˜»æ­¢slurç”Ÿæˆ(branch3): articulation=${articulation}, interval=${interval}`);
                        // å¼ºåˆ¶ä¸ç”Ÿæˆä»»ä½•slur XML
                    } else if (articulation === 'hammer-on' && hammerOnAllowed && interval > 0) {
                        // åªå…è®¸ä¸Šè¡Œhammer-onç”Ÿæˆslur
                        noteXML += `
          <slur type="start"${slurNumberAttr}${slurPlacement}/>`;
                        console.log(`âœ… ALLOWED: hammer-on slur generated in branch3 for ascending interval ${interval}`);
                    } else if (articulation === 'pull-off' && pullOffAllowed && interval < 0) {
                        // åªå…è®¸ä¸‹è¡Œpull-offç”Ÿæˆslur
                        noteXML += `
          <slur type="start"${slurNumberAttr}${slurPlacement}/>`;
                        console.log(`âœ… ALLOWED: pull-off slur generated in branch3 for descending interval ${interval}`);
                    } else {
                        console.log(`ğŸš« BLOCKED: slur blocked in branch3 - articulation=${articulation}, interval=${interval}`);
                    }
                } else if (forceSlurStart && !slurAllowed) {
                    console.log(`ğŸ”’ buildNoteXMLç¬¬ä¸‰åˆ†æ”¯: ${articulation}ä¸è¢«å…è®¸ï¼Œè·³è¿‡slurç”Ÿæˆ`);
                }
            }
            
            noteXML += `
        </notations>`;
        } else if (renderArticulation || needsSlurStop || forceGlissandoStart || needsGlissandoStop) {
            // ä»…æœ‰articulationã€éœ€è¦ç»“æŸsluræˆ–å¤„ç†glissandoçš„æƒ…å†µ
            noteXML += `
        <notations>`;
            
            // æ·»åŠ slurç»“æŸæ ‡è®°
            // å…è®¸slurä¸tieå…±å­˜ï¼Œä½¿ç”¨ä¸åŒçš„numberæ¥åŒºåˆ†
            if (needsSlurStop) {
                // å¦‚æœæœ‰placementä¿¡æ¯ï¼Œæ·»åŠ åˆ°sluræ ‡ç­¾
                const placementAttr = prevSlurPlacement ? ` placement="${prevSlurPlacement}"` : '';
                noteXML += `
          <slur type="stop"${slurNumberAttr}${placementAttr}/>`;
            }
            
            // Glissandoå®ç°ï¼šä»…ä½¿ç”¨æ ‡å‡†glissandoï¼Œé¿å…é¢å¤–sluré€ æˆè¯¯åˆ¤
            if (forceGlissandoStart) {
                noteXML += `
          <glissando type="start" line-type="solid" number="1"/>`;
                console.log(`ğŸ¸ æ·»åŠ æ ‡å‡†glissando startæ ‡ç­¾ (number=1)`);
            }
            
            if (needsGlissandoStop) {
                noteXML += `
          <glissando type="stop" line-type="solid" number="1"/>`;
                console.log(`ğŸ¸ æ·»åŠ æ ‡å‡†glissando stopæ ‡ç­¾ (number=1)`);
            }
            
            // Slide-in/slide-outå®ç° - å«å¤‡ç”¨æ–¹æ¡ˆ
            if (articulation === 'slide-in') {
                // slide-in: ç”±æ¸²æŸ“åè‡ªå®šä¹‰å›¾å±‚ç»˜åˆ¶ï¼Œé¿å…å•ç«¯æ ‡ç­¾å…¼å®¹é—®é¢˜
                console.log(`ğŸ¸ Slide-in: ä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å±‚ç»˜åˆ¶`);
            } else if (articulation === 'slide-out') {
                // slide-out: ç”±æ¸²æŸ“åè‡ªå®šä¹‰å›¾å±‚ç»˜åˆ¶ï¼Œé¿å…å•ç«¯æ ‡ç­¾å…¼å®¹é—®é¢˜
                console.log(`ğŸ¸ Slide-out: ä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å±‚ç»˜åˆ¶`);
            }
            
            // æ·»åŠ articulationæ ‡è®°ï¼ˆglissandoã€slide-inã€slide-outå·²ç»åœ¨notationsä¸­å¤„ç†äº†ï¼‰
            if (renderArticulation && articulation !== 'glissando' && 
                articulation !== 'slide-in' && articulation !== 'slide-out') {
                noteXML += this.buildArticulationXML(articulation);
                // ğŸ”¥ ç¬¬äºŒä¸ªslurç”Ÿæˆåˆ†æ”¯ï¼šå†æ¬¡ä¸¥æ ¼æ£€æŸ¥æƒé™
                // å…è®¸slurä¸tieå…±å­˜ï¼Œä½¿ç”¨ä¸åŒçš„numberæ¥åŒºåˆ†
                
                // å†æ¬¡æ£€æŸ¥ç”¨æˆ·æƒé™ï¼Œç¡®ä¿articulationè¢«å…è®¸
                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                
                let slurAllowed = false;
                if (articulation === 'hammer-on' && hammerOnAllowed) {
                    slurAllowed = true;
                } else if (articulation === 'pull-off' && pullOffAllowed) {
                    slurAllowed = true;
                } else if (!['hammer-on', 'pull-off'].includes(articulation)) {
                    // åªå…è®¸hammer-on/pull-offç”Ÿæˆslurï¼Œå…¶ä»–æŠ€å·§ä¸€å¾‹ä¸ç”Ÿæˆ
                    slurAllowed = false;
                }
                
                console.log(`ğŸ” buildNoteXMLç¬¬äºŒåˆ†æ”¯sluræƒé™æ£€æŸ¥: articulation=${articulation}, forceSlurStart=${forceSlurStart}, slurAllowed=${slurAllowed}`);
                
                if (forceSlurStart && slurAllowed) {
                    // è®¡ç®—å½“å‰éŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘ï¼Œå†³å®šslur placement
                    const currentStemDirection = this.calculateStemDirection(octave, step);
                    let slurPlacement = '';

                    if (currentStemDirection && nextStemDirection) {
                        if (currentStemDirection === nextStemDirection) {
                            // ç¬¦å¹²æ–¹å‘ç›¸åŒï¼Œsluræ”¾åœ¨ç¬¦å¹²çš„åæ–¹å‘
                            slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                        } else {
                            // å…œåº•ï¼šæ–¹å‘ä¸ä¸€è‡´æ—¶ç»Ÿä¸€æ”¾åœ¨ä¸Šæ–¹
                            slurPlacement = ` placement="above"`;
                        }
                    } else if (currentStemDirection) {
                        // å¦‚æœæ— æ³•ç¡®å®šä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„ç¬¦å¹²æ–¹å‘ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™
                        slurPlacement = ` placement="${currentStemDirection === 'up' ? 'below' : 'above'}"`;
                    }
                    
                    // ğŸ”¥ FORCED DEBUG: è®°å½•æ¯ä¸ªslurçš„ç”Ÿæˆ
                    console.log(`ğŸš¨ SLUR GENERATED at buildNoteXML-branch2: articulation=${articulation}, placement=${slurPlacement}`);
                    console.log(`ğŸš¨ User settings check: hammer-on allowed=${hammerOnAllowed}, pull-off allowed=${pullOffAllowed}`);
                    
                    // ğŸ”¥ FORCED CHECK: å¦‚æœæ˜¯pull-offä¸”ä¸è¢«å…è®¸ï¼Œå¼ºåˆ¶é˜»æ­¢
                    if (articulation === 'pull-off' && !pullOffAllowed) {
                        console.log(`ğŸš« FORCED BLOCK: pull-off slurè¢«å¼ºåˆ¶é˜»æ­¢åœ¨branch2ï¼`);
                    } else {
                        noteXML += `
          <slur type="start"${slurNumberAttr}${slurPlacement}/>`;
                    }
                } else if (forceSlurStart && !slurAllowed) {
                    console.log(`ğŸ”’ buildNoteXMLç¬¬äºŒåˆ†æ”¯: ${articulation}ä¸è¢«å…è®¸ï¼Œè·³è¿‡slurç”Ÿæˆ`);
                }
            }
            
            noteXML += `
        </notations>`;
        }
        
        noteXML += `
      </note>`;
        
        // å¦‚æœæœ‰grace noteï¼Œéœ€è¦å°†grace noteå’Œä¸»éŸ³ç¬¦éƒ½åŒ…å«åœ¨è¿”å›ç»“æœä¸­
        const finalXML = fullNoteXML + noteXML;
        
        // è°ƒè¯•ï¼šå¦‚æœåŒ…å«glissandoï¼Œè¾“å‡ºå®Œæ•´çš„note XMLç”¨äºæ£€æŸ¥
        if (finalXML.includes('<glissando') || articulation === 'slide-in' || articulation === 'slide-out' || articulation === 'glissando') {
            console.log(`ğŸ” DEBUG: åŒ…å«glissandoçš„å®Œæ•´note XML:`, finalXML);
            console.log(`ğŸ” DEBUG: articulationç±»å‹:`, articulation);
        }
        
        // è¿”å›XMLå’ŒslurPlacementï¼ˆå¦‚æœæœ‰ï¼‰
        const result = { xml: finalXML };
        
        // å¦‚æœå½“å‰éŸ³ç¬¦æœ‰hammer-onæˆ–pull-offï¼Œéœ€è¦è¿”å›slurPlacement
        if (articulation === 'hammer-on' || articulation === 'pull-off') {
            // æ ¹æ®æ—‹å¾‹æ–¹å‘å†³å®šslur placement
            if (articulation === 'hammer-on') {
                result.slurPlacement = 'above'; // ä¸Šè¡Œæ—‹å¾‹ï¼Œsluråœ¨ä¸Šæ–¹
                console.log(`ğŸ¸ Hammer-on (ä¸Šè¡Œ): sluråœ¨ä¸Šæ–¹`);
            } else if (articulation === 'pull-off') {
                result.slurPlacement = 'below'; // ä¸‹è¡Œæ—‹å¾‹ï¼Œsluråœ¨ä¸‹æ–¹
                console.log(`ğŸ¸ Pull-off (ä¸‹è¡Œ): sluråœ¨ä¸‹æ–¹`);
            }
        }
        
        return result;
    }

    /**
     * æ„å»ºarticulationçš„XMLæ ‡è®°
     * @param {string} articulation - æ¼”å¥æ³•ç±»å‹
     * @param {object} options - é¢å¤–é€‰é¡¹ {isStart, isStop, noteData}
     */
    buildArticulationXML(articulation, options = {}) {
        let xml = '';
        const { isStart = false, isStop = false, noteData = null } = options;
        
        // åŸºæœ¬articulationæ˜ å°„
        const basicArticulations = {
            'staccato': '<articulations><staccato/></articulations>',
            'accent': '<articulations><accent/></articulations>'
        };
        
        // å¯¹äºhammer-onå’Œpull-offï¼Œæ·»åŠ æ–‡å­—æ ‡è®°
        // åŒæ—¶é€šè¿‡sluræ¥è¡¨ç¤ºè¿æ¥å…³ç³»
        if (articulation === 'hammer-on') {
            // æ·»åŠ "H"æ–‡å­—æ ‡è®°
            xml = `
          <articulations>
            <other-articulation>H</other-articulation>
          </articulations>`;
            console.log(`ğŸ¸ hammer-on: æ·»åŠ Hæ ‡è®°ï¼Œsluråœ¨åˆ«å¤„å¤„ç†`);
            return xml;
        } else if (articulation === 'pull-off') {
            // æ·»åŠ "P"æ–‡å­—æ ‡è®°
            xml = `
          <articulations>
            <other-articulation>P</other-articulation>
          </articulations>`;
            console.log(`ğŸ¸ pull-off: æ·»åŠ Pæ ‡è®°ï¼Œsluråœ¨åˆ«å¤„å¤„ç†`);
            return xml;
        }
        
        // Acciaccatura (çŸ­å€šéŸ³) - éœ€è¦ç‰¹æ®Šå¤„ç†
        // æ³¨æ„ï¼šè¿™éœ€è¦åœ¨éŸ³ç¬¦ä¹‹å‰ä½œä¸ºgrace noteå¤„ç†ï¼Œè€Œä¸æ˜¯ä½œä¸ºarticulation
        if (articulation === 'acciaccatura') {
            // Acciaccaturaåº”è¯¥åœ¨buildNoteXMLä¸­ç‰¹æ®Šå¤„ç†ä¸ºgrace note
            console.log(`ğŸµ acciaccatura: éœ€è¦ä½œä¸ºgrace noteå¤„ç†`);
            return '';
        }
        
        // Glissando ç°åœ¨å®Œå…¨åœ¨ buildNoteXML çš„ notations å—ä¸­å¤„ç†
        // è¿™é‡Œä¸å†å¤„ç†glissandoï¼Œé¿å…è¿åMusicXMLè§„èŒƒ
        if (articulation === 'glissando') {
            console.log(`ğŸ¸ Glissando: å·²åœ¨notationsä¸­å¤„ç†ï¼Œè·³è¿‡articulationså¤„ç†`);
            return '';
        }
        
        // Slide In/Out ç°åœ¨å®Œå…¨åœ¨ buildNoteXML çš„ notations å—ä¸­å¤„ç†
        // è¿™é‡Œä¸å†å¤„ç†slide-in/slide-outï¼Œé¿å…é‡å¤å¤„ç†
        if (articulation === 'slide-in') {
            console.log(`ğŸ¸ Slide In: å·²åœ¨notationsä¸­å¤„ç†ï¼Œè·³è¿‡articulationså¤„ç†`);
            return '';
        }
        
        if (articulation === 'slide-out') {
            console.log(`ğŸ¸ Slide Out: å·²åœ¨notationsä¸­å¤„ç†ï¼Œè·³è¿‡articulationså¤„ç†`);
            return '';
        }
        
        // é€‰æ‹©åˆé€‚çš„XMLæ ‡è®°
        if (basicArticulations[articulation]) {
            xml = '\n          ' + basicArticulations[articulation];
            console.log(`ğŸ¼ ç”ŸæˆåŸºæœ¬æ¼”å¥æ³•XML: ${articulation}`);
        } else if (articulation) {
            console.log(`âš ï¸ æœªçŸ¥æ¼”å¥æ³•: ${articulation}`);
        }
        
        return xml;
    }
    
    /**
     * æ„å»ºä¼‘æ­¢ç¬¦XML
     */
    buildRestXML(rest) {
        const { duration, beats, isTriplet, tripletType, tripletPosition, tripletTotal } = rest;
        
        console.log(`ç”Ÿæˆä¼‘æ­¢ç¬¦XML: duration=${duration}, beats=${beats}, isTriplet=${isTriplet}, clef=${this.config.clef}`);
        const durationValue = this.getDurationDivisions(duration, beats);
        
        let restXML = `
      <note>`;
        
        // å…¨éŸ³ç¬¦ä¼‘æ­¢ç¬¦çš„ç‰¹æ®Šå¤„ç†
        if (duration === 'whole' && beats >= 4) {
            // å…¨å°èŠ‚ä¼‘æ­¢ç¬¦ - æ ¹æ®è°±å·è®¾ç½®ä½ç½®ä¿¡æ¯
            const clef = this.config.clef || 'treble';
            let measureRestPosition = '';
            
            // å…¨å°èŠ‚ä¼‘æ­¢ç¬¦æ°¸è¿œæŒ‚åœ¨ç¬¬å››çº¿ä¸‹æ–¹ï¼Œä¸è°±å·æ— å…³
            measureRestPosition = '<line>4</line>';
            
            restXML += `
        <rest measure="yes">
            ${measureRestPosition}
        </rest>
        <duration>${durationValue}</duration>`;
            console.log(`ç”Ÿæˆå…¨å°èŠ‚ä¼‘æ­¢ç¬¦ (measure rest) - ${clef}è°±å·`);
        } else {
            // æ™®é€šä¼‘æ­¢ç¬¦
            const cleanDuration = duration.replace('.', '');
            restXML += `
        <rest>`;
            
            // ä¼‘æ­¢ç¬¦ä½ç½®ä¸è°±å·æ— å…³ï¼Œåªæ ¹æ®äº”çº¿è°±çº¿æ¡ç¼–å·ç¡®å®š
            // ä½¿ç”¨MusicXMLçš„<line>å…ƒç´ ç›´æ¥æŒ‡å®šçº¿æ¡ä½ç½®ï¼ˆä»åº•éƒ¨å¼€å§‹è®¡æ•°ï¼‰
            let restPosition = '';
            
            switch(cleanDuration) {
                case 'whole':
                    // å…¨ä¼‘æ­¢ç¬¦æ°¸è¿œæŒ‚åœ¨ç¬¬å››çº¿ä¸‹æ–¹ï¼ˆçº¿æ¡ç¼–å·ä¸º4ï¼‰
                    restPosition = '<line>4</line>';
                    break;
                case 'half':
                    // äºŒåˆ†ä¼‘æ­¢ç¬¦æ°¸è¿œé¡¶åœ¨ç¬¬ä¸‰çº¿ä¸Šæ–¹ï¼ˆçº¿æ¡ç¼–å·ä¸º3ï¼‰
                    restPosition = '<line>3</line>';
                    break;
                case 'quarter':
                case 'eighth':
                case 'sixteenth':
                case '16th':
                default:
                    // å…¶ä»–ä¼‘æ­¢ç¬¦éƒ½åœ¨ç¬¬ä¸‰çº¿åŒºåŸŸï¼ˆçº¿æ¡ç¼–å·ä¸º3ï¼‰
                    restPosition = '<line>3</line>';
                    break;
            }
            
            restXML += restPosition;
            
            restXML += `</rest>
        <duration>${durationValue}</duration>
        <type>${cleanDuration}</type>`;
            
            // é™„ç‚¹å¤„ç†
            if (duration.includes('.')) {
                restXML += `
        <dot/>`;
            }
            console.log(`ç”Ÿæˆæ™®é€šä¼‘æ­¢ç¬¦: ${duration}`);
        }
        
        // ä¸‰è¿éŸ³æ ‡è®°ï¼ˆä»…é€‚ç”¨äºéå…¨éŸ³ç¬¦ä¼‘æ­¢ç¬¦ï¼‰
        if (isTriplet && duration !== 'whole') {
            // ç»Ÿä¸€çš„è¿éŸ³å¤„ç†ï¼Œä¸éŸ³ç¬¦ä¿æŒä¸€è‡´
            const normalType = duration.replace('.', ''); // ç§»é™¤é™„ç‚¹æ ‡è®°
            
            // æ ¹æ®è¿éŸ³ç±»å‹è®¾ç½®æ­£ç¡®çš„æ—¶å€¼æ”¹å˜æ¯”ä¾‹
            let actualNotes, normalNotes;
            if (tripletType === 'duplet_eighth') {
                actualNotes = 2;
                normalNotes = 3;
            } else if (tripletType === 'quadruplet_eighth') {
                actualNotes = 4;
                normalNotes = 3;
            } else {
                actualNotes = 3;
                normalNotes = 2;
            }
            
            restXML += `
        <time-modification>
            <actual-notes>${actualNotes}</actual-notes>
            <normal-notes>${normalNotes}</normal-notes>
            <normal-type>${normalType}</normal-type>
        </time-modification>`;
            
            // æ·»åŠ notationsæ ‡è®°
            restXML += `
        <notations>`;
            
            const tripletNumber = rest.tripletId || 1; // ä½¿ç”¨å”¯ä¸€çš„ä¸‰è¿éŸ³IDï¼Œé»˜è®¤ä¸º1
            if (tripletPosition === 0) {
                // è¿éŸ³å¼€å§‹ - æ˜¾ç¤ºå¯¹åº”æ•°å­—å’Œæ‹¬å·
                const showNumber = tripletType === 'duplet_eighth' ? '2' : 
                                 tripletType === 'quadruplet_eighth' ? '4' : '3';
                restXML += `
            <tuplet type="start" number="${tripletNumber}" bracket="yes" show-number="${showNumber}" placement="above"/>`;
                console.log(`  ğŸµ ä¼‘æ­¢ç¬¦ä¸‰è¿éŸ³å¼€å§‹: ID=${tripletNumber}, ä½ç½®=${tripletPosition}`);
            } else if (tripletPosition === tripletTotal - 1) {
                // è¿éŸ³ç»“æŸ
                restXML += `
            <tuplet type="stop" number="${tripletNumber}"/>`;
                console.log(`  ğŸµ ä¼‘æ­¢ç¬¦è¿éŸ³ç»“æŸ: ID=${tripletNumber}, ç±»å‹=${tripletType}, ä½ç½®=${tripletPosition}`);
            }
            // ä¸­é—´çš„å…ƒç´ ï¼ˆtripletPosition === 1ï¼‰ä¸éœ€è¦tupletæ ‡è®°
            
            restXML += `
        </notations>`;
            
            console.log(`æ·»åŠ ä¸‰è¿éŸ³æ ‡è®°: ${tripletType}ä¸‰è¿éŸ³, ä½ç½®${tripletPosition}/${tripletTotal}`);
        }
        
        restXML += `
      </note>`;
        
        console.log(`ä¼‘æ­¢ç¬¦XMLç”Ÿæˆå®Œæˆ: ${duration}`);
        return restXML;
    }

    /**
     * è·å–beamä¿¡æ¯
     */
    getBeamInfo(beamGroups, noteIndex) {
        for (const group of beamGroups) {
            if (group.beamMap && group.beamMap[noteIndex]) {
                return group.beamMap[noteIndex];
            }
            if (Array.isArray(group.notes) && group.notes.includes(noteIndex)) {
                if (noteIndex === group.notes[0]) {
                    return 'begin';
                } else if (noteIndex === group.notes[group.notes.length - 1]) {
                    return 'end';
                } else {
                    return 'continue';
                }
            }
        }
        return null;
    }
    
    /**
     * è®¡ç®—ç¬¦å¹²æ–¹å‘
     */
    calculateStemDirection(octave, step) {
        // æ ¹æ®éŸ³é«˜å†³å®šç¬¦å¹²æ–¹å‘
        // B4åŠä»¥ä¸Šå‘ä¸‹ï¼ŒB4ä»¥ä¸‹å‘ä¸Š
        const noteValue = octave * 7 + ['C', 'D', 'E', 'F', 'G', 'A', 'B'].indexOf(step);
        const middleB = 4 * 7 + 6; // B4çš„æ•°å€¼
        
        if (noteValue >= middleB) {
            return 'down';
        } else {
            return 'up';
        }
    }
}

// ====== è¾…åŠ©è®°è°±æ˜¾ç¤ºï¼ˆç®€è°±/è‹±åï¼‰ ======
function collectMeasureNotes(melody) {
    if (!Array.isArray(melody)) return [];
    if (melody.length && melody[0] && melody[0].notes) {
        return melody.map(measure => Array.isArray(measure?.notes) ? measure.notes.filter(Boolean) : []);
    }
    return [melody.filter(item => !!item)];
}

function getReferenceTonicMidi(noteMidi, keySignature) {
    const keyInfo = KEY_SIGNATURES[keySignature];
    const tonicPc = keyInfo && typeof keyInfo.tonic === 'number'
        ? keyInfo.tonic
        : (KEY_SCALES[keySignature]?.[0] ?? 0);
    if (typeof noteMidi !== 'number') return null;
    const approxOctave = Math.round((noteMidi - tonicPc) / 12);
    return tonicPc + approxOctave * 12;
}

function formatJianpuToken(note, keySignature) {
    if (!note) return '';
    if (note.type === 'rest') return '0';
    if (typeof note.midi !== 'number') return '';

    const applyOctaveDots = (digitText, offset) => {
        if (!offset) return digitText;
        if (offset > 0) {
            // ä¸Šæ–¹ç”¨å¯è§çš„ç‹¬ç«‹ç‚¹å­—ç¬¦
            const above = 'Ë™'.repeat(offset); // U+02D9 modifier letter dot above
            return `${above}${digitText}`;
        }
        const count = Math.abs(offset);
        // ä¸‹æ–¹ï¼šé™„åŠ ç»„åˆç‚¹å¹¶è¿½åŠ å¸¸è§„ç‚¹å…œåº•æ˜¾ç¤º
        const combiningBelow = '\u0323'.repeat(count); // combining dot below
        const fallbackPlain = '.'.repeat(count);
        return `${digitText}${combiningBelow}${fallbackPlain}`;
    };

    const pitchClass = ((note.midi % 12) + 12) % 12;
    const scale = KEY_SCALES[keySignature] || KEY_SCALES['C'];

    let degreeIndex = scale.indexOf(pitchClass);
    let accidental = '';

    if (degreeIndex === -1) {
        const sharpBase = scale.findIndex(pc => ((pc + 1) % 12) === pitchClass);
        const flatBase = scale.findIndex(pc => ((pc + 11) % 12) === pitchClass);

        if (sharpBase !== -1) {
            degreeIndex = sharpBase;
            accidental = '#';
        } else if (flatBase !== -1) {
            degreeIndex = flatBase;
            accidental = 'b';
        } else {
            return midiToNoteName(note.midi); // å…œåº•æ˜¾ç¤ºéŸ³å
        }
    }

    const referenceTonic = getReferenceTonicMidi(note.midi, keySignature);
    const octaveOffset = referenceTonic !== null
        ? Math.round((note.midi - referenceTonic) / 12)
        : 0;

    const digit = `${degreeIndex + 1}`;
    const dottedDigit = applyOctaveDots(digit, octaveOffset);

    return `${accidental}${dottedDigit}`;
}

function formatEnglishToken(note, keySignature) {
    if (!note) return '';
    if (note.type === 'rest') return 'Rest';
    if (typeof note.midi !== 'number') return '';

    const pitchClass = ((note.midi % 12) + 12) % 12;
    const spelledName = (typeof PROFESSIONAL_NOTATION_RULES !== 'undefined' && PROFESSIONAL_NOTATION_RULES.getCorrectSpelling)
        ? PROFESSIONAL_NOTATION_RULES.getCorrectSpelling(pitchClass, keySignature)
        : midiToNoteName(note.midi).replace(/\d+$/, '');
    return spelledName;
}

function buildNotationString(measures, formatter, keySignature) {
    return measures
        .map(measure => (measure || [])
            .map(note => formatter(note, keySignature))
            .filter(token => token !== '')
            .join(' ')
        )
        .filter(part => part.length > 0)
        .join(' | ');
}

function updateNotationPanel(melodyData = null) {
    if (melodyData) {
        lastRenderedMelodyData = melodyData;
    }

    // ä»…ç”¨äºè®°å½•æœ€æ–°æ—‹å¾‹ï¼›ç®€è°±/è‹±åç°åœ¨ç›´æ¥æ¸²æŸ“åˆ°è°±é¢ï¼Œæ— éœ€é¢å¤–å®¹å™¨
}

function rerenderLatestScore() {
    if (lastRenderedMelodyData) {
        renderScore(lastRenderedMelodyData);
    }
}

function annotateMusicXML(musicXML, melodyData, options = {}) {
    const { showJianpu, showEnglish } = options;
    if (!showJianpu && !showEnglish) return musicXML;
    if (!melodyData || !Array.isArray(melodyData.melody)) return musicXML;

    const keySignature = melodyData.config?.keySignature || 'C';
    const noteSequence = [];

    melodyData.melody.forEach(measure => {
        if (measure && Array.isArray(measure.notes)) {
            measure.notes.forEach(n => noteSequence.push(n));
        }
    });

    let noteIndex = 0;

    return musicXML.replace(/<note>[\s\S]*?<\/note>/g, (match) => {
        const meta = noteSequence[noteIndex++] || null;
        if (!meta || meta.type === 'rest' || match.includes('<rest')) return match;

        let lyricBlocks = '';

        if (showJianpu) {
            const text = formatJianpuToken(meta, keySignature);
            if (text) {
                lyricBlocks += `
        <lyric number="1">
          <text>${text}</text>
        </lyric>`;
            }
        }

        if (showEnglish) {
            const text = formatEnglishToken(meta, keySignature);
            if (text) {
                lyricBlocks += `
        <lyric number="${showJianpu ? 2 : 1}">
          <text>${text}</text>
        </lyric>`;
            }
        }

        if (!lyricBlocks) return match;
        return match.replace('</note>', `${lyricBlocks}
</note>`);
    });
}

function flattenMelodyNotesForSlide(melodyData) {
    const flattened = [];
    if (!melodyData || !Array.isArray(melodyData.melody)) {
        return flattened;
    }

    melodyData.melody.forEach((measure, measureIndex) => {
        if (!measure || !Array.isArray(measure.notes)) return;
        measure.notes.forEach((note, noteIndex) => {
            if (!note || note.type !== 'note') return;
            flattened.push({ note, measureIndex, noteIndex });
        });
    });

    return flattened;
}

function getOSMDGraphicalNotePoints() {
    try {
        if (typeof osmd === 'undefined' || !osmd || !osmd.GraphicSheet) {
            return [];
        }

        const graphicSheet = osmd.GraphicSheet;
        const measureList = graphicSheet.measureList || graphicSheet.MeasureList || [];
        const unitToPx = (
            osmd.EngravingRules && typeof osmd.EngravingRules.UnitInPixels === 'number' && osmd.EngravingRules.UnitInPixels > 0
        ) ? osmd.EngravingRules.UnitInPixels * (osmd.zoom || 1) : (10 * (osmd.zoom || 1));

        const points = [];

        for (let measureIndex = 0; measureIndex < measureList.length; measureIndex++) {
            const bucket = measureList[measureIndex];
            const graphicalMeasures = Array.isArray(bucket) ? bucket : [bucket];

            for (const graphicalMeasure of graphicalMeasures) {
                if (!graphicalMeasure) continue;

                const staffEntries = graphicalMeasure.staffEntries || graphicalMeasure.StaffEntries || [];
                for (const staffEntry of staffEntries) {
                    const voiceEntries = staffEntry.graphicalVoiceEntries || staffEntry.GraphicalVoiceEntries || [];
                    let pickedPoint = null;

                    for (const voiceEntry of voiceEntries) {
                        const graphicalNotes = voiceEntry.notes || voiceEntry.Notes || [];
                        for (const graphicalNote of graphicalNotes) {
                            const sourceNote = graphicalNote.sourceNote || graphicalNote.SourceNote;
                            if (!sourceNote) continue;

                            const isRest = sourceNote.isRestFlag === true || sourceNote.pitch == null;
                            if (isRest) continue;

                            const noteLength = sourceNote.length || sourceNote.Length;
                            const realValue = noteLength && (noteLength.realValue ?? noteLength.RealValue);
                            if (typeof realValue === 'number' && realValue <= 0) continue; // å¿½ç•¥graceç­‰é›¶æ—¶å€¼éŸ³ç¬¦

                            const bbox = graphicalNote.boundingBox || graphicalNote.BoundingBox ||
                                graphicalNote.PositionAndShape || graphicalNote.positionAndShape;
                            const abs = bbox && (bbox.absolutePosition || bbox.AbsolutePosition || bbox.position || bbox.Position);
                            if (!abs) continue;
                            const size = bbox && (bbox.size || bbox.Size || bbox.extent || bbox.Extent);

                            const xLeft = (abs.x ?? abs.X ?? 0) * unitToPx;
                            const yBase = (abs.y ?? abs.Y ?? 0) * unitToPx;
                            const widthValue = size ? (size.width ?? size.x ?? size.X) : 0;
                            const heightValue = size ? (size.height ?? size.y ?? size.Y) : 0;
                            const noteHeadWidth = (typeof widthValue === 'number' && widthValue > 0)
                                ? widthValue * unitToPx
                                : 9.5 * (osmd.zoom || 1);
                            const noteHeadHeight = (typeof heightValue === 'number' && heightValue > 0)
                                ? heightValue * unitToPx
                                : 7.5 * (osmd.zoom || 1);
                            const x = xLeft;
                            const y = yBase + noteHeadHeight * 0.5;

                            if (!pickedPoint || x < pickedPoint.x) {
                                pickedPoint = { x, y, measureIndex, noteHeadWidth, noteHeadHeight };
                            }
                        }
                    }

                    if (pickedPoint) {
                        points.push(pickedPoint);
                    }
                }
            }
        }

        return points;
    } catch (error) {
        console.warn('âš ï¸ è·å–OSMDéŸ³ç¬¦åæ ‡å¤±è´¥:', error);
        return [];
    }
}

function clearCustomSlideLayer(scoreDiv) {
    const svg = scoreDiv ? scoreDiv.querySelector('svg') : null;
    if (!svg) return;
    const oldLayer = svg.querySelector('g[data-custom-slide-layer="true"]');
    if (oldLayer) oldLayer.remove();
}

function buildCustomSlideSegments(melodyData, notePoints) {
    const noteEntries = flattenMelodyNotesForSlide(melodyData);
    if (!noteEntries.length || !notePoints.length) {
        return [];
    }

    const mappedCount = Math.min(noteEntries.length, notePoints.length);
    if (mappedCount < noteEntries.length) {
        console.warn(`âš ï¸ Slideæ˜ å°„ä¸å®Œæ•´: æ—‹å¾‹éŸ³ç¬¦=${noteEntries.length}, å¯ç”¨åæ ‡=${notePoints.length}`);
    }

    const mapped = [];
    for (let i = 0; i < mappedCount; i++) {
        mapped.push({
            note: noteEntries[i].note,
            point: notePoints[i],
            measureIndex: noteEntries[i].measureIndex,
            noteIndex: noteEntries[i].noteIndex
        });
    }

    const segments = [];
    const toAnchorPoint = (point) => ({
        x: point.x + CUSTOM_SLIDE_ANCHOR_OFFSET_X,
        y: point.y + CUSTOM_SLIDE_ANCHOR_OFFSET_Y
    });
    const estimateNoteHeadRadius = (point) => {
        const w = (typeof point?.noteHeadWidth === 'number' && point.noteHeadWidth > 0) ? point.noteHeadWidth : 9.5;
        const h = (typeof point?.noteHeadHeight === 'number' && point.noteHeadHeight > 0) ? point.noteHeadHeight : 7.5;
        const majorAxis = Math.max(w, h);
        return Math.max(4.5, Math.min(12, majorAxis * 0.45));
    };
    const moveOutsideNoteHead = (center, toward, radius, padding = CUSTOM_SLIDE_NOTE_GAP_PX) => {
        const dx = toward.x - center.x;
        const dy = toward.y - center.y;
        const length = Math.hypot(dx, dy);
        if (length < 0.001) {
            return { x: center.x + radius + padding, y: center.y };
        }
        const factor = (radius + padding) / length;
        return {
            x: center.x + dx * factor,
            y: center.y + dy * factor
        };
    };

    for (let i = 0; i < mapped.length; i++) {
        const current = mapped[i];
        const articulation = current.note.articulation;
        if (!articulation) continue;
        const currentAnchor = toAnchorPoint(current.point);
        const currentRadius = estimateNoteHeadRadius(current.point);

        if (articulation === 'glissando') {
            const next = mapped[i + 1];
            if (!next) continue;

            const measureNotes = melodyData?.melody?.[current.measureIndex]?.notes;
            const immediateNextRaw = Array.isArray(measureNotes) ? measureNotes[current.noteIndex + 1] : null;
            const isImmediateAdjacentPair = immediateNextRaw && immediateNextRaw.type === 'note' && immediateNextRaw === next.note;
            if (!isImmediateAdjacentPair) continue;

            const nextAnchor = toAnchorPoint(next.point);
            const nextRadius = estimateNoteHeadRadius(next.point);

            const forwardDistance = next.point.x - current.point.x;
            if (forwardDistance < 12) continue; // é¿å…è·¨è¡Œæˆ–åå‘è¿æ¥å¯¼è‡´é”™è¯¯çº¿æ¡

            const startPoint = moveOutsideNoteHead(currentAnchor, nextAnchor, currentRadius);
            const endPoint = moveOutsideNoteHead(nextAnchor, currentAnchor, nextRadius);
            if (endPoint.x - startPoint.x < 4) continue;

            segments.push({
                type: 'glissando',
                d: `M ${startPoint.x.toFixed(2)} ${startPoint.y.toFixed(2)} L ${endPoint.x.toFixed(2)} ${endPoint.y.toFixed(2)}`
            });
            continue;
        }

        if (articulation === 'slide-in') {
            const rawStart = {
                x: currentAnchor.x - CUSTOM_SLIDE_IN_OUT_DIAGONAL_OFFSET_PX,
                y: currentAnchor.y + CUSTOM_SLIDE_IN_OUT_DIAGONAL_OFFSET_PX
            };
            const endPoint = moveOutsideNoteHead(currentAnchor, rawStart, currentRadius, CUSTOM_SLIDE_NOTE_GAP_PX);

            segments.push({
                type: 'slide-in',
                d: `M ${rawStart.x.toFixed(2)} ${rawStart.y.toFixed(2)} L ${endPoint.x.toFixed(2)} ${endPoint.y.toFixed(2)}`
            });
            continue;
        }

        if (articulation === 'slide-out') {
            const rawEnd = {
                x: currentAnchor.x + CUSTOM_SLIDE_IN_OUT_DIAGONAL_OFFSET_PX,
                y: currentAnchor.y + CUSTOM_SLIDE_IN_OUT_DIAGONAL_OFFSET_PX
            };
            const startPoint = moveOutsideNoteHead(currentAnchor, rawEnd, currentRadius, CUSTOM_SLIDE_NOTE_GAP_PX);

            segments.push({
                type: 'slide-out',
                d: `M ${startPoint.x.toFixed(2)} ${startPoint.y.toFixed(2)} L ${rawEnd.x.toFixed(2)} ${rawEnd.y.toFixed(2)}`
            });
        }
    }

    return segments;
}

function drawCustomSlideSegments(segments) {
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;

    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;

    clearCustomSlideLayer(scoreDiv);
    if (!segments.length) return;

    const svgNS = 'http://www.w3.org/2000/svg';
    const layer = document.createElementNS(svgNS, 'g');
    layer.setAttribute('data-custom-slide-layer', 'true');
    layer.setAttribute('class', 'custom-slide-layer');
    layer.setAttribute('pointer-events', 'none');

    segments.forEach((segment) => {
        const path = document.createElementNS(svgNS, 'path');
        path.setAttribute('d', segment.d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#1f2933');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');

        if (segment.type === 'glissando') {
            path.setAttribute('stroke-width', '1.4');
        } else {
            path.setAttribute('stroke-width', '1.6');
            path.setAttribute('stroke-dasharray', 'none');
        }

        layer.appendChild(path);
    });

    svg.appendChild(layer);
}

function renderCustomSlideOverlays(melodyData) {
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;

    clearCustomSlideLayer(scoreDiv);

    const noteEntries = flattenMelodyNotesForSlide(melodyData);
    const hasSlideArticulation = noteEntries.some(({ note }) =>
        note.articulation === 'glissando' ||
        note.articulation === 'slide-in' ||
        note.articulation === 'slide-out'
    );

    if (!hasSlideArticulation) return;

    const notePoints = getOSMDGraphicalNotePoints();
    const segments = buildCustomSlideSegments(melodyData, notePoints);
    drawCustomSlideSegments(segments);

    console.log(`ğŸ¸ è‡ªå®šä¹‰Slideæ¸²æŸ“å®Œæˆ: ${segments.length}æ¡`);
}

// ====== OSMDæ¸²æŸ“ç³»ç»Ÿ ======
async function initOSMD() {
    try {
        if (typeof opensheetmusicdisplay === 'undefined') {
            throw new Error('OpenSheetMusicDisplayæœªåŠ è½½');
        }

        console.log('ğŸµ åˆå§‹åŒ–OSMD - æç®€é…ç½®');
        
        // åˆ›å»ºOSMDå®ä¾‹ - æœ€ç®€åŒ–é…ç½®
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("score", {
            autoResize: true,
            backend: "vexflow",
            drawTitle: false,
            drawSubtitle: false,
            drawComposer: false,
            drawLyricist: false,
            drawCredits: false,
            drawPartNames: false
        });
        
        // å¯ç”¨glissandoæ¸²æŸ“å’Œç›¸å…³è®¾ç½®
        if (osmd.EngravingRules) {
            console.log('ğŸ” æ£€æŸ¥OSMDç‰ˆæœ¬å’ŒåŠŸèƒ½æ”¯æŒ:');
            console.log('  - OSMDç‰ˆæœ¬:', typeof osmd.Version !== 'undefined' ? osmd.Version : 'æœªçŸ¥');
            console.log('  - åç«¯å¼•æ“:', osmd.backendType || 'æœªçŸ¥');
            console.log('  - EngravingRuleså¯¹è±¡:', Object.keys(osmd.EngravingRules).filter(key => key.includes('Render')));
            
            // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„æ¸²æŸ“é€‰é¡¹
            const allRenderOptions = Object.keys(osmd.EngravingRules).filter(key => 
                key.startsWith('Render') || key.includes('Glissando') || key.includes('Slur')
            );
            console.log('  - æ‰€æœ‰æ¸²æŸ“ç›¸å…³é€‰é¡¹:', allRenderOptions);
            
            if ("RenderGlissandi" in osmd.EngravingRules) {
                osmd.EngravingRules.RenderGlissandi = true;
                console.log('âœ… å·²å¯ç”¨OSMD glissandoæ¸²æŸ“');
            } else {
                console.log('âŒ OSMDä¸æ”¯æŒRenderGlissandié€‰é¡¹');
                console.log('ğŸ” æ£€æŸ¥æ›¿ä»£é€‰é¡¹: RenderGlissandos, DrawGlissando, etc.');
                
                // æ£€æŸ¥å¯èƒ½çš„æ›¿ä»£åç§°
                const glissandoAlternatives = ['RenderGlissandos', 'DrawGlissando', 'ShowGlissando'];
                glissandoAlternatives.forEach(alt => {
                    if (alt in osmd.EngravingRules) {
                        osmd.EngravingRules[alt] = true;
                        console.log(`âœ… æ‰¾åˆ°å¹¶å¯ç”¨æ›¿ä»£é€‰é¡¹: ${alt}`);
                    }
                });
            }
            
            // å°è¯•å¯ç”¨æ‰€æœ‰å¯èƒ½ç›¸å…³çš„æ¸²æŸ“é€‰é¡¹
            const renderOptions = ['RenderSlurs', 'RenderArpeggios', 'RenderTies', 'RenderOrnaments', 'RenderArticulations'];
            renderOptions.forEach(option => {
                if (option in osmd.EngravingRules) {
                    osmd.EngravingRules[option] = true;
                    console.log(`âœ… å·²å¯ç”¨OSMD ${option}`);
                } else {
                    console.log(`âŒ OSMDä¸æ”¯æŒ${option}é€‰é¡¹`);
                }
            });
            
            console.log('ğŸ” OSMD EngravingRulesæœ€ç»ˆè®¾ç½®:');
            renderOptions.concat(['RenderGlissandi']).forEach(option => {
                if (option in osmd.EngravingRules) {
                    console.log(`  - ${option}: ${osmd.EngravingRules[option]}`);
                } else {
                    console.log(`  - ${option}: ä¸æ”¯æŒ`);
                }
            });
        }
        
        // éšè—æ ‡é¢˜å’Œä¹å™¨åç§°
        if (osmd.EngravingRules) {
            osmd.EngravingRules.drawTitle = false;
            osmd.EngravingRules.drawSubtitle = false;
            osmd.EngravingRules.drawComposer = false;
            osmd.EngravingRules.drawLyricist = false;
            osmd.EngravingRules.drawCredits = false;
            osmd.EngravingRules.drawPartNames = false;
            console.log('âœ… å·²éšè—æ ‡é¢˜å’Œä¹å™¨åç§°');
        }
        
        console.log('âœ… OSMDåˆå§‹åŒ–æˆåŠŸ');
        return osmd;
    } catch (error) {
        console.error('âŒ OSMDåˆå§‹åŒ–å¤±è´¥:', error);
        throw error;
    }
}

async function renderScore(melodyData) {
    console.log('ğŸ¨ å¼€å§‹OSMDæ¸²æŸ“ - æ–°ç­–ç•¥');
    
    const scoreDiv = document.getElementById('score');
    
    try {
        lastRenderedMelodyData = melodyData;

        // æ›´æ–°è¾…åŠ©è®°è°±æ˜¾ç¤ºï¼ˆç®€è°±/è‹±åï¼‰
        updateNotationPanel(melodyData);

        const jianpuEnabled = !!document.getElementById('jianpuToggle')?.checked;
        const englishEnabled = !!document.getElementById('englishNameToggle')?.checked;
        const xmlToLoad = annotateMusicXML(
            melodyData.musicXML,
            melodyData,
            { showJianpu: jianpuEnabled, showEnglish: englishEnabled }
        );

        // æ¸…ç†
        scoreDiv.innerHTML = '';
        if (osmd) {
            osmd.clear();
            osmd = null;
        }
        
        // è·å–å®¹å™¨å®é™…å®½åº¦
        const containerWidth = scoreDiv.clientWidth;
        console.log(`ğŸ“ å®¹å™¨å®½åº¦: ${containerWidth}px`);
        
        // è®¡ç®—æ€»å°èŠ‚æ•°
        const totalMeasures = melodyData.config.measures;
        console.log(`ğŸµ æ€»å°èŠ‚æ•°: ${totalMeasures}`);

        // è·å–å±å¹•å°ºå¯¸ç”¨äºæ‰‹æœºç«¯é€‚é…
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        console.log(`ğŸ“± å±å¹•å°ºå¯¸: ${screenWidth} x ${screenHeight}px`);
        
        // åˆ›å»ºOSMD - ç®€å•é…ç½®
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("score", {
            autoResize: true,
            backend: "vexflow",
            drawTitle: false,
            drawSubtitle: false,
            drawComposer: false,
            drawLyricist: false,
            drawCredits: false,
            drawPartNames: false
        });
        
        // å¯ç”¨glissandoæ¸²æŸ“å’Œç›¸å…³è®¾ç½®
        if (osmd.EngravingRules) {
            console.log('ğŸ” æ£€æŸ¥OSMDç‰ˆæœ¬å’ŒåŠŸèƒ½æ”¯æŒ:');
            console.log('  - OSMDç‰ˆæœ¬:', typeof osmd.Version !== 'undefined' ? osmd.Version : 'æœªçŸ¥');
            console.log('  - åç«¯å¼•æ“:', osmd.backendType || 'æœªçŸ¥');
            console.log('  - EngravingRuleså¯¹è±¡:', Object.keys(osmd.EngravingRules).filter(key => key.includes('Render')));
            
            // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„æ¸²æŸ“é€‰é¡¹
            const allRenderOptions = Object.keys(osmd.EngravingRules).filter(key => 
                key.startsWith('Render') || key.includes('Glissando') || key.includes('Slur')
            );
            console.log('  - æ‰€æœ‰æ¸²æŸ“ç›¸å…³é€‰é¡¹:', allRenderOptions);
            
            if ("RenderGlissandi" in osmd.EngravingRules) {
                osmd.EngravingRules.RenderGlissandi = true;
                console.log('âœ… å·²å¯ç”¨OSMD glissandoæ¸²æŸ“');
            } else {
                console.log('âŒ OSMDä¸æ”¯æŒRenderGlissandié€‰é¡¹');
                console.log('ğŸ” æ£€æŸ¥æ›¿ä»£é€‰é¡¹: RenderGlissandos, DrawGlissando, etc.');
                
                // æ£€æŸ¥å¯èƒ½çš„æ›¿ä»£åç§°
                const glissandoAlternatives = ['RenderGlissandos', 'DrawGlissando', 'ShowGlissando'];
                glissandoAlternatives.forEach(alt => {
                    if (alt in osmd.EngravingRules) {
                        osmd.EngravingRules[alt] = true;
                        console.log(`âœ… æ‰¾åˆ°å¹¶å¯ç”¨æ›¿ä»£é€‰é¡¹: ${alt}`);
                    }
                });
            }
            
            // å°è¯•å¯ç”¨æ‰€æœ‰å¯èƒ½ç›¸å…³çš„æ¸²æŸ“é€‰é¡¹
            const renderOptions = ['RenderSlurs', 'RenderArpeggios', 'RenderTies', 'RenderOrnaments', 'RenderArticulations'];
            renderOptions.forEach(option => {
                if (option in osmd.EngravingRules) {
                    osmd.EngravingRules[option] = true;
                    console.log(`âœ… å·²å¯ç”¨OSMD ${option}`);
                } else {
                    console.log(`âŒ OSMDä¸æ”¯æŒ${option}é€‰é¡¹`);
                }
            });
            
            console.log('ğŸ” OSMD EngravingRulesæœ€ç»ˆè®¾ç½®:');
            renderOptions.concat(['RenderGlissandi']).forEach(option => {
                if (option in osmd.EngravingRules) {
                    console.log(`  - ${option}: ${osmd.EngravingRules[option]}`);
                } else {
                    console.log(`  - ${option}: ä¸æ”¯æŒ`);
                }
            });
        }
        
        // éšè—æ ‡é¢˜å’Œä¹å™¨åç§°
        if (osmd.EngravingRules) {
            osmd.EngravingRules.drawTitle = false;
            osmd.EngravingRules.drawSubtitle = false;
            osmd.EngravingRules.drawComposer = false;
            osmd.EngravingRules.drawLyricist = false;
            osmd.EngravingRules.drawCredits = false;
            osmd.EngravingRules.drawPartNames = false;
            console.log('âœ… å·²éšè—æ ‡é¢˜å’Œä¹å™¨åç§°');
        }
        
        // åŠ è½½MusicXML
        console.log('ğŸ”„ å‡†å¤‡åŠ è½½MusicXMLåˆ°OSMD...');
        console.log('ğŸ“„ MusicXMLéªŒè¯ - é•¿åº¦:', xmlToLoad.length);
        console.log('ğŸ“„ MusicXMLå¼€å¤´:', xmlToLoad.substring(0, 100));
        
        try {
            await osmd.load(xmlToLoad);
            console.log('âœ… MusicXMLåŠ è½½æˆåŠŸ');
        } catch (loadError) {
            console.error('âŒ OSMD MusicXMLåŠ è½½å¤±è´¥:', loadError);
            console.error('ğŸ“„ å®Œæ•´MusicXMLå†…å®¹:');
            console.error(xmlToLoad);
            throw new Error(`OSMDåŠ è½½é”™è¯¯: ${loadError.message}`);
        }
        
          // ğŸ”‘ å¼ºåŠ›ç­–ç•¥ï¼šåŒæ—¶ä½¿ç”¨å¤šç§æ–¹æ³•ç¡®ä¿å¤šå°èŠ‚æ¯è¡Œ
        if (osmd.EngravingRules) {
            console.log('ğŸ¯ åº”ç”¨å¼ºåŠ›å¤šå°èŠ‚å¸ƒå±€...');
            
            // ç¬¬ä¸€å±‚ï¼šè®¾ç½®ç³»ç»Ÿå°èŠ‚æ•°é™åˆ¶ - æ‰‹æœºç«¯ç‰¹æ®Šå¤„ç†
            // æ³¨æ„ï¼šscreenWidthå·²åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜
            if (screenWidth <= 599) {
                // æ‰‹æœºç«¯ï¼šä¸¥æ ¼æ§åˆ¶æ¢è¡Œä½ç½®
                console.log('ğŸ¯ æ‰‹æœºç«¯ï¼šä¸¥æ ¼æ¢è¡Œæ§åˆ¶ç­–ç•¥');

                if (totalMeasures <= 4) {
                    // â‰¤4å°èŠ‚ï¼šå¼ºåˆ¶å•è¡Œæ˜¾ç¤ºï¼Œä¸æ¢è¡Œ
                    osmd.EngravingRules.MaxMeasuresPerSystem = totalMeasures;
                    osmd.EngravingRules.MinMeasuresPerSystem = totalMeasures;
                    if ("RenderXMeasuresPerLineAkaSystem" in osmd.EngravingRules) {
                        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = totalMeasures;
                    }
                    console.log(`ğŸ¯ â‰¤4å°èŠ‚æ¨¡å¼ï¼š${totalMeasures}å°èŠ‚å¼ºåˆ¶å•è¡Œï¼Œä¸å…è®¸æ¢è¡Œ`);
                } else {
                    // >4å°èŠ‚ï¼šä¸¥æ ¼4å°èŠ‚ä¸€è¡Œ
                    osmd.EngravingRules.MaxMeasuresPerSystem = 4;
                    osmd.EngravingRules.MinMeasuresPerSystem = 4;
                    if ("RenderXMeasuresPerLineAkaSystem" in osmd.EngravingRules) {
                        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = 4;
                    }
                    osmd.EngravingRules.CompactMode = true;
                    console.log(`ğŸ¯ >4å°èŠ‚æ¨¡å¼ï¼šä¸¥æ ¼æ¯è¡Œ4å°èŠ‚ï¼Œå¯ç”¨CompactMode + é¢å¤–ç¼©æ”¾`);
                }
            } else {
                // æ¡Œé¢ç«¯ï¼šåŒæ ·ä¸¥æ ¼æ§åˆ¶æ¢è¡Œä½ç½®
                console.log('ğŸ¯ æ¡Œé¢ç«¯ï¼šä¸¥æ ¼æ¢è¡Œæ§åˆ¶ç­–ç•¥');

                if (totalMeasures <= 4) {
                    // â‰¤4å°èŠ‚ï¼šå¼ºåˆ¶å•è¡Œæ˜¾ç¤ºï¼Œä¸æ¢è¡Œ
                    osmd.EngravingRules.MaxMeasuresPerSystem = totalMeasures;
                    osmd.EngravingRules.MinMeasuresPerSystem = totalMeasures;
                    if ("RenderXMeasuresPerLineAkaSystem" in osmd.EngravingRules) {
                        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = totalMeasures;
                    }
                    console.log(`ğŸ¯ â‰¤4å°èŠ‚æ¨¡å¼ï¼š${totalMeasures}å°èŠ‚å¼ºåˆ¶å•è¡Œï¼Œä¸å…è®¸æ¢è¡Œ`);
                } else {
                    // >4å°èŠ‚ï¼šä¸¥æ ¼4å°èŠ‚ä¸€è¡Œ
                    osmd.EngravingRules.MaxMeasuresPerSystem = 4;
                    osmd.EngravingRules.MinMeasuresPerSystem = 4;
                    if ("RenderXMeasuresPerLineAkaSystem" in osmd.EngravingRules) {
                        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = 4;
                    }
                    osmd.EngravingRules.CompactMode = true;
                    console.log(`ğŸ¯ >4å°èŠ‚æ¨¡å¼ï¼šä¸¥æ ¼æ¯è¡Œ4å°èŠ‚ï¼Œå¯ç”¨CompactMode + é¢å¤–ç¼©æ”¾`);
                }
            }
            
            // ç¬¬äºŒå±‚ï¼šå¯ç”¨MusicXMLæ¢è¡Œæ ‡è®°
            if ("NewSystemFromXMLNewSystemAttribute" in osmd.EngravingRules) {
                osmd.EngravingRules.NewSystemFromXMLNewSystemAttribute = true;  // æ”¹ä¸ºtrueä»¥æ”¯æŒMusicXMLæ¢è¡Œ
            }
            if ("NewSystemAtXMLNewSystemAttribute" in osmd.EngravingRules) {
                osmd.EngravingRules.NewSystemAtXMLNewSystemAttribute = true;  // æ”¹ä¸ºtrueä»¥æ”¯æŒMusicXMLæ¢è¡Œ
            }
            if ("NewSystemAtXMLNewSystem" in osmd.EngravingRules) {
                osmd.EngravingRules.NewSystemAtXMLNewSystem = true;  // å¯ç”¨<print new-system="yes"/>æ ‡è®°
                console.log('âœ… å¯ç”¨NewSystemAtXMLNewSystem - æ”¯æŒMusicXMLæ¢è¡Œæ ‡è®°');
            }
            
            // ç¬¬ä¸‰å±‚ï¼šè®¾ç½®åˆé€‚çš„è¾¹è·å’Œé—´è· - å‡å°è¾¹è·è®©ä¹è°±æ›´å¤§
            // è‡ªé€‚åº”è¾¹è· - æ‰‹æœºç«¯å’Œæ¨ªå±å®Œå…¨æ— ç•™ç™½
            // æ³¨æ„ï¼šscreenWidthå’ŒscreenHeightå·²åœ¨ä¸Šé¢å£°æ˜ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨
            const isLandscape = screenWidth > screenHeight && screenHeight <= 599; // æ¨ªå±ä¸”æ˜¯æ‰‹æœºè®¾å¤‡
            const isMobile = screenWidth <= 599 || isLandscape;
            
            if ("PageLeftMargin" in osmd.EngravingRules) {
                osmd.EngravingRules.PageLeftMargin = isMobile ? 1 : 6;
            }
            if ("PageRightMargin" in osmd.EngravingRules) {
                osmd.EngravingRules.PageRightMargin = isMobile ? 1 : 6;
            }
            if ("SystemLeftMargin" in osmd.EngravingRules) {
                osmd.EngravingRules.SystemLeftMargin = isMobile ? 0.5 : 6;
            }
            if ("SystemRightMargin" in osmd.EngravingRules) {
                osmd.EngravingRules.SystemRightMargin = isMobile ? 0.5 : 6;
            }
            
            // æ‰‹æœºç«¯å’Œæ¨ªå±é¢å¤–çš„é€‚ä¸­è¾¹è·è®¾ç½®
            if (isMobile) {
                console.log(`ğŸ“± ${isLandscape ? 'æ¨ªå±' : 'æ‰‹æœº'}è¾¹è·ä¼˜åŒ–ï¼šé€‚ä¸­è¾¹è·è®¾ç½®`);
                if ("PageTopMargin" in osmd.EngravingRules) {
                    osmd.EngravingRules.PageTopMargin = 0;
                }
                if ("PageBottomMargin" in osmd.EngravingRules) {
                    osmd.EngravingRules.PageBottomMargin = 0;
                }
                if ("TitleTopDistance" in osmd.EngravingRules) {
                    osmd.EngravingRules.TitleTopDistance = 0;
                }
                if ("TitleBottomDistance" in osmd.EngravingRules) {
                    osmd.EngravingRules.TitleBottomDistance = 0;
                }
                if ("SubtitleTopDistance" in osmd.EngravingRules) {
                    osmd.EngravingRules.SubtitleTopDistance = 0;
                }
            }
            
            // ç¬¬å››å±‚ï¼šè°ƒæ•´å°èŠ‚é—´è·
            if ("BetweenMeasuresDistance" in osmd.EngravingRules) {
                osmd.EngravingRules.BetweenMeasuresDistance = 15;
            }
            
            // ç¬¬äº”å±‚ï¼šè°ƒæ•´ç³»ç»Ÿé—´è·
            if ("SystemDistance" in osmd.EngravingRules) {
                osmd.EngravingRules.SystemDistance = 20;
            }

            // ç¬¬å…­å±‚ï¼šè®©æœ€åä¸€è¡Œæ‹‰ä¼¸å¡«æ»¡
            if ("StretchLastSystemLine" in osmd.EngravingRules) {
                osmd.EngravingRules.StretchLastSystemLine = true;
            }
            if ("JustifyLastSystem" in osmd.EngravingRules) {
                osmd.EngravingRules.JustifyLastSystem = true;
            }
            
            console.log(`âœ… å¼ºåŠ›å¸ƒå±€é…ç½®:`);
            console.log(`   - æ¯è¡Œç›®æ ‡å°èŠ‚æ•°: ${totalMeasures === 2 ? 2 : 4}`);
            console.log(`   - MinMeasuresPerSystem: ${osmd.EngravingRules.MinMeasuresPerSystem}`);
            console.log(`   - RenderXMeasuresPerLineAkaSystem: ${osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem}`);
        }
        // è®¾ç½®é€‚å½“çš„ç¼©æ”¾ - åŸºäºå±å¹•å¤§å°ã€æ–¹å‘å’Œæ—‹å¾‹é•¿åº¦è‡ªé€‚åº”
        // æ³¨æ„ï¼šscreenWidthå’ŒscreenHeightå·²åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨
        const isLandscape = screenWidth > screenHeight && screenHeight <= 599; // æ¨ªå±ä¸”æ˜¯æ‰‹æœºè®¾å¤‡

        let zoom;
        if (isLandscape) {
            // æ¨ªå±æ¨¡å¼ï¼šæ›´å¤§ç¼©æ”¾ï¼Œå……åˆ†åˆ©ç”¨æ°´å¹³ç©ºé—´
            zoom = 0.7;
            console.log(`ğŸ”„ æ¨ªå±è‡ªé€‚åº”ç¼©æ”¾: ${zoom} (å®½${screenWidth}px é«˜${screenHeight}px)`);
        } else if (screenWidth <= 360) {
            zoom = 0.35;  // æå°å±å¹• - æåº¦å°å‹åŒ–æ—‹å¾‹
        } else if (screenWidth <= 480) {
            zoom = 0.45;  // è¶…å°å±å¹• - è¶…å°å‹åŒ–æ—‹å¾‹
        } else if (screenWidth <= 599) {
            zoom = 0.55;  // å°å±å¹• - å°å‹åŒ–æ—‹å¾‹
        } else if (screenWidth <= 899) {
            zoom = 0.85;  // ä¸­ç­‰å±å¹• - é€‚ä¸­
        } else if (screenWidth <= 1200) {
            zoom = 1.4;   // å¤§å±å¹• - æ›´å¤§æ˜¾ç¤ºï¼Œå……åˆ†åˆ©ç”¨ç©ºé—´
        } else {
            zoom = 1.6;   // è¶…å¤§å±å¹• - æœ€å¤§æ˜¾ç¤º
        }

        // ğŸµ æ ¹æ®æ—‹å¾‹é•¿åº¦è¿›ä¸€æ­¥è°ƒæ•´ç¼©æ”¾ - ç¡®ä¿æ¢è¡Œç­–ç•¥æ­£ç¡®
        if (totalMeasures <= 4) {
            // â‰¤4å°èŠ‚ï¼šå¿…é¡»ä¿è¯å•è¡Œæ˜¾ç¤ºï¼Œé€‚åº¦é™åˆ¶ç¼©æ”¾
            if (screenWidth > 899) {
                // å¤§å±å¹•ä¸Šçš„4å°èŠ‚ä¹Ÿéœ€è¦æ§åˆ¶ç¼©æ”¾ï¼Œé¿å…è¿‡å®½
                const maxSafeZoom = screenWidth <= 1200 ? 0.9 : 1.0; // æ›´ä¿å®ˆçš„ç¼©æ”¾ï¼Œç¡®ä¿å•è¡Œæ˜¾ç¤º
                zoom = Math.min(zoom, maxSafeZoom);
                console.log(`ğŸ¯ 4å°èŠ‚å•è¡Œä¿æŠ¤: é™åˆ¶ç¼©æ”¾è‡³${zoom.toFixed(2)}ï¼Œé¿å…æ¢è¡Œ`);
            }
        } else {
            // >4å°èŠ‚ï¼šæ¯4å°èŠ‚ä¸€è¡Œï¼Œå…è®¸æ›´æ¿€è¿›çš„ç¼©æ”¾å‡å°‘
            const lengthFactor = Math.max(0.6, 1 - (totalMeasures - 4) * 0.08); // æ¯è¶…è¿‡4å°èŠ‚å‡å°‘8%ï¼Œæœ€å°60%
            zoom *= lengthFactor;
            console.log(`ğŸ¯ å¤šè¡Œæ—‹å¾‹è°ƒæ•´: ${totalMeasures}å°èŠ‚ -> ç¼©æ”¾å› å­${lengthFactor.toFixed(2)} -> æœ€ç»ˆç¼©æ”¾${zoom.toFixed(2)}`);
        }

        osmd.zoom = zoom;
        console.log(`ğŸ” æœ€ç»ˆè‡ªé€‚åº”ç¼©æ”¾: ${zoom.toFixed(2)} (å±å¹•å®½åº¦: ${screenWidth}px ${isLandscape ? 'æ¨ªå±' : 'ç«–å±'}, æ—‹å¾‹${totalMeasures}å°èŠ‚)`);
        
        // æ¸²æŸ“
        osmd.render();
        console.log('âœ… OSMDæ¸²æŸ“å®Œæˆ');
        renderCustomSlideOverlays(melodyData);
        setTimeout(() => renderCustomSlideOverlays(melodyData), 80);

        // ğŸ”’ ç«‹å³æ£€æŸ¥å¹¶åº”ç”¨éšè—çŠ¶æ€ï¼ˆé¿å…é—ªç°ï¼‰
        if (typeof isMelodyHidden !== 'undefined' && isMelodyHidden) {
            console.log('ğŸ”’ æ£€æµ‹åˆ°éšè—æ¨¡å¼ï¼Œç«‹å³éšè—å®¹å™¨å’ŒSVGï¼ˆé¿å…é—ªç°ï¼‰');

            // éšè—å®¹å™¨
            scoreDiv.style.opacity = '0';
            scoreDiv.style.filter = 'blur(10px)';

            // éšè—SVGå…ƒç´ 
            const svgElements = scoreDiv.querySelectorAll('svg');
            svgElements.forEach(svg => {
                svg.classList.add('melody-hidden');
                svg.style.opacity = '0';
                svg.style.filter = 'blur(10px)';
                svg.style.transition = 'none';
            });
            console.log('ğŸ”’ âœ… å®¹å™¨å’ŒSVGå·²ç«‹å³éšè—');
        }

        // æ£€æŸ¥å®é™…æ¸²æŸ“ç»“æœ
        setTimeout(() => {
            const svg = scoreDiv.querySelector('svg');
            if (svg) {
                const actualWidth = svg.getBBox ? svg.getBBox().width : svg.clientWidth;
                console.log(`ğŸ“Š å®é™…æ¸²æŸ“å®½åº¦: ${Math.round(actualWidth)}px`);
                
                // åˆ†æå°èŠ‚åˆ†å¸ƒ - ä½¿ç”¨æ­£ç¡®çš„é€‰æ‹©å™¨
                const allG = svg.querySelectorAll('g');
                let measureGroups = [];
                
                allG.forEach(g => {
                    const id = g.getAttribute('id') || '';
                    const className = g.getAttribute('class') || '';
                    
                    if (id.includes('MeasureContent') || className.includes('measure')) {
                        measureGroups.push(g);
                    }
                });
                
                console.log(`ğŸ“ æ¸²æŸ“äº†${measureGroups.length}ä¸ªå°èŠ‚`);
                
                if (measureGroups.length > 0) {
                    // æŒ‰Yåæ ‡åˆ†ç»„å°èŠ‚æ¥æ£€æŸ¥å¸ƒå±€
                    const rows = {};
                    measureGroups.forEach(g => {
                        const transform = g.getAttribute('transform') || '';
                        const parentTransform = g.parentElement?.getAttribute('transform') || '';
                        
                        // å°è¯•ä»transformè·å–Yåæ ‡
                        let y = 0;
                        const match = (transform + ' ' + parentTransform).match(/translate\([^,]+,\s*([^)]+)\)/);
                        if (match) {
                            y = Math.round(parseFloat(match[1]));
                        }
                        
                        // å°†Yåæ ‡è¿‘ä¼¼ç›¸åŒçš„å°èŠ‚åˆ†ä¸ºä¸€ç»„ï¼ˆå®¹å·®20pxï¼‰
                        let foundRow = false;
                        for (let rowY in rows) {
                            if (Math.abs(y - parseFloat(rowY)) < 20) {
                                rows[rowY].push(g);
                                foundRow = true;
                                break;
                            }
                        }
                        if (!foundRow) {
                            rows[y] = [g];
                        }
                    });
                    
                    // æŠ¥å‘Šæ¯è¡Œçš„å°èŠ‚æ•°
                    Object.keys(rows).sort((a, b) => parseFloat(a) - parseFloat(b)).forEach((y, index) => {
                        const count = rows[y].length;
                        console.log(`ğŸ“ ç¬¬${index + 1}è¡Œ: ${count} ä¸ªå°èŠ‚ ${count === 4 ? 'âœ…' : count === 2 && totalMeasures === 2 ? 'âœ…' : 'âŒ'}`);
                    });
                }
            }
        }, 500);
        
        // ä¸å†è®¾ç½®å“åº”å¼ç›‘å¬å™¨ï¼Œä¿æŒå›ºå®š4å°èŠ‚å¸ƒå±€
    } catch (error) {
        console.error('âŒ OSMDæ¸²æŸ“å¤±è´¥:', error);
        scoreDiv.innerHTML = `
            <div style="color: red; padding: 50px; text-align: center;">
                <h3>æ¸²æŸ“å¤±è´¥</h3>
                <p><strong>é”™è¯¯:</strong> ${error.message}</p>
                <p>è¯·æŸ¥çœ‹æ§åˆ¶å°äº†è§£è¯¦æƒ…</p>
            </div>
        `;
        throw error;
    }
}

/**
 * è®¾ç½®å“åº”å¼å¸ƒå±€ç›‘å¬å™¨
 */
function setupResponsiveLayout(melodyData) {
    // ç§»é™¤æ—§çš„ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (window.responsiveResizeHandler) {
        window.removeEventListener('resize', window.responsiveResizeHandler);
    }
    
    // é˜²æŠ–åŠ¨å‡½æ•°ï¼Œä¼˜åŒ–å®¹å™¨å®½åº¦æ£€æµ‹
    let resizeTimeout;
    window.responsiveResizeHandler = function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(async () => {
            console.log('ğŸ“± å±å¹•å°ºå¯¸å˜åŒ–ï¼Œé‡æ–°ç”Ÿæˆå“åº”å¼å¸ƒå±€');
            
            try {
                // ä½¿ç”¨å®¹å™¨å®é™…å®½åº¦è€Œéçª—å£å®½åº¦
                const scoreContainer = document.getElementById('score');
                const containerWidth = scoreContainer ? scoreContainer.clientWidth : window.innerWidth;
                
                // å¼ºåˆ¶æ¯è¡Œ4å°èŠ‚ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
                const measuresPerLine = 4;
                
                console.log(`ğŸ“± å“åº”å¼é‡æ„: å®¹å™¨å®½åº¦=${containerWidth}px, æ¯è¡Œ${measuresPerLine}å°èŠ‚`);
                
                const builder = new MusicXMLBuilder(melodyData.melody, melodyData.config);
                const newMusicXML = builder.build(measuresPerLine);
                
                // é‡æ–°æ¸²æŸ“ä»¥åº”ç”¨æ–°çš„å°èŠ‚åˆ†å¸ƒ
                if (osmd) {
                    await osmd.load(newMusicXML);
                    
                    // é‡æ–°é…ç½®OSMDä»¥åŒ¹é…æ–°çš„æ–­ç‚¹ï¼ˆä½¿ç”¨åŸç”ŸAPIï¼‰
                    if (osmd.EngravingRules) {
                        // é‡æ–°è®¡ç®—å°èŠ‚å®½åº¦ï¼ˆæ¯è¡Œå›ºå®š4å°èŠ‚ï¼‰
                        const availableWidth = containerWidth - 60;
                        const targetMeasureWidth = availableWidth / measuresPerLine;
                        const finalMeasureWidth = Math.max(40, Math.min(300, targetMeasureWidth)); // æœ€å°40pxé€‚åº”å°å±å¹•
                        
                        console.log(`ğŸ“± å“åº”å¼é‡é…ç½®: ${measuresPerLine}å°èŠ‚/è¡Œ, å°èŠ‚å®½åº¦=${Math.round(finalMeasureWidth)}px`);
                        
                        // æ›´æ–°å›ºå®šå°èŠ‚é…ç½®
                        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = measuresPerLine;
                        osmd.EngravingRules.MaxMeasuresPerSystem = measuresPerLine;
                        osmd.EngravingRules.MinMeasuresPerSystem = measuresPerLine;
                        osmd.EngravingRules.FixedMeasureWidth = true;
                        osmd.EngravingRules.FixedMeasureWidthFixedValue = finalMeasureWidth;
                        osmd.EngravingRules.NewSystemAtXMLNewSystem = true;
                        
                        // æ·»åŠ å°èŠ‚åœ¨ç³»ç»Ÿå†…å‡åŒ€åˆ†å¸ƒçš„è®¾ç½®
                        if (osmd.EngravingRules.hasOwnProperty('JustifyMeasuresInSystem')) {
                            osmd.EngravingRules.JustifyMeasuresInSystem = true;
                        } else if (osmd.EngravingRules.hasOwnProperty('justifyMeasuresInSystem')) {
                            osmd.EngravingRules.justifyMeasuresInSystem = true;
                        }
                    }
                    
                    osmd.render();
                    console.log('âœ… å“åº”å¼é‡æ–°æ¸²æŸ“å®Œæˆ - åº”ç”¨æ–°çš„å°èŠ‚åˆ†å¸ƒ');
                }
            } catch (error) {
                console.error('âŒ å“åº”å¼é‡æ–°æ¸²æŸ“å¤±è´¥:', error);
            }
        }, 250); // ç¨å¾®å‡å°‘é˜²æŠ–æ—¶é—´ä»¥æé«˜å“åº”æ€§
    };
    
    window.addEventListener('resize', window.responsiveResizeHandler);
    console.log('ğŸ“± å“åº”å¼å¸ƒå±€ç›‘å¬å™¨å·²è®¾ç½®');
}

/**
 * åªåº”ç”¨åŸºæœ¬æ ·å¼ï¼Œä¸åšä»»ä½•ç¼©æ”¾
 */
function applyOnlyBasicStyles() {
    console.log('ğŸš« å·²å®Œå…¨ç¦ç”¨åŸºæœ¬æ ·å¼è°ƒæ•´ï¼Œä¿æŒOSMDå®Œå…¨åŸç”Ÿæ•ˆæœ');
    
    // åªæ¸…é™¤ä¹‹å‰å¯èƒ½å­˜åœ¨çš„æ ·å¼ï¼Œä½†ä¸æ·»åŠ ä»»ä½•æ–°æ ·å¼
    const oldStyles = ['stretch-to-fill-style', 'force-full-width-style', 'simple-auto-fit-style', 'simple-fill-style', 'force-stretch-style', 'uniform-stretch-style', 'smart-stretch-style', 'dynamic-container-style', 'spacing-only-style', 'osmd-measure-stretch-style'];
    oldStyles.forEach(styleId => {
        const existingStyle = document.getElementById(styleId);
        if (existingStyle) {
            existingStyle.remove();
            console.log(`ğŸ§¹ å·²ç§»é™¤æ ·å¼: ${styleId}`);
        }
    });
    
    console.log('âœ… ä¿æŒOSMDå®Œå…¨åŸç”Ÿæ˜¾ç¤ºæ•ˆæœ');
}

/**
 * ä¸¥æ ¼éªŒè¯å°èŠ‚å¸ƒå±€ï¼šç¡®ä¿æ²¡æœ‰è¡Œè¶…è¿‡æŒ‡å®šçš„æœ€å¤§å°èŠ‚æ•°
 */
function validateStrictMeasureLayout(maxMeasuresPerLine) {
    console.log(`ğŸ” ä¸¥æ ¼éªŒè¯å¸ƒå±€: æ£€æŸ¥æ˜¯å¦æœ‰è¡Œè¶…è¿‡${maxMeasuresPerLine}å°èŠ‚`);
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;
    
    try {
        // æŸ¥æ‰¾æ‰€æœ‰ç³»ç»Ÿï¼ˆè¡Œï¼‰
        const systems = svg.querySelectorAll('g[class*="system"], g.system, g[id*="system"]');
        
        if (systems.length > 0) {
            console.log(`ğŸ“Š æ‰¾åˆ°${systems.length}ä¸ªç³»ç»Ÿï¼ˆè¡Œï¼‰`);
            
            let hasViolation = false;
            systems.forEach((system, index) => {
                const measures = system.querySelectorAll('g[id*="measure"], g.measure, g[class*="measure"]');
                const measureCount = measures.length;
                
                console.log(`  è¡Œ${index + 1}: ${measureCount}ä¸ªå°èŠ‚`);
                
                if (measureCount > maxMeasuresPerLine) {
                    console.error(`âŒ è¿è§„ï¼è¡Œ${index + 1}åŒ…å«${measureCount}ä¸ªå°èŠ‚ï¼Œè¶…è¿‡é™åˆ¶çš„${maxMeasuresPerLine}ä¸ª`);
                    hasViolation = true;
                } else if (measureCount === maxMeasuresPerLine) {
                    console.log(`âœ… è¡Œ${index + 1}æ­£å¥½${measureCount}ä¸ªå°èŠ‚ï¼Œç¬¦åˆè¦æ±‚`);
                } else if (measureCount < maxMeasuresPerLine) {
                    console.log(`âš¡ è¡Œ${index + 1}åªæœ‰${measureCount}ä¸ªå°èŠ‚ï¼Œå¯èƒ½æ˜¯æœ€åä¸€è¡Œ`);
                }
            });
            
            if (!hasViolation) {
                console.log(`âœ… ä¸¥æ ¼éªŒè¯é€šè¿‡ï¼šæ‰€æœ‰è¡Œéƒ½ä¸è¶…è¿‡${maxMeasuresPerLine}å°èŠ‚`);
            }
        } else {
            console.warn('âš ï¸ æœªæ‰¾åˆ°ç³»ç»Ÿå…ƒç´ ï¼Œå°è¯•å…¶ä»–æ–¹æ³•æ£€æµ‹å°èŠ‚å¸ƒå±€');
            
            // å¤‡ç”¨æ–¹æ³•ï¼šé€šè¿‡å°èŠ‚çš„Yåæ ‡åˆ†ç»„
            const measures = svg.querySelectorAll('g[id*="measure"], g.measure, g[class*="measure"]');
            if (measures.length > 0) {
                console.log(`ğŸ“Š æ‰¾åˆ°${measures.length}ä¸ªå°èŠ‚ï¼ŒæŒ‰Yåæ ‡åˆ†ç»„`);
                
                const measuresByY = new Map();
                measures.forEach(measure => {
                    const transform = measure.getAttribute('transform') || '';
                    const translateMatch = transform.match(/translate\([^,]+,\s*([^)]+)\)/);
                    const y = translateMatch ? parseFloat(translateMatch[1]) : 0;
                    
                    const yKey = Math.round(y / 10) * 10; // æŒ‰10pxä¸ºå•ä½åˆ†ç»„
                    if (!measuresByY.has(yKey)) {
                        measuresByY.set(yKey, []);
                    }
                    measuresByY.get(yKey).push(measure);
                });
                
                let hasViolation = false;
                let lineIndex = 0;
                measuresByY.forEach((lineMeasures, y) => {
                    lineIndex++;
                    const measureCount = lineMeasures.length;
                    console.log(`  è¡Œ${lineIndex} (Y=${y}): ${measureCount}ä¸ªå°èŠ‚`);
                    
                    if (measureCount > maxMeasuresPerLine) {
                        console.error(`âŒ è¿è§„ï¼è¡Œ${lineIndex}åŒ…å«${measureCount}ä¸ªå°èŠ‚ï¼Œè¶…è¿‡é™åˆ¶çš„${maxMeasuresPerLine}ä¸ª`);
                        hasViolation = true;
                    }
                });
                
                if (!hasViolation) {
                    console.log(`âœ… ä¸¥æ ¼éªŒè¯é€šè¿‡ï¼šæ‰€æœ‰è¡Œéƒ½ä¸è¶…è¿‡${maxMeasuresPerLine}å°èŠ‚`);
                }
            }
        }
    } catch (error) {
        console.error('âŒ ä¸¥æ ¼å¸ƒå±€éªŒè¯å¤±è´¥:', error);
    }
}

/**
 * æ˜¾ç¤ºä¸åŒå°èŠ‚æ•°çš„å¸ƒå±€æ•ˆæœé¢„æœŸ
 */
function showLayoutExpectation(totalMeasures) {
    console.log(`ğŸ¼ å¸ƒå±€æ•ˆæœé¢„æœŸ (${totalMeasures}å°èŠ‚):`);
    
    if (totalMeasures <= 4) {
        console.log(`  ğŸ“ å•è¡Œå¸ƒå±€: ${totalMeasures}å°èŠ‚ç­‰è·åˆ†å¸ƒï¼Œå……æ»¡å®¹å™¨å®½åº¦`);
        console.log(`  ğŸ¯ é¢„æœŸæ•ˆæœ: å°èŠ‚é—´è·å‡åŒ€ï¼Œæ— å³ä¾§ç©ºç™½`);
    } else {
        const fullLines = Math.floor(totalMeasures / 4);
        const remainingMeasures = totalMeasures % 4;
        
        console.log(`  ğŸ“„ å¤šè¡Œå¸ƒå±€:`);
        for (let i = 1; i <= fullLines; i++) {
            console.log(`    ç¬¬${i}è¡Œ: 4å°èŠ‚ï¼Œå……æ»¡å®¹å™¨å®½åº¦`);
        }
        
        if (remainingMeasures > 0) {
            console.log(`    ç¬¬${fullLines + 1}è¡Œ: ${remainingMeasures}å°èŠ‚ï¼Œç­‰è·åˆ†å¸ƒå……æ»¡å®¹å™¨å®½åº¦`);
        }
        
        console.log(`  ğŸ¯ é¢„æœŸæ•ˆæœ: æ¯è¡Œéƒ½å……æ»¡å®¹å™¨ï¼Œæ— å®½åº¦ä¸ä¸€è‡´é—®é¢˜`);
    }
    
    // æ˜¾ç¤ºå…·ä½“çš„ç”¨ä¾‹è¯´æ˜
    console.log(`\nğŸ“ çº¯é—´è·å¸ƒå±€è¯´æ˜ (éŸ³ç¬¦ä¿æŒåŸå½¢):`);
    console.log(`  2å°èŠ‚ â†’ ç¬¬1è¡Œ: 2å°èŠ‚ï¼Œé€šè¿‡å¢åŠ é—´è·å¡«æ»¡å®¹å™¨`);
    console.log(`  4å°èŠ‚ â†’ ç¬¬1è¡Œ: 4å°èŠ‚ï¼Œé€šè¿‡è°ƒæ•´é—´è·å¡«æ»¡å®¹å™¨`); 
    console.log(`  8å°èŠ‚ â†’ ç¬¬1è¡Œ: 4å°èŠ‚ï¼Œç¬¬2è¡Œ: 4å°èŠ‚ï¼Œæ¯è¡Œé€šè¿‡é—´è·å¡«æ»¡å®¹å™¨`);
    console.log(`  10å°èŠ‚ â†’ 3è¡Œå¸ƒå±€ï¼Œå‰ä¸¤è¡Œå„4å°èŠ‚ï¼Œæœ€åä¸€è¡Œ2å°èŠ‚é€šè¿‡é—´è·å¡«æ»¡`);
    console.log(`  âœ… ä¿è¯: éŸ³ç¬¦ã€æ‹å·ã€è°±å·ç»ä¸å˜å½¢ï¼Œåªè°ƒæ•´å°èŠ‚å’ŒéŸ³ç¬¦é—´è·`);
    console.log(`  ğŸš« ç¦æ­¢: ä»»ä½•CSS transformç¼©æ”¾æˆ–å…ƒç´ å˜å½¢`);
}

/**
 * è°ƒæ•´ä¸å®Œæ•´ç³»ç»Ÿçš„é—´è·ï¼Œç¡®ä¿å°èŠ‚ç­‰è·åˆ†å¸ƒ
 */
function adjustIncompleteSystemSpacing(maxMeasuresPerLine) {
    console.log('ğŸ¯ è°ƒæ•´ä¸å®Œæ•´è¡Œçš„å°èŠ‚é—´è·');
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;
    
    try {
        const containerWidth = scoreDiv.clientWidth - 40;
        const systems = svg.querySelectorAll('g[class*="system"], g.system, g[id*="system"]');
        
        if (systems.length > 0) {
            systems.forEach((system, systemIndex) => {
                const measures = system.querySelectorAll('g[id*="measure"], g.measure, g[class*="measure"]');
                const measureCount = measures.length;
                
                if (measureCount > 0 && measureCount < maxMeasuresPerLine) {
                    console.log(`ğŸ”§ è°ƒæ•´ç¬¬${systemIndex + 1}è¡Œ: ${measureCount}/${maxMeasuresPerLine}å°èŠ‚`);
                    
                    // è®¡ç®—ç­‰è·åˆ†å¸ƒçš„ç†æƒ³é—´è·
                    const idealSpacing = containerWidth / measureCount;
                    const measureSpacing = idealSpacing * 0.8; // é¢„ç•™ä¸€äº›è¾¹è·
                    
                    console.log(`ğŸ“ ç†æƒ³é—´è·: ${idealSpacing.toFixed(1)}px, å®é™…é—´è·: ${measureSpacing.toFixed(1)}px`);
                    
                    // åˆ›å»ºé’ˆå¯¹è¿™ä¸ªç³»ç»Ÿçš„CSSè°ƒæ•´
                    const adjustmentStyle = document.createElement('style');
                    adjustmentStyle.id = `system-spacing-${systemIndex}`;
                    adjustmentStyle.innerHTML = `
                        /* è°ƒæ•´ç¬¬${systemIndex + 1}è¡Œçš„å°èŠ‚é—´è· */
                        #score svg g:nth-child(${systemIndex + 1}) g[id*="measure"],
                        #score svg g:nth-child(${systemIndex + 1}) g.measure {
                            margin-right: ${(measureSpacing * 0.3).toFixed(1)}px !important;
                        }
                        
                        /* ç¡®ä¿è¿™ä¸€è¡Œå……æ»¡å®¹å™¨å®½åº¦ */
                        #score svg g:nth-child(${systemIndex + 1}) {
                            width: ${containerWidth}px !important;
                            display: flex !important;
                            justify-content: space-evenly !important;
                        }
                    `;
                    
                    // ç§»é™¤æ—§çš„è°ƒæ•´æ ·å¼
                    const oldStyle = document.getElementById(`system-spacing-${systemIndex}`);
                    if (oldStyle) oldStyle.remove();
                    
                    document.head.appendChild(adjustmentStyle);
                    
                    console.log(`âœ… ç¬¬${systemIndex + 1}è¡Œé—´è·è°ƒæ•´å®Œæˆ`);
                }
            });
        } else {
            console.warn('âš ï¸ æœªæ‰¾åˆ°ç³»ç»Ÿå…ƒç´ ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•è°ƒæ•´é—´è·');
            
            // å¤‡ç”¨æ–¹æ³•ï¼šç›´æ¥è°ƒæ•´æ‰€æœ‰å°èŠ‚çš„é—´è·
            const measures = svg.querySelectorAll('g[id*="measure"], g.measure, g[class*="measure"]');
            if (measures.length <= maxMeasuresPerLine) {
                const idealSpacing = containerWidth / measures.length;
                
                const globalAdjustmentStyle = document.createElement('style');
                globalAdjustmentStyle.id = 'global-measure-spacing';
                globalAdjustmentStyle.innerHTML = `
                    /* å…¨å±€å°èŠ‚ç­‰è·è°ƒæ•´ */
                    #score svg g[id*="measure"],
                    #score svg g.measure {
                        margin-right: ${(idealSpacing * 0.2).toFixed(1)}px !important;
                    }
                    
                    #score svg {
                        display: flex !important;
                        justify-content: space-evenly !important;
                        align-items: flex-start !important;
                    }
                `;
                
                const oldGlobalStyle = document.getElementById('global-measure-spacing');
                if (oldGlobalStyle) oldGlobalStyle.remove();
                
                document.head.appendChild(globalAdjustmentStyle);
                console.log(`âœ… å…¨å±€é—´è·è°ƒæ•´å®Œæˆ: ${measures.length}å°èŠ‚ç­‰è·åˆ†å¸ƒ`);
            }
        }
    } catch (error) {
        console.error('âŒ é—´è·è°ƒæ•´å¤±è´¥:', error);
    }
}

/**
 * éªŒè¯å¸ƒå±€æ˜¯å¦ç¬¦åˆè¦æ±‚
 */
function validateLayout(expectedMeasuresPerLine) {
    console.log(`ğŸ” éªŒè¯å¸ƒå±€: é¢„æœŸæ¯è¡Œæœ€å¤š${expectedMeasuresPerLine}å°èŠ‚`);
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;
    
    try {
        // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç³»ç»Ÿå…ƒç´ 
        const possibleSelectors = [
            'g[id*="system"]',
            'g.system',
            'g[id*="System"]',
            'g[class*="system"]'
        ];
        
        let systems = [];
        for (const selector of possibleSelectors) {
            systems = svg.querySelectorAll(selector);
            if (systems.length > 0) {
                console.log(`ğŸ“Š æ‰¾åˆ°${systems.length}ä¸ªç³»ç»Ÿï¼Œä½¿ç”¨é€‰æ‹©å™¨: ${selector}`);
                break;
            }
        }
        
        if (systems.length > 0) {
            systems.forEach((system, index) => {
                const measures = system.querySelectorAll('*[id*="measure"], *[class*="measure"]');
                const measureCount = measures.length;
                
                if (measureCount > expectedMeasuresPerLine) {
                    console.warn(`âŒ ç³»ç»Ÿ${index + 1}æœ‰${measureCount}ä¸ªå°èŠ‚ï¼Œè¶…è¿‡é¢„æœŸçš„${expectedMeasuresPerLine}ä¸ªï¼`);
                    console.warn(`ğŸ”§ å¯èƒ½éœ€è¦å¼ºåŒ–OSMDæ¢è¡Œè®¾ç½®æˆ–æ£€æŸ¥MusicXMLæ¢è¡ŒæŒ‡ä»¤`);
                } else {
                    console.log(`âœ… ç³»ç»Ÿ${index + 1}: ${measureCount}ä¸ªå°èŠ‚ (ç¬¦åˆè¦æ±‚)`);
                }
            });
        } else {
            console.log('âš ï¸ æ— æ³•æ‰¾åˆ°ç³»ç»Ÿå…ƒç´ è¿›è¡ŒéªŒè¯');
            // å¤‡ç”¨éªŒè¯æ–¹æ³•ï¼šç›´æ¥æŸ¥æ‰¾æ‰€æœ‰å°èŠ‚
            const allMeasures = svg.querySelectorAll('*[id*="measure"]');
            console.log(`ğŸ“Š æ€»å…±æ‰¾åˆ° ${allMeasures.length} ä¸ªå°èŠ‚å…ƒç´ `);
        }
        
    } catch (error) {
        console.error('âŒ å¸ƒå±€éªŒè¯å¤±è´¥:', error);
    }
}

/**
 * å¤æ‚çš„è‡ªé€‚åº”å®½åº¦è°ƒæ•´ï¼ˆå·²å¼ƒç”¨ - ä¼šå¯¼è‡´SVGå˜å°ï¼‰
 */
function applySimpleAutoFit_DEPRECATED() {
    console.log('ğŸ¨ åº”ç”¨ç®€å•çš„è‡ªé€‚åº”å®½åº¦ï¼Œä¿æŒå°èŠ‚å®Œæ•´æ€§');
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;
    
    try {
        // è·å–SVGçš„åŸå§‹å°ºå¯¸
        const svgWidth = svg.getBoundingClientRect().width;
        const containerWidth = scoreDiv.clientWidth - 40; // å‡å»padding
        
        console.log(`ğŸ“ SVGåŸå§‹å®½åº¦: ${svgWidth.toFixed(0)}px, å®¹å™¨å®½åº¦: ${containerWidth.toFixed(0)}px`);
        
        // åº”ç”¨è‡ªé€‚åº”æ ·å¼
        applyAutoFitStyles(containerWidth);
        
    } catch (error) {
        console.error('âŒ è‡ªé€‚åº”è°ƒæ•´å¤±è´¥:', error);
    }
}

/**
 * åº”ç”¨è‡ªé€‚åº”CSSæ ·å¼
 */
function applyAutoFitStyles(containerWidth) {
    console.log('ğŸš« å·²å®Œå…¨ç¦ç”¨è‡ªé€‚åº”æ ·å¼ï¼Œä¿æŒOSMDåŸç”Ÿæ˜¾ç¤ºæ•ˆæœ');
    
    // ç§»é™¤ä»»ä½•ç°æœ‰çš„æ ·å¼
    const existingStyle = document.getElementById('simple-auto-fit-style');
    if (existingStyle) {
        existingStyle.remove();
        console.log('ğŸ§¹ å·²ç§»é™¤è‡ªé€‚åº”æ ·å¼');
    }
    
    console.log('âœ… ä¿æŒOSMDå®Œå…¨åŸç”Ÿçš„æ˜¾ç¤ºæ•ˆæœï¼Œä¸åšä»»ä½•å°ºå¯¸ä¿®æ”¹');
}

/**
 * å¼ºåˆ¶æ­£ç¡®çš„å°èŠ‚å¸ƒå±€ - DOMæ“ä½œæ–¹æ³•ï¼ˆå·²å¼ƒç”¨ - ä¼šç ´åå°èŠ‚ç»“æ„ï¼‰
 */
function forceProperMeasureLayout_DEPRECATED(maxMeasuresPerLine) {
    console.log(`ğŸ”§ å¼€å§‹å¼ºåˆ¶é‡æ’å°èŠ‚ï¼Œæ¯è¡Œæœ€å¤š${maxMeasuresPerLine}å°èŠ‚`);
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return;
    
    try {
        // åˆ†æå½“å‰å°èŠ‚åˆ†å¸ƒ
        const measures = findAllMeasures(svg);
        console.log(`ğŸ” æ‰¾åˆ°${measures.length}ä¸ªå°èŠ‚`);
        
        if (measures.length === 0) return;
        
        // é‡æ–°æ’åˆ—å°èŠ‚
        rearrangeMeasures(measures, maxMeasuresPerLine);
        
        // åº”ç”¨å¡«æ»¡å®½åº¦æ ·å¼
        applyFullWidthStyles();
        
    } catch (error) {
        console.error('âŒ å¼ºåˆ¶é‡æ’å°èŠ‚å¤±è´¥:', error);
    }
}

/**
 * æŸ¥æ‰¾SVGä¸­çš„æ‰€æœ‰å°èŠ‚å…ƒç´ 
 */
function findAllMeasures(svg) {
    const possibleSelectors = [
        'g[id*="measure"]',
        'g[class*="measure"]', 
        'g[id*="Measure"]',
        'g.measure'
    ];
    
    let measures = [];
    for (const selector of possibleSelectors) {
        measures = svg.querySelectorAll(selector);
        if (measures.length > 0) {
            console.log(`âœ… ä½¿ç”¨é€‰æ‹©å™¨ "${selector}" æ‰¾åˆ°${measures.length}ä¸ªå°èŠ‚`);
            break;
        }
    }
    
    return Array.from(measures);
}

/**
 * é‡æ–°æ’åˆ—å°èŠ‚åˆ°æ­£ç¡®çš„è¡Œ
 */
function rearrangeMeasures(measures, maxMeasuresPerLine) {
    console.log(`ğŸ“ å¼€å§‹é‡æ–°æ’åˆ—${measures.length}ä¸ªå°èŠ‚ï¼Œæ¯è¡Œ${maxMeasuresPerLine}ä¸ª`);
    
    // è·å–ç¬¬ä¸€ä¸ªå°èŠ‚çš„Yä½ç½®ä½œä¸ºåŸºå‡†
    const firstMeasure = measures[0];
    const baseY = getElementY(firstMeasure);
    const measureHeight = 120; // ä¼°ç®—è¡Œé«˜
    
    console.log(`ğŸ“ åŸºå‡†Yä½ç½®: ${baseY}`);
    
    measures.forEach((measure, index) => {
        const rowIndex = Math.floor(index / maxMeasuresPerLine);
        const colIndex = index % maxMeasuresPerLine;
        
        // è®¡ç®—æ–°ä½ç½®
        const newY = baseY + (rowIndex * measureHeight);
        const newX = colIndex * (100 / maxMeasuresPerLine) + '%'; // ç™¾åˆ†æ¯”åˆ†å¸ƒ
        
        // åº”ç”¨æ–°çš„å˜æ¢
        const currentTransform = measure.getAttribute('transform') || '';
        const newTransform = `translate(${colIndex * 200}, ${rowIndex * measureHeight})`;
        
        measure.setAttribute('transform', newTransform);
        
        if (index < 5) { // åªæ‰“å°å‰5ä¸ªçš„è°ƒè¯•ä¿¡æ¯
            console.log(`  å°èŠ‚${index + 1}: è¡Œ${rowIndex + 1}, åˆ—${colIndex + 1}, å˜æ¢=${newTransform}`);
        }
    });
    
    console.log('âœ… å°èŠ‚é‡æ–°æ’åˆ—å®Œæˆ');
}

/**
 * è·å–å…ƒç´ çš„Yåæ ‡
 */
function getElementY(element) {
    const transform = element.getAttribute('transform');
    if (transform) {
        const match = transform.match(/translate\(\s*([^,]+),\s*([^)]+)\)/);
        if (match) {
            return parseFloat(match[2]) || 0;
        }
    }
    return 0;
}

/**
 * åº”ç”¨å¡«æ»¡å®½åº¦çš„æ ·å¼
 */
function applyFullWidthStyles() {
    const existingStyle = document.getElementById('force-full-width-style');
    if (existingStyle) {
        existingStyle.remove();
    }
    
    const style = document.createElement('style');
    style.id = 'force-full-width-style';
    style.innerHTML = `
        #score {
            width: 100% !important;
            max-width: 1000px !important;
            padding: 20px !important;
            margin: 0 auto !important;
        }
        
        #score svg {
            width: 100% !important;
            height: auto !important;
            display: block !important;
        }
    `;
    document.head.appendChild(style);
    
    console.log('âœ… åº”ç”¨äº†å¼ºåˆ¶å…¨å®½åº¦æ ·å¼');
}

/**
 * ç®€åŒ–çš„SVGå®½åº¦å¡«å……æ–¹æ³•ï¼ˆä¿ç•™ä½œä¸ºå¤‡ç”¨ï¼‰
 */
function ensureFullWidthFill() {
    console.log('ğŸ¨ å¼€å§‹ç®€åŒ–çš„SVGå®½åº¦å¡«å……');
    
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return;
    
    // ç­‰å¾…SVGæ¸²æŸ“å®Œæˆ
    setTimeout(() => {
        const svg = scoreDiv.querySelector('svg');
        if (!svg) {
            console.log('âŒ æœªæ‰¾åˆ°SVGå…ƒç´ ');
            return;
        }
        
        console.log('ğŸ“ å¼€å§‹åº”ç”¨ç®€å•çš„å¡«å……æ ·å¼');
        
        // ç›´æ¥åº”ç”¨å¡«å……æ ·å¼
        applySimpleFullWidthStyles();
        
    }, 300); // å¢åŠ å»¶è¿Ÿç¡®ä¿å®Œå…¨æ¸²æŸ“
    
    function applySimpleFullWidthStyles() {
        // æ¸…é™¤ä¹‹å‰çš„æ ·å¼
        const existingStyle = document.getElementById('simple-full-width-style');
        if (existingStyle) {
            existingStyle.remove();
        }
        
        // åº”ç”¨ç®€å•ç›´æ¥çš„æ ·å¼
        const style = document.createElement('style');
        style.id = 'simple-full-width-style';
        style.innerHTML = `
            /* å®¹å™¨æ ·å¼ */
            #score {
                width: 100% !important;
                max-width: 1000px !important;
                padding: 20px !important;
                box-sizing: border-box !important;
                margin: 0 auto !important;
            }
            
            /* SVGå¼ºåˆ¶å¡«æ»¡å®¹å™¨ */
            #score svg {
                width: 100% !important;
                height: auto !important;
                max-width: 100% !important;
                display: block !important;
            }
            
            /* ç§»é™¤OSMDçš„å›ºå®šå®½åº¦ */
            #score svg[width] {
                width: 100% !important;
            }
            
            /* ç¡®ä¿viewBoxè‡ªé€‚åº” */
            #score svg[viewBox] {
                width: 100% !important;
                height: auto !important;
            }
        `;
        document.head.appendChild(style);
        
        console.log('âœ… åº”ç”¨äº†ç®€åŒ–çš„å…¨å®½åº¦æ ·å¼');
        
        // å·²ç¦ç”¨ï¼šä¸å†ä¿®æ”¹SVGå±æ€§ï¼Œä¿æŒOSMDåŸç”Ÿæ•ˆæœ
        console.log('ğŸ”§ ä¿æŒOSMDåŸç”ŸSVGå±æ€§');
    }
}

/**
 * å¼ºåˆ¶æ­£ç¡®çš„å¸ƒå±€ - é€šè¿‡è°ƒæ•´å®¹å™¨å®½åº¦ (å·²å¼ƒç”¨)
 */
async function forceCorrectLayout_DEPRECATED(maxMeasuresPerLine) {
    console.log('ğŸš« å·²å®Œå…¨ç¦ç”¨å¼ºåˆ¶å¸ƒå±€åŠŸèƒ½ï¼Œä¿æŒOSMDå®Œå…¨åŸç”Ÿæ•ˆæœ');
    console.log('ğŸ“ ä¸è¿›è¡Œä»»ä½•å®¹å™¨å®½åº¦ä¿®æ”¹ï¼Œä¸è¿›è¡Œé‡æ–°æ¸²æŸ“');
    
    // åªè¿›è¡Œå¸ƒå±€åˆ†æï¼Œä¸ä¿®æ”¹ä»»ä½•å°ºå¯¸
    setTimeout(() => {
        console.log('ğŸ“Š ä¿æŒåŸç”Ÿå¸ƒå±€ï¼Œä»…åˆ†æç»“æœ');
        analyzeLayout(maxMeasuresPerLine);
    }, 100);
}

/**
 * æ‹‰ä¼¸å°èŠ‚ä»¥å¡«æ»¡å®¹å™¨å®½åº¦
 */
function stretchMeasuresToFillWidth(expectedMeasuresPerLine) {
    console.log('ğŸ“ å·²ç¦ç”¨å°èŠ‚æ‹‰ä¼¸æ“ä½œï¼Œä¿æŒOSMDåŸç”Ÿæ¸²æŸ“æ•ˆæœ');
    
    // ç§»é™¤ä»»ä½•ç°æœ‰çš„æ‹‰ä¼¸æ ·å¼
    const existingStyle = document.getElementById('osmd-measure-stretch-style');
    if (existingStyle) {
        existingStyle.remove();
        console.log('ğŸ§¹ å·²ç§»é™¤æ—§çš„æ‹‰ä¼¸æ ·å¼');
    }
    
    // ç§»é™¤æ‹‰ä¼¸æ ·å¼ç±»
    document.body.classList.remove('measure-stretch-active');
    const scoreDiv = document.getElementById('score');
    if (scoreDiv) {
        scoreDiv.classList.remove('measure-stretch-active');
        
        // æ¢å¤SVGçš„åŸç”Ÿæ ·å¼
        const svg = scoreDiv.querySelector('svg');
        if (svg) {
            svg.style.transform = '';
            svg.style.transformOrigin = '';
            console.log('ğŸ”„ å·²æ¢å¤SVGåŸç”Ÿæ ·å¼');
        }
    }
    
    console.log('âœ… ä¿æŒOSMDåŸç”Ÿå®½åº¦å’Œé—´è·ï¼Œä»…ä¿ç•™å“åº”å¼æ¢è¡ŒåŠŸèƒ½');
}

/**
 * è·å–ç‰¹å®šå¸ƒå±€çš„CSSæ ·å¼
 */
function getLayoutSpecificCSS(layoutType, measureWidth, containerWidth) {
    // å®Œå…¨ç¦ç”¨æ‰€æœ‰å¸ƒå±€ç‰¹å®šçš„CSSæ ·å¼ä¿®æ”¹
    // ä¿æŒOSMDåŸç”Ÿæ¸²æŸ“æ•ˆæœï¼Œä¸è¿›è¡Œä»»ä½•æ‹‰ä¼¸æˆ–é—´è·è°ƒæ•´
    return '';
}

/**
 * è®¾ç½®å“åº”å¼å¸ƒå±€ç›‘å¬å™¨
 */
function setupResponsiveLayoutListener() {
    let currentLayoutType = null;
    let resizeTimeout = null;
    
    function handleResize() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const scoreContainer = document.getElementById('score');
            if (!scoreContainer) return;
            
            const containerWidth = scoreContainer.clientWidth;
            let newLayoutType;
            
            if (containerWidth >= 900) {
                newLayoutType = 'desktop';
            } else if (containerWidth >= 600) {
                newLayoutType = 'tablet';
            } else {
                newLayoutType = 'mobile';
            }
            
            // å¦‚æœå¸ƒå±€ç±»å‹å‘ç”Ÿå˜åŒ–ï¼Œé‡æ–°ç”Ÿæˆä¹è°±
            if (currentLayoutType && currentLayoutType !== newLayoutType) {
                console.log(`ğŸ”„ å“åº”å¼å¸ƒå±€å˜åŒ–: ${currentLayoutType} â†’ ${newLayoutType}`);
                
                // é‡æ–°ç”Ÿæˆå½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹
                if (melodyHistory.length > 0 && currentHistoryIndex >= 0) {
                    const currentMelody = melodyHistory[currentHistoryIndex];
                    if (currentMelody) {
                        console.log('ğŸ”„ é‡æ–°æ¸²æŸ“å½“å‰æ—‹å¾‹ä»¥é€‚åº”æ–°å¸ƒå±€');
                        renderMelodyWithOSMD(currentMelody.musicXML);
                    }
                }
            }
            
            currentLayoutType = newLayoutType;
        }, 300); // 300msé˜²æŠ–
    }
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', handleResize);
    
    // ä½¿ç”¨ResizeObserverç›‘å¬å®¹å™¨å˜åŒ–ï¼ˆæ›´ç²¾ç¡®ï¼‰
    if (window.ResizeObserver) {
        const scoreContainer = document.getElementById('score');
        if (scoreContainer) {
            const resizeObserver = new ResizeObserver(handleResize);
            resizeObserver.observe(scoreContainer);
        }
    }
    
    // åˆå§‹åŒ–å½“å‰å¸ƒå±€ç±»å‹
    handleResize();
    
    console.log('ğŸ“± å“åº”å¼å¸ƒå±€ç›‘å¬å™¨å·²è®¾ç½®');
}

/**
 * è·å–å½“å‰å“åº”å¼å¸ƒå±€ä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
 */
function getCurrentResponsiveLayout() {
    const scoreContainer = document.getElementById('score');
    if (!scoreContainer) return null;
    
    const containerWidth = scoreContainer.clientWidth;
    let layoutType, measuresPerLine;
    
    if (containerWidth >= 900) {
        layoutType = 'desktop';
        measuresPerLine = 4;
    } else if (containerWidth >= 600) {
        layoutType = 'tablet';
        measuresPerLine = 2;
    } else {
        layoutType = 'mobile';
        measuresPerLine = 1;
    }
    
    return {
        containerWidth,
        layoutType,
        measuresPerLine,
        breakpoints: {
            desktop: 'â‰¥900px',
            tablet: '600px-899px',
            mobile: '<600px'
        }
    };
}

/**
 * åˆ†ææœ€ç»ˆå¸ƒå±€ç»“æœ
 */
function analyzeLayout(expectedMeasuresPerLine) {
    setTimeout(() => {
        const scoreDiv = document.getElementById('score');
        if (!scoreDiv) return;
        
        const svg = scoreDiv.querySelector('svg');
        if (!svg) return;
        
        console.log('ğŸ” åˆ†ææœ€ç»ˆå¸ƒå±€ç»“æœ:');
        
        // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç³»ç»Ÿå…ƒç´ 
        const possibleSelectors = [
            'g[id*="system"]',
            'g.system', 
            'g[id*="System"]',
            'g[class*="system"]'
        ];
        
        let systems = [];
        for (const selector of possibleSelectors) {
            systems = svg.querySelectorAll(selector);
            if (systems.length > 0) {
                console.log(`âœ… æ‰¾åˆ°${systems.length}ä¸ªç³»ç»Ÿï¼Œä½¿ç”¨é€‰æ‹©å™¨: ${selector}`);
                break;
            }
        }
        
        if (systems.length > 0) {
            systems.forEach((system, index) => {
                const measures = system.querySelectorAll('*[id*="measure"], *[class*="measure"]');
                const measureCount = measures.length;
                console.log(`  è¡Œ${index + 1}: ${measureCount}ä¸ªå°èŠ‚ ${measureCount > expectedMeasuresPerLine ? 'âŒ è¶…å‡ºé™åˆ¶' : 'âœ… ç¬¦åˆè¦æ±‚'}`);
            });
        } else {
            console.log('âš ï¸ æ— æ³•æ‰¾åˆ°ç³»ç»Ÿå…ƒç´ ï¼Œå°è¯•å…¶ä»–æ–¹æ³•åˆ†æ...');
            // å¤‡ç”¨åˆ†ææ–¹æ³•
            const allMeasures = svg.querySelectorAll('*[id*="measure"]');
            console.log(`æ€»å…±æ‰¾åˆ° ${allMeasures.length} ä¸ªå°èŠ‚å…ƒç´ `);
        }
    }, 300);
}

/**
 * ç›´æ¥æ“ä½œDOMæ¥å®ç°è‡ªå®šä¹‰å¸ƒå±€
 */
function applyCustomLayout(maxMeasuresPerLine) {
    console.log(`ğŸ¨ åº”ç”¨è‡ªå®šä¹‰å¸ƒå±€æ£€æŸ¥: æ¯è¡Œæœ€å¤š${maxMeasuresPerLine}å°èŠ‚`);
    
    try {
        // ç­‰å¾…DOMæ›´æ–°
        setTimeout(() => {
            const scoreDiv = document.getElementById('score');
            if (!scoreDiv) return;
            
            // åˆ†æSVGç»“æ„æ¥ç†è§£OSMDçš„å¸ƒå±€
            const svg = scoreDiv.querySelector('svg');
            if (svg) {
                console.log(`ğŸ“Š SVGå°ºå¯¸: ${svg.getAttribute('width')} x ${svg.getAttribute('height')}`);
                
                // æŸ¥æ‰¾ç³»ç»Ÿï¼ˆè¡Œï¼‰å…ƒç´ 
                const systems = svg.querySelectorAll('g[id*="system"], g.system');
                console.log(`ğŸ¼ æ‰¾åˆ°${systems.length}ä¸ªç³»ç»Ÿ/è¡Œ`);
                
                if (systems.length > 0) {
                    systems.forEach((system, index) => {
                        const measures = system.querySelectorAll('g[id*="measure"], g.measure');
                        console.log(`  ç³»ç»Ÿ${index + 1}: ${measures.length}ä¸ªå°èŠ‚`);
                        
                        // å¦‚æœæŸä¸ªç³»ç»Ÿçš„å°èŠ‚æ•°è¶…è¿‡maxMeasuresPerLineï¼Œè®°å½•è­¦å‘Š
                        if (measures.length > maxMeasuresPerLine) {
                            console.warn(`âš ï¸ ç³»ç»Ÿ${index + 1}åŒ…å«${measures.length}ä¸ªå°èŠ‚ï¼Œè¶…è¿‡é™åˆ¶çš„${maxMeasuresPerLine}ä¸ª`);
                        }
                    });
                } else {
                    // å¤‡é€‰æ–¹æ¡ˆï¼šç›´æ¥æŸ¥æ‰¾æ‰€æœ‰å°èŠ‚
                    const allMeasures = svg.querySelectorAll('*[id*="measure"]');
                    console.log(`ğŸ” æ‰¾åˆ°${allMeasures.length}ä¸ªå¯èƒ½çš„å°èŠ‚å…ƒç´ `);
                    
                    // åˆ†æå‰å‡ ä¸ªå…ƒç´ 
                    for (let i = 0; i < Math.min(5, allMeasures.length); i++) {
                        const measure = allMeasures[i];
                        console.log(`  å°èŠ‚${i + 1}: id="${measure.id}", tag="${measure.tagName}", y="${measure.getAttribute('transform')}"`);
                    }
                }
                
                // å¼ºåˆ¶é‡æ–°æ£€æŸ¥OSMDå†…éƒ¨çŠ¶æ€
                if (window.osmd && window.osmd.EngravingRules) {
                    console.log(`ğŸ”§ å½“å‰OSMDè®¾ç½®æ£€æŸ¥:`);
                    console.log(`  - MaxMeasuresPerSystem: ${window.osmd.EngravingRules.MaxMeasuresPerSystem}`);
                    console.log(`  - MinMeasuresPerSystem: ${window.osmd.EngravingRules.MinMeasuresPerSystem}`);
                }
            }
        }, 200); // å¢åŠ å»¶è¿Ÿä»¥ç¡®ä¿æ¸²æŸ“å®Œæˆ
    } catch (error) {
        console.error('âŒ è‡ªå®šä¹‰å¸ƒå±€åˆ†æå¤±è´¥:', error);
    }
}

/**
 * æµ‹è¯•è°ƒå·å¤„ç†æ˜¯å¦æ­£ç¡®
 */
function testKeySignatureHandling() {
    console.log('\nğŸ§ª === è°ƒå·å¤„ç†æµ‹è¯• ===');
    console.log('åŸåˆ™ï¼šè°ƒå·å†…çš„éŸ³ç¬¦ä¸å†™alterï¼Œåç¦»è°ƒå·æ—¶æ‰å†™alter\n');
    
    // Gå¤§è°ƒæµ‹è¯• (F#åœ¨è°ƒå·ä¸­)
    console.log('ã€Gå¤§è°ƒæµ‹è¯•ã€‘');
    const gTests = [
        { midi: 65, desc: 'Fè‡ªç„¶éŸ³ - éœ€è¦è¿˜åŸè®°å·' },
        { midi: 66, desc: 'F#éŸ³ - è°ƒå·å†…ï¼Œä¸éœ€è¦ä¸´æ—¶è®°å·' },
        { midi: 67, desc: 'GéŸ³ - è‡ªç„¶éŸ³' },
    ];
    
    const gGen = new IntelligentMelodyGenerator(4, 'G', '4/4', 'treble', 12345);
    gTests.forEach(test => {
        const result = gGen.midiToMusicXML(test.midi);
        const alterDesc = result.alter === undefined ? 'ä¸å†™alter(ä½¿ç”¨è°ƒå·)' : `alter=${result.alter}`;
        console.log(`  MIDI ${test.midi} -> ${result.step}${result.octave} | ${alterDesc} | ${test.desc}`);
        
        // ç”Ÿæˆå®é™…çš„XMLç‰‡æ®µ
        const noteXML = `<note><pitch><step>${result.step}</step>${result.alter !== undefined ? `<alter>${result.alter}</alter>` : ''}<octave>${result.octave}</octave></pitch></note>`;
        console.log(`    XML: ${noteXML}`);
    });
    
    // Då¤§è°ƒæµ‹è¯• (F#, C#åœ¨è°ƒå·ä¸­)
    console.log('\nã€Då¤§è°ƒæµ‹è¯•ã€‘');
    const dTests = [
        { midi: 60, desc: 'Cè‡ªç„¶éŸ³ - éœ€è¦è¿˜åŸè®°å·' },
        { midi: 61, desc: 'C#éŸ³ - è°ƒå·å†…ï¼Œä¸éœ€è¦ä¸´æ—¶è®°å·' },
        { midi: 65, desc: 'Fè‡ªç„¶éŸ³ - éœ€è¦è¿˜åŸè®°å·' },
        { midi: 66, desc: 'F#éŸ³ - è°ƒå·å†…ï¼Œä¸éœ€è¦ä¸´æ—¶è®°å·' },
    ];
    
    const dGen = new IntelligentMelodyGenerator(4, 'D', '4/4', 'treble', 12345);
    dTests.forEach(test => {
        const result = dGen.midiToMusicXML(test.midi);
        const alterDesc = result.alter === undefined ? 'ä¸å†™alter(ä½¿ç”¨è°ƒå·)' : `alter=${result.alter}`;
        console.log(`  MIDI ${test.midi} -> ${result.step}${result.octave} | ${alterDesc} | ${test.desc}`);
    });
    
    // Få¤§è°ƒæµ‹è¯• (Bbåœ¨è°ƒå·ä¸­)
    console.log('\nã€Få¤§è°ƒæµ‹è¯•ã€‘');
    const fTests = [
        { midi: 70, desc: 'BbéŸ³ - è°ƒå·å†…ï¼Œä¸éœ€è¦ä¸´æ—¶è®°å·' },
        { midi: 71, desc: 'Bè‡ªç„¶éŸ³ - éœ€è¦è¿˜åŸè®°å·' },
    ];
    
    const fGen = new IntelligentMelodyGenerator(4, 'F', '4/4', 'treble', 12345);
    fTests.forEach(test => {
        const result = fGen.midiToMusicXML(test.midi);
        const alterDesc = result.alter === undefined ? 'ä¸å†™alter(ä½¿ç”¨è°ƒå·)' : `alter=${result.alter}`;
        console.log(`  MIDI ${test.midi} -> ${result.step}${result.octave} | ${alterDesc} | ${test.desc}`);
    });
}

// ====== è°ƒè¯•å‡½æ•° ======

/**
 * æµ‹è¯•ä¸‰è¿éŸ³è®¾ç½®çš„è°ƒè¯•å‡½æ•°
 */
function debugTripletSettings() {
    console.log('\nğŸ”§ === ä¸‰è¿éŸ³è®¾ç½®è°ƒè¯• ===');
    console.log(`å½“å‰ç”¨æˆ·è®¾ç½®: allowedRhythms = [${userSettings?.allowedRhythms?.join(', ')}]`);
    console.log(`åŒ…å«ä¸‰è¿éŸ³: ${userSettings?.allowedRhythms?.includes('triplet')}`);
    
    // æ£€æŸ¥å‰ç«¯å¤é€‰æ¡†çŠ¶æ€
    const tripletCheckbox = document.getElementById('rhythm-triplet');
    if (tripletCheckbox) {
        console.log(`ä¸‰è¿éŸ³å¤é€‰æ¡†çŠ¶æ€: ${tripletCheckbox.checked ? 'âœ…å·²å‹¾é€‰' : 'âŒæœªå‹¾é€‰'}`);
    } else {
        console.log('âŒ æ‰¾ä¸åˆ°ä¸‰è¿éŸ³å¤é€‰æ¡†å…ƒç´ ');
    }
    
    // æ¨¡æ‹Ÿç”Ÿæˆå™¨åˆ›å»º
    try {
        const testGenerator = new IntelligentMelodyGenerator(4, 'C', '4/4', 'treble', 12345);
        console.log(`ç”Ÿæˆå™¨allowedDurations: [${testGenerator.rules.allowedDurations.join(', ')}]`);
        console.log(`ç”Ÿæˆå™¨æ”¯æŒä¸‰è¿éŸ³: ${testGenerator.rules.allowedDurations.includes('triplet')}`);
        
        // æµ‹è¯•canGenerateTriplet
        const canGenerate = testGenerator.canGenerateTriplet(2);
        console.log(`2æ‹æ—¶èƒ½ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerate}`);
    } catch (error) {
        console.error('ç”Ÿæˆå™¨åˆ›å»ºå¤±è´¥:', error);
    }
    
    console.log('======================\n');
}

// ====== ä¸»è¦æ¥å£å‡½æ•° ======
/**
 * ğŸš¨ å¼ºåˆ¶ä¿®å¤åæ‹å››åˆ†éŸ³ç¬¦
 * æ–°æ–¹æ¡ˆï¼šç›´æ¥æ‰«ææ•´ä¸ªæ—‹å¾‹ï¼Œæ‰¾åˆ°æ‰€æœ‰1.5æ‹ä½ç½®çš„å››åˆ†éŸ³ç¬¦å¹¶å¼ºåˆ¶æ‹†åˆ†
 */
function forceFixOffBeatQuarterNotes(melody, timeSignature) {
    if (timeSignature !== '4/4') {
        return melody; // åªå¤„ç†4/4æ‹
    }
    
    console.log(`ğŸš¨ğŸš¨ğŸš¨ === å¼ºåˆ¶ä¿®å¤åæ‹å››åˆ†éŸ³ç¬¦ ===`);
    console.log(`ğŸš¨ è¾“å…¥æ—‹å¾‹ç»“æ„: ${Array.isArray(melody) ? 'æ•°ç»„' : 'å…¶ä»–'}, é•¿åº¦=${melody.length}`);
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯äºŒç»´æ•°ç»„ï¼ˆæ¯ä¸ªå°èŠ‚æ˜¯ä¸€ä¸ªæ•°ç»„ï¼‰
    if (melody.length > 0 && Array.isArray(melody[0])) {
        console.log(`ğŸš¨ æ£€æµ‹åˆ°äºŒç»´æ•°ç»„æ ¼å¼ï¼Œå¤„ç†${melody.length}ä¸ªå°èŠ‚`);
        const fixedMelody = [];
        
        // éå†æ¯ä¸ªå°èŠ‚
        for (let measureIndex = 0; measureIndex < melody.length; measureIndex++) {
            const measure = melody[measureIndex];
            const fixedMeasure = [];
            let currentPosition = 0;
            const tolerance = 0.01;
            
            console.log(`ğŸš¨ å¤„ç†ç¬¬${measureIndex + 1}å°èŠ‚ï¼ŒåŒ…å«${measure.length}ä¸ªå…ƒç´ `);
            
            for (let i = 0; i < measure.length; i++) {
                const note = measure[i];
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å››åˆ†éŸ³ç¬¦
                const isQuarterNote = note.type === 'note' && Math.abs(note.beats - 1.0) < tolerance;
                
                // ğŸ¯ åªå¤„ç†ä½ç½®1.5ï¼ˆç¬¬äºŒæ‹åæ‹ï¼‰çš„å››åˆ†éŸ³ç¬¦
                const isAt1_5Position = Math.abs(currentPosition - 1.5) < tolerance;
                
                // é˜²æ­¢å¯¹hammer-on/pull-offéŸ³ç¬¦è¿›è¡Œtieæ‹†åˆ†
                const hasGuitarTechnique = note.articulation === 'hammer-on' || note.articulation === 'pull-off';
                if (isQuarterNote && isAt1_5Position && !note.isTriplet && !hasGuitarTechnique) {
                    console.log(`ğŸ¯ å‘ç°ä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦ï¼å°èŠ‚${measureIndex + 1}ï¼ŒéŸ³é«˜=${note.midi}`);
                    console.log(`ğŸ¯ æ­¤å››åˆ†éŸ³ç¬¦ä¼šè·¨è¶Šç¬¬3æ‹ï¼Œéœ€è¦æ‹†åˆ†`);
                    
                    // æ‹†åˆ†æˆä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦
                    const firstEighth = {
                        ...note,
                        duration: 'eighth',
                        beats: 0.5,
                        tied: true,
                        tieType: 'start'
                    };
                    
                    const secondEighth = {
                        ...note,
                        duration: 'eighth',
                        beats: 0.5,
                        tied: true,
                        tieType: 'stop'
                    };
                    
                    fixedMeasure.push(firstEighth);
                    fixedMeasure.push(secondEighth);
                    
                    const nextBeat = Math.ceil(currentPosition);
                    console.log(`ğŸš¨ å·²æ‹†åˆ†: ${currentPosition}-${nextBeat} (å…«åˆ†éŸ³ç¬¦+tie) + ${nextBeat}-${currentPosition + 1} (å…«åˆ†éŸ³ç¬¦)`);
                } else {
                    // ä¸éœ€è¦æ‹†åˆ†ï¼Œç›´æ¥æ·»åŠ 
                    fixedMeasure.push(note);
                }
                
                currentPosition += note.beats;
            }
            
            fixedMelody.push(fixedMeasure);
            console.log(`ğŸš¨ å°èŠ‚${measureIndex + 1}å¤„ç†å®Œæˆ: ${measure.length} -> ${fixedMeasure.length} ä¸ªå…ƒç´ `);
        }
        
        console.log(`ğŸš¨ å¼ºåˆ¶ä¿®å¤å®Œæˆ: ${melody.length}ä¸ªå°èŠ‚`);
        return fixedMelody;
    } else {
        // ä¸€ç»´æ•°ç»„æ ¼å¼
        console.log(`ğŸš¨ å¤„ç†ä¸€ç»´æ•°ç»„æ ¼å¼`);
        const fixedMelody = [];
        let currentPosition = 0;
        const tolerance = 0.01;
        
        for (let i = 0; i < melody.length; i++) {
            const note = melody[i];
            const measurePosition = currentPosition % 4; // åœ¨å°èŠ‚å†…çš„ä½ç½®
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å››åˆ†éŸ³ç¬¦
            const isQuarterNote = note.type === 'note' && Math.abs(note.beats - 1.0) < tolerance;
            
            // ğŸš¨ åªå¤„ç†1.5å’Œ2.5ä½ç½®çš„å››åˆ†éŸ³ç¬¦
            const needsSplitPositions = [1.5, 2.5];
            const needsSplit = needsSplitPositions.some(pos => Math.abs(measurePosition - pos) < tolerance);
            
            // é˜²æ­¢å¯¹hammer-on/pull-offéŸ³ç¬¦è¿›è¡Œtieæ‹†åˆ†
            const hasGuitarTechnique = note.articulation === 'hammer-on' || note.articulation === 'pull-off';
            if (isQuarterNote && needsSplit && !note.isTriplet && !hasGuitarTechnique) {
                console.log(`ğŸš¨ å‘ç°éœ€è¦æ‹†åˆ†çš„å››åˆ†éŸ³ç¬¦ï¼ä½ç½®=${measurePosition}, éŸ³é«˜=${note.midi}`);
                console.log(`ğŸš¨ ä½ç½®${measurePosition}çš„å››åˆ†éŸ³ç¬¦ä¼šè·¨è¶Šå¼ºæ‹ï¼Œæ‹†åˆ†ä¸ºä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦å¹¶ç”¨tieè¿æ¥`);
                
                // æ‹†åˆ†æˆä¸¤ä¸ªå…«åˆ†éŸ³ç¬¦
                const firstEighth = {
                    ...note,
                    duration: 'eighth',
                    beats: 0.5,
                    tied: true,
                    tieType: 'start'
                };
                
                const secondEighth = {
                    ...note,
                    duration: 'eighth',
                    beats: 0.5,
                    tied: true,
                    tieType: 'stop'
                };
                
                fixedMelody.push(firstEighth);
                fixedMelody.push(secondEighth);
                
                const nextBeat = Math.ceil(measurePosition);
                console.log(`ğŸš¨ å·²æ‹†åˆ†: ${measurePosition}-${nextBeat} (å…«åˆ†éŸ³ç¬¦+tie) + ${nextBeat}-${measurePosition + 1} (å…«åˆ†éŸ³ç¬¦)`);
            } else {
                // ä¸éœ€è¦æ‹†åˆ†ï¼Œç›´æ¥æ·»åŠ 
                fixedMelody.push(note);
            }
            
            currentPosition += note.beats;
            
            // é‡ç½®å°èŠ‚ä½ç½®
            if (currentPosition >= 4) {
                currentPosition = currentPosition % 4;
            }
        }
        
        console.log(`ğŸš¨ å¼ºåˆ¶ä¿®å¤å®Œæˆ: ${melody.length} -> ${fixedMelody.length} ä¸ªéŸ³ç¬¦`);
        return fixedMelody;
    }
}

/**
 * ğŸµ åˆå¹¶4/4æ‹ä¸­çš„è¿çº¿å››åˆ†éŸ³ç¬¦
 * æœ€é«˜æƒé™è§„åˆ™ï¼šåœ¨4/4æ‹ä¸­ï¼Œå¦‚æœä¸¤ä¸ªå››åˆ†éŸ³ç¬¦é€šè¿‡tieè¿æ¥ï¼Œå¹¶ä¸”éƒ½åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼Œå¿…é¡»åˆå¹¶
 * @param {Array} melody - æ—‹å¾‹æ•°ç»„
 * @param {string} timeSignature - æ‹å·
 * @returns {Array} - å¤„ç†åçš„æ—‹å¾‹
 */
function mergeTiedQuarterNotesIn44(melody, timeSignature) {
    // åªå¤„ç†4/4æ‹
    if (timeSignature !== '4/4') {
        return melody;
    }

    console.log('ğŸ¼ === 4/4æ‹è¿çº¿å››åˆ†éŸ³ç¬¦åˆå¹¶å¤„ç† ===');
    let mergeCount = 0;

    // ğŸ¯ ç®€åŒ–åŠ©æ‰‹å‡½æ•°ï¼šåªæ£€æŸ¥çœŸæ­£å¿…è¦çš„å†²çªï¼Œé»˜è®¤å…è®¸åˆå¹¶
    function shouldMergeBasedOnContext(notes, currentIndex, measureIndex, measureCriticalBeats) {
        const currentNote = notes[currentIndex];
        const nextNote = notes[currentIndex + 1];

        // è®¡ç®—ä½ç½®
        let position = 0;
        for (let j = 0; j < currentIndex; j++) {
            position += notes[j].beats || 0;
        }

        const firstNotePos = position;
        const secondNotePos = position + currentNote.beats;
        const beatOfFirst = Math.floor(firstNotePos);
        const beatOfSecond = Math.floor(secondNotePos);
        const mergedStart = firstNotePos;
        const mergedEnd = secondNotePos + nextNote.beats;
        const tolerance = 0.001;

        console.log(`  ğŸ¯ [ç®€åŒ–æ£€æŸ¥] å°èŠ‚${measureIndex + 1}: ä½ç½®${firstNotePos.toFixed(2)}-${secondNotePos.toFixed(2)}, æ‹${beatOfFirst}-${beatOfSecond}`);

        if (Array.isArray(measureCriticalBeats) && measureCriticalBeats.length > 0) {
            const obscuresCriticalBeat = measureCriticalBeats.some(beat =>
                beat > mergedStart + tolerance && beat < mergedEnd - tolerance
            );
            if (obscuresCriticalBeat) {
                console.log(`  âš ï¸ åˆå¹¶ä¼šé®è”½å…³é”®æ‹ç‚¹[${measureCriticalBeats.join(', ')}]ï¼Œä¿ç•™æ‹†åˆ†`);
                return false;
            }
        }

        // è§„å‰²1ï¼šå¦‚æœåœ¨åŒä¸€æ‹å†…ä¸”å„å 0.5æ‹ï¼Œåº”è¯¥ä¿æŒä¸ºå…«åˆ†éŸ³ç¬¦beaming
        if (beatOfFirst === beatOfSecond &&
            Math.abs(currentNote.beats - 0.5) < 0.001 &&
            Math.abs(nextNote.beats - 0.5) < 0.001) {
            console.log(`  âš ï¸ åŒä¸€æ‹å†…çš„0.5æ‹ tiedéŸ³ç¬¦ï¼Œä¿æŒbeamingç»“æ„`);
            return false;
        }

        // è§„å‰²2ï¼šå¯¹äºç›¸é‚»æ‹çš„æ ‡å‡†å››åˆ†éŸ³ç¬¦ï¼Œé»˜è®¤å…è®¸åˆå¹¶
        if (Math.abs(beatOfSecond - beatOfFirst - 1) < 0.001 &&
            Math.abs(currentNote.beats - 1.0) < 0.001 &&
            Math.abs(nextNote.beats - 1.0) < 0.001 &&
            [0, 1, 2, 3].includes(beatOfFirst) &&
            [0, 1, 2, 3].includes(beatOfSecond)) {
            console.log(`  âœ… ç›¸é‚»æ‹çš„æ ‡å‡†å››åˆ†éŸ³ç¬¦ï¼Œå…è®¸åˆå¹¶`);
            return true;
        }

        // å…¶ä»–æƒ…å†µä¿å®ˆå¤„ç†
        console.log(`  âš ï¸ ä¸ç¬¦åˆæ ‡å‡†æƒ…å†µï¼Œä¿å®ˆå¤„ç†`);
        return false;
    }


    for (let measureIndex = 0; measureIndex < melody.length; measureIndex++) {
        const measure = melody[measureIndex];
        if (!measure || !measure.notes) continue;

        const measureCriticalBeats = RHYTHM_NOTATION_RULES.getCriticalBeatsWithLocalRhythm(
            measure.notes,
            timeSignature
        );

        let processedNotes = [];
        let i = 0;

        while (i < measure.notes.length) {
            const currentNote = measure.notes[i];
            const nextNote = measure.notes[i + 1];

            // æ£€æŸ¥æ˜¯å¦æ»¡è¶³åˆå¹¶æ¡ä»¶
            if (currentNote && nextNote &&
                currentNote.type === 'note' && nextNote.type === 'note' &&
                currentNote.duration === 'quarter' && nextNote.duration === 'quarter' &&
                currentNote.tied === true && currentNote.tieType === 'start' &&
                nextNote.tied === true && nextNote.tieType === 'stop' &&
                currentNote.midi === nextNote.midi) {

                // ğŸ¯ æ™ºèƒ½åˆ†æï¼šåŸºäºä¸Šä¸‹æ–‡å†³å®šæ˜¯å¦åˆå¹¶
                const shouldMerge = shouldMergeBasedOnContext(
                    measure.notes,
                    i,
                    measureIndex,
                    measureCriticalBeats
                );
                if (!shouldMerge) {
                    console.log(`  ğŸµ å°èŠ‚${measureIndex + 1}: åŸºäºä¸Šä¸‹æ–‡åˆ†æï¼Œä¸åˆå¹¶è¿™ä¸¤ä¸ªéŸ³ç¬¦`);
                    processedNotes.push(currentNote);
                    i++;
                    continue;
                }

                // è®¡ç®—ä¸¤ä¸ªéŸ³ç¬¦çš„ä½ç½®
                let position = 0;
                for (let j = 0; j < i; j++) {
                    position += measure.notes[j].beats || 0;
                }

                const firstNotePosition = position;
                const secondNotePosition = position + currentNote.beats;

                // æ£€æŸ¥æ˜¯å¦éƒ½åœ¨å››åˆ†éŸ³ç¬¦æ‹ç‚¹ä¸Šï¼ˆ0, 1, 2, 3ï¼‰
                const isFirstOnBeat = [0, 1, 2, 3].includes(Math.round(firstNotePosition));
                const isSecondOnBeat = [0, 1, 2, 3].includes(Math.round(secondNotePosition));

                if (isFirstOnBeat && isSecondOnBeat) {
                    console.log(`  âœ… å°èŠ‚${measureIndex + 1}: åˆå¹¶ä½ç½®${firstNotePosition.toFixed(2)}å’Œ${secondNotePosition.toFixed(2)}çš„å››åˆ†éŸ³ç¬¦`);

                    // åˆ›å»ºåˆå¹¶åçš„äºŒåˆ†éŸ³ç¬¦
                    const mergedNote = {
                        type: 'note',
                        duration: 'half',
                        beats: 2,
                        step: currentNote.step,
                        octave: currentNote.octave,
                        alter: currentNote.alter,
                        midi: currentNote.midi,
                        tied: false,
                        tieType: null
                    };

                    // ä¿ç•™ç¬¬ä¸€ä¸ªéŸ³ç¬¦çš„å…¶ä»–å±æ€§ï¼ˆå¦‚articulationç­‰ï¼‰
                    if (currentNote.articulation) {
                        mergedNote.articulation = currentNote.articulation;
                    }

                    processedNotes.push(mergedNote);
                    mergeCount++;

                    // è·³è¿‡ä¸‹ä¸€ä¸ªéŸ³ç¬¦
                    i += 2;
                } else {
                    // ä¸æ»¡è¶³æ‹ç‚¹æ¡ä»¶ï¼Œä¿ç•™åŸéŸ³ç¬¦
                    processedNotes.push(currentNote);
                    i++;
                }
            } else {
                // ä¸æ»¡è¶³å…¶ä»–æ¡ä»¶ï¼Œä¿ç•™åŸéŸ³ç¬¦
                processedNotes.push(currentNote);
                i++;
            }
        }

        // æ›´æ–°å°èŠ‚çš„éŸ³ç¬¦
        measure.notes = processedNotes;
    }

    if (mergeCount > 0) {
        console.log(`ğŸµ å…±åˆå¹¶äº† ${mergeCount} ç»„è¿çº¿å››åˆ†éŸ³ç¬¦ä¸ºäºŒåˆ†éŸ³ç¬¦`);
    }

    return melody;
}

function generateMelodyData(measures, keySignature, timeSignature, clef, seed = null) {
    let melody; // åœ¨å¤–å±‚å®šä¹‰å˜é‡
    let generator; // åœ¨å¤–å±‚å®šä¹‰ç”Ÿæˆå™¨å˜é‡
    let originalAllowedRhythms; // å­˜å‚¨åŸå§‹è¿éŸ³è®¾ç½®
    if (typeof window !== 'undefined') {
        window.currentTimeSignature = timeSignature;
    }
    
    // ğŸ”¥ å…¨æ–°æ€è·¯ï¼š6/8æ‹ç›´æ¥ç”Ÿæˆå®Œæ•´MusicXMLï¼Œå®Œå…¨ç»•è¿‡å†…éƒ¨æ•°æ®ç»“æ„
    if (timeSignature === '6/8') {
        console.log('ğŸµ 6/8æ‹ä½¿ç”¨å®‰å…¨ç‰ˆæœ¬ç”Ÿæˆç­–ç•¥');
        
        if (!seed) seed = Math.floor(Math.random() * 1000000);
        const random = new SeededRandom(seed);
        
        // å®‰å…¨çš„ç”¨æˆ·è®¾ç½®è·å–
        const userRange = (userSettings && userSettings.customRange) ? 
            { min: userSettings.customRange.min || 48, max: userSettings.customRange.max || 60 } : 
            { min: 48, max: 60 };
        const maxJump = (userSettings && userSettings.maxJump) ? userSettings.maxJump : 12;
        // ğŸ”¥ ä¿®å¤è°ƒå·æ˜¾ç¤ºé—®é¢˜ï¼šæ”¯æŒæ‰€æœ‰è°ƒå·çš„äº”åº¦åœˆè®¡ç®—ï¼ˆä¸å…¶ä»–æ‹å·ä¿æŒä¸€è‡´ï¼‰
        const keyFifthsMap = {
            // å¤§è°ƒ
            'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6, 'C#': 7,
            'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Gb': -6, 'Cb': -7,
            // å°è°ƒï¼ˆä½¿ç”¨ç›¸å¯¹å¤§è°ƒçš„è°ƒå·ï¼‰
            'Am': 0, 'Em': 1, 'Bm': 2, 'F#m': 3, 'C#m': 4, 'G#m': 5, 'D#m': 6, 'A#m': 7,
            'Dm': -1, 'Gm': -2, 'Cm': -3, 'Fm': -4, 'Bbm': -5, 'Ebm': -6
        };
        const keyFifths = keyFifthsMap[keySignature] || 0;
        
        // ğŸ”¥ è·å–ç”¨æˆ·çš„èŠ‚å¥è®¾ç½®å¹¶è¿‡æ»¤è¿éŸ³ç±»å‹
        originalAllowedRhythms = (userSettings && Array.isArray(userSettings.allowedRhythms)) ?
            [...userSettings.allowedRhythms] : ['eighth'];

        // 6/8æ‹ï¼šç§»é™¤ä¸‰è¿éŸ³ï¼Œä¿ç•™äºŒè¿éŸ³å’Œå››è¿éŸ³
        const filtered68Rhythms = originalAllowedRhythms.filter(rhythm => rhythm !== 'triplet');
        console.log(`ğŸµ 6/8æ‹è¿éŸ³è¿‡æ»¤: ç§»é™¤tripletï¼Œä¿ç•™duplet/quadruplet`);
        console.log(`   åŸå§‹: [${originalAllowedRhythms.join(', ')}]`);
        console.log(`   è¿‡æ»¤å: [${filtered68Rhythms.join(', ')}]`);

        const userRhythms = filtered68Rhythms;
        
        // ğŸ”¥ ä¿®å¤ï¼šè·å–ç”¨æˆ·çš„ä¸´æ—¶è®°å·è®¾ç½® - ä¸4/4æ‹ä¿æŒä¸€è‡´
        const accidentalRate = (userSettings && typeof userSettings.accidentalRate === 'number') ? 
            userSettings.accidentalRate / 100 : 0;
        
        console.log('ğŸ›ï¸ 6/8æ‹è®¾ç½®:');
        console.log(`  - éŸ³åŸŸ: ${userRange.min}-${userRange.max}`);
        console.log(`  - æœ€å¤§è·³åº¦: ${maxJump}åŠéŸ³`);
        console.log(`  - è°ƒå·: ${keySignature} (äº”åº¦åœˆ: ${keyFifths})`);
        console.log(`  - å…è®¸çš„èŠ‚å¥: [${userRhythms.join(', ')}]`);
        console.log(`  - ä¸´æ—¶è®°å·æ¦‚ç‡: ${(accidentalRate * 100).toFixed(0)}%`);
        
        // åº”ç”¨4/4æ‹æ™ºèƒ½æ—‹å¾‹ç”Ÿæˆé€»è¾‘åˆ°6/8æ‹
        
        // ğŸ”¥ ä¿®å¤è°ƒå·å¤„ç†ï¼šä½¿ç”¨ä¸4/4æ‹ç›¸åŒçš„è°ƒå·ç³»ç»Ÿ
        // åˆ›å»ºä¸´æ—¶çš„IntelligentMelodyGeneratoræ¥è·å–æ­£ç¡®çš„è°ƒå†…éŸ³ç¬¦å’ŒéŸ³ç¬¦æ‹¼å†™
        const tempGenerator = new IntelligentMelodyGenerator(1, keySignature, '6/8', clef, seed);
        
        // ğŸ”¥ ä½¿ç”¨å¢å¼ºçš„å°è°ƒå¤„ç†ï¼šè·å–åŒ…å«å’Œå£°å°è°ƒ/æ—‹å¾‹å°è°ƒå˜åŒ–éŸ³çš„éŸ³é˜¶
        const baseScale = KEY_SCALES[keySignature] || KEY_SCALES['C'];
        const scale = getEnhancedScaleForGeneration(baseScale, keySignature);
        
        // è¾…åŠ©å‡½æ•°ï¼šä¸ºéŸ³ç¬¦ç”Ÿæˆè·å–å¢å¼ºçš„éŸ³é˜¶
        function getEnhancedScaleForGeneration(naturalScale, keySignature) {
            const isMinorKey = keySignature.includes('m');
            
            if (!isMinorKey) {
                return naturalScale; // å¤§è°ƒä½¿ç”¨åŸéŸ³é˜¶
            }
            
            // å°è°ƒæ·»åŠ å’Œå£°å°è°ƒå’Œæ—‹å¾‹å°è°ƒçš„å˜åŒ–éŸ³
            const enhanced = [...naturalScale];
            
            // ç¡®å®šè°ƒå·çš„ä¸»éŸ³
            const keyToTonic = {
                'Am': 9, 'Em': 4, 'Bm': 11, 'F#m': 6, 'C#m': 1, 'G#m': 8, 'D#m': 3, 'A#m': 10,
                'Dm': 2, 'Gm': 7, 'Cm': 0, 'Fm': 5, 'Bbm': 10, 'Ebm': 3
            };
            
            const tonic = keyToTonic[keySignature];
            if (tonic !== undefined) {
                // æ·»åŠ å’Œå£°å°è°ƒçš„å¯¼éŸ³ï¼ˆå‡é«˜çš„ç¬¬7çº§ï¼‰
                const leadingTone = (tonic + 11) % 12;
                if (!enhanced.includes(leadingTone)) {
                    enhanced.push(leadingTone);
                }
                
                // æ·»åŠ æ—‹å¾‹å°è°ƒçš„ç¬¬6çº§ï¼ˆå‡é«˜çš„ï¼‰
                const sixthDegree = (tonic + 9) % 12;
                if (!enhanced.includes(sixthDegree)) {
                    enhanced.push(sixthDegree);
                }
            }
            
            return enhanced.sort((a, b) => a - b);
        }
        
        // æ™ºèƒ½éŸ³ç¬¦ç”ŸæˆçŠ¶æ€
        let lastDirection = 0;
        let consecutiveJumps = 0;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºè°ƒå†…éŸ³ç¬¦
        function isInScale(midi) {
            return scale.includes(midi % 12);
        }
        
        const chromaticState = { active: false, remaining: 0, direction: 0 };
        let pendingAccidentalPreference = null;
        const minorAllowed = tempGenerator.getAllowedMinorPitchClasses(keySignature);

        function resetChromaticRun() {
            chromaticState.active = false;
            chromaticState.remaining = 0;
            chromaticState.direction = 0;
        }

        function getChromaticRunLength() {
            let maxLen = 2;
            if (accidentalRate >= 0.75) {
                maxLen = 4;
            } else if (accidentalRate >= 0.45) {
                maxLen = 3;
            }
            return random.nextInt(2, maxLen + 1);
        }

        function determineChromaticDirection(lastMidi, targetMidi) {
            if (typeof lastMidi !== 'number') return 1;
            if (typeof targetMidi !== 'number') {
                return random.nextFloat() < 0.5 ? 1 : -1;
            }
            const direction = Math.sign(targetMidi - lastMidi);
            if (direction === 0) {
                return random.nextFloat() < 0.5 ? 1 : -1;
            }
            return direction > 0 ? 1 : -1;
        }

        function isChromaticStepValid(midi) {
            if (midi < userRange.min || midi > userRange.max) {
                return false;
            }
            if (minorAllowed && !minorAllowed.has(midi % 12)) {
                return false;
            }
            return true;
        }

        function queueAccidentalPreference(midi, direction) {
            const preference = direction > 0 ? '#' : 'b';
            pendingAccidentalPreference = { midi, preference };
        }

        function consumeAccidentalPreference(midi) {
            if (pendingAccidentalPreference) {
                if (pendingAccidentalPreference.midi === midi) {
                    const preference = pendingAccidentalPreference.preference;
                    pendingAccidentalPreference = null;
                    return preference;
                }
                pendingAccidentalPreference = null;
            }
            return null;
        }

        // ğŸ”¥ æ”¹ä¸ºåŠéŸ³é˜¶è¿æ¥é€»è¾‘çš„ä¸´æ—¶è®°å·å¤„ç†
        function addAccidentalIfNeeded(midi, lastMidi = null) {
            if (!accidentalRate || accidentalRate <= 0) {
                resetChromaticRun();
                return midi;
            }
            if (typeof lastMidi !== 'number') {
                resetChromaticRun();
                return midi;
            }
            const interval = Math.abs(midi - lastMidi);
            const allowStepwiseRun = interval <= 2;

            if (chromaticState.active && chromaticState.remaining > 0) {
                if (!allowStepwiseRun) {
                    resetChromaticRun();
                    return midi;
                }
                const nextMidi = lastMidi + chromaticState.direction;
                if (isChromaticStepValid(nextMidi)) {
                    chromaticState.remaining -= 1;
                    if (chromaticState.remaining <= 0) {
                        resetChromaticRun();
                    }
                    queueAccidentalPreference(nextMidi, chromaticState.direction);
                    return nextMidi;
                }
                resetChromaticRun();
                return midi;
            }

            if (!allowStepwiseRun || random.nextFloat() >= accidentalRate) {
                return midi;
            }

            const direction = determineChromaticDirection(lastMidi, midi);
            const nextMidi = lastMidi + direction;
            if (!isChromaticStepValid(nextMidi)) {
                return midi;
            }

            const runLength = getChromaticRunLength();
            chromaticState.active = runLength > 1;
            chromaticState.remaining = Math.max(0, runLength - 1);
            chromaticState.direction = direction;
            queueAccidentalPreference(nextMidi, direction);
            return nextMidi;
        }
        
        // æ™ºèƒ½éŸ³ç¬¦ç”Ÿæˆå‡½æ•°ï¼ˆåŸºäº4/4æ‹é€»è¾‘ï¼‰
        function generateIntelligentNote(lastMidi, isEnding = false) {
            const maxAttempts = 100;
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                attempts++;
                const possibleNotes = [];
                
                // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è°ƒå†…éŸ³ç¬¦
                for (let octave = Math.floor(userRange.min / 12); octave <= Math.floor(userRange.max / 12); octave++) {
                    for (const scaleDegree of scale) {
                        const midi = octave * 12 + scaleDegree;
                        if (midi >= userRange.min && midi <= userRange.max) {
                            possibleNotes.push(midi);
                        }
                    }
                }
                
                if (possibleNotes.length === 0) {
                    console.warn('âš ï¸ æ²¡æœ‰å¯ç”¨çš„è°ƒå†…éŸ³ç¬¦ï¼Œä½¿ç”¨éŸ³åŸŸä¸­å¿ƒ');
                    const centerMidi = Math.floor((userRange.min + userRange.max) / 2);
                    return midiToNoteInfo(centerMidi);
                }
                
                let candidateNotes = [];
                
                if (lastMidi === null) {
                    // ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼šé€‰æ‹©è°ƒå†…éŸ³ç¬¦ï¼Œåå‘ä¸»éŸ³ã€ä¸‰éŸ³ã€äº”éŸ³
                    const preferredDegrees = [0, 4, 7].map(deg => deg % 12); // ä¸»éŸ³ã€ä¸‰åº¦ã€äº”åº¦
                    candidateNotes = possibleNotes.filter(midi => preferredDegrees.includes(midi % 12));
                    if (candidateNotes.length === 0) candidateNotes = possibleNotes;
                } else {
                    // åç»­éŸ³ç¬¦ï¼šåº”ç”¨æ™ºèƒ½çº¦æŸ
                    for (const midi of possibleNotes) {
                        const interval = Math.abs(midi - lastMidi);
                        
                        // æ£€æŸ¥éŸ³ç¨‹è·³åº¦é™åˆ¶
                        if (interval > maxJump) continue;
                        
                        // åº”ç”¨éŸ³ä¹æ€§çº¦æŸ
                        const direction = midi > lastMidi ? 1 : midi < lastMidi ? -1 : 0;
                        
                        // å¤§è·³åå¿…é¡»å›å½’
                        if (consecutiveJumps > 0 && interval > 2) continue;
                        
                        // é¿å…è¿ç»­åŒå‘å¤§è·³
                        if (interval > 4 && direction === lastDirection) continue;
                        
                        candidateNotes.push(midi);
                    }
                    
                    // å¦‚æœæ²¡æœ‰åˆé€‚çš„å€™é€‰éŸ³ç¬¦ï¼Œæ”¾å®½é™åˆ¶
                    if (candidateNotes.length === 0) {
                        candidateNotes = possibleNotes.filter(midi => {
                            const interval = Math.abs(midi - lastMidi);
                            return interval <= maxJump;
                        });
                    }
                    
                    if (candidateNotes.length === 0) {
                        console.warn('âš ï¸ æ²¡æœ‰ç¬¦åˆçº¦æŸçš„éŸ³ç¬¦ï¼Œä½¿ç”¨æœ€è¿‘çš„è°ƒå†…éŸ³ç¬¦');
                        candidateNotes = [possibleNotes.reduce((closest, current) => {
                            return Math.abs(current - lastMidi) < Math.abs(closest - lastMidi) ? current : closest;
                        })];
                    }
                }
                
                // é€‰æ‹©éŸ³ç¬¦
                const selectedMidi = candidateNotes[Math.floor(random.next() * candidateNotes.length)];
                
                // ç‰¹æ®Šæ£€æµ‹ MIDI 72 (B#4)
                if (selectedMidi === 72) {
                    console.error(`ğŸ¯ğŸ¯ğŸ¯ [generateIntelligentNote] ç”Ÿæˆäº† MIDI 72 (B#4)!`);
                    console.error(`ğŸ¯ å½“å‰éŸ³åŸŸ: ${userRange.min}-${userRange.max}`);
                    console.error(`ğŸ¯ è°ƒå·: ${keySignature}`);
                    if (userRange.max <= 60) {
                        console.error(`ğŸš¨ğŸš¨ğŸš¨ é”™è¯¯ï¼šMIDI 72 è¶…å‡º C3-C4 éŸ³åŸŸ (${userRange.min}-${userRange.max})`);
                        // å¼ºåˆ¶ä¿®æ­£åˆ°éŸ³åŸŸå†…
                        const correctedMidi = Math.min(selectedMidi, userRange.max);
                        console.error(`ğŸ”§ ä¿®æ­£ MIDI 72 -> ${correctedMidi}`);
                        return midiToNoteInfo(correctedMidi);
                    }
                }
                
                // é¢å¤–çš„èŒƒå›´éªŒè¯
                if (selectedMidi < userRange.min || selectedMidi > userRange.max) {
                    console.error(`ğŸš¨ [generateIntelligentNote] éŸ³ç¬¦è¶…å‡ºèŒƒå›´: MIDI ${selectedMidi} (éŸ³åŸŸ: ${userRange.min}-${userRange.max})`);
                    const correctedMidi = Math.max(userRange.min, Math.min(userRange.max, selectedMidi));
                    console.error(`ğŸ”§ ä¿®æ­£ä¸º: MIDI ${correctedMidi}`);
                    return midiToNoteInfo(correctedMidi);
                }
                
                // æ›´æ–°çŠ¶æ€
                if (lastMidi !== null) {
                    const interval = Math.abs(selectedMidi - lastMidi);
                    const direction = selectedMidi > lastMidi ? 1 : selectedMidi < lastMidi ? -1 : 0;
                    
                    if (interval > 2) {
                        consecutiveJumps++;
                    } else {
                        consecutiveJumps = 0;
                    }
                    
                    lastDirection = direction;
                }
                
                // ğŸ”¥ ä¿®å¤ï¼šåœ¨è¿”å›ä¹‹å‰åº”ç”¨ä¸´æ—¶è®°å·å¤„ç† - ä¸4/4æ‹ä¿æŒä¸€è‡´
                const finalMidi = addAccidentalIfNeeded(selectedMidi, lastMidi);
                return midiToNoteInfo(finalMidi);
            }
            
            // åº”æ€¥å¤„ç†
            const centerMidi = Math.floor((userRange.min + userRange.max) / 2);
            const finalCenterMidi = addAccidentalIfNeeded(centerMidi, lastMidi);
            return midiToNoteInfo(finalCenterMidi);
        }
        
        // ğŸ”¥ ä¿®å¤éŸ³ç¬¦æ‹¼å†™é—®é¢˜ï¼šä½¿ç”¨ä¸4/4æ‹ç›¸åŒçš„éŸ³ç¬¦æ‹¼å†™é€»è¾‘
        function midiToNoteInfo(midi) {
            // ç‰¹æ®Šæ£€æµ‹ MIDI 72 (B#4)
            if (midi === 72) {
                console.error(`ğŸ¯ğŸ¯ğŸ¯ [midiToNoteInfo] å¤„ç† MIDI 72 (B#4)!`);
                console.error(`ğŸ¯ å½“å‰éŸ³åŸŸ: ${userRange.min}-${userRange.max}`);
                console.error(`ğŸ¯ è°ƒå·: ${keySignature}`);
                if (userRange.max <= 60) {
                    console.error(`ğŸš¨ğŸš¨ğŸš¨ é”™è¯¯ï¼šMIDI 72 åœ¨ C3-C4 éŸ³åŸŸä¸­è¢«å¤„ç†!`);
                    // å¼ºåˆ¶ä¿®æ­£
                    midi = userRange.max;
                    console.error(`ğŸ”§ å¼ºåˆ¶ä¿®æ­£ MIDI 72 -> ${midi}`);
                }
            }
            
            // ğŸ”¥ ä½¿ç”¨ä¸4/4æ‹ç›¸åŒçš„éŸ³ç¬¦æ‹¼å†™é€»è¾‘
            // ä½¿ç”¨å¤–éƒ¨å·²åˆ›å»ºçš„tempGeneratoræ¥è°ƒç”¨midiToMusicXMLæ–¹æ³•
            const preferredAccidental = consumeAccidentalPreference(midi);
            const result = tempGenerator.midiToMusicXML(midi, preferredAccidental);
            
            return {
                midi: midi,
                step: result.step,
                alter: result.alter,
                octave: result.octave
            };
        }
        
        // 6/8æ‹æ™ºèƒ½èŠ‚å¥æ¨¡å¼ç”Ÿæˆå™¨
        function generateSmartRhythmPattern() {
            const availableRhythms = userRhythms.filter(rhythm => 
                ['eighth', '16th', 'quarter', 'quarter.', 'half.', 'dotted-half'].includes(rhythm)
            );
            
            console.log(`ğŸµ å¯ç”¨èŠ‚å¥: [${availableRhythms.join(', ')}]`);
            
            // å¦‚æœæ²¡æœ‰åˆé€‚çš„èŠ‚å¥ï¼Œé»˜è®¤ä½¿ç”¨å…«åˆ†éŸ³ç¬¦
            if (availableRhythms.length === 0) {
                return [
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 }
                ];
            }
            
            // æ ¹æ®ç”¨æˆ·è®¾ç½®ç”Ÿæˆä¸åŒçš„6/8æ‹èŠ‚å¥æ¨¡å¼
            const patterns = [];
            
            // åŸºç¡€æ¨¡å¼ï¼šå…­ä¸ªå…«åˆ†éŸ³ç¬¦ï¼ˆå¦‚æœç”¨æˆ·å…è®¸å…«åˆ†éŸ³ç¬¦ï¼‰
            if (availableRhythms.includes('eighth')) {
                // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®
                const eighthFreq = (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.eighth !== undefined) ?
                    userSettings.rhythmFrequencies.eighth : 40; // é»˜è®¤40%

                console.log(`ğŸ¯ 6/8æ‹å…«åˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®: ${eighthFreq}%`);

                if (eighthFreq > 0) {
                    patterns.push({
                        name: 'sixEighths',
                        weight: eighthFreq, // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨é¢‘ç‡ä½œä¸ºæƒé‡
                        pattern: [
                            { duration: 'eighth', beats: 0.5 },
                            { duration: 'eighth', beats: 0.5 },
                            { duration: 'eighth', beats: 0.5 },
                            { duration: 'eighth', beats: 0.5 },
                            { duration: 'eighth', beats: 0.5 },
                            { duration: 'eighth', beats: 0.5 }
                        ]
                    });
                    console.log(`ğŸµ æ·»åŠ å…­ä¸ªå…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œæƒé‡: ${eighthFreq}`);
                } else {
                    console.log(`ğŸš« å…«åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œè·³è¿‡å…«åˆ†éŸ³ç¬¦æ¨¡å¼`);
                }
            }
            
            // é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆå¦‚æœç”¨æˆ·å…è®¸ï¼‰
            if (availableRhythms.includes('quarter.')) {
                // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®
                const dottedQuarterFreq = (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['dotted-quarter'] !== undefined) ?
                    userSettings.rhythmFrequencies['dotted-quarter'] : 35; // é»˜è®¤35%

                console.log(`ğŸ¯ 6/8æ‹é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®: ${dottedQuarterFreq}%`);

                if (dottedQuarterFreq > 0) {
                    patterns.push({
                        name: 'twoDotted',
                        weight: dottedQuarterFreq, // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨é¢‘ç‡ä½œä¸ºæƒé‡
                        pattern: [
                            { duration: 'quarter', dots: 1, beats: 1.5 },
                            { duration: 'quarter', dots: 1, beats: 1.5 }
                        ]
                    });
                    console.log(`ğŸµ æ·»åŠ ä¸¤ä¸ªé™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œæƒé‡: ${dottedQuarterFreq}`);
                } else {
                    console.log(`ğŸš« é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œè·³è¿‡é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼`);
                }
            }
            
            // ğŸ”¥ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆå¦‚æœç”¨æˆ·å…è®¸ï¼‰- æ•´å°èŠ‚æŒç»­éŸ³ç¬¦
            if (availableRhythms.includes('half.') || availableRhythms.includes('dotted-half')) {
                // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼ˆæ˜ å°„åˆ°å…¨éŸ³ç¬¦é¢‘ç‡ï¼‰
                const dottedHalfFreq = (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.whole !== undefined) ?
                    userSettings.rhythmFrequencies.whole : 10; // é»˜è®¤10%

                console.log(`ğŸ¯ 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®(æ˜ å°„åˆ°å…¨éŸ³ç¬¦): ${dottedHalfFreq}%`);

                if (dottedHalfFreq > 0) {
                    patterns.push({
                        name: 'dottedHalf',
                        weight: dottedHalfFreq, // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨é¢‘ç‡ä½œä¸ºæƒé‡
                        pattern: [
                            { duration: 'half', dots: 1, beats: 3.0 }
                        ]
                    });
                    console.log(`ğŸµ æ·»åŠ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œæƒé‡: ${dottedHalfFreq}`);
                } else {
                    console.log(`ğŸš« é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œè·³è¿‡é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼`);
                }
            }
            
            // åå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆå¦‚æœç”¨æˆ·å…è®¸ï¼‰- ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®
            if (availableRhythms.includes('16th')) {
                // è·å–ç”¨æˆ·çš„åå…­åˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®
                const sixteenthFreq = (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['16th'] !== undefined) ?
                    userSettings.rhythmFrequencies['16th'] : 20; // é»˜è®¤20%

                console.log(`ğŸ¯ 6/8æ‹åå…­åˆ†éŸ³ç¬¦é¢‘ç‡è®¾ç½®: ${sixteenthFreq}%`);

                if (sixteenthFreq > 0) {
                    // æ¨¡å¼1: â™¬â™ªâ™¬â™ª (ä¸¤ç»„åå…­åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦) - æœ€å¸¸è§çš„åå…­åˆ†éŸ³ç¬¦æ¨¡å¼
                    if (availableRhythms.includes('eighth')) {
                        patterns.push({
                            name: 'sixteenthEighth',
                            weight: Math.round(sixteenthFreq * 0.6), // ğŸ”¥ ä¿®å¤ï¼š60%çš„é¢‘ç‡æƒé‡
                            pattern: [
                                { duration: '16th', beats: 0.25 },
                                { duration: '16th', beats: 0.25 },
                                { duration: 'eighth', beats: 0.5 },
                                { duration: '16th', beats: 0.25 },
                                { duration: '16th', beats: 0.25 },
                                { duration: 'eighth', beats: 0.5 }
                            ]
                        });
                        console.log(`ğŸµ æ·»åŠ åå…­åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦æ··åˆæ¨¡å¼ï¼Œæƒé‡: ${Math.round(sixteenthFreq * 0.6)}`);
                    }

                    // æ¨¡å¼2: åäºŒä¸ªåå…­åˆ†éŸ³ç¬¦ - è¾ƒå°‘å‡ºç°ï¼Œå¢åŠ æŒ‘æˆ˜æ€§
                    patterns.push({
                        name: 'twelve16th',
                        weight: Math.round(sixteenthFreq * 0.15), // ğŸ”¥ ä¿®å¤ï¼š15%çš„é¢‘ç‡æƒé‡
                        pattern: [
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 },
                            { duration: '16th', beats: 0.25 }
                        ]
                    });
                    console.log(`ğŸµ æ·»åŠ åäºŒä¸ªåå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œæƒé‡: ${Math.round(sixteenthFreq * 0.15)}`);
                } else {
                    console.log(`ğŸš« åå…­åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œè·³è¿‡åå…­åˆ†éŸ³ç¬¦æ¨¡å¼`);
                }
                
                // æ¨¡å¼3: æ··åˆåå…­åˆ†éŸ³ç¬¦å’Œé™„ç‚¹å››åˆ†éŸ³ç¬¦
                if (availableRhythms.includes('quarter.')) {
                    // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨åå…­åˆ†éŸ³ç¬¦å’Œé™„ç‚¹å››åˆ†éŸ³ç¬¦çš„å¹³å‡é¢‘ç‡
                    const dottedQuarterFreq = (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['dotted-quarter'] !== undefined) ?
                        userSettings.rhythmFrequencies['dotted-quarter'] : 35;
                    const mixedWeight = Math.round((sixteenthFreq + dottedQuarterFreq) / 4); // è¾ƒä½æƒé‡ï¼Œå› ä¸ºæ˜¯æ··åˆæ¨¡å¼

                    if (mixedWeight > 0) {
                        patterns.push({
                            name: 'sixteenth_dotted',
                            weight: mixedWeight, // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨è®¡ç®—çš„æƒé‡
                            pattern: [
                                { duration: '16th', beats: 0.25 },
                                { duration: '16th', beats: 0.25 },
                                { duration: '16th', beats: 0.25 },
                                { duration: '16th', beats: 0.25 },
                                { duration: 'quarter', dots: 1, beats: 1.5 }
                            ]
                        });
                        console.log(`ğŸµ æ·»åŠ åå…­åˆ†éŸ³ç¬¦+é™„ç‚¹å››åˆ†éŸ³ç¬¦æ··åˆæ¨¡å¼ï¼Œæƒé‡: ${mixedWeight}`);
                    } else {
                        console.log(`ğŸš« åå…­åˆ†éŸ³ç¬¦æˆ–é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡è¿‡ä½ï¼Œè·³è¿‡æ··åˆæ¨¡å¼`);
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ¨¡å¼ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‘ç”Ÿï¼‰ï¼Œè¿”å›é»˜è®¤å…«åˆ†éŸ³ç¬¦
            if (patterns.length === 0) {
                return [
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 },
                    { duration: 'eighth', beats: 0.5 }
                ];
            }
            
            // ä½¿ç”¨æƒé‡éšæœºé€‰æ‹©æ¨¡å¼
            const weights = patterns.map(p => p.weight);
            const selectedPattern = random.weighted(patterns, weights);
            console.log(`âœ… é€‰æ‹©6/8æ‹èŠ‚å¥æ¨¡å¼: ${selectedPattern.name}`);
            
            return selectedPattern.pattern;
        }
        
        // ğŸµ ä½¿ç”¨æ­£ç¡®çš„6/8æ‹Beat Clarityè§„åˆ™ç”ŸæˆMusicXML
        console.log('ğŸ¼ å¼€å§‹ç”Ÿæˆç¬¦åˆ6/8æ‹è§„åˆ™çš„æ—‹å¾‹');
        
        let currentMidi = null; // ç¬¬ä¸€ä¸ªéŸ³ç¬¦å°†ç”±æ™ºèƒ½å‡½æ•°é€‰æ‹©
        let measuresXML = '';
        const slideAssignmentState68 = createSlideAssignmentState(random);
        console.log(`ğŸšï¸ 6/8 Slideé¢‘ç‡æ§åˆ¶: ${slideAssignmentState68.slideFrequency}% -> æœŸæœ›${slideAssignmentState68.expectedSlides.toFixed(2)}ä¸ª, ${slideAssignmentState68.isUnlimited ? 'ä¸é™æ•°é‡æ¨¡å¼' : `æœ¬æ¡é¢„ç®—${slideAssignmentState68.slideBudget}ä¸ª`}`);
        
        for (let m = 1; m <= measures; m++) {
            measuresXML += `    <measure number="${m}">`;
            
            // æ·»åŠ æ¢è¡Œæ ‡è®° - æ¯4å°èŠ‚å¼ºåˆ¶æ¢è¡Œï¼ˆç¬¬5ã€9ã€13å°èŠ‚ç­‰ï¼‰
            if (m > 4 && ((m - 1) % 4) === 0) {
                measuresXML += `
      <print new-system="yes"/>`;
                console.log(`ğŸ“ åœ¨ç¬¬${m}å°èŠ‚æ·»åŠ æ¢è¡Œæ ‡è®°`);
            }
            
            if (m === 1) {
                measuresXML += `
      <attributes>
        <divisions>4</divisions>
        <key>
          <fifths>${keyFifths}</fifths>
        </key>
        <time>
          <beats>6</beats>
          <beat-type>8</beat-type>
        </time>
        <clef>
          <sign>${clef === 'treble' ? 'G' : 'F'}</sign>
          <line>${clef === 'treble' ? '2' : '4'}</line>
        </clef>
      </attributes>`;
            }
            
            // ğŸµ æ£€æŸ¥æ˜¯å¦éœ€è¦ä¹å¥å‘¼å¸ï¼ˆåœ¨ä¹å¥æœ«å°¾å¢åŠ ä¼‘æ­¢ç¬¦æ¦‚ç‡ï¼‰
            const needsPhraseBreathe = shouldAddPhraseBreathe(m, measures, random);
            
            // ğŸ”¥ ä½¿ç”¨6/8æ‹ä¸“ç”¨çš„Beat Clarityç”Ÿæˆå™¨
            const measureXML = generate68MeasureWithBeatClarity(
                m, 
                currentMidi, 
                scale, 
                userRange, 
                maxJump, 
                m === measures, 
                random,
                needsPhraseBreathe,
                clef,
                keySignature, // ğŸ”¥ ä¼ é€’è°ƒå·å‚æ•°
                accidentalRate, // ğŸ”¥ ä¿®å¤ï¼šä¼ é€’ä¸´æ—¶è®°å·æ¦‚ç‡å‚æ•°
                slideAssignmentState68
            );
            measuresXML += measureXML.xml;
            currentMidi = measureXML.lastMidi;
            
            // ğŸµ å¦‚æœæ˜¯ä¹å¥ç»“å°¾ï¼Œé‡ç½®MIDIä»¥åˆ›å»ºæ–°ä¹å¥çš„èµ·ç‚¹
            if (needsPhraseBreathe && m < measures) {
                console.log(`ğŸµ ç¬¬${m}å°èŠ‚åæ·»åŠ ä¹å¥å‘¼å¸ï¼Œé‡ç½®æ—‹å¾‹èµ·ç‚¹`);
                currentMidi = null; // è®©ä¸‹ä¸€ä¸ªä¹å¥ä»æ–°èµ·ç‚¹å¼€å§‹
            }
            
            measuresXML += `
    </measure>`;
        }
        
        // ğŸµ ä¹å¥å‘¼å¸åˆ¤æ–­å‡½æ•°
        function shouldAddPhraseBreathe(measureNum, totalMeasures, random) {
            // é¿å…æœ€åä¸€å°èŠ‚æ·»åŠ å‘¼å¸ï¼ˆè‡ªç„¶ç»“å°¾ï¼‰
            if (measureNum === totalMeasures) return false;
            
            // ğŸµ ç»å…¸ä¹å¥é•¿åº¦æ¨¡å¼
            const phrasePatterns = [
                { length: 2, probability: 0.6 },  // ä¸¤å°èŠ‚ä¹å¥ï¼ˆå¸¸è§ï¼‰
                { length: 4, probability: 0.8 },  // å››å°èŠ‚ä¹å¥ï¼ˆç»å…¸ï¼‰
                { length: 3, probability: 0.4 },  // ä¸‰å°èŠ‚ä¹å¥ï¼ˆä¸è§„åˆ™ï¼Œè¾ƒå°‘ï¼‰
            ];
            
            // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦ç¬¦åˆä¹å¥ç»“æ„
            for (const pattern of phrasePatterns) {
                if (measureNum % pattern.length === 0) {
                    if (random.nextFloat() < pattern.probability) {
                        console.log(`ğŸµ ç¬¬${measureNum}å°èŠ‚ï¼š${pattern.length}å°èŠ‚ä¹å¥ç»“æ„ï¼Œæ·»åŠ å‘¼å¸ (æ¦‚ç‡${pattern.probability})`);
                        return true;
                    }
                }
            }
            
            // ğŸµ é¢å¤–éšæœºå‘¼å¸æœºä¼šï¼ˆé¿å…è¿‡é•¿è¿ç»­æ—‹å¾‹ï¼‰
            if (measureNum >= 3 && random.nextFloat() < 0.3) {
                console.log(`ğŸµ ç¬¬${measureNum}å°èŠ‚ï¼šéšæœºæ·»åŠ å‘¼å¸ï¼Œé¿å…è¿‡é•¿è¿ç»­`);
                return true;
            }
            
            return false;
        }

        const musicXML = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE score-partwise PUBLIC
    "-//Recordare//DTD MusicXML 4.0 Partwise//EN"
    "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="4.0">
  <part-list>
    <score-part id="P1">
    </score-part>
  </part-list>
  <part id="P1">
${measuresXML}  </part>
</score-partwise>`;

        console.log('âœ… 6/8æ‹å®‰å…¨ç‰ˆæœ¬ç”Ÿæˆå®Œæˆ');

        // ğŸ”¥ æ¢å¤åŸå§‹çš„allowedRhythmsè®¾ç½®ï¼Œé¿å…å½±å“UIæ˜¾ç¤ºå’Œä¸‹æ¬¡ç”Ÿæˆ
        if (originalAllowedRhythms) {
            userSettings.allowedRhythms = originalAllowedRhythms;
            console.log(`ğŸ”„ 6/8æ‹å·²æ¢å¤åŸå§‹è¿éŸ³è®¾ç½®: [${originalAllowedRhythms.join(', ')}]`);
        }

        return {
            melody: [],
            musicXML: musicXML,
            config: { measures, keySignature, timeSignature: '6/8', clef },
            seed,
            stats: {
                totalNotes: measures * 6,
                totalRests: 0,
                timingValid: true,
                message: '6/8æ‹å®‰å…¨ç”Ÿæˆå™¨ - éµå¾ªç”¨æˆ·è®¾ç½®'
            }
        };
    }
    
    try {
        if (!seed) seed = Math.floor(Math.random() * 1000000);
        
        console.log(`\\nğŸ¼ === ç”Ÿæˆæ—‹å¾‹æ•°æ® ===`);
        console.log(`é…ç½®: ${measures}å°èŠ‚ ${timeSignature} ${keySignature}è°ƒ ${clef}è°±å·`);
        console.log(`éšæœºç§å­: ${seed}`);
        
        // ğŸ”¥ é‡ç½®articulationé¢‘ç‡è®¡æ•°å™¨
        window.articulationCounter = {
            total: 0,
            perTwoMeasures: 0,
            currentMeasurePair: 0
        };
        console.log(`ğŸ¯ é‡ç½®articulationé¢‘ç‡æ§åˆ¶å™¨ - æ¯ä¸¤å°èŠ‚æœ€å¤š2ä¸ªarticulation`);
        
        // å‚æ•°éªŒè¯
        if (typeof measures !== 'number' || measures < 1) {
            throw new Error(`Invalid measures: ${measures}`);
        }
        if (typeof keySignature !== 'string') {
            throw new Error(`Invalid keySignature: ${keySignature}`);
        }
        if (typeof timeSignature !== 'string') {
            throw new Error(`Invalid timeSignature: ${timeSignature}`);
        }
        if (typeof clef !== 'string') {
            throw new Error(`Invalid clef: ${clef}`);
        }
        
        // è°ƒè¯•ä¸‰è¿éŸ³è®¾ç½®
        debugTripletSettings();
        console.log(`ğŸ” ç”¨æˆ·è®¾ç½®è°ƒè¯•:`);
        console.log(`  - allowedRhythms: [${userSettings?.allowedRhythms?.join(', ') || 'undefined'}]`);
        console.log(`  - åŒ…å«ä¸‰è¿éŸ³: ${userSettings?.allowedRhythms?.includes('triplet') || false}`);
        console.log(`  - éŸ³åŸŸ: ${userSettings?.customRange?.min || 'undefined'}-${userSettings?.customRange?.max || 'undefined'}`);
        console.log(`  - æœ€å¤§è·³åº¦: ${userSettings?.maxJump || 'undefined'}åŠéŸ³`);
        
        // åˆ›å»ºæ™ºèƒ½ç”Ÿæˆå™¨
        console.log(`ğŸ—ï¸ åˆ›å»ºç”Ÿæˆå™¨...`);
        try {
            // ğŸ”¥ åœ¨åˆ›å»ºç”Ÿæˆå™¨å‰æ·»åŠ å…¨å±€é”™è¯¯ç›‘å¬
            const originalError = console.error;
            window.addEventListener('error', function(e) {
                console.error('ğŸš¨ å…¨å±€é”™è¯¯æ•è·:', e.error);
                if (e.error && e.error.message && e.error.message.includes('toLowerCase')) {
                    console.error('ğŸ” toLowerCaseé”™è¯¯è¯¦æƒ…:', {
                        message: e.error.message,
                        stack: e.error.stack,
                        filename: e.filename,
                        line: e.lineno,
                        column: e.colno
                    });
                }
            });
            
            // ğŸ”¥ æ ¹æ®æ‹å·æ™ºèƒ½è¿‡æ»¤è¿éŸ³ç±»å‹ï¼Œé¿å…å¤šæ‹å·æ¨¡å¼ä¸‹ç”Ÿæˆç©ºç™½å°èŠ‚
            originalAllowedRhythms = userSettings.allowedRhythms ? [...userSettings.allowedRhythms] : [];

            if (timeSignature === '6/8') {
                // 6/8æ‹ï¼šç§»é™¤ä¸‰è¿éŸ³ï¼Œä¿ç•™äºŒè¿éŸ³å’Œå››è¿éŸ³
                const filtered68Rhythms = originalAllowedRhythms.filter(rhythm => rhythm !== 'triplet');
                console.log(`ğŸµ 6/8æ‹è¿éŸ³è¿‡æ»¤: ç§»é™¤tripletï¼Œä¿ç•™duplet/quadruplet`);
                console.log(`   åŸå§‹: [${originalAllowedRhythms.join(', ')}]`);
                console.log(`   è¿‡æ»¤å: [${filtered68Rhythms.join(', ')}]`);
                userSettings.allowedRhythms = filtered68Rhythms;
            } else {
                // å…¶ä»–æ‹å·ï¼šç§»é™¤äºŒè¿éŸ³å’Œå››è¿éŸ³ï¼Œä¿ç•™ä¸‰è¿éŸ³
                const filteredOtherRhythms = originalAllowedRhythms.filter(rhythm =>
                    rhythm !== 'duplet' && rhythm !== 'quadruplet'
                );
                console.log(`ğŸµ ${timeSignature}æ‹è¿éŸ³è¿‡æ»¤: ç§»é™¤duplet/quadrupletï¼Œä¿ç•™triplet`);
                console.log(`   åŸå§‹: [${originalAllowedRhythms.join(', ')}]`);
                console.log(`   è¿‡æ»¤å: [${filteredOtherRhythms.join(', ')}]`);
                userSettings.allowedRhythms = filteredOtherRhythms;
            }

            generator = new IntelligentMelodyGenerator(
                measures, keySignature, timeSignature, clef, seed
            );
            console.log(`âœ… ç”Ÿæˆå™¨åˆ›å»ºæˆåŠŸï¼Œè¿éŸ³ç±»å‹å·²æ™ºèƒ½è¿‡æ»¤`);
        } catch (error) {
            console.error(`âŒ ç”Ÿæˆå™¨åˆ›å»ºå¤±è´¥:`, error);
            console.error(`âŒ é”™è¯¯è¯¦æƒ…:`, error.message);
            console.error(`âŒ é”™è¯¯å †æ ˆ:`, error.stack);
            
            // ğŸ” ç‰¹åˆ«æ£€æŸ¥toLowerCaseç›¸å…³é”™è¯¯
            if (error.message && error.message.includes('toLowerCase')) {
                console.error('ğŸ” toLowerCaseé”™è¯¯åˆ†æ:', {
                    message: error.message,
                    stack: error.stack,
                    userSettings: userSettings,
                    timeSignature: timeSignature,
                    keySignature: keySignature
                });
            }
            throw error;
        }
        
        // ç”Ÿæˆæ—‹å¾‹
        console.log(`ğŸµ å¼€å§‹ç”Ÿæˆæ—‹å¾‹...`);
        try {
            melody = generator.generateMelody();
            console.log(`âœ… æ—‹å¾‹ç”ŸæˆæˆåŠŸ`);
        } catch (error) {
            console.error(`âŒ æ—‹å¾‹ç”Ÿæˆå¤±è´¥:`, error);
            console.error(`âŒ é”™è¯¯è¯¦æƒ…:`, error.message);
            console.error(`âŒ é”™è¯¯å †æ ˆ:`, error.stack);
            throw error;
        }
        
        if (!melody || !Array.isArray(melody) || melody.length === 0) {
            throw new Error('Failed to generate valid melody');
        }
        
        console.log(`âœ… æ—‹å¾‹ç”Ÿæˆå®Œæˆ: ${melody.length}ä¸ªå°èŠ‚`);
        
        // æ³¨ï¼šä½ç½®1.5çš„å››åˆ†éŸ³ç¬¦æ‹†åˆ†å°†åœ¨MusicXMLæ„å»ºé˜¶æ®µå¤„ç†
    } catch (error) {
        console.error(`âŒ generateMelodyData é”™è¯¯:`, error);
        console.error(`âŒ é”™è¯¯å †æ ˆ:`, error.stack);
        throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ä»¥ä¾¿ä¸Šå±‚å¤„ç†
    }

    // Guard: when accidentals are disabled in a major key, force all notes to stay in-scale.
    if (generator && generator.rules && generator.rules.accidentalRate === 0) {
        const keyLower = (keySignature || '').toLowerCase();
        const isMinorKey = keyLower.endsWith('m');
        if (!isMinorKey) {
            const scale = KEY_SCALES[keySignature] || KEY_SCALES['C'] || [0, 2, 4, 5, 7, 9, 11];
            const scaleSet = new Set(scale);
            const scaleNotes = typeof generator.getScaleNotesInRange === 'function'
                ? generator.getScaleNotesInRange()
                : (() => {
                    const notes = [];
                    for (let octave = Math.floor(generator.rules.range.min / 12); octave <= Math.floor(generator.rules.range.max / 12); octave++) {
                        for (let i = 0; i < scale.length; i++) {
                            const midi = octave * 12 + scale[i];
                            if (midi >= generator.rules.range.min && midi <= generator.rules.range.max) notes.push(midi);
                        }
                    }
                    return notes;
                })();
            const snapToScale = (midi) => {
                const pc = ((midi % 12) + 12) % 12;
                if (scaleSet.has(pc)) return midi;
                if (!scaleNotes.length) return midi;
                let best = scaleNotes[0];
                let bestDist = Math.abs(best - midi);
                for (let i = 1; i < scaleNotes.length; i++) {
                    const candidate = scaleNotes[i];
                    const dist = Math.abs(candidate - midi);
                    if (dist < bestDist || (dist === bestDist && candidate < best)) {
                        best = candidate;
                        bestDist = dist;
                    }
                }
                return best;
            };
            let corrections = 0;
            melody.forEach(measure => {
                if (!measure || !Array.isArray(measure.notes)) return;
                measure.notes.forEach(note => {
                    if (note && note.type === 'note' && typeof note.midi === 'number') {
                        const corrected = snapToScale(note.midi);
                        if (corrected !== note.midi) {
                            const correctedInfo = generator.midiToMusicXML(corrected);
                            note.midi = corrected;
                            note.step = correctedInfo.step;
                            note.octave = correctedInfo.octave;
                            note.alter = correctedInfo.alter;
                            corrections++;
                        }
                        if (note.graceNote && typeof note.graceNote.midi === 'number') {
                            const graceCorrected = snapToScale(note.graceNote.midi);
                            if (graceCorrected !== note.graceNote.midi) {
                                const graceInfo = generator.midiToMusicXML(graceCorrected);
                                note.graceNote.midi = graceCorrected;
                                note.graceNote.step = graceInfo.step;
                                note.graceNote.octave = graceInfo.octave;
                                note.graceNote.alter = graceInfo.alter;
                                corrections++;
                            }
                        }
                    }
                });
            });
            if (corrections > 0) {
                console.log(`âœ… Major-key in-scale enforcement applied: ${corrections} corrections`);
            }
        }
    }
    
    // è°ƒè¯•ï¼šæ£€æŸ¥ç”Ÿæˆçš„æ—‹å¾‹æ˜¯å¦åŒ…å«è°ƒå¤–éŸ³ç¬¦
    if (keySignature === 'G' || keySignature === 'D') {
        console.log(`\nğŸ¼ æ£€æŸ¥${keySignature}å¤§è°ƒç”Ÿæˆçš„æ—‹å¾‹...`);
        const scale = KEY_SCALES[keySignature];
        console.log(`${keySignature}å¤§è°ƒéŸ³é˜¶: [${scale.join(', ')}]`);
        
        let hasOutOfScaleNotes = false;
        melody.forEach((note, index) => {
            if (note.type === 'note' && note.midi !== undefined) {
                const pitchClass = note.midi % 12;
                if (!scale.includes(pitchClass)) {
                    console.error(`âŒ å‘ç°è°ƒå¤–éŸ³ç¬¦ï¼ä½ç½®${index}: MIDI ${note.midi} (pc=${pitchClass}) ä¸åœ¨${keySignature}å¤§è°ƒéŸ³é˜¶ä¸­`);
                    hasOutOfScaleNotes = true;
                }
            }
        });
        
        if (!hasOutOfScaleNotes) {
            console.log(`âœ… æ‰€æœ‰éŸ³ç¬¦éƒ½åœ¨${keySignature}å¤§è°ƒéŸ³é˜¶å†…`);
        }
    }
    
    // æ„å»ºMusicXML
    const builder = new MusicXMLBuilder(melody, {
        measures, keySignature, timeSignature, clef
    });
    // å¼ºåˆ¶æ¯è¡Œ4å°èŠ‚ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
    const scoreContainer = document.getElementById('score');
    const containerWidth = scoreContainer ? scoreContainer.clientWidth : window.innerWidth;
    const measuresPerLine = 4;
    
    console.log(`ğŸµ ç”Ÿæˆæ—‹å¾‹æ—¶æ£€æµ‹: å®¹å™¨å®½åº¦=${containerWidth}px, æ¯è¡Œ${measuresPerLine}å°èŠ‚`);
    
    const musicXML = builder.build(measuresPerLine);
    
    // è°ƒè¯•ï¼šæ£€æŸ¥Gå¤§è°ƒå’ŒDå¤§è°ƒçš„XMLè¾“å‡º
    if (keySignature === 'G' || keySignature === 'D') {
        console.log(`\nğŸ” æ£€æŸ¥${keySignature}å¤§è°ƒçš„MusicXMLè¾“å‡º...`);
        
        // æŸ¥æ‰¾æ‰€æœ‰FéŸ³ç¬¦
        const fNoteRegex = /<note>[\s\S]*?<step>F<\/step>[\s\S]*?<\/note>/g;
        const fNotes = musicXML.match(fNoteRegex) || [];
        
        if (fNotes.length > 0) {
            console.log(`æ‰¾åˆ° ${fNotes.length} ä¸ªFéŸ³ç¬¦:`);
            fNotes.forEach((noteXml, index) => {
                const hasAlter = noteXml.includes('<alter>');
                const alterMatch = noteXml.match(/<alter>([-\d]+)<\/alter>/);
                const alterValue = alterMatch ? alterMatch[1] : 'æ— ';
                
                console.log(`  FéŸ³ç¬¦ #${index + 1}: alter=${alterValue} ${hasAlter ? '(æœ‰alteræ ‡ç­¾)' : '(æ— alteræ ‡ç­¾ï¼Œä½¿ç”¨è°ƒå·é»˜è®¤)'}`);
                
                // å¦‚æœæœ‰alter=0ï¼Œè¿™å°±æ˜¯é—®é¢˜æ‰€åœ¨
                if (alterValue === '0') {
                    console.error(`âŒ é”™è¯¯ï¼šå‘ç°alter=0ï¼è¿™ä¼šå¯¼è‡´OSMDæ˜¾ç¤ºè¿˜åŸè®°å·ã€‚`);
                    console.log('å®Œæ•´éŸ³ç¬¦XML:', noteXml.replace(/\n/g, ' '));
                }
            });
        }
        
        // åŒæ ·æ£€æŸ¥CéŸ³ç¬¦ï¼ˆå¯¹Då¤§è°ƒï¼‰
        if (keySignature === 'D') {
            const cNoteRegex = /<note>[\s\S]*?<step>C<\/step>[\s\S]*?<\/note>/g;
            const cNotes = musicXML.match(cNoteRegex) || [];
            if (cNotes.length > 0) {
                console.log(`æ‰¾åˆ° ${cNotes.length} ä¸ªCéŸ³ç¬¦:`);
                cNotes.forEach((noteXml, index) => {
                    const hasAlter = noteXml.includes('<alter>');
                    const alterMatch = noteXml.match(/<alter>([-\d]+)<\/alter>/);
                    const alterValue = alterMatch ? alterMatch[1] : 'æ— ';
                    console.log(`  CéŸ³ç¬¦ #${index + 1}: alter=${alterValue}`);
                });
            }
        }
    }
    
    console.log('âœ… MusicXMLæ„å»ºå®Œæˆ');
    
    // ğŸ”¥ EMERGENCY DEBUG: æœ€ç»ˆMusicXMLå†…å®¹æ£€æŸ¥
    console.log(`ğŸ”¥ === æœ€ç»ˆMusicXMLå†…å®¹æ£€æŸ¥ ===`);
    const allSlurs = musicXML.match(/<slur[^>]*type="start"[^>]*>/g) || [];
    console.log(`ğŸ” å‘ç° ${allSlurs.length} ä¸ªslur startæ ‡ç­¾:`);
    allSlurs.forEach((slur, index) => {
        console.log(`ğŸ¼ Slur ${index + 1}: ${slur}`);
    });
    
    // æ£€æŸ¥é™„è¿‘çš„éŸ³ç¬¦ä¿¡æ¯
    const slurPositions = [];
    let searchIndex = 0;
    let slurCount = 0;
    while ((searchIndex = musicXML.indexOf('<slur', searchIndex)) !== -1) {
        if (musicXML.substr(searchIndex, 50).includes('type="start"')) {
            slurCount++;
            // æ‰¾åˆ°slurå‰æœ€è¿‘çš„éŸ³ç¬¦ä¿¡æ¯
            const beforeSlur = musicXML.substring(Math.max(0, searchIndex - 200), searchIndex);
            const noteMatch = beforeSlur.match(/<step>([A-G])<\/step>\s*<octave>(\d+)<\/octave>/g);
            if (noteMatch) {
                console.log(`ğŸµ Slur ${slurCount} å‰çš„éŸ³ç¬¦: ${noteMatch[noteMatch.length - 1]}`);
            }
        }
        searchIndex += 5;
    }
    console.log(`ğŸ”¥ === MusicXMLæ£€æŸ¥ç»“æŸ ===`);
    
    // ğŸ”¥ é¢å¤–æ£€æŸ¥ï¼šæœç´¢æ‰€æœ‰articulationæ ‡è®°
    const articulationMatches = musicXML.match(/<articulations[^>]*>[\s\S]*?<\/articulations>/g) || [];
    console.log(`ğŸ¸ å‘ç° ${articulationMatches.length} ä¸ªarticulationæ ‡è®°:`);
    articulationMatches.forEach((art, index) => {
        console.log(`ğŸ¸ Articulation ${index + 1}: ${art.substring(0, 100)}...`);
    });
    
    // æ£€æŸ¥æ‰€æœ‰Hå’ŒPæ ‡è®°
    const hPMarks = musicXML.match(/<technical[^>]*>[\s\S]*?<\/technical>/g) || [];
    console.log(`ğŸ¸ å‘ç° ${hPMarks.length} ä¸ªtechnicalæ ‡è®°:`);
    hPMarks.forEach((tech, index) => {
        console.log(`ğŸ¸ Technical ${index + 1}: ${tech}`);
    });
    
    const finalMusicXML = musicXML;
    
    // ğŸ”¥ æ¢å¤åŸå§‹çš„allowedRhythmsè®¾ç½®ï¼Œé¿å…å½±å“UIæ˜¾ç¤ºå’Œä¸‹æ¬¡ç”Ÿæˆ
    if (typeof originalAllowedRhythms !== 'undefined') {
        userSettings.allowedRhythms = originalAllowedRhythms;
        console.log(`ğŸ”„ å·²æ¢å¤åŸå§‹è¿éŸ³è®¾ç½®: [${originalAllowedRhythms.join(', ')}]`);
    }

    return {
        melody,
        musicXML: finalMusicXML,
        stats: generator.stats,
        config: { measures, keySignature, timeSignature, clef },
        seed
    };
}

// ====== ç”¨æˆ·ç•Œé¢å‡½æ•° ======
async function generateMelody() {
    console.log('\\nğŸ¼ === å¼€å§‹ç”Ÿæˆæ–°æ—‹å¾‹ ===');
    
    // ğŸ”¥ æ·»åŠ ä¸´æ—¶çš„String.prototype.toLowerCaseæ‹¦æˆªæ¥å®šä½é”™è¯¯
    const originalToLowerCase = String.prototype.toLowerCase;
    String.prototype.toLowerCase = function() {
        if (this === undefined || this === null) {
            console.error('ğŸš¨ toLowerCaseè¢«è°ƒç”¨åœ¨undefined/nullå€¼ä¸Š!');
            console.error('ğŸš¨ è°ƒç”¨å †æ ˆ:', new Error().stack);
            throw new Error('Cannot read properties of undefined (reading toLowerCase) - è°ƒç”¨å †æ ˆå·²è¾“å‡ºåˆ°æ§åˆ¶å°');
        }
        return originalToLowerCase.call(this);
    };
    
    try {
        // ğŸ”¥ æ–°é€»è¾‘ï¼šä»å¤šé€‰è®¾ç½®ä¸­è·å–å‚æ•°
        const measures = parseInt(document.querySelector('input[name="measures"]:checked').value);
        
        // ä»ç”¨æˆ·è®¾ç½®çš„å¤šé€‰åˆ—è¡¨ä¸­éšæœºé€‰æ‹©
        const keySignature = getRandomFromArray(userSettings.allowedKeys);
        const timeSignature = getRandomFromArray(userSettings.allowedTimeSignatures);
        const clef = getRandomFromArray(userSettings.allowedClefs);
        // ğŸ”¥ éŸ³ç¨‹è·¨åº¦å¤„ç†ï¼šç°åœ¨æ˜¯å•é€‰æ¨¡å¼ï¼Œ6/8æ‹å’Œå…¶ä»–æ‹å·éƒ½ä½¿ç”¨ç›¸åŒçš„é€‰æ‹©å€¼
        const maxJump = userSettings.allowedIntervals[0] || 12; // å•é€‰å€¼
        if (timeSignature === '6/8') {
            console.log(`ğŸ¯ 6/8æ‹éŸ³ç¨‹è·¨åº¦é™åˆ¶ï¼šä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„ ${maxJump} åŠéŸ³ï¼ˆæœ€é«˜ä¼˜å…ˆæƒï¼‰`);
        } else {
            console.log(`ğŸ¯ å…¶ä»–æ‹å·éŸ³ç¨‹è·¨åº¦é™åˆ¶ï¼šä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„ ${maxJump} åŠéŸ³`);
        }
        
        console.log('ğŸ² ä»å¤šé€‰è®¾ç½®éšæœºé€‰æ‹©:');
        console.log(`   è°ƒå·: ${keySignature} (ä» ${userSettings.allowedKeys.length} ä¸ªé€‰é¡¹ä¸­é€‰æ‹©)`);
        console.log(`   æ‹å·: ${timeSignature} (ä» ${userSettings.allowedTimeSignatures.length} ä¸ªé€‰é¡¹ä¸­é€‰æ‹©)`);
        console.log(`   è°±å·: ${clef} (ä» ${userSettings.allowedClefs.length} ä¸ªé€‰é¡¹ä¸­é€‰æ‹©)`);
        console.log(`   æœ€å¤§éŸ³ç¨‹: ${maxJump} (ç”¨æˆ·é€‰æ‹©çš„å•ä¸€éŸ³ç¨‹è·¨åº¦)`);
        
        // éªŒè¯é€‰æ‹©ç»“æœ
        if (!keySignature || !timeSignature || !clef || !maxJump) {
            console.error('âŒ æ— æ³•ä»ç”¨æˆ·è®¾ç½®ä¸­è·å–æœ‰æ•ˆå‚æ•°ï¼Œè¯·æ£€æŸ¥è®¾ç½®');
            alert('ç”Ÿæˆå¤±è´¥ï¼šè¯·ç¡®ä¿æ¯ä¸ªç±»åˆ«éƒ½è‡³å°‘é€‰æ‹©ä¸€ä¸ªé€‰é¡¹ï¼');
            return;
        }
        
        // æ›´æ–°maxJumpè®¾ç½®
        userSettings.maxJump = maxJump;
        
        // æ›´æ–°ç”¨æˆ·è®¾ç½®ï¼ˆä½†ä¸è°ƒæ•´UIæ˜¾ç¤ºçš„éŸ³åŸŸï¼Œä¿æŒç”¨æˆ·å½“å‰çœ‹åˆ°çš„è®¾ç½®ï¼‰
        // updateCustomRange(); // ç§»é™¤ï¼šä¸éœ€è¦é‡æ–°è¯»å–UIçš„éŸ³åŸŸå€¼
        updateMaxJump(); // æ›´æ–°æœ€å¤§éŸ³ç¨‹è·³åŠ¨
        updateRhythmSettingsRealTime(); // å®æ—¶æ›´æ–°èŠ‚å¥è®¾ç½®ï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³
        
        // éªŒè¯å…³é”®è®¾ç½®
        if (!userSettings.customRange || userSettings.customRange.min >= userSettings.customRange.max) {
            console.error('âŒ éŸ³åŸŸè®¾ç½®æ— æ•ˆï¼Œé‡æ–°è®¾ç½®ä¸ºé»˜è®¤å€¼');
            userSettings.customRange = { min: 60, max: 79 }; // C5-C6ï¼Œåœ¨A2-A6èŒƒå›´å†…
        }
        
        // éªŒè¯éŸ³åŸŸåœ¨æ”¯æŒèŒƒå›´å†… (A2=45 åˆ° A6=93)
        if (userSettings.customRange.min < 33) {
            console.warn('âš ï¸ æœ€ä½éŸ³ä½äºA1ï¼Œè°ƒæ•´åˆ°A1');
            userSettings.customRange.min = 33;
        }
        if (userSettings.customRange.max > 93) {
            console.warn('âš ï¸ æœ€é«˜éŸ³é«˜äºE6ï¼Œè°ƒæ•´åˆ°E6');
            userSettings.customRange.max = 93;
        }

        if (!userSettings.maxJump || userSettings.maxJump < 1 || userSettings.maxJump > 12) {
            console.error('âŒ æœ€å¤§éŸ³ç¨‹è·³åº¦è®¾ç½®æ— æ•ˆï¼Œé‡æ–°è®¾ç½®ä¸ºé»˜è®¤å€¼');
            userSettings.maxJump = 12;
        }
        
        console.log('ç”¨æˆ·è®¾ç½®:', { measures, keySignature, timeSignature, clef });
        console.log('âœ… å·²éªŒè¯çš„è‡ªå®šä¹‰è®¾ç½®:', userSettings);
        console.log(`ğŸ¹ éŸ³åŸŸçº¦æŸ: MIDI ${userSettings.customRange.min}-${userSettings.customRange.max}`);
        console.log(`ğŸ¶ æœ€å¤§è·³åº¦çº¦æŸ: ${userSettings.maxJump}åŠéŸ³`);

        // ç”Ÿæˆæ—‹å¾‹æ•°æ®
        const melodyData = generateMelodyData(measures, keySignature, timeSignature, clef);
        
        // ä¿å­˜å†å²
        melodyHistory.push(melodyData);
        if (melodyHistory.length > 20) melodyHistory.shift();
        currentHistoryIndex = melodyHistory.length - 1;

        // æ¸²æŸ“
        await renderScore(melodyData);
        
        // æ›´æ–°ç»Ÿè®¡
        updateStatistics(melodyData);
        
        // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹è°±å·
        currentDisplayedClef = clef;
        console.log(`ğŸ¼ å½“å‰æ˜¾ç¤ºæ—‹å¾‹è°±å·å·²æ›´æ–°ä¸º: ${clef}`);
        
        // æ›´æ–°UIæ˜¾ç¤ºä¸ºå½“å‰è°±å·çš„éŸ³åŸŸè®¾ç½®
        updateUIForClefRange(clef);
        
        console.log('ğŸ‰ ç”Ÿæˆå’Œæ¸²æŸ“å®Œæˆï¼');
        
    } catch (error) {
        console.error('âŒ ç”Ÿæˆå¤±è´¥:', error);
        
        const scoreDiv = document.getElementById('score');
        scoreDiv.innerHTML = `
            <div style="color: red; padding: 50px; text-align: center;">
                <h3>ç”Ÿæˆå¤±è´¥</h3>
                <p><strong>é”™è¯¯:</strong> ${error.message}</p>
                <p>è¯·æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</p>
            </div>
        `;
    } finally {
        // ğŸ”¥ æ¢å¤åŸå§‹çš„toLowerCaseæ–¹æ³•
        String.prototype.toLowerCase = originalToLowerCase;
        console.log('ğŸ”„ å·²æ¢å¤åŸå§‹toLowerCaseæ–¹æ³•');
    }
}

function previousMelody() {
    if (currentHistoryIndex > 0) {
        currentHistoryIndex--;
        const melodyData = melodyHistory[currentHistoryIndex];
        renderScore(melodyData);
        updateStatistics(melodyData);
        
        // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹è°±å·å’ŒUI
        if (melodyData.config && melodyData.config.clef) {
            currentDisplayedClef = melodyData.config.clef;
            console.log(`ğŸ¼ å½“å‰æ˜¾ç¤ºæ—‹å¾‹è°±å·å·²æ›´æ–°ä¸º: ${melodyData.config.clef}`);
            
            // æ›´æ–°UIæ˜¾ç¤ºä¸ºå½“å‰è°±å·çš„éŸ³åŸŸè®¾ç½®
            updateUIForClefRange(melodyData.config.clef);
        }
        
        console.log('â¬…ï¸ åˆ‡æ¢åˆ°ä¸Šä¸€æ¡æ—‹å¾‹');
    }
}

function nextMelody() {
    if (currentHistoryIndex < melodyHistory.length - 1) {
        currentHistoryIndex++;
        const melodyData = melodyHistory[currentHistoryIndex];
        renderScore(melodyData);
        updateStatistics(melodyData);
        
        // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹è°±å·å’ŒUI
        if (melodyData.config && melodyData.config.clef) {
            currentDisplayedClef = melodyData.config.clef;
            console.log(`ğŸ¼ å½“å‰æ˜¾ç¤ºæ—‹å¾‹è°±å·å·²æ›´æ–°ä¸º: ${melodyData.config.clef}`);
            
            // æ›´æ–°UIæ˜¾ç¤ºä¸ºå½“å‰è°±å·çš„éŸ³åŸŸè®¾ç½®
            updateUIForClefRange(melodyData.config.clef);
        }
        
        console.log('â¡ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€æ¡æ—‹å¾‹');
    }
}

async function regenerateSameSeed() {
    if (melodyHistory.length > 0 && currentHistoryIndex >= 0) {
        const currentMelody = melodyHistory[currentHistoryIndex];
        const { config, seed } = currentMelody;
        
        console.log(`ğŸ”„ ä½¿ç”¨ç›¸åŒç§å­é‡æ–°ç”Ÿæˆæ—‹å¾‹: ${seed}`);
        
        try {
            // è·å–å½“å‰è®¾ç½®å¹¶æ›´æ–°ç”¨æˆ·è®¾ç½®ï¼ˆä½†ä¸æ”¹å˜UIæ˜¾ç¤ºçš„éŸ³åŸŸï¼‰
            updateMaxJump();
            updateRhythmSettingsRealTime();
            
            // ä½¿ç”¨ç›¸åŒçš„é…ç½®å’Œç§å­é‡æ–°ç”Ÿæˆ
            const melodyData = generateMelodyData(
                config.measures, 
                config.keySignature, 
                config.timeSignature, 
                config.clef, 
                seed
            );
            
            // æ›¿æ¢å½“å‰å†å²è®°å½•ä¸­çš„æ—‹å¾‹
            melodyHistory[currentHistoryIndex] = melodyData;
            
            // é‡æ–°æ¸²æŸ“å’Œæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            await renderScore(melodyData);
            updateStatistics(melodyData);
            
            // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹è°±å·
            currentDisplayedClef = config.clef;
            console.log(`ğŸ¼ å½“å‰æ˜¾ç¤ºæ—‹å¾‹è°±å·å·²æ›´æ–°ä¸º: ${config.clef}`);
            
            // æ›´æ–°UIæ˜¾ç¤ºä¸ºå½“å‰è°±å·çš„éŸ³åŸŸè®¾ç½®
            updateUIForClefRange(config.clef);
            
            console.log('âœ… ç›¸åŒç§å­æ—‹å¾‹é‡æ–°ç”Ÿæˆå®Œæˆ');
        } catch (error) {
            console.error('âŒ é‡æ–°ç”Ÿæˆæ—‹å¾‹å¤±è´¥:', error);
        }
    } else {
        console.warn('âš ï¸ æ²¡æœ‰å¯ç”¨çš„æ—‹å¾‹å†å²è®°å½•');
    }
}

function updateStatistics(melodyData) {
    const { stats, config, seed } = melodyData;
    
    // å®‰å…¨æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ - åªåœ¨å…ƒç´ å­˜åœ¨æ—¶æ›´æ–°
    const noteCountEl = document.getElementById('noteCount');
    if (noteCountEl) noteCountEl.textContent = `${stats.noteCount}éŸ³ç¬¦ + ${stats.restCount}ä¼‘æ­¢ç¬¦`;
    
    const rangeEl = document.getElementById('range');
    if (rangeEl) rangeEl.textContent = `${stats.maxMidi - stats.minMidi} åŠéŸ³`;
    
    const maxIntervalEl = document.getElementById('maxIntervalStat');
    if (maxIntervalEl) maxIntervalEl.textContent = `${stats.maxInterval} åŠéŸ³`;
    
    const restRatioEl = document.getElementById('restRatio');
    if (restRatioEl) restRatioEl.textContent = `${(stats.restRatio * 100).toFixed(1)}%`;
    
    const seedEl = document.getElementById('currentSeed');
    if (seedEl) seedEl.textContent = seed;
    
    // æ›´æ–°æ‹å·ç±»å‹ä¿¡æ¯
    updateTimeSignatureInfo(config.timeSignature, stats);
    
    const constraintCheck = stats.maxInterval <= (userSettings?.maxJump || 12) ? 'âœ…' : 'âŒ';
    const rangeCheck = (stats.minMidi >= (userSettings?.customRange?.min || 60) && 
                       stats.maxMidi <= (userSettings?.customRange?.max || 72)) ? 'âœ…' : 'âŒ';
    
    const debugText = 
        `ç”¨æˆ·è‡ªå®šä¹‰è®¾ç½®: MIDIéŸ³åŸŸ${userSettings?.customRange?.min || 60}-${userSettings?.customRange?.max || 72} (æ”¯æŒA2-A6) æœ€å¤§è·³è¿›${userSettings?.maxJump || 12}åŠéŸ³\\n` +
        `ç”Ÿæˆé…ç½®: ${config.measures}å°èŠ‚ ${config.timeSignature}æ‹ ${config.keySignature}è°ƒ ${config.clef}è°±å·\\n` +
        `å†…å®¹åˆ†æ: ${stats.noteCount}éŸ³ç¬¦ ${stats.restCount}ä¼‘æ­¢ç¬¦ ${stats.beamCount}ä¸ªbeamè¿æ¥\\n` +
        `éŸ³åŸŸç»Ÿè®¡: æœ€ä½${stats.minMidi} æœ€é«˜${stats.maxMidi} å®é™…æœ€å¤§è·³è¿›${stats.maxInterval}åŠéŸ³\\n` +
        `çº¦æŸéªŒè¯: ${constraintCheck}è·³è¿›é™åˆ¶ ${rangeCheck}éŸ³åŸŸé™åˆ¶${stats.constraintViolations ? ' è¿è§„æ¬¡æ•°:' + stats.constraintViolations : ''}\\n` +
        `è´¨é‡æŒ‡æ ‡: ä¼‘æ­¢ç¬¦æ¯”ä¾‹${(stats.restRatio*100).toFixed(1)}% ä¸´æ—¶è®°å·${userSettings?.accidentalRate || 0}%æ¦‚ç‡\\n` +
        `æ¸²æŸ“å¼•æ“: OpenSheetMusicDisplayä¸“ä¸šæ’ç‰ˆ | ç§å­: ${seed}`;
    
    // å®‰å…¨æ›´æ–°è°ƒè¯•ä¿¡æ¯ - åªåœ¨å…ƒç´ å­˜åœ¨æ—¶æ›´æ–°
    const debugInfoEl = document.getElementById('debugInfo');
    if (debugInfoEl) debugInfoEl.textContent = debugText;
}

// ====== æ–°åŠŸèƒ½å‡½æ•° ======

/**
 * æ‰“å¼€èŠ‚å¥è®¾ç½®å¼¹çª—
 */
function openRhythmSettings() {
    console.log('ğŸ“ æ‰“å¼€èŠ‚å¥è®¾ç½®å¼¹çª—');
    
    // æ ¹æ®å½“å‰è®¾ç½®æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
    const rhythmInputs = document.querySelectorAll('#rhythmModal input[type="checkbox"]');
    rhythmInputs.forEach(input => {
        if (input.id === 'allowDottedNotes') {
            input.checked = userSettings.allowDottedNotes;
        } else {
            input.checked = Array.isArray(userSettings.allowedRhythms) && userSettings.allowedRhythms.includes(input.value);
        }
    });
    
    // æ¢å¤é¢‘ç‡è®¾ç½®
    if (userSettings.rhythmFrequencies) {
        Object.entries(userSettings.rhythmFrequencies).forEach(([type, value]) => {
            const slider = document.getElementById(`freq-${type}`);
            const valueSpan = document.getElementById(`freq-${type}-value`);
            if (slider && valueSpan) {
                slider.value = value;
                valueSpan.textContent = value + '%';
            }
        });
    }
    
    document.getElementById('rhythmModal').style.display = 'flex';
    syncSelectAllState(
        'rhythms',
        [
            'rhythm-whole',
            'rhythm-dotted-half',
            'rhythm-half',
            'rhythm-dotted-quarter',
            'rhythm-quarter',
            'rhythm-eighth',
            'rhythm-16th',
            'rhythm-triplet',
            'rhythm-duplet',
            'rhythm-quadruplet'
        ],
        'button[onclick="selectAllRhythms()"]'
    );
    
    // ğŸ”„ åˆå§‹åŒ–åŒæ­¥æœºåˆ¶
    setTimeout(() => {
        initializeRhythmCheckboxSync();
        console.log('âœ… èŠ‚å¥è®¾ç½®åŒæ­¥æœºåˆ¶å·²åˆå§‹åŒ–');
    }, 100);
}

/**
 * å…³é—­èŠ‚å¥è®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰
 */
function closeRhythmSettingsWithSave() {
    console.log('âŒ å…³é—­èŠ‚å¥è®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    // æ”¶é›†é€‰ä¸­çš„åŸºæœ¬èŠ‚å¥ç±»å‹
    const selectedRhythms = [];
    const basicRhythmInputs = document.querySelectorAll('#rhythmModal input[type="checkbox"]');
    basicRhythmInputs.forEach(input => {
        if (input.checked) {
            selectedRhythms.push(input.value);
        }
    });
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (selectedRhythms.length > 0) {
        const allowDottedNotesElement = document.getElementById('allowDottedNotes');
        const allowDottedNotes = allowDottedNotesElement ? allowDottedNotesElement.checked : false;
        
        let finalRhythms = [...selectedRhythms];
        if (allowDottedNotes) {
            // ğŸµ ä¿®å¤é™„ç‚¹éŸ³ç¬¦ä¾èµ–é€»è¾‘ï¼šé™„ç‚¹éŸ³ç¬¦=åŸéŸ³ç¬¦+å…¶ä¸€åŠæ—¶å€¼
            // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = äºŒåˆ†éŸ³ç¬¦ + å››åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰å››åˆ†éŸ³ç¬¦ï¼‰
            if (selectedRhythms.includes('half') && selectedRhythms.includes('quarter')) {
                finalRhythms.push('half.');
            }
            // é™„ç‚¹å››åˆ†éŸ³ç¬¦ = å››åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰å…«åˆ†éŸ³ç¬¦ï¼‰
            if (selectedRhythms.includes('quarter') && selectedRhythms.includes('eighth')) {
                finalRhythms.push('quarter.');
            }
            // é™„ç‚¹å…«åˆ†éŸ³ç¬¦ = å…«åˆ†éŸ³ç¬¦ + åå…­åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰åå…­åˆ†éŸ³ç¬¦ï¼‰
            if (selectedRhythms.includes('eighth') && selectedRhythms.includes('16th')) {
                finalRhythms.push('eighth.');
            }
        } else {
            // ğŸ”’ å…³é—­æ€»å¼€å…³æ—¶ï¼Œç¡®ä¿ä¸ä¿å­˜ä»»ä½•é™„ç‚¹æ—¶å€¼
            const before = [...finalRhythms];
            finalRhythms = finalRhythms.filter(r => !(r.includes('.') || r.startsWith('dotted-')));
            if (before.length !== finalRhythms.length) {
                console.log(`ğŸ§¹ å…³é—­æ€»å¼€å…³ï¼šä¿å­˜å‰ç§»é™¤é™„ç‚¹æ—¶å€¼ [${before.join(', ')}] -> [${finalRhythms.join(', ')}]`);
            }
        }
        
        const frequencies = {};
        const rhythmTypes = ['dotted', 'whole', 'dotted-half', 'half', 'dotted-quarter', 'quarter', 'dotted-eighth', 'eighth', '16th', 'triplet', 'duplet', 'quadruplet'];
        rhythmTypes.forEach(type => {
            const slider = document.getElementById(`freq-${type}`);
            if (slider) {
                frequencies[type] = parseInt(slider.value);
            }
        });
        
        userSettings.allowedRhythms = finalRhythms;
        userSettings.allowDottedNotes = allowDottedNotes;
        userSettings.rhythmFrequencies = frequencies;
        
        console.log(`âœ… èŠ‚å¥è®¾ç½®å·²é™é»˜ä¿å­˜`);
    }
    
    document.getElementById('rhythmModal').style.display = 'none';
    resetSelectAllStates();
}

/**
 * å…³é—­èŠ‚å¥è®¾ç½®å¼¹çª—
 */
function closeRhythmSettings() {
    console.log('âŒ å…³é—­èŠ‚å¥è®¾ç½®å¼¹çª—');
    closeRhythmSettingsWithSave();
}

/**
 * ä¿å­˜èŠ‚å¥è®¾ç½®
 */
function saveRhythmSettings() {
    console.log('ğŸ’¾ ä¿å­˜èŠ‚å¥è®¾ç½®');
    
    // æ”¶é›†é€‰ä¸­çš„åŸºæœ¬èŠ‚å¥ç±»å‹
    const selectedRhythms = [];
    const basicRhythmInputs = document.querySelectorAll('#rhythmModal input[type="checkbox"]');
    basicRhythmInputs.forEach(input => {
        if (input.checked) {
            selectedRhythms.push(input.value);
        }
    });
    
    // è‡³å°‘é€‰æ‹©ä¸€ç§åŸºæœ¬èŠ‚å¥
    if (selectedRhythms.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§åŸºæœ¬èŠ‚å¥ç±»å‹ï¼');
        return;
    }
    
    // è·å–é™„ç‚¹éŸ³ç¬¦è®¾ç½® (å¦‚æœå…ƒç´ å­˜åœ¨)
    const allowDottedNotesElement = document.getElementById('allowDottedNotes');
    const allowDottedNotes = allowDottedNotesElement ? allowDottedNotesElement.checked : false;
    
    // ğŸµ ä¿®å¤é™„ç‚¹éŸ³ç¬¦ä¾èµ–é€»è¾‘ï¼šé™„ç‚¹éŸ³ç¬¦=åŸéŸ³ç¬¦+å…¶ä¸€åŠæ—¶å€¼
    let finalRhythms = Array.isArray(selectedRhythms) ? [...selectedRhythms] : [];
    if (allowDottedNotes && Array.isArray(selectedRhythms)) {
        // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = äºŒåˆ†éŸ³ç¬¦ + å››åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰å››åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('half') && selectedRhythms.includes('quarter')) {
            finalRhythms.push('half.');
        }
        // é™„ç‚¹å››åˆ†éŸ³ç¬¦ = å››åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰å…«åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('quarter') && selectedRhythms.includes('eighth')) {
            finalRhythms.push('quarter.');
        }
        // é™„ç‚¹å…«åˆ†éŸ³ç¬¦ = å…«åˆ†éŸ³ç¬¦ + åå…­åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦å‹¾é€‰åå…­åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('eighth') && selectedRhythms.includes('16th')) {
            finalRhythms.push('eighth.');
        }
    } else if (!allowDottedNotes) {
        // ğŸ”’ å…³é—­æ€»å¼€å…³æ—¶ï¼Œç¡®ä¿ä¸ä¿å­˜ä»»ä½•é™„ç‚¹æ—¶å€¼
        const before = [...finalRhythms];
        finalRhythms = finalRhythms.filter(r => !(r.includes('.') || r.startsWith('dotted-')));
        if (before.length !== finalRhythms.length) {
            console.log(`ğŸ§¹ å…³é—­æ€»å¼€å…³ï¼šä¿å­˜å‰ç§»é™¤é™„ç‚¹æ—¶å€¼ [${before.join(', ')}] -> [${finalRhythms.join(', ')}]`);
        }
    }
    
    // æ”¶é›†é¢‘ç‡è®¾ç½® - ğŸ”¥ ä¿®å¤ï¼šæ·»åŠ ç¼ºå¤±çš„dupletå’Œquadrupletï¼Œä»¥åŠdotted-quarter
    const frequencies = {};
    const rhythmTypes = ['dotted', 'whole', 'dotted-half', 'half', 'dotted-quarter', 'quarter', 'dotted-eighth', 'eighth', '16th', 'triplet', 'duplet', 'quadruplet'];
    rhythmTypes.forEach(type => {
        const slider = document.getElementById(`freq-${type}`);
        if (slider) {
            frequencies[type] = parseInt(slider.value);
            console.log(`ğŸ“Š æ”¶é›†é¢‘ç‡è®¾ç½®: ${type} = ${frequencies[type]}%`);
        } else {
            console.warn(`âš ï¸ é¢‘ç‡æ»‘å—æœªæ‰¾åˆ°: freq-${type}`);
        }
    });
    
    // æ›´æ–°è®¾ç½®
    userSettings.allowedRhythms = finalRhythms;
    userSettings.allowDottedNotes = allowDottedNotes;
    userSettings.rhythmFrequencies = frequencies;
    
    console.log(`âœ… åŸºæœ¬èŠ‚å¥å·²ä¿å­˜: ${selectedRhythms.join(', ')}`);
    console.log(`âœ… å…è®¸é™„ç‚¹éŸ³ç¬¦: ${allowDottedNotes}`);
    console.log(`âœ… æœ€ç»ˆèŠ‚å¥åˆ—è¡¨: ${finalRhythms.join(', ')}`);
    console.log(`âœ… èŠ‚å¥é¢‘ç‡è®¾ç½®: ${JSON.stringify(frequencies)}`);
    
    closeRhythmSettings();
}

/**
 * æ‰“å¼€Articulationè®¾ç½®å¼¹çª—
 */
function openArticulationSettings() {
    console.log('ğŸµ æ‰“å¼€Articulation & Ornamentsè®¾ç½®å¼¹çª—');
    
    try {
        // ğŸ”¥ å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿userSettings.articulationså­˜åœ¨
        if (!userSettings.articulations) {
            console.warn('âš ï¸ userSettings.articulationsä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–é»˜è®¤è®¾ç½®');
            userSettings.articulations = {
                enabled: false,
                basic: [],
                guitar: [],
                ornaments: [],
                strings: [],
                bass: [],
                frequencies: {
                    staccato: 20,
                    accent: 15,
                    acciaccatura: 10,
                    slur: 15,
                    slide: 10
                }
            };
        }
        
        // æ¢å¤å½“å‰è®¾ç½®åˆ°UI
        const artSettings = userSettings.articulations;
        const requiredFreqTypes = ['staccato', 'accent', 'acciaccatura', 'slur', 'slide'];
        if (!artSettings.frequencies || typeof artSettings.frequencies !== 'object') {
            artSettings.frequencies = {};
        }
        requiredFreqTypes.forEach(type => {
            if (artSettings.frequencies[type] === undefined) {
                artSettings.frequencies[type] = getDefaultArticulationFrequency(type);
            }
        });
    
        // ğŸ”¥ å®‰å…¨æ£€æŸ¥DOMå…ƒç´ å¹¶æ¢å¤è®¾ç½®
        const elementsToCheck = [
            {id: 'art-staccato', type: 'basic', value: 'staccato'},
            {id: 'art-accent', type: 'basic', value: 'accent'},
            {id: 'art-acciaccatura', type: 'basic', value: 'acciaccatura'},
            {id: 'gtr-hammer', type: 'guitar', value: 'hammer-on'},
            {id: 'gtr-pull', type: 'guitar', value: 'pull-off'},
            {id: 'gtr-glissando', type: 'guitar', value: 'glissando'},
            {id: 'gtr-slide-in', type: 'guitar', value: 'slide-in'},
            {id: 'gtr-slide-out', type: 'guitar', value: 'slide-out'}
        ];

        elementsToCheck.forEach(({id, type, value}) => {
            const element = document.getElementById(id);
            if (element) {
                element.checked = artSettings[type].includes(value);
                console.log(`âœ… æ¢å¤${id}è®¾ç½®: ${element.checked}`);
            } else {
                console.warn(`âš ï¸ æœªæ‰¾åˆ°å…ƒç´ : ${id}`);
            }
        });
    
    // å¼¦ä¹æŠ€å·§å·²ç§»é™¤
    
    // è´æ–¯æŠ€å·§å·²ç§»é™¤
    
        // æ¢å¤é¢‘ç‡è®¾ç½®
        if (artSettings.frequencies) {
            console.log('ğŸ›ï¸ æ¢å¤é¢‘ç‡è®¾ç½®:', artSettings.frequencies);
            Object.entries(artSettings.frequencies).forEach(([type, value]) => {
                const slider = document.getElementById(`freq-${type}`);
                const valueSpan = document.getElementById(`freq-${type}-value`);
                if (slider && valueSpan) {
                    slider.value = value;
                    valueSpan.textContent = value + '%';
                    console.log(`âœ… æ¢å¤é¢‘ç‡${type}: ${value}%`);
                } else {
                    console.warn(`âš ï¸ æœªæ‰¾åˆ°é¢‘ç‡æ§åˆ¶å…ƒç´ : freq-${type}`);
                }
            });
        }
        
        // ğŸ”¥ æœ€ç»ˆæ£€æŸ¥ï¼šç¡®ä¿æ¨¡æ€æ¡†å…ƒç´ å­˜åœ¨
        const modal = document.getElementById('articulationModal');
        if (modal) {
            modal.style.display = 'flex';
            syncSelectAllState(
                'basicArticulations',
                ['art-staccato', 'art-accent', 'art-acciaccatura'],
                'button[onclick="selectAllBasicArticulations()"]'
            );
            syncSelectAllState(
                'guitarTechniques',
                ['gtr-hammer', 'gtr-pull', 'gtr-glissando', 'gtr-slide-in', 'gtr-slide-out'],
                'button[onclick="selectAllGuitarTechniques()"]'
            );
            console.log('âœ… Articulationè®¾ç½®å¼¹çª—å·²æ‰“å¼€');
            
            // ğŸ”„ åˆå§‹åŒ–åŒæ­¥æœºåˆ¶
            setTimeout(() => {
                initializeArticulationCheckboxSync();
                console.log('âœ… æ¼”å¥æ³•è®¾ç½®åŒæ­¥æœºåˆ¶å·²åˆå§‹åŒ–');
            }, 100);
        } else {
            console.error('âŒ æœªæ‰¾åˆ°articulationModalå…ƒç´ ');
            throw new Error('articulationModalå…ƒç´ ä¸å­˜åœ¨');
        }
        
    } catch (error) {
        console.error('âŒ æ‰“å¼€Articulationè®¾ç½®å¼¹çª—æ—¶å‡ºé”™:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        alert('æ‰“å¼€è®¾ç½®æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚');
    }
}

/**
 * å…³é—­Articulationè®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰  
 */
function closeArticulationSettingsWithSave() {
    console.log('âŒ å…³é—­Articulationè®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    const artSettings = {
        enabled: false,
        basic: [],
        ornaments: [],
        guitar: [],
        strings: [],
        bass: []
    };
    
    // æ”¶é›†æ‰€æœ‰é€‰ä¸­çš„articulations
    const checkboxGroups = [
        { prefix: 'art-', type: 'basic' },
        { prefix: 'orn-', type: 'ornaments' },
        { prefix: 'gtr-', type: 'guitar' },
        { prefix: 'strings-', type: 'strings' },
        { prefix: 'bass-', type: 'bass' }
    ];
    
    let hasSelection = false;
    checkboxGroups.forEach(group => {
        const inputs = document.querySelectorAll(`#articulationModal input[id^="${group.prefix}"]`);
        inputs.forEach(input => {
            if (input.checked) {
                const fallbackValue = input.id.replace(group.prefix, '');
                const value = (input.value && String(input.value).trim()) ? input.value : fallbackValue;
                artSettings[group.type].push(value);
                hasSelection = true;
            }
        });
    });
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (hasSelection) {
        artSettings.enabled = artSettings.basic.length > 0 || 
                             artSettings.ornaments.length > 0 || 
                             artSettings.guitar.length > 0 ||
                             artSettings.strings.length > 0 ||
                             artSettings.bass.length > 0;
        
        const frequencies = {};
        const artTypes = ['staccato', 'accent', 'acciaccatura', 'slur', 'slide'];
        artTypes.forEach(type => {
            const slider = document.getElementById(`freq-${type}`);
            if (slider) {
                frequencies[type] = parseInt(slider.value);
            } else {
                const existingValue = userSettings?.articulations?.frequencies?.[type];
                frequencies[type] = normalizeFrequencyPercentage(existingValue, getDefaultArticulationFrequency(type));
            }
        });
        
        userSettings.articulations = artSettings;
        userSettings.articulations.frequencies = frequencies;
        
        console.log(`âœ… Articulationè®¾ç½®å·²é™é»˜ä¿å­˜`);
    }
    
    document.getElementById('articulationModal').style.display = 'none';
    resetSelectAllStates();
}

/**
 * å…³é—­Articulationè®¾ç½®å¼¹çª—
 */
function closeArticulationSettings() {
    closeArticulationSettingsWithSave();
}

// ====== ğŸš€ å¢å¼ºçš„å…¨é€‰åˆ‡æ¢åŠŸèƒ½ ======
/**
 * å¢å¼ºçš„å…¨é€‰åˆ‡æ¢åŠŸèƒ½
 * å®ç°"å…¨é€‰"æŒ‰é’®çš„çŠ¶æ€è®°å¿†å’Œåˆ‡æ¢åŠŸèƒ½
 */

// å­˜å‚¨æ¯ä¸ªå…¨é€‰æŒ‰é’®çš„çŠ¶æ€è®°å¿†
const selectAllStates = {
    rhythms: { isAllSelected: false, previousStates: null },
    basicArticulations: { isAllSelected: false, previousStates: null },
    guitarTechniques: { isAllSelected: false, previousStates: null },
    majorKeys: { isAllSelected: false, previousStates: null },
    minorKeys: { isAllSelected: false, previousStates: null },
    timeSignatures: { isAllSelected: false, previousStates: null },
    intervals: { isAllSelected: false, previousStates: null },
    clefs: { isAllSelected: false, previousStates: null }
};

/**
 * è®°å½•å½“å‰å¤é€‰æ¡†çŠ¶æ€
 * @param {Array} checkboxIds - å¤é€‰æ¡†IDæ•°ç»„
 * @returns {Object} å½“å‰çŠ¶æ€å¯¹è±¡
 */
function captureCurrentStates(checkboxIds) {
    const states = {};
    checkboxIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox && isCheckboxVisible(checkbox)) {
            states[id] = checkbox.checked;
        }
    });
    return states;
}

/**
 * æ¢å¤ä¹‹å‰çš„å¤é€‰æ¡†çŠ¶æ€
 * @param {Object} previousStates - ä¹‹å‰çš„çŠ¶æ€å¯¹è±¡
 */
function restorePreviousStates(previousStates) {
    if (!previousStates) return;
    
    Object.keys(previousStates).forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.checked = previousStates[id];
        }
    });
}

/**
 * è®¾ç½®æ‰€æœ‰å¤é€‰æ¡†ä¸ºé€‰ä¸­çŠ¶æ€
 * @param {Array} checkboxIds - å¤é€‰æ¡†IDæ•°ç»„
 */
function selectAllCheckboxes(checkboxIds) {
    checkboxIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox && isCheckboxVisible(checkbox)) {
            checkbox.checked = true;
        }
    });
}

function deselectAllCheckboxes(checkboxIds) {
    checkboxIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox && isCheckboxVisible(checkbox)) {
            checkbox.checked = false;
        }
    });
}

function isCheckboxVisible(checkbox) {
    if (!checkbox) return false;
    const container = checkbox.closest('.checkbox-item') || checkbox.parentElement;
    if (!container) return true;
    const style = window.getComputedStyle(container);
    return style.display !== 'none' && style.visibility !== 'hidden';
}

function areAllCheckboxesChecked(checkboxIds) {
    let hasVisible = false;
    for (const id of checkboxIds) {
        const checkbox = document.getElementById(id);
        if (!checkbox || !isCheckboxVisible(checkbox)) {
            continue;
        }
        hasVisible = true;
        if (!checkbox.checked) {
            return false;
        }
    }
    return hasVisible;
}

function syncSelectAllState(stateKey, checkboxIds, buttonSelector) {
    const state = selectAllStates[stateKey];
    const allChecked = areAllCheckboxesChecked(checkboxIds);
    state.isAllSelected = allChecked;
    state.previousStates = null;
    updateSelectAllButton(buttonSelector, allChecked);
}

/**
 * æ›´æ–°å…¨é€‰æŒ‰é’®çš„æ–‡æœ¬å’ŒçŠ¶æ€
 * @param {string} buttonSelector - æŒ‰é’®é€‰æ‹©å™¨
 * @param {boolean} isAllSelected - æ˜¯å¦ä¸ºå…¨é€‰çŠ¶æ€
 */
function updateSelectAllButton(buttonSelector, isAllSelected) {
    const button = document.querySelector(buttonSelector);
    if (button) {
        button.textContent = isAllSelected ? 'å–æ¶ˆå…¨é€‰' : 'å…¨é€‰';
        // æ·»åŠ è§†è§‰æç¤º
        if (isAllSelected) {
            button.style.background = '#FF3B30'; // iOSçº¢è‰²
            button.style.color = 'white';
        } else {
            button.style.background = '#28a745'; // ç»¿è‰²
            button.style.color = 'white';
        }
    }
}

/**
 * é€šç”¨çš„å…¨é€‰åˆ‡æ¢å‡½æ•°
 * @param {string} stateKey - çŠ¶æ€é”®å
 * @param {Array} checkboxIds - å¤é€‰æ¡†IDæ•°ç»„
 * @param {string} buttonSelector - æŒ‰é’®é€‰æ‹©å™¨
 * @param {string} logPrefix - æ—¥å¿—å‰ç¼€
 */
function toggleSelectAll(stateKey, checkboxIds, buttonSelector, logPrefix) {
    const state = selectAllStates[stateKey];
    
    if (!state.isAllSelected) {
        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šè®°ä½å½“å‰çŠ¶æ€ï¼Œç„¶åå…¨é€‰
        console.log(`${logPrefix} è®°ä½å½“å‰çŠ¶æ€å¹¶å…¨é€‰`);
        state.previousStates = captureCurrentStates(checkboxIds);
        selectAllCheckboxes(checkboxIds);
        state.isAllSelected = true;
    } else {
        // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šæ¢å¤ä¹‹å‰çš„çŠ¶æ€ï¼Œæˆ–ç›´æ¥å–æ¶ˆå…¨é€‰
        if (state.previousStates) {
            console.log(`${logPrefix} æ¢å¤åˆ°å…¨é€‰å‰çš„çŠ¶æ€`);
            restorePreviousStates(state.previousStates);
        } else {
            console.log(`${logPrefix} å–æ¶ˆå…¨é€‰`);
            deselectAllCheckboxes(checkboxIds);
        }
        state.isAllSelected = false;
        state.previousStates = null;
    }
    
    // æ›´æ–°æŒ‰é’®å¤–è§‚
    updateSelectAllButton(buttonSelector, state.isAllSelected);
}

// ç›‘å¬æ¨¡æ€æ¡†å…³é—­äº‹ä»¶ï¼Œé‡ç½®æŒ‰é’®çŠ¶æ€
function resetSelectAllStates() {
    Object.keys(selectAllStates).forEach(key => {
        selectAllStates[key].isAllSelected = false;
        selectAllStates[key].previousStates = null;
    });
    
    // é‡ç½®æ‰€æœ‰å…¨é€‰æŒ‰é’®çš„å¤–è§‚
    document.querySelectorAll('.btn-select-all').forEach(button => {
        button.textContent = 'å…¨é€‰';
        button.style.background = '#28a745';
        button.style.color = 'white';
    });
}

// åˆå§‹åŒ–å¢å¼ºå…¨é€‰åŠŸèƒ½çš„DOMäº‹ä»¶ç›‘å¬å™¨
function initializeEnhancedSelectAll() {
    console.log('[DEBUG] åˆå§‹åŒ–å¢å¼ºå…¨é€‰åŠŸèƒ½');
    
    // åˆå§‹åŒ–æ‰€æœ‰å…¨é€‰æŒ‰é’®æ ·å¼
    setTimeout(() => {
        document.querySelectorAll('.btn-select-all').forEach(button => {
            button.style.background = '#28a745';
            button.style.color = 'white';
            button.style.transition = 'all 0.3s ease';
        });
    }, 1000); // å»¶è¿Ÿç¡®ä¿DOMå·²åŠ è½½å®Œæˆ
}

// è‡ªåŠ¨åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', initializeEnhancedSelectAll);

console.log('[INFO] å¢å¼ºå…¨é€‰åˆ‡æ¢åŠŸèƒ½å·²åŠ è½½å¹¶é›†æˆåˆ°sight-reading-final.js');

/**
 * å…¨é€‰åŸºæœ¬æ¼”å¥æ³•
 */
function selectAllBasicArticulations() {
    const articulationIds = [
        'art-staccato',
        'art-accent', 
        'art-acciaccatura'
    ];
    
    toggleSelectAll(
        'basicArticulations', 
        articulationIds, 
        'button[onclick="selectAllBasicArticulations()"]',
        'æ¼”å¥æ³•'
    );
}

/**
 * å…¨é€‰å‰ä»–æŠ€å·§
 */
function selectAllGuitarTechniques() {
    const guitarIds = [
        'gtr-hammer',
        'gtr-pull',
        'gtr-glissando',
        'gtr-slide-in',
        'gtr-slide-out'
    ];
    
    toggleSelectAll(
        'guitarTechniques', 
        guitarIds, 
        'button[onclick="selectAllGuitarTechniques()"]',
        'å‰ä»–'
    );
}

/**
 * å…¨é€‰æ‰€æœ‰èŠ‚å¥é€‰é¡¹
 */
function selectAllRhythms() {
    // ğŸ¯ åŠ¨æ€è·å–å½“å‰å¯è§çš„èŠ‚å¥é€‰é¡¹ï¼Œé¿å…é€‰ä¸­éšè—çš„é™„ç‚¹éŸ³ç¬¦
    const allRhythmIds = [
        'rhythm-whole',
        'rhythm-dotted-half',
        'rhythm-half',
        'rhythm-dotted-quarter',
        'rhythm-quarter',
        'rhythm-eighth',
        'rhythm-16th',
        'rhythm-triplet',
        'rhythm-duplet',
        'rhythm-quadruplet'
    ];

    // ğŸ” åªåŒ…å«å½“å‰å¯è§çš„èŠ‚å¥é€‰é¡¹
    const visibleRhythmIds = allRhythmIds.filter(id => {
        const element = document.getElementById(id);
        const label = document.getElementById(id.replace('rhythm-', 'rhythm-') + '-label') ||
                     element?.closest('.checkbox-item');

        // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ä¸”å¯è§
        return element && label &&
               (label.style.display !== 'none' && getComputedStyle(label).display !== 'none');
    });

    console.log(`ğŸµ å…¨é€‰èŠ‚å¥ï¼šå½“å‰å¯è§çš„é€‰é¡¹ [${visibleRhythmIds.join(', ')}]`);

    toggleSelectAll(
        'rhythms',
        visibleRhythmIds,
        'button[onclick="selectAllRhythms()"]',
        'éŸ³ç¬¦'
    );
}

/**
 * ä¿å­˜Articulationè®¾ç½®
 */
function saveArticulationSettings() {
    console.log('ğŸ’¾ ä¿å­˜Articulation & Ornamentsè®¾ç½®');
    
    const artSettings = {
        enabled: false,
        basic: [],
        ornaments: [],
        guitar: [],
        strings: [],
        bass: []
    };
    
    // æ”¶é›†åŸºæœ¬articulation
    if (document.getElementById('art-staccato').checked) artSettings.basic.push('staccato');
    if (document.getElementById('art-accent').checked) artSettings.basic.push('accent');
    if (document.getElementById('art-acciaccatura').checked) artSettings.basic.push('acciaccatura');
    
    // è£…é¥°éŸ³å·²ç§»é™¤
    
    // æ”¶é›†å‰ä»–æŠ€å·§
    if (document.getElementById('gtr-hammer').checked) artSettings.guitar.push('hammer-on');
    if (document.getElementById('gtr-pull').checked) artSettings.guitar.push('pull-off');
    if (document.getElementById('gtr-glissando').checked) artSettings.guitar.push('glissando');
    if (document.getElementById('gtr-slide-in').checked) artSettings.guitar.push('slide-in');
    if (document.getElementById('gtr-slide-out').checked) artSettings.guitar.push('slide-out');
    
    // å¼¦ä¹æŠ€å·§å·²ç§»é™¤
    
    // è´æ–¯æŠ€å·§å·²ç§»é™¤
    
    // ğŸ”¥ æ™ºèƒ½æ”¶é›†é¢‘ç‡è®¾ç½® - ä¼˜å…ˆä½¿ç”¨å®æ—¶æ›´æ–°çš„å€¼ï¼Œæ»‘å—å€¼ä½œä¸ºåå¤‡
    const frequencies = {};
    const articulationTypes = ['staccato', 'accent', 'acciaccatura', 'slur', 'slide'];  // slur+slideå‡ä¸ºç»Ÿä¸€æ§åˆ¶é¡¹
    articulationTypes.forEach(type => {
        // ä¼˜å…ˆä½¿ç”¨userSettingsä¸­å·²å­˜åœ¨çš„å®æ—¶æ›´æ–°å€¼
        if (userSettings.articulations && 
            userSettings.articulations.frequencies && 
            userSettings.articulations.frequencies[type] !== undefined) {
            frequencies[type] = userSettings.articulations.frequencies[type];
            console.log(`ğŸ”„ ä½¿ç”¨å®æ—¶æ›´æ–°å€¼: ${type} = ${frequencies[type]}%`);
        } else {
            // åå¤‡ï¼šä»æ»‘å—è¯»å–
            const slider = document.getElementById(`freq-${type}`);
            if (slider) {
                frequencies[type] = parseInt(slider.value);
                console.log(`ğŸ“Š ä»æ»‘å—è¯»å–: ${type} = ${frequencies[type]}%`);
            }
        }
    });
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•articulationè¢«é€‰ä¸­
    artSettings.enabled = (artSettings.basic.length > 0 || 
                          artSettings.guitar.length > 0);
    artSettings.frequencies = frequencies;
    
    // ğŸ”¥ æ™ºèƒ½åˆå¹¶è®¾ç½®ï¼Œä¸è¦å®Œå…¨è¦†ç›–articulationså¯¹è±¡
    if (!userSettings.articulations) {
        userSettings.articulations = artSettings;
    } else {
        // åªæ›´æ–°éœ€è¦æ›´æ–°çš„éƒ¨åˆ†
        userSettings.articulations.enabled = artSettings.enabled;
        userSettings.articulations.basic = artSettings.basic;
        userSettings.articulations.guitar = artSettings.guitar;
        userSettings.articulations.ornaments = artSettings.ornaments;
        userSettings.articulations.strings = artSettings.strings;
        userSettings.articulations.bass = artSettings.bass;
        userSettings.articulations.frequencies = frequencies; // ä½¿ç”¨æ™ºèƒ½æ”¶é›†çš„é¢‘ç‡
    }
    
    console.log('âœ… Articulationè®¾ç½®å·²ä¿å­˜:', artSettings);
    console.log('âœ… æ¼”å¥æ³•é¢‘ç‡è®¾ç½®:', frequencies);
    console.log('ğŸ” æœ€ç»ˆuserSettings.articulations.frequencies:', userSettings.articulations.frequencies);
    
    closeArticulationSettings();
}

/**
 * åˆ‡æ¢èŠ‚å¥é«˜çº§è®¾ç½®æ˜¾ç¤ºçŠ¶æ€
 */
function toggleRhythmAdvancedSettings() {
    const advancedSettings = document.getElementById('rhythmAdvancedSettings');
    const toggleBtn = document.getElementById('rhythmAdvancedBtn');
    
    if (advancedSettings.style.display === 'none') {
        advancedSettings.style.display = 'block';
        toggleBtn.textContent = 'æ”¶èµ·é«˜çº§è®¾ç½®';
        // åˆå§‹åŒ–æ»‘å—äº‹ä»¶ç›‘å¬å™¨
        initializeRhythmFrequencySliders();
    } else {
        advancedSettings.style.display = 'none';
        toggleBtn.textContent = 'é«˜çº§è®¾ç½®';
    }
}

/**
 * åˆå§‹åŒ–èŠ‚å¥é¢‘ç‡æ»‘å—äº‹ä»¶ç›‘å¬å™¨
 */
function initializeRhythmFrequencySliders() {
    const rhythmTypes = ['dotted', 'whole', 'dotted-half', 'half', 'dotted-quarter', 'quarter', 'dotted-eighth', 'eighth', '16th', 'triplet', 'duplet', 'quadruplet'];
    
    rhythmTypes.forEach(type => {
        const slider = document.getElementById(`freq-${type}`);
        const valueSpan = document.getElementById(`freq-${type}-value`);
        const checkbox = document.getElementById(`rhythm-${type}`);
        
        if (slider && valueSpan) {
            // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
            slider.removeEventListener('input', slider._handler);
            
            // åˆ›å»ºæ–°çš„å¤„ç†å‡½æ•°
            slider._handler = function() {
                const frequency = parseInt(this.value);
                valueSpan.textContent = frequency + '%';
                
                // ğŸ”¥ è‡ªåŠ¨åŒæ­¥æœºåˆ¶ï¼šå½“é¢‘ç‡ä¸º0%æ—¶ï¼Œå–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
                if (checkbox) {
                    if (frequency === 0) {
                        checkbox.checked = false;
                        console.log(`ğŸ”„ è‡ªåŠ¨å–æ¶ˆå‹¾é€‰ ${type}: é¢‘ç‡ä¸º 0%`);
                    } else if (!checkbox.checked) {
                        checkbox.checked = true;
                        console.log(`ğŸ”„ è‡ªåŠ¨å‹¾é€‰ ${type}: é¢‘ç‡ä¸º ${frequency}%`);
                    }
                }
                
                // æ›´æ–°userSettingsä¸­çš„é¢‘ç‡è®¾ç½®
                if (!userSettings.rhythmFrequencies) {
                    userSettings.rhythmFrequencies = {};
                }
                userSettings.rhythmFrequencies[type] = frequency;
            };
            
            slider.addEventListener('input', slider._handler);
            
            // è®¾ç½®åˆå§‹å€¼
            valueSpan.textContent = slider.value + '%';
        }
    });
}

/**
 * é‡ç½®èŠ‚å¥é¢‘ç‡ä¸ºé»˜è®¤å€¼
 */
function resetRhythmFrequencies() {
    const defaultFrequencies = {
        dotted: 20,
        whole: 10,
        'dotted-half': 15,
        half: 30,
        'dotted-quarter': 35,
        quarter: 50,
        'dotted-eighth': 25,
        eighth: 40,
        '16th': 20,
        triplet: 35,
        duplet: 30,
        quadruplet: 25
    };
    
    Object.entries(defaultFrequencies).forEach(([type, value]) => {
        const slider = document.getElementById(`freq-${type}`);
        const valueSpan = document.getElementById(`freq-${type}-value`);
        
        if (slider && valueSpan) {
            slider.value = value;
            valueSpan.textContent = value + '%';
        }
    });
    
    console.log('ğŸ”„ èŠ‚å¥é¢‘ç‡å·²é‡ç½®ä¸ºé»˜è®¤å€¼ï¼ˆåŒ…æ‹¬äºŒè¿éŸ³å’Œå››è¿éŸ³ï¼‰');
}

/**
 * åˆ‡æ¢æ¼”å¥æ³•é«˜çº§è®¾ç½®æ˜¾ç¤ºçŠ¶æ€
 */
function toggleArticulationAdvancedSettings() {
    const advancedSettings = document.getElementById('articulationAdvancedSettings');
    const toggleBtn = document.getElementById('articulationAdvancedBtn');
    
    if (advancedSettings.style.display === 'none') {
        advancedSettings.style.display = 'block';
        toggleBtn.textContent = 'æ”¶èµ·é«˜çº§è®¾ç½®';
        // åˆå§‹åŒ–æ»‘å—äº‹ä»¶ç›‘å¬å™¨
        initializeArticulationFrequencySliders();
    } else {
        advancedSettings.style.display = 'none';
        toggleBtn.textContent = 'é«˜çº§è®¾ç½®';
    }
}

/**
 * åˆå§‹åŒ–æ¼”å¥æ³•é¢‘ç‡æ»‘å—äº‹ä»¶ç›‘å¬å™¨
 */
function initializeArticulationFrequencySliders() {
    const articulationTypes = ['staccato', 'accent', 'acciaccatura', 'slur', 'slide'];
    
    articulationTypes.forEach(type => {
        const slider = document.getElementById(`freq-${type}`);
        const valueSpan = document.getElementById(`freq-${type}-value`);
        
        // æ˜ å°„articulationç±»å‹åˆ°å¯¹åº”çš„å¤é€‰æ¡†ID
        let checkboxId;
        if (type === 'staccato') checkboxId = 'art-staccato';
        else if (type === 'accent') checkboxId = 'art-accent';
        else if (type === 'acciaccatura') checkboxId = 'art-acciaccatura';
        else if (type === 'slur' || type === 'slide') {
            if (slider && valueSpan) {
                // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
                slider.removeEventListener('input', slider._handler);
                
                // åˆ›å»ºæ–°çš„å¤„ç†å‡½æ•°
                slider._handler = function() {
                    const frequency = parseInt(this.value);
                    valueSpan.textContent = frequency + '%';
                    
                    // ğŸ”¥ ä¿®å¤ï¼šç§»é™¤é”™è¯¯çš„è‡ªåŠ¨åŒæ­¥æœºåˆ¶
                    // sluræ»‘å—ä¸åº”è¯¥æ§åˆ¶å¤é€‰æ¡†çŠ¶æ€ï¼Œè€Œæ˜¯ç›¸å
                    // å¤é€‰æ¡†çŠ¶æ€åº”è¯¥ç”±ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶ï¼Œæ»‘å—åªæ˜¯è®¾ç½®é¢‘ç‡
                    if (type === 'slur') {
                        console.log(`ğŸ¯ æ›´æ–°sluré¢‘ç‡ä¸º: ${frequency}%`);
                    } else {
                        console.log(`ğŸ¯ æ›´æ–°slideé¢‘ç‡ä¸º: ${frequency}%`);
                    }
                    
                    // æ›´æ–°userSettingsä¸­çš„é¢‘ç‡è®¾ç½®
                    if (!userSettings.articulations) {
                        userSettings.articulations = { frequencies: {} };
                    }
                    if (!userSettings.articulations.frequencies) {
                        userSettings.articulations.frequencies = {};
                    }
                    userSettings.articulations.frequencies[type] = frequency;
                };
                
                slider.addEventListener('input', slider._handler);
                
                // è®¾ç½®åˆå§‹å€¼
                valueSpan.textContent = slider.value + '%';
            }
            return; // è·³è¿‡ä¸‹é¢çš„é€šç”¨å¤„ç†
        }
        
        const checkbox = document.getElementById(checkboxId);
        
        if (slider && valueSpan) {
            // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
            slider.removeEventListener('input', slider._handler);
            
            // åˆ›å»ºæ–°çš„å¤„ç†å‡½æ•°
            slider._handler = function() {
                const frequency = parseInt(this.value);
                valueSpan.textContent = frequency + '%';
                
                // ğŸ”¥ è‡ªåŠ¨åŒæ­¥æœºåˆ¶ï¼šå½“é¢‘ç‡ä¸º0%æ—¶ï¼Œå–æ¶ˆå‹¾é€‰å¤é€‰æ¡†
                if (checkbox) {
                    if (frequency === 0) {
                        checkbox.checked = false;
                        console.log(`ğŸ”„ è‡ªåŠ¨å–æ¶ˆå‹¾é€‰ ${type}: é¢‘ç‡ä¸º 0%`);
                    } else if (!checkbox.checked) {
                        checkbox.checked = true;
                        console.log(`ğŸ”„ è‡ªåŠ¨å‹¾é€‰ ${type}: é¢‘ç‡ä¸º ${frequency}%`);
                    }
                }
                
                // æ›´æ–°userSettingsä¸­çš„é¢‘ç‡è®¾ç½®
                if (!userSettings.articulations) {
                    userSettings.articulations = { frequencies: {} };
                }
                if (!userSettings.articulations.frequencies) {
                    userSettings.articulations.frequencies = {};
                }
                userSettings.articulations.frequencies[type] = frequency;
            };
            
            slider.addEventListener('input', slider._handler);
            
            // è®¾ç½®åˆå§‹å€¼
            valueSpan.textContent = slider.value + '%';
        }
    });
}

/**
 * é‡ç½®æ¼”å¥æ³•é¢‘ç‡ä¸ºé»˜è®¤å€¼
 */
function resetArticulationFrequencies() {
    const defaultFrequencies = {
        staccato: 20,
        accent: 15,
        acciaccatura: 10,
        slur: 15,  // ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶
        slide: 10  // ğŸ”¥ ç»Ÿä¸€æ§åˆ¶æ™®é€šslide/slide-in/slide-out
    };
    
    // ğŸ”¥ æ›´æ–°userSettingsä¸­çš„é¢‘ç‡è®¾ç½®
    if (!userSettings.articulations) {
        userSettings.articulations = { frequencies: {} };
    }
    if (!userSettings.articulations.frequencies) {
        userSettings.articulations.frequencies = {};
    }
    
    Object.entries(defaultFrequencies).forEach(([type, value]) => {
        const slider = document.getElementById(`freq-${type}`);
        const valueSpan = document.getElementById(`freq-${type}-value`);
        
        if (slider && valueSpan) {
            slider.value = value;
            valueSpan.textContent = value + '%';
            
            // ğŸ”¥ åŒæ­¥æ›´æ–°userSettings
            userSettings.articulations.frequencies[type] = value;
        }
    });
    
    console.log('ğŸ”„ æ¼”å¥æ³•é¢‘ç‡å·²é‡ç½®ä¸ºé»˜è®¤å€¼');
    console.log('ğŸ“Š æ›´æ–°åçš„é¢‘ç‡è®¾ç½®:', userSettings.articulations.frequencies);
}

/**
 * é‡ç½®éŸ³åŸŸè®¾ç½®ï¼Œå…è®¸è°±å·è‡ªåŠ¨è°ƒæ•´éŸ³åŸŸ
 * @param {string} targetClef - å¯é€‰å‚æ•°ï¼ŒæŒ‡å®šè¦é‡ç½®çš„è°±å·ã€‚å¦‚æœä¸æä¾›ï¼Œåˆ™é‡ç½®å½“å‰è°±å·
 */
function resetRangeSettings(targetClef = null) {
    // è·å–è¦é‡ç½®çš„è°±å·
    const clefElement = document.getElementById('clef');
    const currentClef = clefElement ? clefElement.value : 'treble';
    const clefToReset = targetClef || currentClef;
    
    // é‡ç½®æŒ‡å®šè°±å·çš„è‡ªå®šä¹‰è®¾ç½®
    if (userSettings.clefRanges[clefToReset]) {
        userSettings.clefRanges[clefToReset].hasCustomRange = false;
        userSettings.clefRanges[clefToReset].customRange = null;
    }
    
    // é‡ç½®å‘åå…¼å®¹çš„å…¨å±€è®¾ç½®
    userSettings.hasCustomRange = false;
    
    // é‡æ–°åº”ç”¨è°±å·çš„é»˜è®¤éŸ³åŸŸï¼ˆåªæœ‰å½“å‰æ˜¾ç¤ºçš„è°±å·æ‰æ›´æ–°UIï¼‰
    if (clefToReset === currentClef) {
        adjustRangeForClef(clefToReset);
    }
    
    const clefName = clefToReset === 'treble' ? 'é«˜éŸ³è°±å·' : clefToReset === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·';
    console.log(`ğŸ”„ ${clefName}éŸ³åŸŸè®¾ç½®å·²é‡ç½®ï¼Œç°åœ¨ä¼šä½¿ç”¨é»˜è®¤éŸ³åŸŸ`);
}

/**
 * é‡ç½®æ‰€æœ‰è°±å·çš„éŸ³åŸŸè®¾ç½®
 */
function resetAllRangeSettings() {
    // é‡ç½®æ‰€æœ‰è°±å·çš„è‡ªå®šä¹‰è®¾ç½®
    Object.keys(userSettings.clefRanges).forEach(clef => {
        userSettings.clefRanges[clef].hasCustomRange = false;
        userSettings.clefRanges[clef].customRange = null;
    });
    
    // é‡ç½®å‘åå…¼å®¹çš„å…¨å±€è®¾ç½®
    userSettings.hasCustomRange = false;
    
    // é‡æ–°åº”ç”¨å½“å‰è°±å·çš„é»˜è®¤éŸ³åŸŸ
    const clefElement = document.getElementById('clef');
    const currentClef = clefElement ? clefElement.value : 'treble';
    adjustRangeForClef(currentClef);
    
    console.log('ğŸ”„ æ‰€æœ‰è°±å·çš„éŸ³åŸŸè®¾ç½®å·²é‡ç½®ï¼Œç°åœ¨ä¼šä½¿ç”¨å„è‡ªçš„é»˜è®¤éŸ³åŸŸ');
}

/**
 * æ›´æ–°éŸ³åŸŸè®¾ç½®
 */
function updateCustomRange() {
    const minRange = parseInt(document.getElementById('rangeMin').value);
    const maxRange = parseInt(document.getElementById('rangeMax').value);
    
    // éªŒè¯éŸ³åŸŸè®¾ç½®
    if (minRange >= maxRange) {
        alert('æœ€ä½éŸ³å¿…é¡»ä½äºæœ€é«˜éŸ³ï¼');
        return;
    }
    
    // éªŒè¯éŸ³åŸŸåœ¨æ”¯æŒèŒƒå›´å†… (A2=33 åˆ° A6=81)
    if (minRange < 33 || maxRange > 85) {
        alert('éŸ³åŸŸå¿…é¡»åœ¨A2åˆ°A6èŒƒå›´å†…ï¼');
        return;
    }
    
    // è·å–å½“å‰æ˜¾ç¤ºæ—‹å¾‹çš„è°±å·ï¼ˆå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é€‰æ‹©çš„è°±å·ï¼‰
    let targetClef = currentDisplayedClef;
    if (!targetClef) {
        // å¦‚æœè¿˜æ²¡æœ‰ç”Ÿæˆæ—‹å¾‹ï¼Œä½¿ç”¨å½“å‰é€‰æ‹©çš„è°±å·
        const clefElement = document.getElementById('clef');
        targetClef = clefElement ? clefElement.value : 'treble';
        console.log('âš ï¸ å½“å‰æ²¡æœ‰æ˜¾ç¤ºæ—‹å¾‹ï¼Œä½¿ç”¨ç•Œé¢é€‰æ‹©çš„è°±å·');
    }
    
    // ä¸ºå¯¹åº”è°±å·ä¿å­˜è‡ªå®šä¹‰éŸ³åŸŸè®¾ç½®
    if (!userSettings.clefRanges[targetClef]) {
        userSettings.clefRanges[targetClef] = { customRange: null, hasCustomRange: false };
    }
    
    userSettings.clefRanges[targetClef].customRange = { min: minRange, max: maxRange };
    userSettings.clefRanges[targetClef].hasCustomRange = true;
    
    // ä¿æŒå‘åå…¼å®¹ï¼ˆä¸ºæ—§ä»£ç ï¼‰
    userSettings.customRange = { min: minRange, max: maxRange };
    userSettings.hasCustomRange = true;
    
    // æ˜¾ç¤ºå‹å¥½çš„éŸ³å
    const minNote = midiToNoteName(minRange);
    const maxNote = midiToNoteName(maxRange);
    const clefName = targetClef === 'treble' ? 'é«˜éŸ³è°±å·' : targetClef === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·';
    console.log(`ğŸ¹ ${clefName}éŸ³åŸŸè®¾ç½®å·²æ›´æ–°: ${minNote}-${maxNote} (MIDI ${minRange}-${maxRange}) [åŸºäºå½“å‰æ˜¾ç¤ºçš„æ—‹å¾‹]`);
}

/**
 * MIDIè½¬éŸ³åæ˜¾ç¤º
 */
function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const octave = Math.floor(midi / 12) - 1;
    const noteName = notes[midi % 12];
    return noteName + octave;
}

/**
 * æ›´æ–°ä¸´æ—¶è®°å·æ¦‚ç‡
 */
function updateAccidentalRate() {
    const rate = parseInt(document.getElementById('accidentalRate').value);
    userSettings.accidentalRate = rate;
    document.getElementById('accidentalRateValue').textContent = rate + '%';
    console.log(`â™¯â™­ ä¸´æ—¶è®°å·æ¦‚ç‡å·²æ›´æ–°: ${rate}%`);
}

/**
 * è·å–æŒ‡å®šè°±å·çš„éŸ³åŸŸè®¾ç½®ï¼ˆä¸æ›´æ–°UIï¼‰
 */
function getRangeForClef(clef) {
    const defaultRanges = {
        treble: { min: 60, max: 79 },  // C4-G5 (é«˜éŸ³è°±å· - ä¿æŒåŸæœ‰é»˜è®¤å€¼)
        alto: { min: 50, max: 71 },    // D3-B4 (ä¸­éŸ³è°±å·)
        bass: { min: 40, max: 64 }     // E2-E4 (ä½éŸ³è°±å·)
    };
    
    // æ£€æŸ¥è¿™ä¸ªè°±å·æ˜¯å¦æœ‰è‡ªå®šä¹‰éŸ³åŸŸè®¾ç½®
    if (userSettings.clefRanges[clef] && userSettings.clefRanges[clef].hasCustomRange) {
        // ä½¿ç”¨è¯¥è°±å·çš„è‡ªå®šä¹‰éŸ³åŸŸ
        return userSettings.clefRanges[clef].customRange;
    } else {
        // ä½¿ç”¨é»˜è®¤éŸ³åŸŸ
        return defaultRanges[clef] || defaultRanges.treble;
    }
}

/**
 * æ›´æ–°UIæ˜¾ç¤ºä¸ºæŒ‡å®šè°±å·çš„éŸ³åŸŸè®¾ç½®ï¼ˆä¸è§¦å‘ä¿å­˜äº‹ä»¶ï¼‰
 */
function updateUIForClefRange(clef) {
    // è·å–è¯¥è°±å·çš„éŸ³åŸŸè®¾ç½®
    const targetRange = getRangeForClef(clef);
    const clefName = clef === 'treble' ? 'é«˜éŸ³è°±å·' : clef === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·';
    
    // æ›´æ–°å…¨å±€è®¾ç½®ï¼ˆä¸ºå‘åå…¼å®¹ï¼‰
    userSettings.customRange = { min: targetRange.min, max: targetRange.max };
    
    // æ›´æ–°ç•Œé¢æ˜¾ç¤ºï¼ˆä¸è§¦å‘changeäº‹ä»¶ä»¥é¿å…ä¿å­˜ï¼‰
    const rangeMinElement = document.getElementById('rangeMin');
    const rangeMaxElement = document.getElementById('rangeMax');
    
    if (rangeMinElement) {
        rangeMinElement.value = targetRange.min;
    }
    if (rangeMaxElement) {
        rangeMaxElement.value = targetRange.max;
    }
    
    const minNote = midiToNoteName(targetRange.min);
    const maxNote = midiToNoteName(targetRange.max);
    const settingType = (userSettings.clefRanges[clef] && userSettings.clefRanges[clef].hasCustomRange) ? 'è‡ªå®šä¹‰' : 'é»˜è®¤';
    console.log(`ğŸ”„ UIå·²æ›´æ–°æ˜¾ç¤º${clefName}çš„${settingType}éŸ³åŸŸ: ${minNote}-${maxNote} (MIDI ${targetRange.min}-${targetRange.max})`);
}

/**
 * æ ¹æ®è°±å·è°ƒæ•´é»˜è®¤éŸ³åŸŸ
 */
function adjustRangeForClef(clef) {
    // å¦‚æœæ˜¯éšæœºè°±å·ï¼Œä¸è°ƒæ•´éŸ³åŸŸ
    if (clef === 'random') {
        console.log('ğŸ² éšæœºè°±å·æ¨¡å¼ï¼Œä¸è‡ªåŠ¨è°ƒæ•´éŸ³åŸŸ');
        return;
    }
    
    // è·å–è¯¥è°±å·çš„éŸ³åŸŸè®¾ç½®
    const targetRange = getRangeForClef(clef);
    const clefName = clef === 'treble' ? 'é«˜éŸ³è°±å·' : clef === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·';
    
    // æ›´æ–°å…¨å±€è®¾ç½®ï¼ˆä¸ºå‘åå…¼å®¹ï¼‰
    userSettings.customRange = { min: targetRange.min, max: targetRange.max };
    
    // æ›´æ–°ç•Œé¢æ˜¾ç¤º
    const rangeMinElement = document.getElementById('rangeMin');
    const rangeMaxElement = document.getElementById('rangeMax');
    
    if (rangeMinElement) {
        rangeMinElement.value = targetRange.min;
        // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°æ˜¾ç¤º
        rangeMinElement.dispatchEvent(new Event('change'));
    }
    if (rangeMaxElement) {
        rangeMaxElement.value = targetRange.max;
        // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°æ˜¾ç¤º
        rangeMaxElement.dispatchEvent(new Event('change'));
    }
    
    const minNote = midiToNoteName(targetRange.min);
    const maxNote = midiToNoteName(targetRange.max);
    const settingType = (userSettings.clefRanges[clef] && userSettings.clefRanges[clef].hasCustomRange) ? 'è‡ªå®šä¹‰' : 'é»˜è®¤';
    console.log(`ğŸ¼ ${clefName}éŸ³åŸŸå·²è®¾ä¸º${settingType}å€¼: ${minNote}-${maxNote} (MIDI ${targetRange.min}-${targetRange.max})`);
}

/**
 * æ›´æ–°æœ€å¤§éŸ³ç¨‹è·³åŠ¨
 */
function updateMaxJump() {
    const maxIntervalElement = document.getElementById('maxInterval');
    if (!maxIntervalElement) {
        console.error('âŒ maxIntervalå…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    const maxJump = parseInt(maxIntervalElement.value);
    console.log(`ğŸ”„ è¯»å–æœ€å¤§éŸ³ç¨‹è®¾ç½®: ${maxJump} (ä¹‹å‰: ${userSettings.maxJump})`);
    
    if (isNaN(maxJump) || maxJump < 1 || maxJump > 12) {
        console.error('âŒ æ— æ•ˆçš„æœ€å¤§éŸ³ç¨‹è·³åº¦å€¼:', maxJump);
        return;
    }
    
    userSettings.maxJump = maxJump;
    console.log(`âœ… æœ€å¤§éŸ³ç¨‹è·³åŠ¨å·²æ›´æ–°: ${maxJump}åŠéŸ³`);
    console.log(`ğŸ” éªŒè¯æ›´æ–°åçš„userSettings.maxJump: ${userSettings.maxJump}`);
}

/**
 * å®æ—¶æ›´æ–°èŠ‚å¥è®¾ç½®ï¼ˆåŒ…æ‹¬ä¸‰è¿éŸ³ï¼‰
 */
function updateRhythmSettingsRealTime() {
    console.log('ğŸµ å®æ—¶æ›´æ–°èŠ‚å¥è®¾ç½®');
    
    // æ”¶é›†å½“å‰é€‰ä¸­çš„åŸºæœ¬èŠ‚å¥ç±»å‹
    let selectedRhythms = [];

    // ğŸ” æ£€æŸ¥åŸºæœ¬èŠ‚å¥å¤é€‰æ¡†ï¼ˆä¸åŒ…æ‹¬å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦é€‰é¡¹ï¼‰
    const basicRhythmIds = [
        'rhythm-whole', 'rhythm-half', 'rhythm-quarter', 'rhythm-eighth', 'rhythm-16th',
        'rhythm-triplet', 'rhythm-duplet', 'rhythm-quadruplet'
    ];

    // ğŸ” æ£€æŸ¥å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦å¤é€‰æ¡†ï¼ˆç”¨äº6/8æ‹ç­‰ç‰¹æ®Šæƒ…å†µï¼‰
    const specificDottedIds = ['rhythm-dotted-half', 'rhythm-dotted-quarter'];

    // æ”¶é›†åŸºæœ¬èŠ‚å¥
    basicRhythmIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox && checkbox.checked) {
            selectedRhythms.push(checkbox.value);
            console.log(`âœ… åŸºæœ¬èŠ‚å¥å·²é€‰ä¸­: ${checkbox.value} (æ¥è‡ª ${id})`);
        }
    });

    // æ”¶é›†å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦ï¼ˆä¸»è¦ç”¨äº6/8æ‹ï¼‰
    // ä»…å½“æ€»å¼€å…³å¯ç”¨æ—¶æ‰å…è®¸è¯»å–å…·ä½“é™„ç‚¹é€‰é¡¹
    // ğŸ¯ å¦‚æœæ€»å¼€å…³å…³é—­ï¼Œåˆ™æ¸…é™¤è¿™äº›å…·ä½“é™„ç‚¹å¤é€‰æ¡†çš„å‹¾é€‰çŠ¶æ€ï¼Œé¿å…è¢«è¯¯ä¿å­˜
    const allowDottedNotesCheckbox = document.getElementById('allowDottedNotes');
    const shouldAddDottedNotes = allowDottedNotesCheckbox && allowDottedNotesCheckbox.checked;
    specificDottedIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (!checkbox) return;
        if (shouldAddDottedNotes) {
            if (checkbox.checked && checkbox.style.display !== 'none') {
                selectedRhythms.push(checkbox.value);
                console.log(`âœ… å…·ä½“é™„ç‚¹éŸ³ç¬¦å·²é€‰ä¸­: ${checkbox.value} (æ¥è‡ª ${id})`);
            }
        } else {
            // å…³é—­æ€»å¼€å…³æ—¶ï¼Œå¼ºåˆ¶å–æ¶ˆå…·ä½“é™„ç‚¹å¤é€‰æ¡†
            if (checkbox.checked) {
                checkbox.checked = false;
                console.log(`ğŸ”§ å…³é—­æ€»å¼€å…³ï¼šå–æ¶ˆå‹¾é€‰å…·ä½“é™„ç‚¹ ${id}`);
            }
        }
    });

    // ğŸµ æ£€æŸ¥é€šç”¨çš„"é™„ç‚¹éŸ³ç¬¦"å¼€å…³ï¼ˆå·²åœ¨ä¸Šæ–¹è¯»å–ï¼‰

    console.log(`ğŸ“ åŸºæœ¬èŠ‚å¥é€‰æ‹©: [${selectedRhythms.join(', ')}]`);
    console.log(`ğŸµ é™„ç‚¹éŸ³ç¬¦å¼€å…³: ${shouldAddDottedNotes ? 'å¼€å¯' : 'å…³é—­'}`);

    // ğŸ¯ å¦‚æœå¼€å¯äº†é™„ç‚¹éŸ³ç¬¦ï¼Œä¸ºé€‚åˆçš„åŸºæœ¬èŠ‚å¥è‡ªåŠ¨ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬
    if (shouldAddDottedNotes) {
        const dottedToAdd = [];

        // ğŸ¯ æ™ºèƒ½é™„ç‚¹éŸ³ç¬¦ç”Ÿæˆï¼šåªæœ‰å½“æ”¯æŒéŸ³ç¬¦å­˜åœ¨æ—¶æ‰ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬
        console.log(`ğŸµ æ™ºèƒ½é™„ç‚¹éŸ³ç¬¦ç”Ÿæˆå¼€å§‹ï¼Œæ£€æŸ¥åŸºç¡€èŠ‚å¥æ”¯æŒ...`);

        // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦éœ€è¦å››åˆ†éŸ³ç¬¦æ”¯æŒï¼ˆé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = äºŒåˆ†éŸ³ç¬¦ + å››åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('half') && selectedRhythms.includes('quarter')) {
            if (!selectedRhythms.includes('half.')) {
                dottedToAdd.push('half.');
                console.log(`ğŸµ âœ… æ·»åŠ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ (åŸºäºäºŒåˆ†éŸ³ç¬¦+å››åˆ†éŸ³ç¬¦æ”¯æŒ)`);
            }
        } else if (selectedRhythms.includes('half')) {
            console.log(`ğŸµ âš ï¸ è·³è¿‡é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼šéœ€è¦å››åˆ†éŸ³ç¬¦æ”¯æŒä½†æœªå‹¾é€‰`);
        }

        // é™„ç‚¹å››åˆ†éŸ³ç¬¦éœ€è¦å…«åˆ†éŸ³ç¬¦æ”¯æŒï¼ˆé™„ç‚¹å››åˆ†éŸ³ç¬¦ = å››åˆ†éŸ³ç¬¦ + å…«åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('quarter') && selectedRhythms.includes('eighth')) {
            if (!selectedRhythms.includes('quarter.')) {
                dottedToAdd.push('quarter.');
                console.log(`ğŸµ âœ… æ·»åŠ é™„ç‚¹å››åˆ†éŸ³ç¬¦ (åŸºäºå››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦æ”¯æŒ)`);
            }
        } else if (selectedRhythms.includes('quarter')) {
            console.log(`ğŸµ âš ï¸ è·³è¿‡é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼šéœ€è¦å…«åˆ†éŸ³ç¬¦æ”¯æŒä½†æœªå‹¾é€‰`);
        }

        // é™„ç‚¹å…«åˆ†éŸ³ç¬¦éœ€è¦åå…­åˆ†éŸ³ç¬¦æ”¯æŒï¼ˆé™„ç‚¹å…«åˆ†éŸ³ç¬¦ = å…«åˆ†éŸ³ç¬¦ + åå…­åˆ†éŸ³ç¬¦ï¼‰
        if (selectedRhythms.includes('eighth') && selectedRhythms.includes('16th')) {
            if (!selectedRhythms.includes('eighth.')) {
                dottedToAdd.push('eighth.');
                console.log(`ğŸµ âœ… æ·»åŠ é™„ç‚¹å…«åˆ†éŸ³ç¬¦ (åŸºäºå…«åˆ†éŸ³ç¬¦+åå…­åˆ†éŸ³ç¬¦æ”¯æŒ)`);
            }
        } else if (selectedRhythms.includes('eighth')) {
            console.log(`ğŸµ âš ï¸ è·³è¿‡é™„ç‚¹å…«åˆ†éŸ³ç¬¦ï¼šéœ€è¦åå…­åˆ†éŸ³ç¬¦æ”¯æŒä½†æœªå‹¾é€‰`);
        }

        // é™„ç‚¹åå…­åˆ†éŸ³ç¬¦éœ€è¦ä¸‰åäºŒåˆ†éŸ³ç¬¦æ”¯æŒï¼Œä½†é€šå¸¸ä¸ä½¿ç”¨
        if (selectedRhythms.includes('16th') && selectedRhythms.includes('32nd')) {
            if (!selectedRhythms.includes('16th.')) {
                dottedToAdd.push('16th.');
                console.log(`ğŸµ âœ… æ·»åŠ é™„ç‚¹åå…­åˆ†éŸ³ç¬¦ (åŸºäºåå…­åˆ†éŸ³ç¬¦+ä¸‰åäºŒåˆ†éŸ³ç¬¦æ”¯æŒ)`);
            }
        }

        // æ·»åŠ ç”Ÿæˆçš„é™„ç‚¹éŸ³ç¬¦
        selectedRhythms.push(...dottedToAdd);
    }

    // å½“æ€»å¼€å…³å…³é—­æ—¶ï¼Œç§»é™¤ä»»ä½•é™„ç‚¹æ—¶å€¼ï¼ˆåŒ…å«ä¸¤ç§è¡¨ç¤ºæ³•ï¼‰
    if (!shouldAddDottedNotes) {
        const before = [...selectedRhythms];
        selectedRhythms = selectedRhythms.filter(r => !(r.includes('.') || r.startsWith('dotted-')));
        if (before.length !== selectedRhythms.length) {
            console.log(`ğŸ§¹ å·²ç§»é™¤é™„ç‚¹æ—¶å€¼ï¼ˆå› æ€»å¼€å…³å…³é—­ï¼‰ï¼šä» [${before.join(', ')}] -> [${selectedRhythms.join(', ')}]`);
        }
    }

    if (selectedRhythms.length === 0) {
        console.log('âš ï¸ æœªé€‰æ‹©ä»»ä½•èŠ‚å¥ï¼Œå°†ç”Ÿæˆç©ºæ—‹å¾‹');
    }

    console.log(`ğŸ“ æœ€ç»ˆèŠ‚å¥è®¾ç½®: [${selectedRhythms.join(', ')}]`);

    // ä¿å­˜åˆ°ç”¨æˆ·è®¾ç½®
    userSettings.allowedRhythms = selectedRhythms;
    
    // ä»¥ç”¨æˆ·å¼€å…³ä¸ºå”¯ä¸€çœŸæºï¼Œç¦æ­¢è¢«åå‘â€œæ¨å¼€â€
    userSettings.allowDottedNotes = shouldAddDottedNotes;
    
    const hasDottedNotes = selectedRhythms.some(rhythm =>
        rhythm === 'dotted-half' || rhythm === 'dotted-quarter' || rhythm.includes('.')
    );
    console.log(`ğŸµ èŠ‚å¥è®¾ç½®æ›´æ–°å®Œæˆ:`);
    console.log(`  - é€‰ä¸­çš„èŠ‚å¥: [${selectedRhythms.join(', ')}]`);
    console.log(`  - åŒ…å«é™„ç‚¹éŸ³ç¬¦: ${hasDottedNotes}`);
    console.log(`  - åŒ…å«ä¸‰è¿éŸ³: ${selectedRhythms.includes('triplet')}`);
    // allowUpbeat console log removed
}

// ====== è°ƒè¯•å’Œæµ‹è¯•å‡½æ•° ======
/**
 * æµ‹è¯•ä¸‰è¿éŸ³é€»è¾‘çš„è°ƒè¯•å‡½æ•°
 */
function testTripletLogic() {
    console.log('\\nğŸ§ª === ä¸‰è¿éŸ³é€»è¾‘æµ‹è¯• ===');
    
    // æµ‹è¯•åœºæ™¯1: å¯ç”¨ä¸‰è¿éŸ³
    console.log('ğŸ“ æµ‹è¯•åœºæ™¯1: å¯ç”¨ä¸‰è¿éŸ³');
    userSettings.allowedRhythms = ['quarter', 'eighth', 'triplet'];
    
    const generator = new IntelligentMelodyGenerator(2, 'C', '4/4', 'treble', 12345);
    console.log(`ç”Ÿæˆå™¨è§„åˆ™ä¸­çš„allowedDurations: [${generator.rules.allowedDurations.join(', ')}]`);
    console.log(`åŒ…å«ä¸‰è¿éŸ³: ${generator.rules.allowedDurations.includes('triplet')}`);
    
    // æµ‹è¯•chooseDurationæ˜¯å¦æ­£ç¡®è¿‡æ»¤æ‰triplet
    const availableDurations = generator.chooseDuration(2, true);
    console.log(`chooseDurationæµ‹è¯•(2æ‹): ${availableDurations}`);
    
    // æµ‹è¯•canGenerateTriplet
    const canGenerate4Beats = generator.canGenerateTriplet(4);
    const canGenerate2Beats = generator.canGenerateTriplet(2);
    const canGenerate1Beat = generator.canGenerateTriplet(1);
    const canGenerateHalfBeat = generator.canGenerateTriplet(0.5);
    
    console.log(`4æ‹æ—¶å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerate4Beats}`);
    console.log(`2æ‹æ—¶å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerate2Beats}`);
    console.log(`1æ‹æ—¶å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerate1Beat}`);
    console.log(`0.5æ‹æ—¶å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerateHalfBeat}`);
    
    // æµ‹è¯•åœºæ™¯2: åªå¯ç”¨ä¸‰è¿éŸ³
    console.log('\\nğŸ“ æµ‹è¯•åœºæ™¯2: åªå¯ç”¨ä¸‰è¿éŸ³');
    userSettings.allowedRhythms = ['triplet'];
    updateRhythmSettingsRealTime(); // åº”è¯¥è‡ªåŠ¨æ·»åŠ quarter
    console.log(`å®æ—¶æ›´æ–°å: [${userSettings.allowedRhythms.join(', ')}]`);
    
    // æµ‹è¯•åœºæ™¯3: ç¦ç”¨ä¸‰è¿éŸ³
    console.log('\\nğŸ“ æµ‹è¯•åœºæ™¯3: ç¦ç”¨ä¸‰è¿éŸ³');
    userSettings.allowedRhythms = ['quarter', 'eighth'];
    
    const generator2 = new IntelligentMelodyGenerator(2, 'C', '4/4', 'treble', 12346);
    console.log(`ç”Ÿæˆå™¨è§„åˆ™ä¸­çš„allowedDurations: [${generator2.rules.allowedDurations.join(', ')}]`);
    console.log(`åŒ…å«ä¸‰è¿éŸ³: ${generator2.rules.allowedDurations.includes('triplet')}`);
    
    const canGenerate2 = generator2.canGenerateTriplet(4);
    console.log(`4æ‹æ—¶å¯ä»¥ç”Ÿæˆä¸‰è¿éŸ³: ${canGenerate2}`);
    
    console.log('âœ… ä¸‰è¿éŸ³é€»è¾‘æµ‹è¯•å®Œæˆ');
}

/**
 * æµ‹è¯•å“åº”å¼å¸ƒå±€çš„è°ƒè¯•å‡½æ•°
 */
function testResponsiveLayout() {
    console.log('\nğŸ§ª === å“åº”å¼å¸ƒå±€æµ‹è¯• ===');
    
    // ç”Ÿæˆ8å°èŠ‚æµ‹è¯•æ—‹å¾‹
    const testMelody = generateMelodyData(8, 'C', '4/4', 'treble', 99999);
    
    console.log('ç”Ÿæˆçš„MusicXMLç‰‡æ®µ (æŸ¥æ‰¾ new-system):');
    const xmlLines = testMelody.musicXML.split('\n');
    xmlLines.forEach((line, index) => {
        if (line.includes('new-system') || line.includes('<measure')) {
            console.log(`Line ${index + 1}: ${line.trim()}`);
        }
    });
    
    // æ£€æŸ¥å®¹å™¨å®½åº¦å’Œå“åº”å¼æ–­ç‚¹
    const scoreContainer = document.getElementById('score');
    if (scoreContainer) {
        const containerWidth = scoreContainer.clientWidth;
        const windowWidth = window.innerWidth;
        // å¼ºåˆ¶æ¯è¡Œ4å°èŠ‚ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
        const expectedMeasuresPerLine = 4;
        
        console.log(`ğŸ” å®¹å™¨çŠ¶æ€æ£€æŸ¥:`);
        console.log(`  - çª—å£å®½åº¦: ${windowWidth}px`);
        console.log(`  - å®¹å™¨å®½åº¦: ${containerWidth}px`);
        console.log(`  - æœŸæœ›æ¯è¡Œå°èŠ‚æ•°: ${expectedMeasuresPerLine}`);
        
        // æ£€æŸ¥CSSæ ·å¼å½±å“
        const computedStyle = window.getComputedStyle(scoreContainer);
        console.log(`  - CSS max-width: ${computedStyle.maxWidth}`);
        console.log(`  - CSS width: ${computedStyle.width}`);
        
        // æµ‹è¯•Builderçš„å“åº”å¼é€»è¾‘
        const builder = new MusicXMLBuilder(testMelody.melody, {
            measures: 8, keySignature: 'C', timeSignature: '4/4', clef: 'treble'
        });
        
        const actualMeasuresPerLine = builder.getMeasuresPerLine();
        const measureDistance = builder.getMeasureDistance(
            builder.currentLayout?.layoutType || 'desktop',
            actualMeasuresPerLine
        );
        
        console.log(`ğŸ¼ Builderç»“æœ:`);
        console.log(`  - å®é™…æ¯è¡Œå°èŠ‚æ•°: ${actualMeasuresPerLine}`);
        console.log(`  - è®¡ç®—é—´è·: ${measureDistance}`);
        console.log(`  - å¸ƒå±€ç±»å‹: ${builder.currentLayout?.layoutType || 'unknown'}`);
        
        // éªŒè¯ä¸€è‡´æ€§
        if (actualMeasuresPerLine === expectedMeasuresPerLine) {
            console.log('âœ… å“åº”å¼æ–­ç‚¹é€»è¾‘ä¸€è‡´');
        } else {
            console.warn(`âŒ æ–­ç‚¹é€»è¾‘ä¸ä¸€è‡´: æœŸæœ›${expectedMeasuresPerLine}, å®é™…${actualMeasuresPerLine}`);
        }
        
        // åˆ†æå°èŠ‚åˆ†å¸ƒæ•ˆæœ
        console.log(`ğŸ“Š å°èŠ‚åˆ†å¸ƒåˆ†æ:`);
        const systemWidth = containerWidth * 0.98;
        const availableSpace = systemWidth - 100;
        const measureWidth = availableSpace / actualMeasuresPerLine;
        console.log(`  - ç³»ç»Ÿå®½åº¦: ${Math.round(systemWidth)}px (å®¹å™¨çš„98%)`);
        console.log(`  - å¯ç”¨ç©ºé—´: ${Math.round(availableSpace)}px`);
        console.log(`  - æ¯å°èŠ‚å®½åº¦: ${Math.round(measureWidth)}px`);
        console.log(`  - ç©ºé—´åˆ©ç”¨ç‡: ${((measureWidth * actualMeasuresPerLine / containerWidth) * 100).toFixed(1)}%`);
        
        const totalMeasures = 8;
        const expectedLines = Math.ceil(totalMeasures / actualMeasuresPerLine);
        console.log(`  - é¢„æœŸè¡Œæ•°: ${expectedLines}è¡Œ (æ€»å…±${totalMeasures}å°èŠ‚)`);
        
        // æ£€æŸ¥MusicXMLå†…å®¹
        const xmlLines = testMelody.musicXML.split('\n');
        const measureWidthMatches = testMelody.musicXML.match(/<measure-width>(\d+(?:\.\d+)?)<\/measure-width>/g) || [];
        console.log(`  - MusicXMLä¸­measure-widthæŒ‡ä»¤: ${measureWidthMatches.length}ä¸ª`);
        if (measureWidthMatches.length > 0) {
            measureWidthMatches.forEach((match, index) => {
                const width = match.match(/(\d+(?:\.\d+)?)/)[1];
                console.log(`    è¡Œ${index + 1}: ${width}px`);
            });
        }
        
        // æ£€æŸ¥OSMDè®¾ç½®ï¼ˆæ–°çš„å›ºå®šå®½åº¦APIï¼‰
        if (window.osmd && window.osmd.EngravingRules) {
            console.log(`ğŸµ OSMDè®¾ç½®æ£€æŸ¥:`);
            console.log(`  - RenderXMeasuresPerLineAkaSystem: ${window.osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem}`);
            console.log(`  - MaxMeasuresPerSystem: ${window.osmd.EngravingRules.MaxMeasuresPerSystem}`);
            console.log(`  - FixedMeasureWidth: ${window.osmd.EngravingRules.FixedMeasureWidth}`);
            console.log(`  - FixedMeasureWidthFixedValue: ${window.osmd.EngravingRules.FixedMeasureWidthFixedValue}`);
            console.log(`  - NewSystemAtXMLNewSystem: ${window.osmd.EngravingRules.NewSystemAtXMLNewSystem}`);
        }
    }
}

/**
 * å®æ—¶ç›‘æ§å“åº”å¼çŠ¶æ€çš„å‡½æ•°
 */
function monitorResponsiveState() {
    setInterval(() => {
        const scoreContainer = document.getElementById('score');
        if (scoreContainer) {
            const containerWidth = scoreContainer.clientWidth;
            const windowWidth = window.innerWidth;
            
            // å¼ºåˆ¶æ¯è¡Œ4å°èŠ‚ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
            const currentBreakpoint = 'fixed(4)';
            
            // åªåœ¨çŠ¶æ€å˜åŒ–æ—¶æ‰“å°
            if (!window.lastReportedBreakpoint || window.lastReportedBreakpoint !== currentBreakpoint) {
                console.log(`ğŸ“± å“åº”å¼çŠ¶æ€: ${currentBreakpoint} - çª—å£${windowWidth}px, å®¹å™¨${containerWidth}px`);
                window.lastReportedBreakpoint = currentBreakpoint;
            }
        }
    }, 1000);
}

// ====== åˆå§‹åŒ– ======
console.log('ğŸ¼ è§†å¥æ—‹å¾‹ç”Ÿæˆå™¨ - ç»ˆæç‰ˆå·²åŠ è½½');
console.log('ğŸ¯ ä¸¥æ ¼éµå¾ªéŸ³ä¹ç†è®ºï¼Œä½¿ç”¨OSMDä¸“ä¸šæ¸²æŸ“');
console.log('ğŸ§ª è°ƒè¯•å‘½ä»¤: testResponsiveLayout() - æµ‹è¯•å“åº”å¼å¸ƒå±€');

// å¼ºåˆ¶åº”ç”¨4å°èŠ‚å¸ƒå±€çš„å‡½æ•°ï¼ˆæ”¹è¿›ç‰ˆï¼‰
function force4MeasuresLayout() {
    console.log('ğŸ”§ å¼ºåˆ¶åº”ç”¨æ¯è¡Œ4å°èŠ‚å¸ƒå±€...');
    
    if (!window.osmd) {
        console.error('OSMDå®ä¾‹ä¸å­˜åœ¨ï¼Œè¯·å…ˆç”Ÿæˆæ—‹å¾‹');
        return;
    }
    
    const scoreContainer = document.getElementById('score');
    const containerWidth = scoreContainer ? scoreContainer.clientWidth : 1000;
    
    console.log('å½“å‰å®¹å™¨å®½åº¦:', containerWidth + 'px');
    
    if (window.osmd.EngravingRules) {
        // æ£€æŸ¥å½“å‰é…ç½®
        console.log('ğŸ” å½“å‰OSMDé…ç½®:');
        console.log('  - RenderXMeasuresPerLineAkaSystem:', window.osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem);
        console.log('  - FixedMeasureWidth:', window.osmd.EngravingRules.FixedMeasureWidth);
        console.log('  - FixedMeasureWidthFixedValue:', window.osmd.EngravingRules.FixedMeasureWidthFixedValue);
        
        // è®¡ç®—æ–°çš„å°èŠ‚å®½åº¦
        const availableWidth = containerWidth - 80;
        const measureWidth = Math.max(50, Math.min(250, availableWidth / 4));
        
        console.log('ğŸ“ è®¡ç®—å°èŠ‚å®½åº¦:', Math.round(measureWidth) + 'px');
        
        // åº”ç”¨é…ç½®
        window.osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = 4;
        window.osmd.EngravingRules.FixedMeasureWidth = true;
        window.osmd.EngravingRules.FixedMeasureWidthFixedValue = measureWidth;
        window.osmd.EngravingRules.CompactMode = false;
        window.osmd.EngravingRules.NewSystemAtXMLNewSystem = true;
        
        // æ·»åŠ å°èŠ‚åœ¨ç³»ç»Ÿå†…å‡åŒ€åˆ†å¸ƒçš„è®¾ç½®
        if (window.osmd.EngravingRules.hasOwnProperty('JustifyMeasuresInSystem')) {
            window.osmd.EngravingRules.JustifyMeasuresInSystem = true;
        } else if (window.osmd.EngravingRules.hasOwnProperty('justifyMeasuresInSystem')) {
            window.osmd.EngravingRules.justifyMeasuresInSystem = true;
        }
        
        // é‡æ–°æ¸²æŸ“
        try {
            console.log('ğŸ¨ é‡æ–°æ¸²æŸ“ä¸­...');
            window.osmd.render();
            
            // å»¶è¿Ÿæ£€æŸ¥ç»“æœ
            setTimeout(() => {
                console.log('âœ… æ¸²æŸ“å®Œæˆï¼Œæ£€æŸ¥ç»“æœ:');
                console.log('  - RenderXMeasuresPerLineAkaSystem:', window.osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem);
                console.log('  - FixedMeasureWidth:', window.osmd.EngravingRules.FixedMeasureWidth);
                console.log('  - FixedMeasureWidthFixedValue:', window.osmd.EngravingRules.FixedMeasureWidthFixedValue);
                
                // åˆ†æå®é™…æ¸²æŸ“ç»“æœ
                const svgElement = document.querySelector('#score svg');
                if (svgElement) {
                    const measures = svgElement.querySelectorAll('g[id*="measure"], g[class*="measure"]');
                    console.log('ğŸ“Š å®é™…æ¸²æŸ“:', measures.length + 'ä¸ªå°èŠ‚');
                } else {
                    console.log('âŒ æœªæ‰¾åˆ°SVGå…ƒç´ ');
                }
            }, 200);
            
        } catch (error) {
            console.error('âŒ é‡æ–°æ¸²æŸ“å¤±è´¥:', error);
        }
    } else {
        console.error('âŒ EngravingRulesä¸å¯ç”¨');
        console.log('OSMDå¯¹è±¡:', window.osmd);
    }
}

// å°†è°ƒè¯•å‡½æ•°æš´éœ²åˆ°å…¨å±€ï¼Œæ–¹ä¾¿æ§åˆ¶å°è°ƒç”¨
window.testResponsiveLayout = testResponsiveLayout;
window.monitorResponsiveState = monitorResponsiveState;
window.force4MeasuresLayout = force4MeasuresLayout;

document.addEventListener('DOMContentLoaded', function() {
    console.log('ğŸ“„ é¡µé¢åŠ è½½å®Œæˆï¼Œæ£€æŸ¥ä¾èµ–');
    
    // è¿è¡Œè°ƒå·å¤„ç†æµ‹è¯•ï¼ˆåœ¨URLä¸­æ·»åŠ #testæ¥å¯ç”¨ï¼‰
    if (window.location.hash === '#test') {
        setTimeout(() => {
            testKeySignatureHandling();
        }, 1000);
    }
    
    // ç¡®ä¿ userSettings è¢«æ­£ç¡®åˆå§‹åŒ–
    if (!userSettings || typeof userSettings !== 'object') {
        console.warn('âš ï¸ userSettingsæœªæ­£ç¡®åˆå§‹åŒ–ï¼Œé‡æ–°è®¾ç½®');
        userSettings = {
            customRange: { min: 60, max: 79 }, // C5-C6ï¼Œåœ¨A2-A6èŒƒå›´å†…
            hasCustomRange: false, // æ ‡è®°ç”¨æˆ·æ˜¯å¦æ‰‹åŠ¨è®¾ç½®äº†éŸ³åŸŸ
            allowedRhythms: ['half', 'quarter', 'eighth'],
            allowDottedNotes: true,
            accidentalRate: 0,
            maxJump: 12,
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç¡®ä¿articulationsé…ç½®è¢«ä¿ç•™
            articulations: {
                enabled: false,
                basic: [],
                guitar: [], // è¿™é‡Œå¾ˆé‡è¦ï¼
                ornaments: [],
                strings: [],
                bass: []
            }
        };
    }
    
    // ğŸ”¥ é¢å¤–ä¿®å¤ï¼šç¡®ä¿articulationså­å¯¹è±¡å­˜åœ¨
    if (!userSettings.articulations || typeof userSettings.articulations !== 'object') {
        console.warn('âš ï¸ userSettings.articulationsæœªæ­£ç¡®åˆå§‹åŒ–ï¼Œé‡æ–°è®¾ç½®');
        userSettings.articulations = {
            enabled: false,
            basic: [],
            guitar: [], // è¿™é‡Œå¾ˆé‡è¦ï¼
            ornaments: [],
            strings: [],
            bass: [],
            frequencies: {
                staccato: 20,
                accent: 15,
                acciaccatura: 10,
                slur: 15,
                slide: 10
            }
        };
    }
    
    // ğŸ”¥ ç¡®ä¿guitaræ•°ç»„å­˜åœ¨
    if (!Array.isArray(userSettings.articulations.guitar)) {
        console.warn('âš ï¸ userSettings.articulations.guitarä¸æ˜¯æ•°ç»„ï¼Œé‡æ–°è®¾ç½®');
        userSettings.articulations.guitar = [];
    }
    
    // ğŸ”¥ ç¡®ä¿frequencieså¯¹è±¡å­˜åœ¨
    if (!userSettings.articulations.frequencies || typeof userSettings.articulations.frequencies !== 'object') {
        console.warn('âš ï¸ userSettings.articulations.frequenciesæœªæ­£ç¡®åˆå§‹åŒ–ï¼Œé‡æ–°è®¾ç½®');
        userSettings.articulations.frequencies = {
            staccato: 20,
            accent: 15,
            acciaccatura: 10,
            slur: 15,  // ç»Ÿä¸€çš„å‡»å‹¾å¼¦é¢‘ç‡æ§åˆ¶
            slide: 10  // ç»Ÿä¸€çš„Slideé¢‘ç‡æ§åˆ¶
        };
    }
    
    // éªŒè¯å¿…è¦çš„æ•°ç»„å±æ€§
    if (!Array.isArray(userSettings.allowedRhythms)) {
        console.warn('âš ï¸ allowedRhythmsä¸æ˜¯æ•°ç»„ï¼Œé‡æ–°è®¾ç½®');
        userSettings.allowedRhythms = ['quarter'];
    }
    
    console.log('âœ… userSettingséªŒè¯å®Œæˆ:', userSettings);
    
    if (typeof opensheetmusicdisplay === 'undefined') {
        console.error('âŒ OpenSheetMusicDisplayæœªåŠ è½½');
        document.getElementById('score').innerHTML = `
            <div style="color: red; text-align: center; padding: 50px;">
                <h3>ä¾èµ–åº“æœªåŠ è½½</h3>
                <p>OpenSheetMusicDisplayåº“åŠ è½½å¤±è´¥</p>
                <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å¹¶åˆ·æ–°é¡µé¢</p>
            </div>
        `;
    } else {
        console.log('âœ… æ‰€æœ‰ä¾èµ–åº“å°±ç»ª');
        
        // å¯åŠ¨å“åº”å¼ç›‘æ§
        monitorResponsiveState();
        console.log('ğŸ“± å“åº”å¼çŠ¶æ€ç›‘æ§å·²å¯åŠ¨');
    }
    
    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ - å®æ—¶æ›´æ–°è®¾ç½®
    document.getElementById('rangeMin').addEventListener('change', function() {
        updateCustomRange();
        console.log('ğŸ”„ éŸ³åŸŸèŒƒå›´å·²å®æ—¶æ›´æ–°');
    });
    document.getElementById('rangeMax').addEventListener('change', function() {
        updateCustomRange();
        console.log('ğŸ”„ éŸ³åŸŸèŒƒå›´å·²å®æ—¶æ›´æ–°');
    });
    document.getElementById('accidentalRate').addEventListener('input', function() {
        updateAccidentalRate();
        console.log('ğŸ”„ ä¸´æ—¶è®°å·æ¦‚ç‡å·²å®æ—¶æ›´æ–°');
    });
    
    // è°±å·åˆ‡æ¢ç›‘å¬å™¨
    document.getElementById('clef').addEventListener('change', function() {
        const selectedClef = this.value;
        adjustRangeForClef(selectedClef);
        console.log(`ğŸ”„ è°±å·å·²åˆ‡æ¢åˆ°: ${selectedClef === 'treble' ? 'é«˜éŸ³è°±å·' : selectedClef === 'alto' ? 'ä¸­éŸ³è°±å·' : 'ä½éŸ³è°±å·'}`);
    });
    const maxIntervalElement = document.getElementById('maxInterval');
    if (maxIntervalElement) {
        console.log('âœ… æ‰¾åˆ°maxIntervalå…ƒç´ :', maxIntervalElement.tagName, maxIntervalElement.type);
        console.log('ğŸ” å…ƒç´ å½“å‰çŠ¶æ€ - å€¼:', maxIntervalElement.value, 'ç¦ç”¨:', maxIntervalElement.disabled);
        console.log('ğŸ” å…ƒç´ é€‰é¡¹æ•°é‡:', maxIntervalElement.options.length);
        
        // æ·»åŠ å¤šç§äº‹ä»¶ç›‘å¬å™¨è¿›è¡Œè°ƒè¯•
        maxIntervalElement.addEventListener('change', function() {
            console.log('ğŸ¯ maxInterval changeäº‹ä»¶è§¦å‘ï¼Œå½“å‰å€¼:', this.value);
            updateMaxJump();
            console.log('ğŸ”„ æœ€å¤§éŸ³ç¨‹è·³åŠ¨å·²å®æ—¶æ›´æ–°');
        });
        
        maxIntervalElement.addEventListener('click', function() {
            console.log('ğŸ–±ï¸ maxInterval clickäº‹ä»¶è§¦å‘');
        });
        
        // å®šæœŸæ£€æŸ¥å…ƒç´ çŠ¶æ€
        setTimeout(() => {
            console.log('â° 5ç§’åæ£€æŸ¥maxIntervalçŠ¶æ€ - å€¼:', maxIntervalElement.value, 'ç¦ç”¨:', maxIntervalElement.disabled);
        }, 5000);
        
    } else {
        console.error('âŒ æœªæ‰¾åˆ°maxIntervalå…ƒç´ ');
    }
    
    // æ·»åŠ èŠ‚å¥è®¾ç½®å®æ—¶æ›´æ–°ç›‘å¬å™¨
    const rhythmInputs = document.querySelectorAll('#rhythmModal input[type="checkbox"]');
    rhythmInputs.forEach(input => {
        input.addEventListener('change', function() {
            console.log(`ğŸµ èŠ‚å¥é€‰é¡¹å˜åŒ–: ${this.id} = ${this.checked}`);
            updateRhythmSettingsRealTime();
        });
    });
    
    // åˆå§‹åŒ–æ‰€æœ‰è®¾ç½®
    // ç¡®ä¿æ»‘å—å€¼ä¸º0
    const accidentalSlider = document.getElementById('accidentalRate');
    if (accidentalSlider) {
        accidentalSlider.value = 0;  // ç¡®ä¿æ»‘å—åœ¨æœ€å·¦è¾¹
    }
    updateAccidentalRate();
    updateMaxJump();
    updateCustomRange();
    updateRhythmSettingsRealTime(); // åˆå§‹åŒ–èŠ‚å¥è®¾ç½®
    
    // ğŸ”¥ ä¼˜åŒ–çš„å‰ä»–æŠ€å·§é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ
    console.log('ğŸ¸ å¼€å§‹åˆå§‹åŒ– slur/slide é¢‘ç‡æ§åˆ¶å™¨...');
    
    // ğŸ”¥ ç¡®ä¿frequencieså¯¹è±¡å­˜åœ¨ä¸”æœ‰æ­£ç¡®çš„åˆå§‹å€¼
    if (!userSettings.articulations.frequencies) {
        userSettings.articulations.frequencies = {
            staccato: 20,
            accent: 15,
            acciaccatura: 10,
            slur: 15,
            slide: 10
        };
        console.log('ğŸ”§ é‡æ–°åˆå§‹åŒ– frequencies å¯¹è±¡');
    }

    ['slur', 'slide'].forEach(type => {
        const slider = document.getElementById(`freq-${type}`);
        const valueDisplay = document.getElementById(`freq-${type}-value`);
        if (!slider || !valueDisplay) {
            console.log(`âŒ ${type}æ»‘å—æˆ–æ˜¾ç¤ºå…ƒç´ æœªæ‰¾åˆ°`);
            return;
        }
        const initialValue = userSettings.articulations.frequencies[type] ?? getDefaultArticulationFrequency(type);
        slider.value = initialValue;
        valueDisplay.textContent = `${initialValue}%`;

        slider.removeEventListener('input', slider._initHandler);
        slider._initHandler = function() {
            const value = parseInt(this.value);
            valueDisplay.textContent = `${value}%`;
            userSettings.articulations.frequencies[type] = value;
            console.log(`ğŸ¸ ${type}é¢‘ç‡æ›´æ–°: ${value}%`);
        };
        slider.addEventListener('input', slider._initHandler);
        console.log(`âœ… ${type}æ»‘å—åˆå§‹åŒ–å®Œæˆ: ${initialValue}%`);
    });

    console.log('ğŸ¸ å‰ä»–æŠ€å·§é¢‘ç‡æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ!');
    console.log('ğŸ“Š å½“å‰é¢‘ç‡è®¾ç½®:', userSettings.articulations.frequencies);
    
    // ğŸ”¥ ç§»é™¤æ—§çš„é”™è¯¯çš„timeSignatureå…ƒç´ ç›‘å¬å™¨ä»£ç 
    // å› ä¸ºHTMLä¸­ä½¿ç”¨çš„æ˜¯å¤šä¸ªå¤é€‰æ¡†(time-6/8ç­‰)è€Œä¸æ˜¯å•ä¸ªselectå…ƒç´ 
    // ç°åœ¨ä½¿ç”¨æ–°çš„initializeTimeSignatureListeners()å‡½æ•°æ¥å¤„ç†æ‹å·å˜åŒ–äº‹ä»¶
    
    // è®¾ç½®å“åº”å¼å¸ƒå±€ç›‘å¬å™¨
    setupResponsiveLayoutListener();
    
    console.log('ğŸ”§ æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨å·²è®¾ç½®ï¼ŒåŒ…æ‹¬å®æ—¶èŠ‚å¥æ›´æ–°ã€æ‹å·èŠ‚å¥é€‰é¡¹åˆ‡æ¢å’Œå“åº”å¼å¸ƒå±€');
});

// ====== å…¨å±€å¯¼å‡ºçš„å“åº”å¼å¸ƒå±€æµ‹è¯•å‡½æ•° ======

/**
 * æµ‹è¯•å“åº”å¼å¸ƒå±€åŠŸèƒ½ï¼ˆç”¨äºè°ƒè¯•ï¼‰
 */
function testResponsiveLayouts() {
    console.log('ğŸ§ª å¼€å§‹å“åº”å¼å¸ƒå±€æµ‹è¯•...');
    
    const testWidths = [400, 700, 1000]; // ç§»åŠ¨ç«¯ã€å¹³æ¿ç«¯ã€æ¡Œé¢ç«¯
    const scoreContainer = document.getElementById('score');
    
    if (!scoreContainer) {
        console.error('âŒ æµ‹è¯•å¤±è´¥ï¼šæœªæ‰¾åˆ°scoreå®¹å™¨');
        return;
    }
    
    const originalStyle = scoreContainer.style.cssText;
    let testIndex = 0;
    
    function runNextTest() {
        if (testIndex >= testWidths.length) {
            // æµ‹è¯•å®Œæˆï¼Œæ¢å¤åŸå§‹æ ·å¼
            scoreContainer.style.cssText = originalStyle;
            console.log('âœ… å“åº”å¼å¸ƒå±€æµ‹è¯•å®Œæˆ');
            return;
        }
        
        const testWidth = testWidths[testIndex];
        console.log(`\nğŸ“± æµ‹è¯•å®½åº¦ ${testWidth}px:`);
        
        // ä¸´æ—¶è®¾ç½®å®¹å™¨å®½åº¦ (ä»…ç”¨äºæµ‹è¯•)
        scoreContainer.style.width = testWidth + 'px';
        scoreContainer.style.maxWidth = testWidth + 'px';
        console.log(`ğŸ§ª æµ‹è¯•æ¨¡å¼ï¼šä¸´æ—¶è®¾ç½®å®½åº¦ä¸º ${testWidth}px`);
        
        // è·å–å¸ƒå±€ä¿¡æ¯
        setTimeout(() => {
            const layout = getCurrentResponsiveLayout();
            console.log(`   å¸ƒå±€ç±»å‹: ${layout.layoutType}`);
            console.log(`   æ¯è¡Œå°èŠ‚: ${layout.measuresPerLine}ä¸ª`);
            console.log(`   å®é™…å®½åº¦: ${layout.containerWidth}px`);
            
            testIndex++;
            setTimeout(runNextTest, 1000); // ç­‰å¾…1ç§’å†è¿›è¡Œä¸‹ä¸€ä¸ªæµ‹è¯•
        }, 500);
    }
    
    runNextTest();
}

/**
 * å¼ºåˆ¶é‡æ–°ç”Ÿæˆå½“å‰æ—‹å¾‹ï¼ˆç”¨äºå¸ƒå±€å˜åŒ–åçš„æµ‹è¯•ï¼‰
 */
function regenerateCurrentMelody() {
    if (melodyHistory.length > 0 && currentHistoryIndex >= 0) {
        const currentMelody = melodyHistory[currentHistoryIndex];
        if (currentMelody) {
            console.log('ğŸ”„ é‡æ–°ç”Ÿæˆå½“å‰æ—‹å¾‹ä»¥é€‚åº”å½“å‰å¸ƒå±€');
            
            // è·å–å½“å‰è®¾ç½®é‡æ–°ç”Ÿæˆ
            const generator = new IntelligentMelodyGenerator(
                currentMelody.config.measures,
                currentMelody.config.keySignature,
                currentMelody.config.timeSignature,
                currentMelody.config.clef,
                currentMelody.seed
            );
            
            const builder = new MusicXMLBuilder(generator, currentMelody.config);
            const measuresPerLine = builder.getMeasuresPerLine();
            const newXML = builder.build(measuresPerLine);
            
            renderMelodyWithOSMD(newXML);
            
            // æ›´æ–°å†å²è®°å½•
            melodyHistory[currentHistoryIndex] = {
                ...currentMelody,
                musicXML: newXML
            };
            
            return true;
        }
    }
    
    console.warn('âš ï¸ æ— å½“å‰æ—‹å¾‹å¯é‡æ–°ç”Ÿæˆ');
    return false;
}

/**
 * æ˜¾ç¤ºå½“å‰å“åº”å¼å¸ƒå±€ä¿¡æ¯
 */
function showCurrentLayout() {
    const layout = getCurrentResponsiveLayout();
    
    if (layout) {
        console.log('\nğŸ“Š å½“å‰å“åº”å¼å¸ƒå±€ä¿¡æ¯:');
        console.log(`   å®¹å™¨å®½åº¦: ${layout.containerWidth}px`);
        console.log(`   å¸ƒå±€ç±»å‹: ${layout.layoutType}`);
        console.log(`   æ¯è¡Œå°èŠ‚: ${layout.measuresPerLine}ä¸ª`);
        console.log(`   æ–­ç‚¹è§„åˆ™:`);
        console.log(`     æ¡Œé¢ç«¯: ${layout.breakpoints.desktop}`);
        console.log(`     å¹³æ¿ç«¯: ${layout.breakpoints.tablet}`);
        console.log(`     ç§»åŠ¨ç«¯: ${layout.breakpoints.mobile}`);
        
        return layout;
    } else {
        console.error('âŒ æ— æ³•è·å–å¸ƒå±€ä¿¡æ¯');
        return null;
    }
}

/**
 * renderMelodyWithOSMDå‡½æ•°å®šä¹‰
 */
async function renderMelodyWithOSMD(musicXML) {
    console.log('ğŸµ ä½¿ç”¨renderMelodyWithOSMDæ¸²æŸ“MusicXML');
    
    const melodyData = {
        musicXML: musicXML,
        config: {
            measures: 8, // é»˜è®¤å€¼ï¼Œå¯ä»¥ä»XMLè§£æ
            keySignature: 'C',
            timeSignature: '4/4',
            clef: 'treble'
        }
    };
    
    return await renderScore(melodyData);
}

// ä¿®å¤RenderXMeasuresPerLineAkaSystemé…ç½®çš„å‡½æ•°
function fixRenderXMeasuresConfig() {
    console.log('ğŸ”§ ä¿®å¤RenderXMeasuresPerLineAkaSystemé…ç½®...');
    
    if (!osmd || !osmd.EngravingRules) {
        console.error('âŒ OSMDå®ä¾‹æˆ–EngravingRulesä¸å­˜åœ¨');
        return;
    }
    
    const measuresPerLine = 4;
    
    console.log(`ğŸ“‹ ä¿®å¤å‰é…ç½®:`);
    console.log(`  - MaxMeasuresPerSystem: ${osmd.EngravingRules.MaxMeasuresPerSystem}`);
    console.log(`  - MinMeasuresPerSystem: ${osmd.EngravingRules.MinMeasuresPerSystem}`);
    console.log(`  - RenderXMeasuresPerLineAkaSystem: ${osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem}`);
    
    // æ ¸å¿ƒä¿®å¤ï¼šè®¾ç½®RenderXMeasuresPerLineAkaSystem
    osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = measuresPerLine;
    osmd.EngravingRules.MaxMeasuresPerSystem = measuresPerLine;
    osmd.EngravingRules.MinMeasuresPerSystem = measuresPerLine;
    
    // æ·»åŠ å°èŠ‚åœ¨ç³»ç»Ÿå†…å‡åŒ€åˆ†å¸ƒçš„è®¾ç½®
    if (osmd.EngravingRules.hasOwnProperty('JustifyMeasuresInSystem')) {
        osmd.EngravingRules.JustifyMeasuresInSystem = true;
        console.log('âœ… å¯ç”¨JustifyMeasuresInSystemä»¥ç¡®ä¿å°èŠ‚å‡åŒ€åˆ†å¸ƒ');
    } else if (osmd.EngravingRules.hasOwnProperty('justifyMeasuresInSystem')) {
        osmd.EngravingRules.justifyMeasuresInSystem = true;
        console.log('âœ… å¯ç”¨justifyMeasuresInSystemä»¥ç¡®ä¿å°èŠ‚å‡åŒ€åˆ†å¸ƒ');
    }
    
    // è®¡ç®—é€‚å½“çš„å°èŠ‚å®½åº¦
    const scoreContainer = document.getElementById('score');
    const containerWidth = scoreContainer ? scoreContainer.clientWidth : 1000;
    const maxTotalWidth = 800;
    const availableWidth = Math.min(containerWidth - 60, maxTotalWidth);
    const measureWidth = Math.max(120, availableWidth / measuresPerLine);
    
    osmd.EngravingRules.FixedMeasureWidth = true;
    osmd.EngravingRules.FixedMeasureWidthFixedValue = measureWidth;
    
    console.log(`ğŸ“‹ ä¿®å¤åé…ç½®:`);
    console.log(`  - MaxMeasuresPerSystem: ${osmd.EngravingRules.MaxMeasuresPerSystem}`);
    console.log(`  - MinMeasuresPerSystem: ${osmd.EngravingRules.MinMeasuresPerSystem}`);
    console.log(`  - RenderXMeasuresPerLineAkaSystem: ${osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem}`);
    console.log(`  - FixedMeasureWidth: ${osmd.EngravingRules.FixedMeasureWidth}`);
    console.log(`  - FixedMeasureWidthFixedValue: ${Math.round(osmd.EngravingRules.FixedMeasureWidthFixedValue)}`);
    
    try {
        osmd.render();
        console.log('âœ… é‡æ–°æ¸²æŸ“å®Œæˆ');
        
        // éªŒè¯ç»“æœ
        setTimeout(() => {
            const svg = scoreContainer.querySelector('svg');
            if (svg) {
                // ä½¿ç”¨æ­£ç¡®çš„é€‰æ‹©å™¨
                const allG = svg.querySelectorAll('g');
                let measures = [];
                
                allG.forEach(g => {
                    const id = g.getAttribute('id') || '';
                    const className = g.getAttribute('class') || '';
                    
                    if (id.includes('MeasureContent') || className.includes('measure')) {
                        measures.push(g);
                    }
                });
                
                console.log(`ğŸ“Š æ¸²æŸ“ç»“æœ: ${measures.length}ä¸ªå°èŠ‚`);
                
                // åˆ†ææ¯è¡Œçš„å°èŠ‚æ•°
                if (measures.length > 0) {
                    const positions = [];
                    measures.forEach((measure, i) => {
                        const bbox = measure.getBBox();
                        positions.push({
                            measure: i + 1,
                            y: Math.round(bbox.y)
                        });
                    });
                    
                    // æŒ‰Yä½ç½®åˆ†ç»„ç»Ÿè®¡æ¯è¡Œå°èŠ‚æ•°
                    const lines = {};
                    positions.forEach(pos => {
                        const lineKey = Math.round(pos.y / 50) * 50; // æ¯50pxä¸ºä¸€è¡Œ
                        if (!lines[lineKey]) lines[lineKey] = 0;
                        lines[lineKey]++;
                    });
                    
                    console.log('ğŸ“ æ¯è¡Œå°èŠ‚åˆ†å¸ƒ:');
                    Object.keys(lines).forEach((y, index) => {
                        console.log(`  ç¬¬${index + 1}è¡Œ: ${lines[y]}ä¸ªå°èŠ‚`);
                    });
                }
            }
        }, 300);
        
    } catch (error) {
        console.error('âŒ é‡æ–°æ¸²æŸ“å¤±è´¥:', error);
    }
}

// å¼ºåˆ¶åº”ç”¨4å°èŠ‚å¸ƒå±€çš„è°ƒè¯•å‡½æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
function force4MeasuresPerLine() {
    console.log('ğŸ”§ å¼ºåˆ¶åº”ç”¨4å°èŠ‚æ¯è¡Œå¸ƒå±€...');
    fixRenderXMeasuresConfig();
}

// æ£€æŸ¥OSMDå®é™…å¯ç”¨çš„å±æ€§å’Œé…ç½®é€‰é¡¹
function inspectOSMD() {
    console.log('ğŸ” æ£€æŸ¥OSMDå®ä¾‹çš„å®é™…å±æ€§å’Œæ–¹æ³•...');
    
    if (!osmd) {
        console.error('âŒ OSMDå®ä¾‹ä¸å­˜åœ¨');
        return;
    }
    
    console.log('ğŸ“Š OSMDå®ä¾‹ä¿¡æ¯:');
    console.log('  - ç±»å‹:', typeof osmd);
    console.log('  - æ„é€ å‡½æ•°:', osmd.constructor.name);
    
    if (osmd.EngravingRules) {
        console.log('ğŸ“ EngravingRules å±æ€§:');
        const rules = osmd.EngravingRules;
        
        // æ£€æŸ¥æ‰€æœ‰å¯èƒ½å½±å“å¸ƒå±€çš„å±æ€§
        const layoutProperties = [
            'MaxMeasuresPerSystem',
            'MinMeasuresPerSystem', 
            'RenderXMeasuresPerLineAkaSystem',
            'FixedMeasureWidth',
            'FixedMeasureWidthFixedValue',
            'NewSystemAtXMLNewSystem',
            'CompactMode',
            'PageFormat',
            'SystemDistance',
            'MeasureDistance'
        ];
        
        layoutProperties.forEach(prop => {
            if (prop in rules) {
                console.log(`  - ${prop}: ${rules[prop]}`);
            } else {
                console.log(`  - ${prop}: [ä¸å­˜åœ¨]`);
            }
        });
    } else {
        console.log('âŒ EngravingRulesä¸å­˜åœ¨');
    }
    
    // æ£€æŸ¥å…¶ä»–å¯èƒ½çš„é…ç½®å¯¹è±¡
    const configObjects = ['rules', 'Options', 'settings', 'configuration'];
    configObjects.forEach(obj => {
        if (osmd[obj]) {
            console.log(`ğŸ“‹ æ‰¾åˆ°é…ç½®å¯¹è±¡ ${obj}:`, osmd[obj]);
        }
    });
}

// åˆ›å»ºä¸€ä¸ªæœ€ç®€å•çš„4å°èŠ‚MusicXMLæµ‹è¯•
function createSimpleMusicXML() {
    return `<?xml version="1.0" encoding="UTF-8"?>
<score-partwise version="3.0">
  <part-list>
    <score-part id="P1">
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>4</divisions>
        <key><fifths>0</fifths><mode>major</mode></key>
        <time><beats>4</beats><beat-type>4</beat-type></time>
        <clef><sign>G</sign><line>2</line></clef>
      </attributes>
      <note><pitch><step>C</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>D</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>E</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>F</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="2">
      <note><pitch><step>G</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>A</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>B</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>C</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="3">
      <note><pitch><step>D</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>E</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>F</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>G</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="4">
      <note><pitch><step>A</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>B</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>C</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>D</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="5">
      <note><pitch><step>E</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>F</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>G</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>A</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="6">
      <note><pitch><step>B</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>C</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>D</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>E</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="7">
      <note><pitch><step>F</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>G</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>A</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>B</step><octave>4</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
    <measure number="8">
      <note><pitch><step>C</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>D</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>E</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
      <note><pitch><step>F</step><octave>5</octave></pitch><duration>4</duration><type>quarter</type></note>
    </measure>
  </part>
</score-partwise>`;
}

// æµ‹è¯•å®Œå…¨ç®€åŒ–çš„OSMDæ¸²æŸ“
async function testSimpleOSMD() {
    console.log('ğŸ§ª æµ‹è¯•å®Œå…¨ç®€åŒ–çš„OSMDæ¸²æŸ“');
    
    try {
        const scoreDiv = document.getElementById('score');
        scoreDiv.innerHTML = '';
        
        // é‡æ–°åˆå§‹åŒ–
        if (osmd) {
            osmd.clear();
            osmd = null;
        }
        
        // åˆ›å»ºæœ€ç®€å•çš„OSMDå®ä¾‹
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("score", {
            autoResize: true,
            backend: "vexflow",
            drawTitle: false,
            drawSubtitle: false,
            drawComposer: false,
            drawLyricist: false,
            drawCredits: false,
            drawPartNames: false
        });
        
        // å¯ç”¨glissandoæ¸²æŸ“å’Œç›¸å…³è®¾ç½®
        if (osmd.EngravingRules) {
            console.log('ğŸ” æ£€æŸ¥OSMDç‰ˆæœ¬å’ŒåŠŸèƒ½æ”¯æŒ:');
            console.log('  - OSMDç‰ˆæœ¬:', typeof osmd.Version !== 'undefined' ? osmd.Version : 'æœªçŸ¥');
            console.log('  - åç«¯å¼•æ“:', osmd.backendType || 'æœªçŸ¥');
            console.log('  - EngravingRuleså¯¹è±¡:', Object.keys(osmd.EngravingRules).filter(key => key.includes('Render')));
            
            // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„æ¸²æŸ“é€‰é¡¹
            const allRenderOptions = Object.keys(osmd.EngravingRules).filter(key => 
                key.startsWith('Render') || key.includes('Glissando') || key.includes('Slur')
            );
            console.log('  - æ‰€æœ‰æ¸²æŸ“ç›¸å…³é€‰é¡¹:', allRenderOptions);
            
            if ("RenderGlissandi" in osmd.EngravingRules) {
                osmd.EngravingRules.RenderGlissandi = true;
                console.log('âœ… å·²å¯ç”¨OSMD glissandoæ¸²æŸ“');
            } else {
                console.log('âŒ OSMDä¸æ”¯æŒRenderGlissandié€‰é¡¹');
                console.log('ğŸ” æ£€æŸ¥æ›¿ä»£é€‰é¡¹: RenderGlissandos, DrawGlissando, etc.');
                
                // æ£€æŸ¥å¯èƒ½çš„æ›¿ä»£åç§°
                const glissandoAlternatives = ['RenderGlissandos', 'DrawGlissando', 'ShowGlissando'];
                glissandoAlternatives.forEach(alt => {
                    if (alt in osmd.EngravingRules) {
                        osmd.EngravingRules[alt] = true;
                        console.log(`âœ… æ‰¾åˆ°å¹¶å¯ç”¨æ›¿ä»£é€‰é¡¹: ${alt}`);
                    }
                });
            }
            
            // å°è¯•å¯ç”¨æ‰€æœ‰å¯èƒ½ç›¸å…³çš„æ¸²æŸ“é€‰é¡¹
            const renderOptions = ['RenderSlurs', 'RenderArpeggios', 'RenderTies', 'RenderOrnaments', 'RenderArticulations'];
            renderOptions.forEach(option => {
                if (option in osmd.EngravingRules) {
                    osmd.EngravingRules[option] = true;
                    console.log(`âœ… å·²å¯ç”¨OSMD ${option}`);
                } else {
                    console.log(`âŒ OSMDä¸æ”¯æŒ${option}é€‰é¡¹`);
                }
            });
            
            console.log('ğŸ” OSMD EngravingRulesæœ€ç»ˆè®¾ç½®:');
            renderOptions.concat(['RenderGlissandi']).forEach(option => {
                if (option in osmd.EngravingRules) {
                    console.log(`  - ${option}: ${osmd.EngravingRules[option]}`);
                } else {
                    console.log(`  - ${option}: ä¸æ”¯æŒ`);
                }
            });
        }
        
        // éšè—æ ‡é¢˜å’Œä¹å™¨åç§°
        if (osmd.EngravingRules) {
            osmd.EngravingRules.drawTitle = false;
            osmd.EngravingRules.drawSubtitle = false;
            osmd.EngravingRules.drawComposer = false;
            osmd.EngravingRules.drawLyricist = false;
            osmd.EngravingRules.drawCredits = false;
            osmd.EngravingRules.drawPartNames = false;
            console.log('âœ… å·²éšè—æ ‡é¢˜å’Œä¹å™¨åç§°');
        }
        
        console.log('âœ… OSMDå®ä¾‹åˆ›å»ºå®Œæˆ');
        
        // æ£€æŸ¥å®é™…å±æ€§
        inspectOSMD();
        
        // åŠ è½½ç®€å•çš„8å°èŠ‚MusicXML
        const simpleXML = createSimpleMusicXML();
        await osmd.load(simpleXML);
        console.log('âœ… ç®€å•MusicXMLåŠ è½½å®Œæˆ');
        
        // åœ¨æ¸²æŸ“å‰å°è¯•è®¾ç½®ä»»ä½•å¯ç”¨çš„é…ç½®
        if (osmd.EngravingRules) {
            console.log('ğŸ›ï¸ å°è¯•è®¾ç½®å¸ƒå±€é…ç½®...');
            
            // å°è¯•æ‰€æœ‰å¯èƒ½çš„å±æ€§
            try { osmd.EngravingRules.MaxMeasuresPerSystem = 4; } catch(e) { console.log('MaxMeasuresPerSystemè®¾ç½®å¤±è´¥'); }
            try { osmd.EngravingRules.MinMeasuresPerSystem = 4; } catch(e) { console.log('MinMeasuresPerSystemè®¾ç½®å¤±è´¥'); }
            try { osmd.EngravingRules.FixedMeasureWidth = true; } catch(e) { console.log('FixedMeasureWidthè®¾ç½®å¤±è´¥'); }
            try { osmd.EngravingRules.FixedMeasureWidthFixedValue = 150; } catch(e) { console.log('FixedMeasureWidthFixedValueè®¾ç½®å¤±è´¥'); }
            
            // æ·»åŠ å°èŠ‚åœ¨ç³»ç»Ÿå†…å‡åŒ€åˆ†å¸ƒçš„è®¾ç½®
            try {
                if (osmd.EngravingRules.hasOwnProperty('JustifyMeasuresInSystem')) {
                    osmd.EngravingRules.JustifyMeasuresInSystem = true;
                    console.log('âœ… å¯ç”¨JustifyMeasuresInSystem');
                } else if (osmd.EngravingRules.hasOwnProperty('justifyMeasuresInSystem')) {
                    osmd.EngravingRules.justifyMeasuresInSystem = true;
                    console.log('âœ… å¯ç”¨justifyMeasuresInSystem');
                }
            } catch(e) { console.log('JustifyMeasuresInSystemè®¾ç½®å¤±è´¥:', e); }
        }
        
        // æ¸²æŸ“
        osmd.render();
        console.log('âœ… æ¸²æŸ“å®Œæˆ');
        
        // åˆ†æç»“æœ
        setTimeout(() => {
            const svg = scoreDiv.querySelector('svg');
            if (svg) {
                // ä½¿ç”¨æ­£ç¡®çš„é€‰æ‹©å™¨
                const allG = svg.querySelectorAll('g');
                let measures = [];
                
                allG.forEach(g => {
                    const id = g.getAttribute('id') || '';
                    const className = g.getAttribute('class') || '';
                    
                    if (id.includes('MeasureContent') || className.includes('measure')) {
                        measures.push(g);
                    }
                });
                
                console.log(`ğŸ“Š æ¸²æŸ“ç»“æœ: æ‰¾åˆ° ${measures.length} ä¸ªå°èŠ‚å…ƒç´ `);
                
                // åˆ†æå°èŠ‚ä½ç½®
                if (measures.length > 0) {
                    const positions = [];
                    measures.forEach((measure, i) => {
                        const bbox = measure.getBBox();
                        positions.push({
                            measure: i + 1,
                            x: Math.round(bbox.x),
                            y: Math.round(bbox.y)
                        });
                    });
                    
                    console.log('ğŸ“ å°èŠ‚ä½ç½®åˆ†æ:');
                    positions.forEach(pos => {
                        console.log(`  å°èŠ‚${pos.measure}: x=${pos.x}, y=${pos.y}`);
                    });
                }
            }
        }, 500);
        
    } catch (error) {
        console.error('âŒ ç®€åŒ–æµ‹è¯•å¤±è´¥:', error);
    }
}

// å°†è¿™äº›å‡½æ•°å¯¼å‡ºåˆ°å…¨å±€ï¼Œæ–¹ä¾¿åœ¨æ§åˆ¶å°è°ƒç”¨
window.testResponsiveLayouts = testResponsiveLayouts;
window.regenerateCurrentMelody = regenerateCurrentMelody;
window.force4MeasuresPerLine = force4MeasuresPerLine;
window.inspectOSMD = inspectOSMD;
window.testSimpleOSMD = testSimpleOSMD;
window.testKeySignatureHandling = testKeySignatureHandling;

/**
 * åŸºäºOSMDå›¾å½¢å±‚è¯»å–æ¯ä¸ªå°èŠ‚çš„åƒç´ çŸ©å½¢ï¼ˆç›¸å¯¹äº#scoreå®¹å™¨ï¼‰
 * è¿”å›: [{x,y,width,height}, ...] æˆ– null
 */
window.getOSMDMeasureRects = function(){
  try {
    if (typeof osmd === 'undefined' || !osmd) return null;
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return null;
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return null;
    const container = (svg && svg.parentElement) ? svg.parentElement : scoreDiv;
    const containerRect = container.getBoundingClientRect();
    const svgBBox = svg.getBoundingClientRect();
    const gs = osmd.GraphicSheet;
    const unitToPx = (osmd && osmd.EngravingRules && typeof osmd.EngravingRules.UnitInPixels === 'number')
      ? osmd.EngravingRules.UnitInPixels * (osmd.zoom || 1)
      : (10 * (osmd.zoom || 1));

    // èšåˆå™¨ï¼šæŒ‰å°èŠ‚åºå·åˆå¹¶å¤šè°±è¡¨çŸ©å½¢
    const byMeasure = new Map(); // num -> {minX,minY,maxX,maxY}

    function addMeasureBBox(measureObj){
      if (!measureObj) return;
      const ps = measureObj.PositionAndShape || measureObj.positionAndShape || measureObj.boundingBox || measureObj.BoundingBox;
      const abs = ps && (ps.AbsolutePosition || ps.absolutePosition || ps.Position || ps.position);
      const size = ps && (ps.Size || ps.size || ps.Extent || ps.extent);
      if (!abs || !size) return;
      const ax = (abs.x || abs.X || 0) * unitToPx;
      const ay = (abs.y || abs.Y || 0) * unitToPx;
      const aw = (size.width || size.X || size.x || 0) * unitToPx;
      const ah = (size.height || size.Y || size.y || 0) * unitToPx;
      if (!(aw > 0 && ah > 0)) return;
      // å–å°èŠ‚ç¼–å·ï¼ˆå¤šè·¯å¾„å…¼å®¹ï¼‰
      const pm = measureObj.ParentMeasure || measureObj.parentMeasure || measureObj.SourceMeasure || measureObj.sourceMeasure || measureObj;
      let num = pm && (pm.MeasureNumber || pm.measureNumber || pm.measure_no || pm.measureNo);
      if (typeof num === 'string') num = parseInt(num, 10);
      if (!isFinite(num)) return;
      // è½¬æ¢åˆ°SVGå±€éƒ¨åæ ‡ï¼ˆåƒç´ ï¼‰
      const relX = ax;
      const relY = ay;
      const minX = relX, minY = relY, maxX = relX + aw, maxY = relY + ah;
      const prev = byMeasure.get(num);
      if (!prev) byMeasure.set(num, { minX, minY, maxX, maxY });
      else {
        prev.minX = Math.min(prev.minX, minX);
        prev.minY = Math.min(prev.minY, minY);
        prev.maxX = Math.max(prev.maxX, maxX);
        prev.maxY = Math.max(prev.maxY, maxY);
      }
    }

    // 1) MeasureListï¼ˆè‹¥å¯ç”¨ï¼‰
    if (gs && Array.isArray(gs.MeasureList) && gs.MeasureList.length > 0){
      for (const gm of gs.MeasureList){ addMeasureBBox(gm); }
    }
    // 2) åå°„éå†å…¶å®ƒå®¹å™¨ä¸­çš„ GraphicalMeasures
    if (gs){
      const arrays = Object.keys(gs).map(k => gs[k]).filter(v => Array.isArray(v));
      for (const arr of arrays){
        for (const item of arr){
          const measures = item && (item.Measures || item.measures || item.GraphicalMeasures || item.graphicalMeasures || item.measuresInStaff || item.MeasuresInStaff);
          if (!measures || !Array.isArray(measures)) continue;
          for (const m of measures){ addMeasureBBox(m); }
        }
      }
    }

    if (byMeasure.size > 0){
      const nums = Array.from(byMeasure.keys()).sort((a,b)=>a-b);
      const rects = nums.map(n => {
        const b = byMeasure.get(n);
        return { x: b.minX, y: b.minY, width: Math.max(1, b.maxX - b.minX), height: Math.max(1, b.maxY - b.minY) };
      });
      return rects;
    }
  } catch(_) {}
  return null;
};

/**
 * ä» OSMD å›¾å½¢å±‚è¯»å–â€œå•å£°éƒ¨æ—‹å¾‹â€çš„éŸ³ç¬¦æ—¶é—´çº¿ä¸åƒç´ ä½ç½®ï¼ˆä»…éŸ³ç¬¦ï¼Œä¸å«ä¼‘æ­¢è·³ç‚¹ï¼‰ã€‚
 * è¿”å›ï¼š{
 *   events: [{ measure, absQN, durQN, x, y1, y2 }...],
 *   measureStarts: [QN...],
 *   measureTotals: [QN...]
 * }
 * è¯´æ˜ï¼š
 * - QN ä¸ºå››åˆ†éŸ³ç¬¦å•ä½ï¼ˆquarter-note unitsï¼‰
 * - x/y ä¸ºç›¸å¯¹SVGåƒç´ åæ ‡ï¼ˆä¸ getOSMDMeasureRects ä¸€è‡´ï¼‰
 * - åˆå¹¶è·¨å°èŠ‚ tieï¼Œåªåœ¨ç¬¬ä¸€ä¸ªéŸ³å¤´è¾“å‡ºäº‹ä»¶
 */
window.getOSMDNoteTimeline = function(){
  try{
    if (typeof osmd === 'undefined' || !osmd) return null;
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) return null;
    const svg = scoreDiv.querySelector('svg');
    if (!svg) return null;
    const gs = osmd.GraphicSheet;
    if (!gs) return null;
    const unitToPx = (osmd && osmd.EngravingRules && typeof osmd.EngravingRules.UnitInPixels === 'number')
      ? osmd.EngravingRules.UnitInPixels * (osmd.zoom || 1)
      : (10 * (osmd.zoom || 1));

    function fracToQN(fr){
      if (!fr) return null;
      const real = (fr.RealValue ?? fr.realValue);
      if (typeof real === 'number') return real * 4;
      const num = fr.Numerator ?? fr.numerator;
      const den = fr.Denominator ?? fr.denominator;
      if (typeof num === 'number' && typeof den === 'number' && den !== 0) return (num/den)*4;
      return null;
    }

    // è¯»å– MeasureListï¼ˆå•å£°éƒ¨æ—‹å¾‹ï¼‰
    const gMeasures = Array.isArray(gs.MeasureList) ? gs.MeasureList : [];
    const measureStarts = [];
    const measureTotals = [];
    // æå–æ¯å°èŠ‚çš„ç»å¯¹èµ·å§‹QNä¸å°èŠ‚é•¿åº¦QN
    for (let i=0;i<gMeasures.length;i++){
      const gm = gMeasures[i];
      const sm = (gm && (gm.ParentMeasure || gm.parentMeasure || gm.SourceMeasure || gm.sourceMeasure || (gm.measure && gm.measure.sourceMeasure))) || null;
      // ç»å¯¹æ—¶é—´æˆ³
      const absTs = sm && (sm.AbsoluteTimestamp || sm.absoluteTimestamp || sm.AbsoluteTimeStamp || sm.absoluteTimeStamp);
      const startQN = fracToQN(absTs) ?? (i>0 ? (measureStarts[i-1] + (measureTotals[i-1]||0)) : 0);
      measureStarts.push(startQN);
      // å°èŠ‚æ—¶é•¿ï¼šbeats/beatType
      let beats=4, beatType=4;
      try{
        const timeSig = sm && (sm.ActiveTimeSignature || sm.activeTimeSignature || sm.TimeSignature || sm.timeSignature);
        if (timeSig){
          const num = timeSig.Numerator ?? timeSig.numerator; if (typeof num==='number') beats = num;
          const den = timeSig.Denominator ?? timeSig.denominator; if (typeof den==='number') beatType = den;
        }
      }catch(_){ }
      const measQN = beats * (4/beatType);
      measureTotals.push(measQN);
    }

    // éå†æ¯å°èŠ‚çš„ StaffEntries â†’ GraphicalNotes
    const events = [];
    for (let mi=0; mi<gMeasures.length; mi++){
      const gm = gMeasures[mi];
      if (!gm) continue;
      // è¯»å–æœ¬å°èŠ‚çš„ GraphicalNotes å®¹å™¨ï¼ˆä¸åŒç‰ˆæœ¬å±æ€§åä¸åŒï¼Œå®½æ¾åŒ¹é…ï¼‰
      const allArrays = Object.values(gm).filter(v => Array.isArray(v));
      const staffEntries = [];
      for (const arr of allArrays){
        for (const it of arr){
          if (it && (it.graphicalNotes || it.GraphicalNotes || it.notes)) staffEntries.push(it);
        }
      }
      // Measure å‚ç›´ä½ç½®ä¾› y1/y2 è®¡ç®—
      let my = 0, mh = 0; try{
        const ps = gm.PositionAndShape || gm.positionAndShape || gm.boundingBox || gm.BoundingBox;
        const size = ps && (ps.Size || ps.size || ps.Extent || ps.extent);
        const abs = ps && (ps.AbsolutePosition || ps.absolutePosition || ps.Position || ps.position);
        if (size && abs){ my = (abs.y || abs.Y || 0) * unitToPx; mh = (size.height || size.y || size.Y || 0) * unitToPx; }
      }catch(_){ }

      // tie åˆå¹¶ï¼šç”¨ map è®°å½•æ­£åœ¨è¿›è¡Œçš„ tie é“¾ï¼ˆæŒ‰éŸ³é«˜ pitch ç®€åŒ–é”®å€¼ï¼‰
      const tieMap = new Map();
      // éå† staffEntries
      for (const se of staffEntries){
        const gNotes = (se.graphicalNotes || se.GraphicalNotes || se.notes || []);
        // å–å¾—è¯¥æ¡ç›®çš„ç›¸å¯¹/ç»å¯¹æ—¶é—´
        let relQN = 0, absQN = 0;
        try{
          const sse = se.parentStaffEntry || se.ParentStaffEntry || se.sourceStaffEntry || se.SourceStaffEntry || se;
          const relTs = sse && (sse.Timestamp || sse.timestamp || sse.RelativeTimestamp || sse.relativeTimestamp);
          const gm2 = se.ParentMeasure || se.parentMeasure || gm;
          const sm = gm2 && (gm2.ParentMeasure || gm2.parentMeasure || gm2.SourceMeasure || gm2.sourceMeasure || (gm2.measure && gm2.measure.sourceMeasure));
          const absTs = sm && (sm.AbsoluteTimestamp || sm.absoluteTimestamp || sm.AbsoluteTimeStamp || sm.absoluteTimeStamp);
          relQN = fracToQN(relTs) ?? 0;
          absQN = fracToQN(absTs) ?? (measureStarts[mi]||0);
        }catch(_){ absQN = measureStarts[mi]||0; relQN = 0; }
        const entryAbsQN = absQN + relQN;

        // ç®€åŒ–ï¼šå•å£°éƒ¨ï¼Œè‹¥ gNotes æœ‰å¤šä¸ªï¼Œå–æœ€å·¦ï¼ˆx æœ€å°ï¼‰ä¸€ä¸ªä½œä¸ºè·³åœç‚¹
        let picked = null; let minX = Infinity;
        for (const gn of gNotes){
          // ä¼‘æ­¢è·³è¿‡ï¼šGraphicalNote æºä¸º rest çš„å¯é€šè¿‡ sourceNote.Rest æˆ– sourceNote.isRest
          try{
            const sn = gn.sourceNote || gn.SourceNote;
            const isRest = !!(sn && (sn.Rest || sn.isRest));
            if (isRest) continue;
          }catch(_){ }
          const ps = gn.PositionAndShape || gn.positionAndShape || gn.boundingBox || gn.BoundingBox;
          const abs = ps && (ps.AbsolutePosition || ps.absolutePosition || ps.Position || ps.position);
          if (!abs) continue;
          const x = (abs.x || abs.X || 0) * unitToPx;
          if (x < minX){ minX = x; picked = gn; }
        }
        if (!picked) continue;
        // è¯»å–æ—¶å€¼ï¼ˆå››åˆ†æ‹å•ä½ï¼‰
        let durQN = 0; try{
          const sn = picked.sourceNote || picked.SourceNote;
          const len = sn && (sn.Length || sn.length);
          const lqn = fracToQN(len);
          if (typeof lqn === 'number') durQN = lqn;
        }catch(_){ }
        // tie åˆå¹¶ï¼šå¦‚æœè¯¥ note æ˜¯ tie çš„ä¸€éƒ¨åˆ†ï¼ŒæŒ‰ pitch èšåˆ
        let tied = false; try{
          const sn = picked.sourceNote || picked.SourceNote;
          const tie = sn && (sn.NoteTie || sn.noteTie || sn.Tie || sn.tie);
          // ç”¨ pitchï¼ˆæ­¥+å…«åº¦ï¼‰åšé”®
          const pitch = sn && sn.halfTone ? sn.halfTone : (sn && sn.Pitch ? (sn.Pitch.Fundamental || sn.Pitch.FundamentalNote || null) : null);
          const key = pitch != null ? String(pitch) : `${mi}:${entryAbsQN}`;
          const isTieStart = tie && (tie.StartNote || tie.startNote || tie.Start || tie.start);
          const isTieEnd = tie && (tie.EndNote || tie.endNote || tie.End || tie.end);
          if (isTieStart && !isTieEnd){
            tieMap.set(key, { startQN: entryAbsQN, durQN: durQN, x: minX, my, mh });
            tied = true;
          } else if (isTieEnd && tieMap.has(key)){
            const t = tieMap.get(key);
            t.durQN += durQN;
            // ç»“æŸæ—¶è¾“å‡ºåˆå¹¶åçš„äº‹ä»¶
            const y1 = t.my + t.mh * 0.05; const y2 = y1 + Math.max(2, t.mh*0.9);
            events.push({ measure: mi, absQN: t.startQN, durQN: t.durQN, x: Math.max(0, t.x - 10), y1, y2 });
            tieMap.delete(key);
            tied = true;
          }
        }catch(_){ }
        if (tied) continue;
        const y1 = my + mh * 0.05; const y2 = y1 + Math.max(2, mh*0.9);
        events.push({ measure: mi, absQN: entryAbsQN, durQN: durQN, x: Math.max(0, minX - 10), y1, y2 });
      }
    }
    return { events, measureStarts, measureTotals };
  } catch(_){ return null; }
};

/**
 * ç”ŸæˆGå¤§è°ƒçš„æµ‹è¯•XMLï¼Œç›´æ¥æµ‹è¯•OSMDçš„æ¸²æŸ“
 */
function testGMajorXML() {
    console.log('\nğŸµ ç”ŸæˆGå¤§è°ƒæµ‹è¯•XML...');
    
    const testXML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <part-list>
    <score-part id="P1">
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>4</divisions>
        <key>
          <fifths>1</fifths>
          <mode>major</mode>
        </key>
        <time>
          <beats>4</beats>
          <beat-type>4</beat-type>
        </time>
        <clef>
          <sign>G</sign>
          <line>2</line>
        </clef>
      </attributes>
      <!-- F# ä¸å¸¦alteræ ‡ç­¾ï¼ˆåº”è¯¥æ˜¾ç¤ºä¸ºF#ï¼‰ -->
      <note>
        <pitch>
          <step>F</step>
          <octave>5</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
      </note>
      <!-- Fè‡ªç„¶éŸ³å¸¦alter=0ï¼ˆåº”è¯¥æ˜¾ç¤ºè¿˜åŸè®°å·ï¼‰ -->
      <note>
        <pitch>
          <step>F</step>
          <alter>0</alter>
          <octave>5</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
        <accidental>natural</accidental>
      </note>
      <!-- Gè‡ªç„¶éŸ³ -->
      <note>
        <pitch>
          <step>G</step>
          <octave>5</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
      </note>
      <!-- Aè‡ªç„¶éŸ³ -->
      <note>
        <pitch>
          <step>A</step>
          <octave>5</octave>
        </pitch>
        <duration>4</duration>
        <type>quarter</type>
      </note>
    </measure>
  </part>
</score-partwise>`;
    
    console.log('æµ‹è¯•XMLå·²ç”Ÿæˆï¼ŒåŒ…å«ï¼š');
    console.log('1. Fä¸å¸¦alterï¼ˆåº”æ˜¾ç¤ºF#ï¼‰');
    console.log('2. Få¸¦alter=0ï¼ˆåº”æ˜¾ç¤ºFâ™®ï¼‰');
    console.log('3. Gå’ŒAï¼ˆè‡ªç„¶éŸ³ï¼‰');
    
    // æ¸²æŸ“æµ‹è¯•XML
    renderMelodyWithOSMD(testXML);
    
    return testXML;
}

window.testGMajorXML = testGMajorXML;

/**
 * è°ƒè¯•ï¼šæ£€æŸ¥å½“å‰æ¸²æŸ“çš„å†…å®¹
 */
function debugCurrentScore() {
    const scoreDiv = document.getElementById('score');
    if (!scoreDiv) {
        console.log('âŒ æ‰¾ä¸åˆ°scoreå…ƒç´ ');
        return;
    }
    
    // æŸ¥æ‰¾æ‰€æœ‰éŸ³ç¬¦
    const notes = scoreDiv.querySelectorAll('.vf-stavenote');
    console.log(`\nğŸµ å½“å‰ä¹è°±åŒ…å« ${notes.length} ä¸ªéŸ³ç¬¦`);
    
    // æŸ¥æ‰¾æ‰€æœ‰å‡é™å·
    const accidentals = scoreDiv.querySelectorAll('.vf-accidental');
    console.log(`ğŸµ åŒ…å« ${accidentals.length} ä¸ªä¸´æ—¶è®°å·`);
    
    // æŸ¥æ‰¾è°ƒå·
    const keySignatures = scoreDiv.querySelectorAll('.vf-keysignature');
    console.log(`ğŸµ åŒ…å« ${keySignatures.length} ä¸ªè°ƒå·æ ‡è®°`);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¿˜åŸè®°å·
    const naturals = Array.from(scoreDiv.querySelectorAll('*')).filter(el => {
        const text = el.textContent || '';
        const className = typeof el.className === 'string' ? el.className : '';
        return text.includes('â™®') || className.includes('natural');
    });
    
    if (naturals.length > 0) {
        console.warn(`âš ï¸ å‘ç° ${naturals.length} ä¸ªè¿˜åŸè®°å·ï¼`);
    }
    
    // è¾“å‡ºå®é™…çš„SVGå†…å®¹ç‰‡æ®µ
    const svg = scoreDiv.querySelector('svg');
    if (svg) {
        const svgContent = svg.outerHTML.substring(0, 500);
        console.log('SVGå†…å®¹é¢„è§ˆ:', svgContent);
    }
}

window.debugCurrentScore = debugCurrentScore;

/**
 * æµ‹è¯•Gå¤§è°ƒä¿®å¤æ•ˆæœ
 */
function testGMajorFix() {
    console.log('\nğŸ§ª === æµ‹è¯•Gå¤§è°ƒä¿®å¤ ===');
    
    // åˆ›å»ºä¸€ä¸ªåŒ…å«F#çš„Gå¤§è°ƒéŸ³é˜¶
    const testMelody = [
        { midi: 67, duration: { beats: 1 } }, // G4
        { midi: 69, duration: { beats: 1 } }, // A4
        { midi: 71, duration: { beats: 1 } }, // B4
        { midi: 72, duration: { beats: 1 } }, // C5
        { midi: 74, duration: { beats: 1 } }, // D5
        { midi: 76, duration: { beats: 1 } }, // E5
        { midi: 78, duration: { beats: 1 } }, // F#5 (å…³é”®æµ‹è¯•ç‚¹)
        { midi: 79, duration: { beats: 1 } }, // G5
    ];
    
    const generator = new IntelligentMelodyGenerator(2, 'G', '4/4', 'treble', 12345);
    
    console.log('ğŸµ Gå¤§è°ƒéŸ³é˜¶MIDIè½¬æ¢æµ‹è¯•:');
    testMelody.forEach((note, i) => {
        const result = generator.midiToMusicXML(note.midi);
        const noteStr = `${result.step}${result.alter === 1 ? '#' : result.alter === -1 ? 'b' : ''}${result.octave}`;
        console.log(`  ${i+1}. MIDI ${note.midi} -> ${noteStr}, alter=${result.alter === undefined ? 'undefined(è‡ªç„¶éŸ³)' : result.alter}`);
    });
    
    // æ„å»ºå®Œæ•´MusicXML
    const builder = new MusicXMLBuilder(testMelody, {
        measures: 2,
        keySignature: 'G',
        timeSignature: '4/4',
        clef: 'treble'
    });
    
    const xml = builder.build(4);
    
    // åˆ†æXMLä¸­çš„FéŸ³ç¬¦å¤„ç†
    console.log('\nğŸ“„ XMLåˆ†æ:');
    const fNoteRegex = /<step>F<\/step>[\s\S]*?(?:<\/note>)/g;
    const fNotes = xml.match(fNoteRegex) || [];
    
    if (fNotes.length > 0) {
        fNotes.forEach((fNote, i) => {
            const hasAlter = fNote.includes('<alter>1</alter>');
            console.log(`  FéŸ³ç¬¦${i+1}: ${hasAlter ? 'âœ… åŒ…å«alter=1(F#)' : 'âŒ ç¼ºå°‘alteræ ‡ç­¾'}`);
        });
    } else {
        console.log('  æœªæ‰¾åˆ°FéŸ³ç¬¦');
    }
    
    // æ¸²æŸ“åˆ°é¡µé¢
    console.log('\nğŸ¨ æ¸²æŸ“æµ‹è¯•æ—‹å¾‹...');
    renderScore({
        musicXML: xml,
        stats: { noteCount: 8, restCount: 0 },
        config: { measures: 2, keySignature: 'G', timeSignature: '4/4', clef: 'treble' }
    });
    
    // å»¶è¿Ÿæ£€æŸ¥æ¸²æŸ“ç»“æœ
    setTimeout(() => {
        console.log('\nğŸ” æ£€æŸ¥OSMDæ¸²æŸ“ç»“æœ...');
        debugCurrentScore();
    }, 1000);
    
    console.log('\nâœ… æµ‹è¯•å®Œæˆï¼è¯·æ£€æŸ¥F#æ˜¯å¦æ­£ç¡®æ˜¾ç¤ºï¼ˆä¸åº”æœ‰è¿˜åŸè®°å·ï¼‰');
}

window.testGMajorFix = testGMajorFix;

/**
 * æç®€ç‰ˆï¼šå¼ºåˆ¶4å°èŠ‚æ¯è¡Œ
 */
async function forceFixedMeasuresLayout() {
    console.log('\nğŸ”§ === åº”ç”¨å¼ºåŠ›å¤šå°èŠ‚å¸ƒå±€ ===');
    
    if (!osmd) {
        console.error('âŒ è¯·å…ˆç”Ÿæˆæ—‹å¾‹');
        return;
    }
    
    const scoreDiv = document.getElementById('score');
    const containerWidth = scoreDiv ? scoreDiv.clientWidth : 800;
    
    // è·å–æ€»å°èŠ‚æ•°
    const totalMeasures = osmd.GraphicSheet ? osmd.GraphicSheet.MeasureList.length : 4;
    console.log(`ğŸ“Š æ£€æµ‹åˆ° ${totalMeasures} ä¸ªå°èŠ‚`);
    
    // å¼ºåŠ›è®¾ç½®å¤šå°èŠ‚æ¯è¡Œ
    if (totalMeasures === 2) {
        osmd.EngravingRules.MaxMeasuresPerSystem = 2;
        osmd.EngravingRules.MinMeasuresPerSystem = 2;
        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = 2;
    } else {
        osmd.EngravingRules.MaxMeasuresPerSystem = 4;
        osmd.EngravingRules.MinMeasuresPerSystem = Math.min(4, totalMeasures);
        osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem = 4;
    }
    
    // å¯ç”¨XMLæ¢è¡Œ
    osmd.EngravingRules.NewSystemFromXMLNewSystemAttribute = true;  // å¯ç”¨MusicXMLæ¢è¡Œæ ‡è®°
    osmd.EngravingRules.NewSystemAtXMLNewSystemAttribute = true;  // å¯ç”¨MusicXMLæ¢è¡Œæ ‡è®°
    osmd.EngravingRules.NewSystemAtXMLNewSystem = true;  // å¯ç”¨<print new-system="yes"/>æ ‡è®°
    
    // è®¡ç®—å®½åº¦
    osmd.EngravingRules.FixedMeasureWidth = true;
    const zoom = 0.7;
    const padding = 40;
    const effectiveWidth = (containerWidth - padding) / zoom;
    const maxMeasuresPerLine = totalMeasures === 2 ? 2 : 4;
    const measureWidth = Math.floor(effectiveWidth / maxMeasuresPerLine * 0.85);
    
    osmd.EngravingRules.FixedMeasureWidthFixedValue = measureWidth;
    osmd.zoom = zoom;
    
    // è®¾ç½®è¾¹è·
    osmd.EngravingRules.PageLeftMargin = 2;
    osmd.EngravingRules.PageRightMargin = 2;
    osmd.EngravingRules.SystemLeftMargin = 1;
    osmd.EngravingRules.SystemRightMargin = 1;
    osmd.EngravingRules.SystemDistance = 8;
    
    // é‡æ–°æ¸²æŸ“
    osmd.render();
    console.log(`âœ… å¼ºåŠ›å¸ƒå±€åº”ç”¨: æ¯è¡Œ${maxMeasuresPerLine}å°èŠ‚ï¼Œç¦ç”¨XMLæ¢è¡Œ`);
}

window.forceFixedMeasuresLayout = forceFixedMeasuresLayout;

/**
 * è°ƒè¯•å‡½æ•°ï¼šæ£€æŸ¥OSMDå½“å‰è®¾ç½®
 */
function debugOSMDSettings() {
    console.log('\nğŸ” === OSMDå½“å‰è®¾ç½® ===');
    if (!osmd) {
        console.error('âŒ OSMDæœªåˆå§‹åŒ–');
        return;
    }
    
    if (osmd.EngravingRules) {
        console.log('ğŸ“‹ EngravingRulesè®¾ç½®:');
        console.log(`   - RenderXMeasuresPerLineAkaSystem: ${osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem}`);
        console.log(`   - FixedMeasureWidth: ${osmd.EngravingRules.FixedMeasureWidth}`);
        console.log(`   - FixedMeasureWidthFixedValue: ${osmd.EngravingRules.FixedMeasureWidthFixedValue}`);
        console.log(`   - PageLeftMargin: ${osmd.EngravingRules.PageLeftMargin}`);
        console.log(`   - PageRightMargin: ${osmd.EngravingRules.PageRightMargin}`);
        console.log(`   - SystemLeftMargin: ${osmd.EngravingRules.SystemLeftMargin}`);
        console.log(`   - SystemRightMargin: ${osmd.EngravingRules.SystemRightMargin}`);
    }
    
    console.log(`ğŸ“ Zoom: ${osmd.zoom}`);
    
    if (osmd.GraphicSheet && osmd.GraphicSheet.MeasureList) {
        console.log(`ğŸ“Š æ€»å°èŠ‚æ•°: ${osmd.GraphicSheet.MeasureList.length}`);
    }
}

window.debugOSMDSettings = debugOSMDSettings;

/**
 * åˆ›å»ºä¸€ä¸ªå®Œå…¨è‡ªå®šä¹‰çš„4å°èŠ‚å¸ƒå±€æµ‹è¯•
 */
async function test4MeasuresLayout() {
    console.log('\nğŸ§ª === æµ‹è¯•4å°èŠ‚å¸ƒå±€ ===');
    
    // ç”Ÿæˆä¸€ä¸ª16å°èŠ‚çš„æµ‹è¯•æ—‹å¾‹ï¼ˆåº”è¯¥æ˜¾ç¤ºä¸º4è¡Œï¼‰
    const testMelodyData = generateMelodyData(16, 'C', '4/4', 'treble', 99999);
    
    console.log('ğŸ“ ç”Ÿæˆ16å°èŠ‚æµ‹è¯•æ—‹å¾‹...');
    
    // æ¸²æŸ“
    await renderScore(testMelodyData);
    
    // ç­‰å¾…æ¸²æŸ“å®Œæˆåæ£€æŸ¥
    setTimeout(async () => {
        console.log('\nğŸ” æ£€æŸ¥å¸ƒå±€ç»“æœ...');
        const scoreDiv = document.getElementById('score');
        const svg = scoreDiv.querySelector('svg');
        
        if (svg) {
            // åˆ†æSVGç»“æ„
            const gElements = svg.querySelectorAll('g');
            let measureCount = 0;
            let systemCount = 0;
            
            gElements.forEach(g => {
                const id = g.getAttribute('id') || '';
                const className = g.getAttribute('class') || '';
                
                if (id.includes('measure') || className.includes('measure')) {
                    measureCount++;
                }
                if (id.includes('system') || className.includes('system')) {
                    systemCount++;
                }
            });
            
            console.log(`âœ… å¸ƒå±€åˆ†æ:`);
            console.log(`   - æ€»å°èŠ‚æ•°: ${measureCount}`);
            console.log(`   - ç³»ç»Ÿ(è¡Œ)æ•°: ${systemCount}`);
            console.log(`   - é¢„æœŸ: 16å°èŠ‚åˆ†ä¸º4è¡Œï¼Œæ¯è¡Œ4å°èŠ‚`);
            
            // è·å–ç¬¬ä¸€è¡Œçš„å°èŠ‚ä½ç½®
            const firstLineMeasures = [];
            let currentY = null;
            
            gElements.forEach(g => {
                if (g.getAttribute('id')?.includes('measure')) {
                    const transform = g.getAttribute('transform');
                    if (transform) {
                        const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
                        if (match) {
                            const y = parseFloat(match[2]);
                            if (currentY === null) currentY = y;
                            
                            if (Math.abs(y - currentY) < 10) {
                                firstLineMeasures.push(g);
                            }
                        }
                    }
                }
            });
            
            console.log(`   - ç¬¬ä¸€è¡Œå°èŠ‚æ•°: ${firstLineMeasures.length}`);
            
            if (firstLineMeasures.length !== 4) {
                console.warn('âš ï¸ ç¬¬ä¸€è¡Œä¸æ˜¯4ä¸ªå°èŠ‚ï¼Œå°è¯•å¼ºåˆ¶ä¿®å¤...');
                await forceFixedMeasuresLayout();
            } else {
                console.log('âœ… å¸ƒå±€æ­£ç¡®ï¼šæ¯è¡Œ4å°èŠ‚');
            }
        }
    }, 1000);
}

window.test4MeasuresLayout = test4MeasuresLayout;

// å¯¼å‡ºä¸»è¦åŠŸèƒ½å‡½æ•°åˆ°å…¨å±€ï¼Œä¿®å¤æŒ‰é’®æ— å“åº”é—®é¢˜
window.generateMelody = generateMelody;
window.previousMelody = previousMelody;
window.nextMelody = nextMelody;
window.regenerateSameSeed = regenerateSameSeed;
window.updateMinNote = updateMinNote;
window.updateMaxNote = updateMaxNote;
window.updateMaxInterval = updateMaxInterval;
window.updateAccidentalRate = updateAccidentalRate;

// å¯¼å‡ºå¼¹çª—ç›¸å…³å‡½æ•°
window.openRhythmSettings = openRhythmSettings;
window.closeRhythmSettings = closeRhythmSettings;
window.saveRhythmSettings = saveRhythmSettings;
window.openArticulationSettings = openArticulationSettings;
window.closeArticulationSettings = closeArticulationSettings;
window.saveArticulationSettings = saveArticulationSettings;
window.selectAllBasicArticulations = selectAllBasicArticulations;
window.selectAllGuitarTechniques = selectAllGuitarTechniques;
window.selectAllRhythms = selectAllRhythms;
// é«˜çº§è®¾ç½®ç›¸å…³å‡½æ•°
window.toggleRhythmAdvancedSettings = toggleRhythmAdvancedSettings;
window.resetRhythmFrequencies = resetRhythmFrequencies;
window.testAccidentalGeneration = testAccidentalGeneration;
window.debugAddAccidental = debugAddAccidental;

// ğŸ§ª éªŒè¯ä¿®å¤çš„æµ‹è¯•å‡½æ•°
window.testScreenDimensions = function() {
    console.log('ğŸ§ª æµ‹è¯•å±å¹•å°ºå¯¸è·å–:');
    console.log(`  - window.innerWidth: ${window.innerWidth}`);
    console.log(`  - window.innerHeight: ${window.innerHeight}`);
    console.log('âœ… å±å¹•å°ºå¯¸è·å–æ­£å¸¸');
};

window.testGenerateMelodyExists = function() {
    console.log('ğŸ§ª æµ‹è¯•generateMelodyå‡½æ•°å­˜åœ¨æ€§:');
    console.log(`  - typeof generateMelody: ${typeof generateMelody}`);
    console.log(`  - typeof window.generateMelody: ${typeof window.generateMelody}`);
    if (typeof generateMelody === 'function') {
        console.log('âœ… generateMelodyå‡½æ•°å­˜åœ¨ä¸”å¯ç”¨');
    } else {
        console.log('âŒ generateMelodyå‡½æ•°ä¸å­˜åœ¨');
    }
};

// ğŸ” æ·±åº¦è°ƒè¯•ä¸´æ—¶è®°å·ç”Ÿæˆ
window.deepDebugAccidentals = function() {
    console.log('\nğŸ” æ·±åº¦è°ƒè¯•ä¸´æ—¶è®°å·ç”Ÿæˆé€»è¾‘');

    // æµ‹è¯•å…³é”®è°ƒå·å’ŒéŸ³ç¬¦ç»„åˆ
    const testCases = [
        { keySignature: 'C', midi: 60, noteName: 'C' },      // Cå¤§è°ƒä¸­çš„C
        { keySignature: 'C', midi: 62, noteName: 'D' },      // Cå¤§è°ƒä¸­çš„D
        { keySignature: 'G', midi: 62, noteName: 'D' },      // Gå¤§è°ƒä¸­çš„D
        { keySignature: 'F', midi: 62, noteName: 'D' },      // Få¤§è°ƒä¸­çš„D
        { keySignature: 'Bb', midi: 62, noteName: 'D' },     // Bbå¤§è°ƒä¸­çš„D
    ];

    testCases.forEach(testCase => {
        console.log(`\nğŸ“ æµ‹è¯•: ${testCase.keySignature}å¤§è°ƒä¸­çš„${testCase.noteName}éŸ³ç¬¦ (MIDI ${testCase.midi})`);

        const generator = new IntelligentMelodyGenerator(1, testCase.keySignature, '4/4', 'treble', 12345);
        generator.rules = {
            range: { min: 60, max: 79 },
            accidentalRate: 1.0,
            maxJump: 12
        };

        // æµ‹è¯•å¤šæ¬¡ç”Ÿæˆ
        const results = [];
        for (let i = 0; i < 20; i++) {
            const result = generator.addAccidental(testCase.midi);
            results.push(result);
        }

        // ç»Ÿè®¡ç»“æœ
        const sharps = results.filter(r => r === testCase.midi + 1).length;
        const flats = results.filter(r => r === testCase.midi - 1).length;
        const unchanged = results.filter(r => r === testCase.midi).length;

        console.log(`  ç»“æœç»Ÿè®¡ï¼ˆ20æ¬¡ç”Ÿæˆï¼‰:`);
        console.log(`    å‡å·: ${sharps}æ¬¡ (${(sharps/20*100).toFixed(1)}%)`);
        console.log(`    é™å·: ${flats}æ¬¡ (${(flats/20*100).toFixed(1)}%)`);
        console.log(`    æ— å˜åŒ–: ${unchanged}æ¬¡ (${(unchanged/20*100).toFixed(1)}%)`);

        if (sharps === 0) console.log(`    âŒ å‡å·ç”Ÿæˆè¢«é˜»æ­¢`);
        if (flats === 0) console.log(`    âŒ é™å·ç”Ÿæˆè¢«é˜»æ­¢`);
        if (sharps > 0 && flats > 0) console.log(`    âœ… å‡é™å·éƒ½èƒ½ç”Ÿæˆ`);
    });

    console.log('\nğŸ” æ·±åº¦è°ƒè¯•å®Œæˆ');
};

// ğŸ¯ ä¸“é—¨æµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„é—®é¢˜
window.testUserReportedIssue = function() {
    console.log('\nğŸ¯ æµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„ä¸´æ—¶è®°å·é—®é¢˜');

    // åˆ›å»ºç®€åŒ–çš„æµ‹è¯•å‡½æ•°
    function testAccidentalInKey(keySignature, testMidi, noteName) {
        console.log(`\nğŸ“ æµ‹è¯• ${keySignature}å¤§è°ƒä¸­çš„${noteName}éŸ³ç¬¦ (MIDI ${testMidi})`);

        const keyInfo = KEY_SIGNATURES[keySignature];
        const noteClass = testMidi % 12;
        const originalKeyInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

        console.log(`  è°ƒå·ä¿¡æ¯: å‡${keyInfo.sharps.length}ä¸ª, é™${keyInfo.flats.length}ä¸ª`);
        console.log(`  åŸéŸ³ç¬¦å½±å“: ${JSON.stringify(originalKeyInfo)}`);

        // æµ‹è¯•å‡å·
        const sharpNote = testMidi + 1;
        const sharpNoteClass = sharpNote % 12;
        const sharpKeyInfo = isNoteAffectedByKeySignature(sharpNoteClass, keySignature);
        const canAddSharp = !sharpKeyInfo.isFlat;

        console.log(`  å‡å·æµ‹è¯•: ${testMidi} â†’ ${sharpNote} (ç±»åˆ«${sharpNoteClass})`);
        console.log(`    å‡å·éŸ³ç¬¦è¢«è°ƒå·å½±å“: ${JSON.stringify(sharpKeyInfo)}`);
        console.log(`    å¯ä»¥æ·»åŠ å‡å·: ${canAddSharp}`);

        // æµ‹è¯•é™å·
        const flatNote = testMidi - 1;
        const flatNoteClass = flatNote % 12;
        const flatKeyInfo = isNoteAffectedByKeySignature(flatNoteClass, keySignature);
        const canAddFlat = !flatKeyInfo.isSharp;

        console.log(`  é™å·æµ‹è¯•: ${testMidi} â†’ ${flatNote} (ç±»åˆ«${flatNoteClass})`);
        console.log(`    é™å·éŸ³ç¬¦è¢«è°ƒå·å½±å“: ${JSON.stringify(flatKeyInfo)}`);
        console.log(`    å¯ä»¥æ·»åŠ é™å·: ${canAddFlat}`);

        // ç»“è®º
        if (canAddSharp && canAddFlat) {
            console.log(`  âœ… ç»“è®º: å‡å·å’Œé™å·éƒ½å¯ä»¥ç”Ÿæˆ`);
        } else if (canAddSharp && !canAddFlat) {
            console.log(`  âŒ ç»“è®º: åªèƒ½ç”Ÿæˆå‡å·ï¼Œä¸èƒ½ç”Ÿæˆé™å·`);
        } else if (!canAddSharp && canAddFlat) {
            console.log(`  âŒ ç»“è®º: åªèƒ½ç”Ÿæˆé™å·ï¼Œä¸èƒ½ç”Ÿæˆå‡å·`);
        } else {
            console.log(`  âŒ ç»“è®º: å‡å·å’Œé™å·éƒ½ä¸èƒ½ç”Ÿæˆ`);
        }

        return { canAddSharp, canAddFlat };
    }

    // æµ‹è¯•ç”¨æˆ·æè¿°çš„å…·ä½“åœºæ™¯
    console.log('\n=== æµ‹è¯•Cå¤§è°ƒï¼ˆæ— å‡é™å·ï¼‰===');
    testAccidentalInKey('C', 60, 'C');  // CéŸ³ç¬¦
    testAccidentalInKey('C', 62, 'D');  // DéŸ³ç¬¦

    console.log('\n=== æµ‹è¯•Gå¤§è°ƒï¼ˆå‡è®°å·è°ƒå·ï¼‰===');
    testAccidentalInKey('G', 60, 'C');  // CéŸ³ç¬¦
    testAccidentalInKey('G', 62, 'D');  // DéŸ³ç¬¦

    console.log('\n=== æµ‹è¯•Få¤§è°ƒï¼ˆé™è®°å·è°ƒå·ï¼‰===');
    testAccidentalInKey('F', 60, 'C');  // CéŸ³ç¬¦
    testAccidentalInKey('F', 62, 'D');  // DéŸ³ç¬¦

    console.log('\nğŸ¯ ç”¨æˆ·é—®é¢˜æµ‹è¯•å®Œæˆ');
};

// ğŸ” éŸ³ç¬¦ç±»åˆ«å¯¹åº”è¡¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰
window.showNoteClassMapping = function() {
    console.log('\nğŸµ MIDIéŸ³ç¬¦ç±»åˆ«å¯¹åº”è¡¨:');
    const noteNames = ['C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G', 'G#/Ab', 'A', 'A#/Bb', 'B'];
    for (let i = 0; i < 12; i++) {
        console.log(`  ç±»åˆ« ${i}: ${noteNames[i]}`);
    }

    console.log('\nğŸ“Š é‡è¦è°ƒå·çš„å‡é™å·ç±»åˆ«:');
    console.log('  Cå¤§è°ƒ: æ— å‡é™å·');
    console.log('  Gå¤§è°ƒ: F# (ç±»åˆ«6)');
    console.log('  Få¤§è°ƒ: Bb (ç±»åˆ«10)');
};

// ğŸ§ª æµ‹è¯•ä¿®å¤åçš„ä¸´æ—¶è®°å·ç”Ÿæˆæ˜¯å¦è¿˜æœ‰ä¼˜å…ˆæƒé—®é¢˜
window.testAccidentalPriority = function() {
    console.log('\nğŸ”¬=== ä¸´æ—¶è®°å·ä¼˜å…ˆæƒæµ‹è¯• ===');

    function testKeySignature(keySignature, testMidi, testName) {
        console.log(`\nğŸ“‹ æµ‹è¯•è°ƒå·: ${keySignature}å¤§è°ƒï¼ŒéŸ³ç¬¦: ${testName} (MIDI ${testMidi})`);

        // 4/4æ‹æµ‹è¯•
        const generator44 = new IntelligentMelodyGenerator(1, keySignature, '4/4', 'treble', Date.now());
        generator44.rules = {
            range: { min: 48, max: 84 },
            accidentalRate: 1.0,
            maxJump: 12
        };

        const results44 = { sharps: 0, flats: 0, unchanged: 0 };
        const totalTests = 100;

        for (let i = 0; i < totalTests; i++) {
            const result = generator44.addAccidental(testMidi);
            if (result === testMidi + 1) results44.sharps++;
            else if (result === testMidi - 1) results44.flats++;
            else results44.unchanged++;
        }

        console.log(`  ğŸ¼ 4/4æ‹ ${totalTests}æ¬¡æµ‹è¯•:`);
        console.log(`    å‡å·: ${results44.sharps}æ¬¡ (${(results44.sharps/totalTests*100).toFixed(1)}%)`);
        console.log(`    é™å·: ${results44.flats}æ¬¡ (${(results44.flats/totalTests*100).toFixed(1)}%)`);
        console.log(`    æ— å˜åŒ–: ${results44.unchanged}æ¬¡ (${(results44.unchanged/totalTests*100).toFixed(1)}%)`);

        // åˆ†ææ˜¯å¦æœ‰æ˜æ˜¾åå‘
        const ratio = results44.sharps / (results44.flats || 1);
        if (ratio > 2) {
            console.log(`    âš ï¸  æ˜æ˜¾åå‘å‡å· (æ¯”ä¾‹ ${ratio.toFixed(1)}:1)`);
        } else if (ratio < 0.5) {
            console.log(`    âš ï¸  æ˜æ˜¾åå‘é™å· (æ¯”ä¾‹ 1:${(1/ratio).toFixed(1)})`);
        } else if (results44.sharps > 0 && results44.flats > 0) {
            console.log(`    âœ… å‡é™å·åˆ†å¸ƒæ­£å¸¸ (æ¯”ä¾‹ ${ratio.toFixed(1)}:1)`);
        }

        return { ratio, total: results44.sharps + results44.flats };
    }

    // æµ‹è¯•ä¸åŒè°ƒå·
    const results = [];

    // Cå¤§è°ƒï¼ˆæ— å‡é™å·ï¼‰
    results.push({ key: 'C', ...testKeySignature('C', 60, 'CéŸ³ç¬¦') });
    results.push({ key: 'C', ...testKeySignature('C', 62, 'DéŸ³ç¬¦') });

    // Gå¤§è°ƒï¼ˆå‡è®°å·è°ƒå·ï¼‰
    results.push({ key: 'G', ...testKeySignature('G', 60, 'CéŸ³ç¬¦') });
    results.push({ key: 'G', ...testKeySignature('G', 62, 'DéŸ³ç¬¦') });

    // Få¤§è°ƒï¼ˆé™è®°å·è°ƒå·ï¼‰
    results.push({ key: 'F', ...testKeySignature('F', 60, 'CéŸ³ç¬¦') });
    results.push({ key: 'F', ...testKeySignature('F', 62, 'DéŸ³ç¬¦') });

    // æ€»ç»“åˆ†æ
    console.log('\nğŸ“Š === ä¼˜å…ˆæƒåˆ†ææ€»ç»“ ===');
    const sharpKeys = results.filter(r => r.key === 'G');
    const flatKeys = results.filter(r => r.key === 'F');
    const neutralKeys = results.filter(r => r.key === 'C');

    const avgSharpKeyRatio = sharpKeys.reduce((sum, r) => sum + r.ratio, 0) / sharpKeys.length;
    const avgFlatKeyRatio = flatKeys.reduce((sum, r) => sum + r.ratio, 0) / flatKeys.length;
    const avgNeutralRatio = neutralKeys.reduce((sum, r) => sum + r.ratio, 0) / neutralKeys.length;

    console.log(`å‡è®°å·è°ƒå·å¹³å‡æ¯”ä¾‹: ${avgSharpKeyRatio.toFixed(2)}:1`);
    console.log(`é™è®°å·è°ƒå·å¹³å‡æ¯”ä¾‹: ${avgFlatKeyRatio.toFixed(2)}:1`);
    console.log(`ä¸­æ€§è°ƒå·å¹³å‡æ¯”ä¾‹: ${avgNeutralRatio.toFixed(2)}:1`);

    if (avgSharpKeyRatio > 1.5) {
        console.log(`âŒ å‘ç°é—®é¢˜: å‡è®°å·è°ƒå·ä¸­å‡å·æœ‰æ˜æ˜¾ä¼˜å…ˆæƒ!`);
    }
    if (avgFlatKeyRatio < 0.67) {
        console.log(`âŒ å‘ç°é—®é¢˜: é™è®°å·è°ƒå·ä¸­é™å·æœ‰æ˜æ˜¾ä¼˜å…ˆæƒ!`);
    }
    if (Math.abs(avgNeutralRatio - 1) > 0.3) {
        console.log(`âŒ å‘ç°é—®é¢˜: ä¸­æ€§è°ƒå·ä¸­é€‰æ‹©ä¸å‡åŒ€!`);
    }

    console.log('\nğŸ” æµ‹è¯•å®Œæˆ');
};

// ğŸš€ ç«‹å³æ‰§è¡Œå¿«é€ŸéªŒè¯æµ‹è¯•
window.quickAccidentalTest = function() {
    console.log('\nğŸš€=== å¿«é€Ÿä¸´æ—¶è®°å·éªŒè¯æµ‹è¯• ===');

    try {
        // æµ‹è¯•4/4æ‹ç”Ÿæˆå™¨
        const gen44 = new IntelligentMelodyGenerator(1, 'G', '4/4', 'treble', 12345);
        gen44.rules = { range: { min: 48, max: 84 }, accidentalRate: 1.0, maxJump: 12 };

        // æµ‹è¯•CéŸ³ç¬¦(MIDI 60)åœ¨Gå¤§è°ƒä¸­çš„ä¸´æ—¶è®°å·ç”Ÿæˆ
        console.log('\nğŸ“ æµ‹è¯•Gå¤§è°ƒä¸­CéŸ³ç¬¦çš„ä¸´æ—¶è®°å·ç”Ÿæˆ:');
        const results = { sharps: 0, flats: 0, unchanged: 0 };

        for (let i = 0; i < 20; i++) {
            const result = gen44.addAccidental(60);
            if (result === 61) results.sharps++;      // C#
            else if (result === 59) results.flats++;  // Cb
            else results.unchanged++;
        }

        console.log(`  å‡å·(C#): ${results.sharps}æ¬¡`);
        console.log(`  é™å·(Cb): ${results.flats}æ¬¡`);
        console.log(`  æ— å˜åŒ–: ${results.unchanged}æ¬¡`);

        if (results.sharps > 0 && results.flats > 0) {
            console.log('  âœ… æˆåŠŸ: å‡å·å’Œé™å·éƒ½èƒ½ç”Ÿæˆ!');
            return true;
        } else if (results.sharps > 0 && results.flats === 0) {
            console.log('  âŒ é—®é¢˜ä»å­˜åœ¨: åªèƒ½ç”Ÿæˆå‡å·ï¼Œæ— æ³•ç”Ÿæˆé™å·');
            return false;
        } else if (results.sharps === 0 && results.flats > 0) {
            console.log('  âŒ é—®é¢˜ä»å­˜åœ¨: åªèƒ½ç”Ÿæˆé™å·ï¼Œæ— æ³•ç”Ÿæˆå‡å·');
            return false;
        } else {
            console.log('  âŒ ä¸¥é‡é—®é¢˜: æ— æ³•ç”Ÿæˆä»»ä½•ä¸´æ—¶è®°å·');
            return false;
        }

    } catch (error) {
        console.log('  âŒ æµ‹è¯•å‘ç”Ÿé”™è¯¯:', error.message);
        return false;
    }
};

// ğŸ§ª åˆ›å»ºè¯¦ç»†æ—¥å¿—ç‰ˆæœ¬çš„ä¸´æ—¶è®°å·å‡½æ•°
window.addAccidentalWithLogging = function(midi, keySignature) {
    console.log(`\nğŸ§ª è¯¦ç»†æ—¥å¿—: ä¸ºMIDI ${midi}åœ¨${keySignature}å¤§è°ƒä¸­æ·»åŠ ä¸´æ—¶è®°å·`);

    const accidentalChoices = [];
    const noteClass = midi % 12;
    const keySignatureInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    console.log(`  åŸéŸ³ç¬¦: MIDI ${midi} â†’ ç±»åˆ« ${noteClass} (${noteNames[noteClass]})`);
    console.log(`  åŸéŸ³ç¬¦å—è°ƒå·å½±å“: ${JSON.stringify(keySignatureInfo)}`);

    // æµ‹è¯•å‡å·
    const sharpNote = midi + 1;
    const sharpNoteClass = sharpNote % 12;
    const sharpKeyInfo = isNoteAffectedByKeySignature(sharpNoteClass, keySignature);

    console.log(`  å‡å·æµ‹è¯•: MIDI ${sharpNote} â†’ ç±»åˆ« ${sharpNoteClass} (${noteNames[sharpNoteClass]})`);
    console.log(`    å‡å·éŸ³ç¬¦å—è°ƒå·å½±å“: ${JSON.stringify(sharpKeyInfo)}`);
    console.log(`    å‡å·æ¡ä»¶: ${sharpNote} <= 72 (${sharpNote <= 72}) && !isFlat (${!sharpKeyInfo.isFlat})`);

    if (sharpNote <= 72 && !sharpKeyInfo.isFlat) {
        accidentalChoices.push(sharpNote);
        console.log(`    âœ… å‡å·è¢«æ·»åŠ åˆ°é€‰æ‹©åˆ—è¡¨`);
    } else {
        console.log(`    âŒ å‡å·è¢«æ‹’ç»`);
        if (sharpNote > 72) console.log(`      åŸå› : è¶…å‡ºéŸ³åŸŸä¸Šé™`);
        if (sharpKeyInfo.isFlat) console.log(`      åŸå› : å‡å·åçš„éŸ³ç¬¦å·²è¢«è°ƒå·é™ä½`);
    }

    // æµ‹è¯•é™å·
    const flatNote = midi - 1;
    const flatNoteClass = flatNote % 12;
    const flatKeyInfo = isNoteAffectedByKeySignature(flatNoteClass, keySignature);

    console.log(`  é™å·æµ‹è¯•: MIDI ${flatNote} â†’ ç±»åˆ« ${flatNoteClass} (${noteNames[flatNoteClass]})`);
    console.log(`    é™å·éŸ³ç¬¦å—è°ƒå·å½±å“: ${JSON.stringify(flatKeyInfo)}`);
    console.log(`    é™å·æ¡ä»¶: ${flatNote} >= 60 (${flatNote >= 60}) && !isSharp (${!flatKeyInfo.isSharp})`);

    if (flatNote >= 60 && !flatKeyInfo.isSharp) {
        accidentalChoices.push(flatNote);
        console.log(`    âœ… é™å·è¢«æ·»åŠ åˆ°é€‰æ‹©åˆ—è¡¨`);
    } else {
        console.log(`    âŒ é™å·è¢«æ‹’ç»`);
        if (flatNote < 60) console.log(`      åŸå› : è¶…å‡ºéŸ³åŸŸä¸‹é™`);
        if (flatKeyInfo.isSharp) console.log(`      åŸå› : é™å·åçš„éŸ³ç¬¦å·²è¢«è°ƒå·å‡é«˜`);
    }

    console.log(`  æœ€ç»ˆå¯é€‰ä¸´æ—¶è®°å·: [${accidentalChoices.join(', ')}]`);

    if (accidentalChoices.length === 0) {
        console.log(`  ğŸ”„ ç»“æœ: æ— å¯ç”¨ä¸´æ—¶è®°å·ï¼Œè¿”å›åŸéŸ³ç¬¦ ${midi}`);
        return midi;
    }

    const selected = accidentalChoices[Math.floor(Math.random() * accidentalChoices.length)];
    console.log(`  ğŸ¯ ç»“æœ: éšæœºé€‰æ‹© ${selected}`);
    return selected;
};

// ğŸš€ ç»ˆæéªŒè¯ï¼šç›´æ¥æµ‹è¯•ç”¨æˆ·é—®é¢˜
window.finalAccidentalTest = function() {
    console.log('\nğŸš€ ç»ˆæéªŒè¯ï¼šæµ‹è¯•ä¸´æ—¶è®°å·ä¿®å¤ç»“æœ');
    console.log('è¿™ä¸ªæµ‹è¯•å°†éªŒè¯ç”¨æˆ·æŠ¥å‘Šçš„å…·ä½“é—®é¢˜æ˜¯å¦å·²è§£å†³\n');

    // ç›´æ¥æ¨¡æ‹Ÿç”¨æˆ·åœºæ™¯
    console.log('=== åœºæ™¯1: Cå¤§è°ƒï¼ˆæ— å‡é™å·è°ƒå·ï¼‰===');
    console.log('â“ é—®é¢˜ï¼šåº”è¯¥èƒ½ç”Ÿæˆå‡å·å’Œé™å·ï¼Œä¸åº”è¯¥åªæœ‰å‡å·å’Œè¿˜åŸè®°å·');

    addAccidentalWithLogging(60, 'C');  // CéŸ³ç¬¦
    addAccidentalWithLogging(62, 'C');  // DéŸ³ç¬¦

    console.log('\n=== åœºæ™¯2: Gå¤§è°ƒï¼ˆå‡è®°å·è°ƒå·ï¼‰===');
    console.log('â“ é—®é¢˜ï¼šåº”è¯¥èƒ½ç”Ÿæˆå‡å·å’Œé™å·ï¼Œä¸åº”è¯¥åªæœ‰å‡å·å’Œè¿˜åŸè®°å·');

    addAccidentalWithLogging(60, 'G');  // CéŸ³ç¬¦
    addAccidentalWithLogging(62, 'G');  // DéŸ³ç¬¦

    console.log('\n=== åœºæ™¯3: Få¤§è°ƒï¼ˆé™è®°å·è°ƒå·ï¼‰===');
    console.log('â“ é—®é¢˜ï¼šåº”è¯¥èƒ½ç”Ÿæˆå‡å·å’Œé™å·ï¼Œä¸åº”è¯¥åªæœ‰é™å·å’Œè¿˜åŸè®°å·');

    addAccidentalWithLogging(60, 'F');  // CéŸ³ç¬¦
    addAccidentalWithLogging(62, 'F');  // DéŸ³ç¬¦

    console.log('\nğŸ¯ å¦‚æœä¿®å¤æˆåŠŸï¼Œæ‚¨åº”è¯¥çœ‹åˆ°:');
    console.log('  - åœ¨æ‰€æœ‰è°ƒå·ä¸­ï¼Œå‡å·å’Œé™å·éƒ½è¢«æ·»åŠ åˆ°é€‰æ‹©åˆ—è¡¨');
    console.log('  - ä¸´æ—¶è®°å·é€‰æ‹©ä¸å†å—è°ƒå·ç±»å‹é™åˆ¶');
    console.log('  - Cå¤§è°ƒã€Gå¤§è°ƒã€Få¤§è°ƒéƒ½èƒ½ç”Ÿæˆå®Œæ•´çš„å‡é™å·ç»„åˆ');

    console.log('\nğŸš€ ç»ˆæéªŒè¯å®Œæˆï¼');
};

// ğŸ”¬ æ·±åº¦è¯Šæ–­ï¼šåˆ†æä¸´æ—¶è®°å·é—®é¢˜çš„æ ¹æœ¬åŸå› 
window.deepDiagnoseAccidentalIssue = function() {
    console.log('\nğŸ”¬ æ·±åº¦è¯Šæ–­ï¼šåˆ†æä¸´æ—¶è®°å·é—®é¢˜çš„æ ¹æœ¬åŸå› ');
    console.log('==================================================');

    // æ­¥éª¤1ï¼šæ£€æŸ¥è°ƒå·å®šä¹‰
    console.log('\nğŸ“Š æ­¥éª¤1ï¼šæ£€æŸ¥è°ƒå·å®šä¹‰');
    const testKeys = ['C', 'G', 'D', 'F', 'Bb', 'Eb'];
    testKeys.forEach(key => {
        const keyInfo = KEY_SIGNATURES[key];
        console.log(`  ${key}å¤§è°ƒ: å‡å·[${keyInfo.sharps.join(',')}] é™å·[${keyInfo.flats.join(',')}]`);
    });

    // æ­¥éª¤2ï¼šæ£€æŸ¥isNoteAffectedByKeySignatureå‡½æ•°
    console.log('\nğŸ” æ­¥éª¤2ï¼šæ£€æŸ¥éŸ³ç¬¦å—è°ƒå·å½±å“æ£€æµ‹');
    [60, 61, 62, 63].forEach(midi => {
        const noteClass = midi % 12;
        console.log(`\n  MIDI ${midi} (ç±»åˆ«${noteClass}):`);
        ['C', 'G', 'F'].forEach(key => {
            const affected = isNoteAffectedByKeySignature(noteClass, key);
            console.log(`    ${key}å¤§è°ƒ: ${JSON.stringify(affected)}`);
        });
    });

    // æ­¥éª¤3ï¼šæ¨¡æ‹Ÿå®é™…çš„ä¸´æ—¶è®°å·ç”Ÿæˆè¿‡ç¨‹
    console.log('\nâš™ï¸ æ­¥éª¤3ï¼šæ¨¡æ‹Ÿå®é™…çš„ä¸´æ—¶è®°å·ç”Ÿæˆè¿‡ç¨‹');

    function simulateAccidentalGeneration(midi, keySignature) {
        console.log(`\n  ğŸ“ æ¨¡æ‹Ÿ: MIDI ${midi} åœ¨ ${keySignature}å¤§è°ƒ`);

        const choices = [];
        const noteClass = midi % 12;
        const origInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

        console.log(`    åŸéŸ³ç¬¦ç±»åˆ«${noteClass}: ${JSON.stringify(origInfo)}`);

        // æ£€æŸ¥å‡å·
        const sharpNote = midi + 1;
        const sharpClass = sharpNote % 12;
        const sharpInfo = isNoteAffectedByKeySignature(sharpClass, keySignature);
        const canSharp = !sharpInfo.isFlat;

        console.log(`    å‡å·æµ‹è¯•: ${midi}â†’${sharpNote} (ç±»åˆ«${sharpClass})`);
        console.log(`      è°ƒå·å½±å“: ${JSON.stringify(sharpInfo)}`);
        console.log(`      æ¡ä»¶: !isFlat = ${!sharpInfo.isFlat}`);
        console.log(`      ç»“æœ: ${canSharp ? 'âœ…å¯ä»¥' : 'âŒä¸å¯ä»¥'}`);

        if (canSharp) choices.push(`${sharpNote}(å‡å·)`);

        // æ£€æŸ¥é™å·
        const flatNote = midi - 1;
        const flatClass = flatNote % 12;
        const flatInfo = isNoteAffectedByKeySignature(flatClass, keySignature);
        const canFlat = !flatInfo.isSharp;

        console.log(`    é™å·æµ‹è¯•: ${midi}â†’${flatNote} (ç±»åˆ«${flatClass})`);
        console.log(`      è°ƒå·å½±å“: ${JSON.stringify(flatInfo)}`);
        console.log(`      æ¡ä»¶: !isSharp = ${!flatInfo.isSharp}`);
        console.log(`      ç»“æœ: ${canFlat ? 'âœ…å¯ä»¥' : 'âŒä¸å¯ä»¥'}`);

        if (canFlat) choices.push(`${flatNote}(é™å·)`);

        console.log(`    æœ€ç»ˆé€‰æ‹©: [${choices.join(', ')}]`);

        return { canSharp, canFlat, choices };
    }

    // æµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„å…·ä½“åœºæ™¯
    console.log('\nğŸ¯ ç”¨æˆ·æŠ¥å‘Šçš„åœºæ™¯æµ‹è¯•:');

    console.log('\n  === Cå¤§è°ƒæµ‹è¯• ===');
    simulateAccidentalGeneration(60, 'C');  // CéŸ³ç¬¦
    simulateAccidentalGeneration(62, 'C');  // DéŸ³ç¬¦

    console.log('\n  === Gå¤§è°ƒæµ‹è¯• ===');
    simulateAccidentalGeneration(60, 'G');  // CéŸ³ç¬¦
    simulateAccidentalGeneration(62, 'G');  // DéŸ³ç¬¦

    console.log('\n  === Få¤§è°ƒæµ‹è¯• ===');
    simulateAccidentalGeneration(60, 'F');  // CéŸ³ç¬¦
    simulateAccidentalGeneration(62, 'F');  // DéŸ³ç¬¦

    // æ­¥éª¤4ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–éšè—çš„é™åˆ¶
    console.log('\nğŸ•µï¸ æ­¥éª¤4ï¼šæ£€æŸ¥å¯èƒ½çš„å…¶ä»–é™åˆ¶');
    console.log('  - æ£€æŸ¥éŸ³åŸŸé™åˆ¶ (60-72): âœ…');
    console.log('  - æ£€æŸ¥åŒéŸ³å¼‚åå†²çªé¿å…: âœ…');
    console.log('  - æ£€æŸ¥è°ƒå·ç±»å‹é™åˆ¶: ğŸ”éœ€è¦éªŒè¯');

    console.log('\nğŸ”¬ è¯Šæ–­å®Œæˆ');
    console.log('==================================================');
};

// ğŸ” å®æ—¶éªŒè¯ï¼šæ£€æŸ¥å½“å‰å®é™…ç”Ÿæˆè¡Œä¸º
window.realTimeAccidentalTest = function() {
    console.log('\nğŸ” å®æ—¶éªŒè¯ï¼šæ£€æŸ¥å½“å‰å®é™…ç”Ÿæˆè¡Œä¸º');
    console.log('===========================================');

    // åˆ›å»ºçœŸå®çš„ç”Ÿæˆå™¨å®ä¾‹
    function testRealGeneration(keySignature, testMidi, testName) {
        console.log(`\nğŸ¼ æµ‹è¯• ${keySignature}å¤§è°ƒä¸­çš„${testName} (MIDI ${testMidi})`);

        const generator = new IntelligentMelodyGenerator(1, keySignature, '4/4', 'treble', Date.now());
        generator.rules = {
            range: { min: 60, max: 79 },
            accidentalRate: 1.0,  // 100%æ¦‚ç‡ç¡®ä¿ç”Ÿæˆ
            maxJump: 12
        };

        // å¤šæ¬¡æµ‹è¯•ä»¥è§‚å¯Ÿéšæœºæ€§
        const results = { sharps: 0, flats: 0, unchanged: 0 };
        const totalTests = 50;

        for (let i = 0; i < totalTests; i++) {
            const result = generator.addAccidental(testMidi);
            if (result === testMidi + 1) results.sharps++;
            else if (result === testMidi - 1) results.flats++;
            else results.unchanged++;
        }

        console.log(`  ğŸ“Š ${totalTests}æ¬¡æµ‹è¯•ç»“æœ:`);
        console.log(`    å‡å·: ${results.sharps}æ¬¡ (${(results.sharps/totalTests*100).toFixed(1)}%)`);
        console.log(`    é™å·: ${results.flats}æ¬¡ (${(results.flats/totalTests*100).toFixed(1)}%)`);
        console.log(`    æ— å˜åŒ–: ${results.unchanged}æ¬¡ (${(results.unchanged/totalTests*100).toFixed(1)}%)`);

        // åˆ†æç»“æœ
        if (results.sharps > 0 && results.flats > 0) {
            console.log(`    âœ… ç»“è®º: å‡å·å’Œé™å·éƒ½èƒ½æ­£å¸¸ç”Ÿæˆ`);
        } else if (results.sharps > 0 && results.flats === 0) {
            console.log(`    âŒ é—®é¢˜: åªèƒ½ç”Ÿæˆå‡å·ï¼Œæ— æ³•ç”Ÿæˆé™å·`);
        } else if (results.sharps === 0 && results.flats > 0) {
            console.log(`    âŒ é—®é¢˜: åªèƒ½ç”Ÿæˆé™å·ï¼Œæ— æ³•ç”Ÿæˆå‡å·`);
        } else {
            console.log(`    âŒ ä¸¥é‡é—®é¢˜: æ— æ³•ç”Ÿæˆä»»ä½•ä¸´æ—¶è®°å·`);
        }

        return results;
    }

    // æµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„å…³é”®åœºæ™¯
    console.log('\nğŸ¯ ç”¨æˆ·å…³é”®åœºæ™¯æµ‹è¯•:');
    testRealGeneration('C', 60, 'CéŸ³ç¬¦');
    testRealGeneration('C', 62, 'DéŸ³ç¬¦');
    testRealGeneration('G', 60, 'CéŸ³ç¬¦');
    testRealGeneration('G', 62, 'DéŸ³ç¬¦');
    testRealGeneration('F', 60, 'CéŸ³ç¬¦');
    testRealGeneration('F', 62, 'DéŸ³ç¬¦');

    console.log('\nğŸ” å®æ—¶éªŒè¯å®Œæˆ');
    console.log('===========================================');
};

// ğŸ§ª 6/8æ‹ä¸´æ—¶è®°å·æµ‹è¯•
window.test68AccidentalGeneration = function() {
    console.log('\nğŸ§ª 6/8æ‹ä¸´æ—¶è®°å·ç”Ÿæˆæµ‹è¯•');
    console.log('===============================');

    // æµ‹è¯•6/8æ‹çš„ä¸¤ä¸ªä¸»è¦è·¯å¾„
    function test68Path(pathName, midi, keySignature) {
        console.log(`\nğŸµ æµ‹è¯•${pathName} - ${keySignature}å¤§è°ƒ MIDI ${midi}`);

        if (pathName === 'ä¸»è·¯å¾„') {
            // æµ‹è¯•ä¸»6/8æ‹ç”Ÿæˆè·¯å¾„çš„ä¸´æ—¶è®°å·å‡½æ•°
            const userRange = { min: 60, max: 79 };
            const random = { nextFloat: () => Math.random() };
            const accidentalRate = 1.0;

            // æ¨¡æ‹Ÿ6/8æ‹ä¸»è·¯å¾„çš„addAccidentalå‡½æ•°
            function addAccidental68Main(midi) {
                const accidentalChoices = [];
                const noteClass = midi % 12;
                const keySignatureInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

                const sharpNote = midi + 1;
                const sharpNoteClass = sharpNote % 12;
                if (sharpNote <= userRange.max) {
                    accidentalChoices.push(sharpNote);
                }

                const flatNote = midi - 1;
                const flatNoteClass = flatNote % 12;
                if (flatNote >= userRange.min) {
                    accidentalChoices.push(flatNote);
                }

                return accidentalChoices;
            }

            const choices = addAccidental68Main(midi);
            console.log(`    å¯é€‰ä¸´æ—¶è®°å·: [${choices.join(', ')}]`);

            const hasSharp = choices.includes(midi + 1);
            const hasFlat = choices.includes(midi - 1);
            console.log(`    å‡å·å¯ç”¨: ${hasSharp ? 'âœ…' : 'âŒ'}`);
            console.log(`    é™å·å¯ç”¨: ${hasFlat ? 'âœ…' : 'âŒ'}`);

        } else if (pathName === 'Beat Clarityè·¯å¾„') {
            // æµ‹è¯•Beat Clarityè·¯å¾„ - éœ€è¦æ‰¾åˆ°è¯¥å‡½æ•°
            console.log(`    â³ Beat Clarityè·¯å¾„æµ‹è¯•å¾…å®ç°`);
        }
    }

    test68Path('ä¸»è·¯å¾„', 60, 'C');
    test68Path('ä¸»è·¯å¾„', 60, 'G');
    test68Path('ä¸»è·¯å¾„', 60, 'F');

    console.log('\nğŸ§ª 6/8æ‹æµ‹è¯•å®Œæˆ');
    console.log('===============================');
};

// ğŸš¨ æœ€ç»ˆç¡®è®¤ï¼šéªŒè¯ä¿®å¤æ˜¯å¦çœŸæ­£ç”Ÿæ•ˆ
window.finalConfirmation = function() {
    console.log('\nğŸš¨ æœ€ç»ˆç¡®è®¤ï¼šéªŒè¯ä¿®å¤æ˜¯å¦çœŸæ­£ç”Ÿæ•ˆ');
    console.log('==========================================');

    // æ­¥éª¤1ï¼šç›´æ¥æ£€æŸ¥ä¿®å¤åçš„ä»£ç é€»è¾‘
    console.log('\nğŸ“‹ æ­¥éª¤1ï¼šæ£€æŸ¥å½“å‰ä»£ç ä¸­çš„é™åˆ¶æ¡ä»¶');

    function checkCurrentLogic(midi, keySignature) {
        console.log(`\nğŸ” æ£€æŸ¥ ${keySignature}å¤§è°ƒä¸­MIDI ${midi}çš„é€»è¾‘:`);

        const noteClass = midi % 12;
        const origInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

        // æ£€æŸ¥å‡å·é€»è¾‘
        const sharpNote = midi + 1;
        const sharpClass = sharpNote % 12;
        const sharpInfo = isNoteAffectedByKeySignature(sharpClass, keySignature);

        console.log(`  å‡å·æ£€æŸ¥: ${midi} â†’ ${sharpNote}`);
        console.log(`    å‡å·éŸ³ç¬¦ç±»åˆ« ${sharpClass} å—è°ƒå·å½±å“: ${JSON.stringify(sharpInfo)}`);
        console.log(`    æ¡ä»¶: !isFlat = ${!sharpInfo.isFlat}`);
        console.log(`    ç»“æœ: ${!sharpInfo.isFlat ? 'âœ…å…è®¸' : 'âŒç¦æ­¢'}`);

        // æ£€æŸ¥é™å·é€»è¾‘
        const flatNote = midi - 1;
        const flatClass = flatNote % 12;
        const flatInfo = isNoteAffectedByKeySignature(flatClass, keySignature);

        console.log(`  é™å·æ£€æŸ¥: ${midi} â†’ ${flatNote}`);
        console.log(`    é™å·éŸ³ç¬¦ç±»åˆ« ${flatClass} å—è°ƒå·å½±å“: ${JSON.stringify(flatInfo)}`);
        console.log(`    æ¡ä»¶: !isSharp = ${!flatInfo.isSharp}`);
        console.log(`    ç»“æœ: ${!flatInfo.isSharp ? 'âœ…å…è®¸' : 'âŒç¦æ­¢'}`);

        return {
            canSharp: !sharpInfo.isFlat,
            canFlat: !flatInfo.isSharp
        };
    }

    // æ­¥éª¤2ï¼šæµ‹è¯•å…³é”®åœºæ™¯
    console.log('\nğŸ¯ æ­¥éª¤2ï¼šæµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„å…³é”®åœºæ™¯');

    const testCases = [
        { key: 'C', midi: 60, name: 'Cå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { key: 'C', midi: 62, name: 'Cå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { key: 'G', midi: 60, name: 'Gå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { key: 'G', midi: 62, name: 'Gå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { key: 'F', midi: 60, name: 'Få¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { key: 'F', midi: 62, name: 'Få¤§è°ƒä¸­çš„DéŸ³ç¬¦' }
    ];

    const results = [];
    testCases.forEach(testCase => {
        const result = checkCurrentLogic(testCase.midi, testCase.key);
        results.push({
            ...testCase,
            ...result
        });
    });

    // æ­¥éª¤3ï¼šåˆ†æç»“æœ
    console.log('\nğŸ“Š æ­¥éª¤3ï¼šåˆ†ææµ‹è¯•ç»“æœ');

    let allFixed = true;
    results.forEach(result => {
        const status = result.canSharp && result.canFlat ? 'âœ…ä¿®å¤æˆåŠŸ' : 'âŒä»æœ‰é—®é¢˜';
        console.log(`  ${result.name}: ${status}`);
        if (!result.canSharp || !result.canFlat) {
            allFixed = false;
            if (!result.canSharp) console.log(`    - å‡å·è¢«é˜»æ­¢`);
            if (!result.canFlat) console.log(`    - é™å·è¢«é˜»æ­¢`);
        }
    });

    // æ­¥éª¤4ï¼šæœ€ç»ˆç»“è®º
    console.log('\nğŸ¯ æ­¥éª¤4ï¼šæœ€ç»ˆç»“è®º');
    if (allFixed) {
        console.log('âœ… ä¿®å¤æˆåŠŸï¼æ‰€æœ‰æµ‹è¯•åœºæ™¯éƒ½èƒ½æ­£å¸¸ç”Ÿæˆå‡å·å’Œé™å·');
        console.log('   ç”¨æˆ·æŠ¥å‘Šçš„é—®é¢˜åº”è¯¥å·²ç»è§£å†³');
    } else {
        console.log('âŒ ä¿®å¤ä¸å®Œæ•´ï¼ä»æœ‰åœºæ™¯æ— æ³•æ­£å¸¸ç”Ÿæˆä¸´æ—¶è®°å·');
        console.log('   éœ€è¦è¿›ä¸€æ­¥è°ƒæŸ¥å’Œä¿®å¤');
    }

    console.log('\nğŸš¨ æœ€ç»ˆç¡®è®¤å®Œæˆ');
    console.log('==========================================');

    return allFixed;
};

// ğŸµ éªŒè¯èŠ‚å¥é»˜è®¤è®¾ç½®ä¿®å¤
window.verifyRhythmDefaults = function() {
    console.log('\nğŸµ éªŒè¯èŠ‚å¥é»˜è®¤è®¾ç½®ä¿®å¤');
    console.log('================================');

    // æ£€æŸ¥userSettingsä¸­çš„é»˜è®¤è®¾ç½®
    console.log('\nğŸ“‹ æ­¥éª¤1ï¼šæ£€æŸ¥userSettingsé»˜è®¤è®¾ç½®');
    console.log(`  å½“å‰allowedRhythms: [${userSettings.allowedRhythms.join(', ')}]`);

    const expectedRhythms = ['half', 'quarter', 'eighth'];
    const actualRhythms = userSettings.allowedRhythms;

    const isCorrect = expectedRhythms.every(rhythm => actualRhythms.includes(rhythm)) &&
                     actualRhythms.length === expectedRhythms.length &&
                     !actualRhythms.includes('16th');

    if (isCorrect) {
        console.log('  âœ… JavaScripté»˜è®¤è®¾ç½®æ­£ç¡®');
    } else {
        console.log('  âŒ JavaScripté»˜è®¤è®¾ç½®ä¸æ­£ç¡®');
        console.log(`    æœŸæœ›: [${expectedRhythms.join(', ')}]`);
        console.log(`    å®é™…: [${actualRhythms.join(', ')}]`);
    }

    // æ£€æŸ¥HTMLä¸­çš„checkboxçŠ¶æ€
    console.log('\nğŸ“‹ æ­¥éª¤2ï¼šæ£€æŸ¥HTMLä¸­çš„checkboxé»˜è®¤çŠ¶æ€');

    const checkboxes = [
        { id: 'rhythm-half', name: 'äºŒåˆ†éŸ³ç¬¦', shouldBeChecked: true },
        { id: 'rhythm-quarter', name: 'å››åˆ†éŸ³ç¬¦', shouldBeChecked: true },
        { id: 'rhythm-eighth', name: 'å…«åˆ†éŸ³ç¬¦', shouldBeChecked: true },
        { id: 'rhythm-16th', name: 'åå…­åˆ†éŸ³ç¬¦', shouldBeChecked: false }
    ];

    let htmlCorrect = true;
    checkboxes.forEach(checkbox => {
        const element = document.getElementById(checkbox.id);
        if (element) {
            const actualState = element.checked;
            const expectedState = checkbox.shouldBeChecked;
            const status = actualState === expectedState ? 'âœ…' : 'âŒ';

            console.log(`  ${status} ${checkbox.name}: ${actualState ? 'å‹¾é€‰' : 'æœªå‹¾é€‰'} (æœŸæœ›: ${expectedState ? 'å‹¾é€‰' : 'æœªå‹¾é€‰'})`);

            if (actualState !== expectedState) {
                htmlCorrect = false;
            }
        } else {
            console.log(`  âš ï¸  æ‰¾ä¸åˆ°${checkbox.name}çš„checkboxå…ƒç´ `);
        }
    });

    // æ­¥éª¤3ï¼šæ€»ç»“
    console.log('\nğŸ“Š æ­¥éª¤3ï¼šéªŒè¯æ€»ç»“');
    const overallCorrect = isCorrect && htmlCorrect;

    if (overallCorrect) {
        console.log('âœ… ä¿®å¤æˆåŠŸï¼èŠ‚å¥é»˜è®¤è®¾ç½®å®Œå…¨æ­£ç¡®');
        console.log('   - JavaScripté»˜è®¤åªåŒ…å«äºŒåˆ†éŸ³ç¬¦ã€å››åˆ†éŸ³ç¬¦ã€å…«åˆ†éŸ³ç¬¦');
        console.log('   - HTMLä¸­åå…­åˆ†éŸ³ç¬¦é»˜è®¤ä¸å‹¾é€‰');
        console.log('   - ç”¨æˆ·åˆæ¬¡æ‰“å¼€é¡µé¢å°†çœ‹åˆ°æœŸæœ›çš„é»˜è®¤èŠ‚å¥è®¾ç½®');
    } else {
        console.log('âŒ ä¿®å¤ä¸å®Œæ•´ï¼Œä»éœ€è°ƒæ•´');
        if (!isCorrect) console.log('   - JavaScripté»˜è®¤è®¾ç½®éœ€è¦ä¿®æ­£');
        if (!htmlCorrect) console.log('   - HTML checkboxçŠ¶æ€éœ€è¦ä¿®æ­£');
    }

    console.log('\nğŸµ éªŒè¯å®Œæˆ');
    console.log('================================');

    return overallCorrect;
};

// ğŸ”¬ æ·±åº¦åˆ†æåŒéŸ³å¼‚åæ£€æµ‹é€»è¾‘é—®é¢˜
window.analyzeEnharmonicIssue = function() {
    console.log('\nğŸ”¬ æ·±åº¦åˆ†æåŒéŸ³å¼‚åæ£€æµ‹é€»è¾‘é—®é¢˜');
    console.log('==========================================');

    // æ­¥éª¤1ï¼šæ£€æŸ¥KEY_SIGNATURESå®šä¹‰çš„å‡†ç¡®æ€§
    console.log('\nğŸ“Š æ­¥éª¤1ï¼šæ£€æŸ¥KEY_SIGNATURESå®šä¹‰');

    const noteClassNames = ['C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G', 'G#/Ab', 'A', 'A#/Bb', 'B'];

    console.log('éŸ³ç¬¦ç±»åˆ«æ˜ å°„ï¼š');
    noteClassNames.forEach((name, index) => {
        console.log(`  ç±»åˆ« ${index}: ${name}`);
    });

    console.log('\nå…³é”®è°ƒå·çš„å®šä¹‰ï¼š');
    ['C', 'G', 'F'].forEach(key => {
        const keyInfo = KEY_SIGNATURES[key];
        console.log(`  ${key}å¤§è°ƒ:`);
        console.log(`    å‡å·ç±»åˆ«: [${keyInfo.sharps.join(', ')}] (${keyInfo.sharps.map(s => noteClassNames[s]).join(', ')})`);
        console.log(`    é™å·ç±»åˆ«: [${keyInfo.flats.join(', ')}] (${keyInfo.flats.map(f => noteClassNames[f]).join(', ')})`);
    });

    // æ­¥éª¤2ï¼šè¯¦ç»†åˆ†æisNoteAffectedByKeySignatureå‡½æ•°
    console.log('\nğŸ” æ­¥éª¤2ï¼šåˆ†æisNoteAffectedByKeySignatureå‡½æ•°è¡Œä¸º');

    function detailedNoteAnalysis(noteClass, keySignature) {
        console.log(`\n  ğŸ“ åˆ†æéŸ³ç¬¦ç±»åˆ« ${noteClass} (${noteClassNames[noteClass]}) åœ¨ ${keySignature}å¤§è°ƒä¸­:`);

        const keyInfo = KEY_SIGNATURES[keySignature];
        const result = isNoteAffectedByKeySignature(noteClass, keySignature);

        console.log(`    è°ƒå·ä¿¡æ¯: å‡å·[${keyInfo.sharps.join(',')}] é™å·[${keyInfo.flats.join(',')}]`);
        console.log(`    æ£€æµ‹ç»“æœ: ${JSON.stringify(result)}`);
        console.log(`    æ˜¯å¦è¢«å‡é«˜: ${result.isSharp}`);
        console.log(`    æ˜¯å¦è¢«é™ä½: ${result.isFlat}`);

        // æ£€æŸ¥é€»è¾‘æ˜¯å¦åˆç†
        const shouldBeSharp = keyInfo.sharps.includes(noteClass);
        const shouldBeFlat = keyInfo.flats.includes(noteClass);

        if (result.isSharp !== shouldBeSharp) {
            console.log(`    âŒ å‡å·æ£€æµ‹é”™è¯¯: æœŸæœ›${shouldBeSharp}, å®é™…${result.isSharp}`);
        }
        if (result.isFlat !== shouldBeFlat) {
            console.log(`    âŒ é™å·æ£€æµ‹é”™è¯¯: æœŸæœ›${shouldBeFlat}, å®é™…${result.isFlat}`);
        }

        return result;
    }

    // æµ‹è¯•å…³é”®éŸ³ç¬¦ç±»åˆ«
    const testCases = [
        { noteClass: 0, keySignature: 'C' },  // Cåœ¨Cå¤§è°ƒ
        { noteClass: 1, keySignature: 'C' },  // C#/Dbåœ¨Cå¤§è°ƒ
        { noteClass: 2, keySignature: 'C' },  // Dåœ¨Cå¤§è°ƒ
        { noteClass: 0, keySignature: 'G' },  // Cåœ¨Gå¤§è°ƒ
        { noteClass: 1, keySignature: 'G' },  // C#/Dbåœ¨Gå¤§è°ƒ
        { noteClass: 6, keySignature: 'G' },  // F#/Gbåœ¨Gå¤§è°ƒ
        { noteClass: 0, keySignature: 'F' },  // Cåœ¨Få¤§è°ƒ
        { noteClass: 10, keySignature: 'F' }, // A#/Bbåœ¨Få¤§è°ƒ
    ];

    testCases.forEach(testCase => {
        detailedNoteAnalysis(testCase.noteClass, testCase.keySignature);
    });

    // æ­¥éª¤3ï¼šåˆ†æä¸´æ—¶è®°å·ç”Ÿæˆçš„å…·ä½“é˜»å¡ç‚¹
    console.log('\nâš™ï¸ æ­¥éª¤3ï¼šåˆ†æä¸´æ—¶è®°å·ç”Ÿæˆçš„å…·ä½“é˜»å¡ç‚¹');

    function analyzeAccidentalBlocking(originalMidi, keySignature) {
        const originalClass = originalMidi % 12;
        console.log(`\n  ğŸ¯ åˆ†æMIDI ${originalMidi} (ç±»åˆ«${originalClass}, ${noteClassNames[originalClass]}) åœ¨${keySignature}å¤§è°ƒ:`);

        // åˆ†æå‡å·é˜»å¡
        const sharpMidi = originalMidi + 1;
        const sharpClass = sharpMidi % 12;
        const sharpInfo = isNoteAffectedByKeySignature(sharpClass, keySignature);

        console.log(`    å‡å·åˆ†æ: ${originalMidi} â†’ ${sharpMidi} (ç±»åˆ«${sharpClass}, ${noteClassNames[sharpClass]})`);
        console.log(`      å‡å·éŸ³ç¬¦å—è°ƒå·å½±å“: ${JSON.stringify(sharpInfo)}`);
        console.log(`      é˜»å¡æ¡ä»¶: isFlat = ${sharpInfo.isFlat}`);
        console.log(`      å‡å·${sharpInfo.isFlat ? 'âŒè¢«é˜»å¡' : 'âœ…å¯ç”Ÿæˆ'}`);

        // åˆ†æé™å·é˜»å¡
        const flatMidi = originalMidi - 1;
        const flatClass = flatMidi % 12;
        const flatInfo = isNoteAffectedByKeySignature(flatClass, keySignature);

        console.log(`    é™å·åˆ†æ: ${originalMidi} â†’ ${flatMidi} (ç±»åˆ«${flatClass}, ${noteClassNames[flatClass]})`);
        console.log(`      é™å·éŸ³ç¬¦å—è°ƒå·å½±å“: ${JSON.stringify(flatInfo)}`);
        console.log(`      é˜»å¡æ¡ä»¶: isSharp = ${flatInfo.isSharp}`);
        console.log(`      é™å·${flatInfo.isSharp ? 'âŒè¢«é˜»å¡' : 'âœ…å¯ç”Ÿæˆ'}`);

        return {
            canSharp: !sharpInfo.isFlat,
            canFlat: !flatInfo.isSharp,
            sharpBlocked: sharpInfo.isFlat,
            flatBlocked: flatInfo.isSharp
        };
    }

    // æµ‹è¯•ç”¨æˆ·æŠ¥å‘Šçš„å…·ä½“é—®é¢˜
    const problemCases = [
        { midi: 60, key: 'C', name: 'Cå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'C', name: 'Cå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { midi: 60, key: 'G', name: 'Gå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'G', name: 'Gå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { midi: 60, key: 'F', name: 'Få¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'F', name: 'Få¤§è°ƒä¸­çš„DéŸ³ç¬¦' }
    ];

    let foundIssues = [];
    problemCases.forEach(testCase => {
        const result = analyzeAccidentalBlocking(testCase.midi, testCase.key);
        if (result.sharpBlocked || result.flatBlocked) {
            foundIssues.push({
                ...testCase,
                sharpBlocked: result.sharpBlocked,
                flatBlocked: result.flatBlocked
            });
        }
    });

    // æ­¥éª¤4ï¼šæ€»ç»“é—®é¢˜
    console.log('\nğŸ¯ æ­¥éª¤4ï¼šé—®é¢˜æ€»ç»“');
    if (foundIssues.length > 0) {
        console.log('âŒ å‘ç°åŒéŸ³å¼‚åæ£€æµ‹é—®é¢˜:');
        foundIssues.forEach(issue => {
            console.log(`  ${issue.name}:`);
            if (issue.sharpBlocked) console.log(`    - å‡å·è¢«é”™è¯¯é˜»å¡`);
            if (issue.flatBlocked) console.log(`    - é™å·è¢«é”™è¯¯é˜»å¡`);
        });
    } else {
        console.log('âœ… åŒéŸ³å¼‚åæ£€æµ‹é€»è¾‘çœ‹èµ·æ¥æ­£å¸¸');
    }

    console.log('\nğŸ”¬ åˆ†æå®Œæˆ');
    console.log('==========================================');

    return foundIssues;
};

// ğŸ§ª æµ‹è¯•ç®€åŒ–çš„ä¸´æ—¶è®°å·é€»è¾‘ï¼ˆä¸æ£€æŸ¥åŒéŸ³å¼‚åå†²çªï¼‰
window.testSimplifiedAccidentalLogic = function() {
    console.log('\nğŸ§ª æµ‹è¯•ç®€åŒ–çš„ä¸´æ—¶è®°å·é€»è¾‘ï¼ˆä¸æ£€æŸ¥åŒéŸ³å¼‚åå†²çªï¼‰');
    console.log('===================================================');

    // ç®€åŒ–ç‰ˆæœ¬ï¼šåªæ£€æŸ¥éŸ³åŸŸï¼Œä¸æ£€æŸ¥åŒéŸ³å¼‚åå†²çª
    function simplifiedAddAccidental(midi, keySignature, range = { min: 60, max: 79 }) {
        console.log(`\nğŸ“ ç®€åŒ–é€»è¾‘æµ‹è¯•: MIDI ${midi} åœ¨ ${keySignature}å¤§è°ƒ`);

        const accidentalChoices = [];

        // å°è¯•å‡å·ï¼ˆ+1åŠéŸ³ï¼‰
        const sharpNote = midi + 1;
        if (sharpNote <= range.max) {
            accidentalChoices.push(sharpNote);
            console.log(`  âœ… å‡å·å¯ç”¨: ${midi} â†’ ${sharpNote}`);
        } else {
            console.log(`  âŒ å‡å·è¶…å‡ºéŸ³åŸŸ: ${sharpNote} > ${range.max}`);
        }

        // å°è¯•é™å·ï¼ˆ-1åŠéŸ³ï¼‰
        const flatNote = midi - 1;
        if (flatNote >= range.min) {
            accidentalChoices.push(flatNote);
            console.log(`  âœ… é™å·å¯ç”¨: ${midi} â†’ ${flatNote}`);
        } else {
            console.log(`  âŒ é™å·è¶…å‡ºéŸ³åŸŸ: ${flatNote} < ${range.min}`);
        }

        console.log(`  å¯é€‰ä¸´æ—¶è®°å·: [${accidentalChoices.join(', ')}]`);

        return accidentalChoices;
    }

    // å¯¹æ¯”æµ‹è¯•ï¼šåŸå§‹é€»è¾‘ vs ç®€åŒ–é€»è¾‘
    const testCases = [
        { midi: 60, key: 'C', name: 'Cå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'C', name: 'Cå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { midi: 60, key: 'G', name: 'Gå¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'G', name: 'Gå¤§è°ƒä¸­çš„DéŸ³ç¬¦' },
        { midi: 60, key: 'F', name: 'Få¤§è°ƒä¸­çš„CéŸ³ç¬¦' },
        { midi: 62, key: 'F', name: 'Få¤§è°ƒä¸­çš„DéŸ³ç¬¦' }
    ];

    testCases.forEach(testCase => {
        console.log(`\nğŸ” å¯¹æ¯”æµ‹è¯•: ${testCase.name}`);

        // åŸå§‹é€»è¾‘ï¼ˆå¸¦åŒéŸ³å¼‚åæ£€æµ‹ï¼‰
        console.log('  ğŸ“Š åŸå§‹é€»è¾‘ç»“æœ:');
        const originalChoices = [];
        const noteClass = testCase.midi % 12;

        const sharpNote = testCase.midi + 1;
        const sharpClass = sharpNote % 12;
        const sharpInfo = isNoteAffectedByKeySignature(sharpClass, testCase.key);
        if (sharpNote <= 72 && !sharpInfo.isFlat) {
            originalChoices.push(sharpNote);
        }

        const flatNote = testCase.midi - 1;
        const flatClass = flatNote % 12;
        const flatInfo = isNoteAffectedByKeySignature(flatClass, testCase.key);
        if (flatNote >= 60 && !flatInfo.isSharp) {
            originalChoices.push(flatNote);
        }

        console.log(`    åŸå§‹é€»è¾‘å¯é€‰: [${originalChoices.join(', ')}]`);

        // ç®€åŒ–é€»è¾‘ï¼ˆä¸æ£€æŸ¥åŒéŸ³å¼‚åå†²çªï¼‰
        console.log('  ğŸ“Š ç®€åŒ–é€»è¾‘ç»“æœ:');
        const simplifiedChoices = simplifiedAddAccidental(testCase.midi, testCase.key);

        // å¯¹æ¯”åˆ†æ
        const originalHasSharp = originalChoices.includes(sharpNote);
        const originalHasFlat = originalChoices.includes(flatNote);
        const simplifiedHasSharp = simplifiedChoices.includes(sharpNote);
        const simplifiedHasFlat = simplifiedChoices.includes(flatNote);

        console.log('  ğŸ“ˆ å¯¹æ¯”åˆ†æ:');
        console.log(`    å‡å·: åŸå§‹${originalHasSharp ? 'âœ…' : 'âŒ'} vs ç®€åŒ–${simplifiedHasSharp ? 'âœ…' : 'âŒ'}`);
        console.log(`    é™å·: åŸå§‹${originalHasFlat ? 'âœ…' : 'âŒ'} vs ç®€åŒ–${simplifiedHasFlat ? 'âœ…' : 'âŒ'}`);

        if (simplifiedHasSharp && simplifiedHasFlat) {
            if (!originalHasSharp || !originalHasFlat) {
                console.log(`    ğŸš¨ åŒéŸ³å¼‚åæ£€æµ‹é˜»æ­¢äº†åˆç†çš„ä¸´æ—¶è®°å·ç”Ÿæˆï¼`);
            }
        }
    });

    console.log('\nğŸ¯ ç»“è®º');
    console.log('å¦‚æœç®€åŒ–é€»è¾‘æ˜¾ç¤ºæ‰€æœ‰æƒ…å†µéƒ½èƒ½ç”Ÿæˆå‡å·å’Œé™å·ï¼Œ');
    console.log('è€ŒåŸå§‹é€»è¾‘æœ‰é˜»å¡ï¼Œåˆ™è¯´æ˜åŒéŸ³å¼‚åæ£€æµ‹ç¡®å®æ˜¯é—®é¢˜æ‰€åœ¨ã€‚');

    console.log('\nğŸ§ª æµ‹è¯•å®Œæˆ');
    console.log('===================================================');
};

// ğŸ”§ æä¾›ä¿®å¤æ–¹æ¡ˆï¼šæ›´å®½æ¾çš„åŒéŸ³å¼‚åæ£€æµ‹
window.fixEnharmonicLogic = function() {
    console.log('\nğŸ”§ ä¿®å¤åŒéŸ³å¼‚åæ£€æµ‹é€»è¾‘');
    console.log('=============================');

    console.log('å½“å‰ä¸´æ—¶è®°å·ç”Ÿæˆä½¿ç”¨çš„æ˜¯ä¸¥æ ¼çš„åŒéŸ³å¼‚åå†²çªæ£€æµ‹ï¼š');
    console.log('- å¦‚æœå‡å·åçš„éŸ³ç¬¦è¢«è°ƒå·é™ä½ï¼Œåˆ™ç¦æ­¢ç”Ÿæˆå‡å·');
    console.log('- å¦‚æœé™å·åçš„éŸ³ç¬¦è¢«è°ƒå·å‡é«˜ï¼Œåˆ™ç¦æ­¢ç”Ÿæˆé™å·');
    console.log('');
    console.log('ä½†è¿™ç§æ£€æµ‹å¯èƒ½è¿‡äºä¸¥æ ¼ï¼Œå®é™…ä¸Šï¼š');
    console.log('- ä¸´æ—¶è®°å·çš„ç›®çš„å°±æ˜¯åˆ›é€ è°ƒå¤–éŸ³');
    console.log('- åŒéŸ³å¼‚ååœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­æ˜¯å¯ä»¥æ¥å—çš„');
    console.log('');
    console.log('å»ºè®®çš„ä¿®å¤æ–¹æ¡ˆï¼š');
    console.log('1. å®Œå…¨ç§»é™¤åŒéŸ³å¼‚åå†²çªæ£€æµ‹');
    console.log('2. æˆ–è€…ä½¿ç”¨æ›´å®½æ¾çš„æ£€æµ‹é€»è¾‘');
    console.log('3. åªä¿ç•™éŸ³åŸŸæ£€æŸ¥');

    // åˆ›å»ºä¿®å¤ç‰ˆæœ¬çš„ä¸´æ—¶è®°å·å‡½æ•°
    console.log('\nğŸ› ï¸ åˆ›å»ºä¿®å¤ç‰ˆæœ¬çš„addAccidentalå‡½æ•°...');

    window.addAccidentalFixed = function(midi, keySignature, range = { min: 60, max: 79 }) {
        const accidentalChoices = [];

        // åªæ£€æŸ¥éŸ³åŸŸï¼Œä¸æ£€æŸ¥åŒéŸ³å¼‚åå†²çª
        const sharpNote = midi + 1;
        if (sharpNote <= range.max) {
            accidentalChoices.push(sharpNote);
        }

        const flatNote = midi - 1;
        if (flatNote >= range.min) {
            accidentalChoices.push(flatNote);
        }

        // éšæœºé€‰æ‹©
        if (accidentalChoices.length > 0) {
            const selected = accidentalChoices[Math.floor(Math.random() * accidentalChoices.length)];
            console.log(`ğŸ¯ ä¿®å¤ç‰ˆæœ¬: MIDI ${midi} â†’ ${selected} åœ¨ ${keySignature}å¤§è°ƒ`);
            return selected;
        }

        console.log(`ğŸ¯ ä¿®å¤ç‰ˆæœ¬: MIDI ${midi} â†’ ${midi} (æ— å˜åŒ–) åœ¨ ${keySignature}å¤§è°ƒ`);
        return midi;
    };

    console.log('âœ… ä¿®å¤ç‰ˆæœ¬å‡½æ•°å·²åˆ›å»º: window.addAccidentalFixed()');
    console.log('');
    console.log('æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç æµ‹è¯•ä¿®å¤ç‰ˆæœ¬ï¼š');
    console.log('addAccidentalFixed(60, "C")  // Cå¤§è°ƒä¸­çš„CéŸ³ç¬¦');
    console.log('addAccidentalFixed(62, "G")  // Gå¤§è°ƒä¸­çš„DéŸ³ç¬¦');
    console.log('addAccidentalFixed(60, "F")  // Få¤§è°ƒä¸­çš„CéŸ³ç¬¦');

    console.log('\nğŸ”§ ä¿®å¤å®Œæˆ');
    console.log('=============================');
};
window.toggleArticulationAdvancedSettings = toggleArticulationAdvancedSettings;
window.resetArticulationFrequencies = resetArticulationFrequencies;
window.resetRangeSettings = resetRangeSettings;
window.resetAllRangeSettings = resetAllRangeSettings;
window.updateUIForClefRange = updateUIForClefRange;

console.log('ğŸ“š OSMDè§†å¥ç”Ÿæˆå™¨å·²å®Œå…¨åŠ è½½');
console.log('âœ… ä¸»è¦åŠŸèƒ½å‡½æ•°å·²å¯¼å‡ºåˆ°å…¨å±€');
console.log('ğŸ’¡ å¯ç”¨è°ƒè¯•å‘½ä»¤:');
console.log('   - testGMajorFix() : æµ‹è¯•Gå¤§è°ƒF#æ¸²æŸ“');
console.log('   - test4MeasuresLayout() : æµ‹è¯•4å°èŠ‚/è¡Œå¸ƒå±€');
console.log('   - forceFixedMeasuresLayout() : å¼ºåˆ¶ä¿®å¤ä¸º4å°èŠ‚/è¡Œ');
console.log('ğŸ”§ å¯ç”¨çš„è°ƒè¯•å‡½æ•°:');
console.log('   - testSimpleOSMD(): æµ‹è¯•æœ€ç®€åŒ–çš„OSMDæ¸²æŸ“å¹¶æ£€æŸ¥å±æ€§');
console.log('ğŸ¹ éŸ³åŸŸè®¾ç½®å‡½æ•°:');
console.log('   - resetRangeSettings(): é‡ç½®å½“å‰è°±å·çš„éŸ³åŸŸè®¾ç½®');
console.log('   - resetAllRangeSettings(): é‡ç½®æ‰€æœ‰è°±å·çš„éŸ³åŸŸè®¾ç½®');
console.log('   - updateUIForClefRange("treble/alto/bass"): æ›´æ–°UIæ˜¾ç¤ºä¸ºæŒ‡å®šè°±å·çš„éŸ³åŸŸ');
console.log('   - inspectOSMD(): æ£€æŸ¥OSMDå®é™…å¯ç”¨çš„å±æ€§ï¼ˆéœ€è¦å…ˆæœ‰å®ä¾‹ï¼‰');
console.log('   - force4MeasuresPerLine(): å¼ºåˆ¶åº”ç”¨4å°èŠ‚å¸ƒå±€');
console.log('ğŸ“ ç›®æ ‡: æ‰€æœ‰è®¾å¤‡å¼ºåˆ¶4å°èŠ‚æ¯è¡Œ');
console.log('');
console.log('ğŸš€ è¯·åœ¨æ§åˆ¶å°è¿è¡Œ: testSimpleOSMD()');
console.log('   è¿™å°†åˆ›å»ºOSMDå®ä¾‹å¹¶æµ‹è¯•4å°èŠ‚å¸ƒå±€');

// ====== 6/8æ‹ä¸“ç”¨UIæ›´æ–°å‡½æ•° ======

/**
 * æ›´æ–°æ‹å·ç±»å‹ä¿¡æ¯å’Œ6/8æ‹ä¸“ç”¨é¢æ¿
 */
function updateTimeSignatureInfo(timeSignature, stats) {
    // æ›´æ–°æ‹å·ç±»å‹æ˜¾ç¤º
    const timeSigElement = document.getElementById('timeSigType');
    const timeSigInfo = document.getElementById('timeSigInfo');
    
    if (!timeSigElement || !timeSigInfo) return;
    
    // æ ¹æ®æ‹å·è®¾ç½®æ˜¾ç¤ºå†…å®¹
    switch (timeSignature) {
        case '6/8':
            timeSigElement.textContent = '6/8 å¤åˆäºŒæ‹å­';
            timeSigElement.classList.add('highlight');
            timeSigInfo.style.display = 'block';
            
            // æ›´æ–°6/8æ‹ä¸“ç”¨ä¿¡æ¯
            update68Info(stats);
            break;
        case '4/4':
            timeSigElement.textContent = '4/4 ç®€å•å››æ‹å­';
            timeSigElement.classList.remove('highlight');
            timeSigInfo.style.display = 'none';
            break;
        case '3/4':
            timeSigElement.textContent = '3/4 ç®€å•ä¸‰æ‹å­';
            timeSigElement.classList.remove('highlight');
            timeSigInfo.style.display = 'none';
            break;
        case '2/4':
            timeSigElement.textContent = '2/4 ç®€å•äºŒæ‹å­';
            timeSigElement.classList.remove('highlight');
            timeSigInfo.style.display = 'none';
            break;
        default:
            timeSigElement.textContent = timeSignature;
            timeSigElement.classList.remove('highlight');
            timeSigInfo.style.display = 'none';
    }
}

/**
 * æ›´æ–°6/8æ‹ä¸“ç”¨ä¿¡æ¯é¢æ¿
 */
function update68Info(stats) {
    // åˆ†æbeamç»„æ•°é‡ï¼Œç¡®å®šæ˜¯å¦æ­£ç¡®å®ç°äº†3+3åˆ†ç»„
    const expectedBeams = Math.floor(stats.noteCount * 0.6); // å‡è®¾60%çš„éŸ³ç¬¦éœ€è¦beamè¿æ¥
    const beamEfficiency = stats.beamCount > 0 ? 
        Math.min(100, (stats.beamCount / Math.max(1, expectedBeams) * 100)) : 0;
    
    // æ ¹æ®ä¼‘æ­¢ç¬¦æ¯”ä¾‹å’Œbeamè¿æ¥æƒ…å†µåˆ¤æ–­èŠ‚å¥ç‰¹ç‚¹
    let rhythmFeature = 'æ ‡å‡†æµåŠ¨';
    if (stats.restRatio > 0.3) {
        rhythmFeature = 'è·³è·ƒæ„Ÿå¼º';
    } else if (beamEfficiency > 70) {
        rhythmFeature = 'è¿ç»µæµç•…';
    } else if (stats.beamCount < 2) {
        rhythmFeature = 'ç‹¬ç«‹éŸ³ç¬¦';
    }
    
    // æ›´æ–°æ˜¾ç¤º
    const meterTypeElement = document.getElementById('meterType');
    const beamGroupsElement = document.getElementById('beamGroups');
    const strongBeatsElement = document.getElementById('strongBeats');
    const rhythmFeaturesElement = document.getElementById('rhythmFeatures');
    
    if (meterTypeElement) meterTypeElement.textContent = 'å¤åˆäºŒæ‹å­';
    if (beamGroupsElement) {
        beamGroupsElement.textContent = stats.beamCount > 0 ? 
            `3+3åˆ†ç»„ (${stats.beamCount}ç»„)` : '3+3åˆ†ç»„';
    }
    if (strongBeatsElement) strongBeatsElement.textContent = '0.0, 1.5æ‹';
    if (rhythmFeaturesElement) rhythmFeaturesElement.textContent = rhythmFeature;
    
    console.log(`ğŸµ 6/8æ‹åˆ†æ: beamç»„${stats.beamCount}ä¸ª, èŠ‚å¥ç‰¹ç‚¹: ${rhythmFeature}`);
}

// ====== 6/8æ‹Beat Clarityè§„åˆ™å®ç° ======

/**
 * ğŸ”¥ å…¨æ–°ç®€åŒ–ç‰ˆï¼š6/8æ‹åå…­åˆ†éŸ³ç¬¦ç”Ÿæˆå™¨
 * æŠ›å¼ƒæ‰€æœ‰å¤æ‚é€»è¾‘ï¼Œä½¿ç”¨ç›´æ¥æœ‰æ•ˆçš„æ–¹æ³•
 */
function generate68MeasureWithBeatClarity(measureNumber, currentMidi, scale, userRange, maxJump, isLastMeasure, random, needsPhraseBreathe = false, clef = 'treble', keySignature = 'C', accidentalRate = 0, slideAssignmentState = null) {
    console.log('ğŸ¼ [Cantus Firmusé£æ ¼] 6/8æ‹æ—‹å¾‹ç”Ÿæˆå™¨');
    console.log(`ğŸ¯ ä¸´æ—¶è®°å·æ¦‚ç‡: ${(accidentalRate * 100).toFixed(0)}%`);
    const activeSlideState = slideAssignmentState || createSlideAssignmentState(random);
    
    const chromaticState = { active: false, remaining: 0, direction: 0 };
    let pendingAccidentalPreference = null;

    function resetChromaticRun() {
        chromaticState.active = false;
        chromaticState.remaining = 0;
        chromaticState.direction = 0;
    }

    function getChromaticRunLength() {
        let maxLen = 2;
        if (accidentalRate >= 0.75) {
            maxLen = 4;
        } else if (accidentalRate >= 0.45) {
            maxLen = 3;
        }
        return random.nextInt(2, maxLen + 1);
    }

    function determineChromaticDirection(lastMidi, targetMidi) {
        if (typeof lastMidi !== 'number') return 1;
        if (typeof targetMidi !== 'number') {
            return random.nextFloat() < 0.5 ? 1 : -1;
        }
        const direction = Math.sign(targetMidi - lastMidi);
        if (direction === 0) {
            return random.nextFloat() < 0.5 ? 1 : -1;
        }
        return direction > 0 ? 1 : -1;
    }

    function isChromaticStepValid(midi) {
        return midi >= userRange.min && midi <= userRange.max;
    }

    function queueAccidentalPreference(midi, direction) {
        const preference = direction > 0 ? '#' : 'b';
        pendingAccidentalPreference = { midi, preference };
    }

    function consumeAccidentalPreference(midi) {
        if (pendingAccidentalPreference) {
            if (pendingAccidentalPreference.midi === midi) {
                const preference = pendingAccidentalPreference.preference;
                pendingAccidentalPreference = null;
                return preference;
            }
            pendingAccidentalPreference = null;
        }
        return null;
    }

    // ğŸ”¥ æ”¹ä¸ºåŠéŸ³é˜¶è¿æ¥é€»è¾‘çš„ä¸´æ—¶è®°å·å¤„ç†
    function addAccidentalIfNeeded(midi, lastMidi = null) {
        if (!accidentalRate || accidentalRate <= 0) {
            resetChromaticRun();
            return midi;
        }
        if (typeof lastMidi !== 'number') {
            resetChromaticRun();
            return midi;
        }
        const interval = Math.abs(midi - lastMidi);
        const allowStepwiseRun = interval <= 2;

        if (chromaticState.active && chromaticState.remaining > 0) {
            if (!allowStepwiseRun) {
                resetChromaticRun();
                return midi;
            }
            const nextMidi = lastMidi + chromaticState.direction;
            if (isChromaticStepValid(nextMidi)) {
                chromaticState.remaining -= 1;
                if (chromaticState.remaining <= 0) {
                    resetChromaticRun();
                }
                queueAccidentalPreference(nextMidi, chromaticState.direction);
                return nextMidi;
            }
            resetChromaticRun();
            return midi;
        }

        if (!allowStepwiseRun || random.nextFloat() >= accidentalRate) {
            return midi;
        }

        const direction = determineChromaticDirection(lastMidi, midi);
        const nextMidi = lastMidi + direction;
        if (!isChromaticStepValid(nextMidi)) {
            return midi;
        }

        const runLength = getChromaticRunLength();
        chromaticState.active = runLength > 1;
        chromaticState.remaining = Math.max(0, runLength - 1);
        chromaticState.direction = direction;
        queueAccidentalPreference(nextMidi, direction);
        return nextMidi;
    }
    
    // ğŸ”¥ ä¿®å¤è°ƒå·å¤„ç†ï¼šåˆ›å»ºä¸´æ—¶ç”Ÿæˆå™¨ç”¨äºæ­£ç¡®çš„éŸ³ç¬¦æ‹¼å†™
    const tempGenerator = new IntelligentMelodyGenerator(1, keySignature, '6/8', clef, random.seed || 12345);
    
    // å®šä¹‰ä½¿ç”¨æ­£ç¡®è°ƒå·é€»è¾‘çš„éŸ³ç¬¦ä¿¡æ¯è½¬æ¢å‡½æ•°
    function midiToNoteInfoWithCorrectSpelling(midi) {
        const preferredAccidental = consumeAccidentalPreference(midi);
        const result = tempGenerator.midiToMusicXML(midi, preferredAccidental);
        return {
            midi: midi,
            step: result.step,
            alter: result.alter,
            octave: result.octave
        };
    }
    
    // ğŸ¯ ä¸¥æ ¼éµå®ˆç”¨æˆ·è®¾ç½®
    const userRhythms = (typeof userSettings !== 'undefined' && Array.isArray(userSettings.allowedRhythms)) ? 
        userSettings.allowedRhythms : ['eighth'];
    const allowDottedNotes = (typeof userSettings !== 'undefined') ? userSettings.allowDottedNotes : false;
    // allowUpbeat setting removed
    
    // ç¡®ä¿ç”¨æˆ·è®¾ç½®æœ‰æ•ˆ
    const safeUserRange = userRange || { min: 60, max: 79 };
    // ğŸ”¥ 6/8æ‹éŸ³ç¨‹è·¨åº¦æœ€é«˜ä¼˜å…ˆæƒï¼šä¸¥æ ¼éµå¾ªæœ€å°å‹¾é€‰éŸ³ç¨‹ä½œä¸ºæœ€å¤§è·¨åº¦
    const safeMaxJump = maxJump || 12; // æ¥è‡ªä¸»å‡½æ•°çš„æœ€å°å‹¾é€‰éŸ³ç¨‹
    const safeScale = scale || [0, 2, 4, 5, 7, 9, 11];
    
    // ğŸš¨ 6/8æ‹éŸ³ç¨‹è·¨åº¦éªŒè¯ - æœ€é«˜ä¼˜å…ˆæƒ
    console.log(`ğŸ¯ 6/8æ‹éŸ³ç¨‹è·¨åº¦éªŒè¯ï¼šä¸¥æ ¼é™åˆ¶ä¸º ${safeMaxJump} åŠéŸ³ (æ¥è‡ªç”¨æˆ·å‹¾é€‰çš„æœ€å°éŸ³ç¨‹)`);
    if (typeof userSettings !== 'undefined' && userSettings.allowedIntervals) {
        const minAllowedInterval = Math.min(...userSettings.allowedIntervals);
        if (safeMaxJump !== minAllowedInterval) {
            console.warn(`âš ï¸ 6/8æ‹éŸ³ç¨‹è·¨åº¦ä¸åŒ¹é…! æœŸæœ›: ${minAllowedInterval}, å®é™…: ${safeMaxJump}`);
        } else {
            console.log(`âœ… 6/8æ‹éŸ³ç¨‹è·¨åº¦æ­£ç¡®ï¼š${safeMaxJump} åŠéŸ³`);
        }
    }
    
    const has16th = userRhythms.includes('16th') || userRhythms.includes('sixteenth');
    const hasEighth = userRhythms.includes('eighth') || userRhythms.includes('8th');
    const hasQuarter = userRhythms.includes('quarter') || userRhythms.includes('4th');
    // ğŸ”¥ ä¿®å¤é™„ç‚¹å››åˆ†éŸ³ç¬¦æ£€æµ‹ç¼ºå¤±é—®é¢˜
    const hasDottedQuarter = userRhythms.includes('quarter.') || userRhythms.includes('dotted-quarter');
    const hasHalf = userRhythms.includes('half') || userRhythms.includes('2nd');
    const hasDuplet = userRhythms.includes('duplet');
    const hasQuadruplet = userRhythms.includes('quadruplet');
    
    console.log(`ğŸ›ï¸ ç”¨æˆ·è®¾ç½®ä¸¥æ ¼æ¨¡å¼:`);
    console.log(`  - éŸ³åŸŸ: MIDI ${safeUserRange.min}-${safeUserRange.max}`);
    console.log(`  - æœ€å¤§è·³åº¦: ${safeMaxJump}åŠéŸ³`);
    console.log(`  - å…è®¸èŠ‚å¥: [${userRhythms.join(', ')}]`);
    console.log(`  - åå…­åˆ†éŸ³ç¬¦: ${has16th}, å…«åˆ†éŸ³ç¬¦: ${hasEighth}, å››åˆ†éŸ³ç¬¦: ${hasQuarter}, äºŒåˆ†éŸ³ç¬¦: ${hasHalf}`);
    console.log(`  - äºŒè¿éŸ³: ${hasDuplet}, å››è¿éŸ³: ${hasQuadruplet}`);
    console.log(`  - å…è®¸é™„ç‚¹: ${allowDottedNotes}`);
    // allowUpbeat console log removed
    
    // ğŸµ 6/8æ‹æ­£ç¡®çš„èŠ‚å¥æ¨¡å¼ - å¼ºè°ƒ0.0å’Œ1.5æ‹
    const notes = [];
    
    // å®šä¹‰6/8æ‹çš„æ—¶é—´ä½ç½® (divisions=4æ—¶)
    const BEAT_POSITIONS = {
        strong1: 0.0,      // ç¬¬1å¼ºæ‹ (ç¬¬1ä¸ªå…«åˆ†éŸ³ç¬¦)
        weak1: 0.5,        // å¼±æ‹ (ç¬¬2ä¸ªå…«åˆ†éŸ³ç¬¦) 
        weak2: 1.0,        // å¼±æ‹ (ç¬¬3ä¸ªå…«åˆ†éŸ³ç¬¦)
        strong2: 1.5,      // ç¬¬2å¼ºæ‹ (ç¬¬4ä¸ªå…«åˆ†éŸ³ç¬¦)
        weak3: 2.0,        // å¼±æ‹ (ç¬¬5ä¸ªå…«åˆ†éŸ³ç¬¦)
        weak4: 2.5         // å¼±æ‹ (ç¬¬6ä¸ªå…«åˆ†éŸ³ç¬¦)
    };
    
    // æ ¹æ®ç”¨æˆ·è®¾ç½®æ„å»ºå¯ç”¨çš„èŠ‚å¥æ¨¡å¼
    let availablePatterns = [];
    
    // ğŸ”¥ å¼ºåŒ–é¢‘ç‡æ§åˆ¶ï¼š6/8æ‹èŠ‚å¥ç±»å‹æ˜ å°„åˆ°4/4æ‹å¯¹åº”é¢‘ç‡è®¾ç½®
    const isEighthAllowed = hasEighth && (userSettings?.rhythmFrequencies?.eighth === undefined || userSettings.rhythmFrequencies.eighth > 0);
    const isQuarterAllowed = hasQuarter && (userSettings?.rhythmFrequencies?.quarter === undefined || userSettings.rhythmFrequencies.quarter > 0);
    // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹ä¸­çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
    const isDottedQuarterAllowed = hasDottedQuarter &&
                                  (userSettings?.rhythmFrequencies?.['dotted-quarter'] === undefined || userSettings.rhythmFrequencies['dotted-quarter'] > 0);
    const isHalfAllowed = hasHalf && (userSettings?.rhythmFrequencies?.half === undefined || userSettings.rhythmFrequencies.half > 0);
    // ğŸ”¥ 6/8æ‹ä¸­çš„é™„ç‚¹äºŒåˆ†éŸ³ç¬¦å¯¹åº”4/4æ‹ä¸­çš„å…¨éŸ³ç¬¦
    const isDottedHalfAllowed = (userRhythms.includes('half.') || userRhythms.includes('dotted-half')) && 
                               (userSettings?.rhythmFrequencies?.whole === undefined || userSettings.rhythmFrequencies.whole > 0);
    const is16thAllowed = has16th && (userSettings?.rhythmFrequencies?.['16th'] === undefined || userSettings.rhythmFrequencies['16th'] > 0);
    // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹ä¸­çš„äºŒè¿éŸ³å’Œå››è¿éŸ³åº”è¯¥ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
    const isDupletAllowed = hasDuplet && (userSettings?.rhythmFrequencies?.duplet === undefined || userSettings.rhythmFrequencies.duplet > 0);
    const isQuadrupletAllowed = hasQuadruplet && (userSettings?.rhythmFrequencies?.quadruplet === undefined || userSettings.rhythmFrequencies.quadruplet > 0);
    
    console.log(`ğŸ”¥ 6/8æ‹é«˜çº§é¢‘ç‡æ§åˆ¶æ£€æŸ¥ç»“æœï¼ˆæ˜ å°„åˆ°4/4æ‹å¯¹åº”é¢‘ç‡ï¼‰:`);
    console.log(`  - å…«åˆ†éŸ³ç¬¦: ${hasEighth} && eighth_freq=${userSettings?.rhythmFrequencies?.eighth}% -> ${isEighthAllowed}`);
    console.log(`  - å››åˆ†éŸ³ç¬¦: ${hasQuarter} && quarter_freq=${userSettings?.rhythmFrequencies?.quarter}% -> ${isQuarterAllowed}`);
    // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹ä¸­çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
    console.log(`  - é™„ç‚¹å››åˆ†éŸ³ç¬¦: ${hasDottedQuarter} && dotted-quarter_freq=${userSettings?.rhythmFrequencies?.['dotted-quarter']}% -> ${isDottedQuarterAllowed}`);
    console.log(`  - äºŒåˆ†éŸ³ç¬¦: ${hasHalf} && half_freq=${userSettings?.rhythmFrequencies?.half}% -> ${isHalfAllowed}`);
    // ğŸ”¥ 6/8æ‹ä¸­çš„é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ä½¿ç”¨4/4æ‹çš„å…¨éŸ³ç¬¦é¢‘ç‡
    console.log(`  - é™„ç‚¹äºŒåˆ†éŸ³ç¬¦: ${userRhythms.includes('half.') || userRhythms.includes('dotted-half')} && whole_freq=${userSettings?.rhythmFrequencies?.whole}% -> ${isDottedHalfAllowed}`);
    console.log(`  - åå…­åˆ†éŸ³ç¬¦: ${has16th} && 16th_freq=${userSettings?.rhythmFrequencies?.['16th']}% -> ${is16thAllowed}`);
    // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹ä¸­çš„äºŒè¿éŸ³å’Œå››è¿éŸ³ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
    console.log(`  - äºŒè¿éŸ³: ${hasDuplet} && duplet_freq=${userSettings?.rhythmFrequencies?.duplet}% -> ${isDupletAllowed}`);
    console.log(`  - å››è¿éŸ³: ${hasQuadruplet} && quadruplet_freq=${userSettings?.rhythmFrequencies?.quadruplet}% -> ${isQuadrupletAllowed}`);
    
    // åŸºç¡€å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰
    if (isEighthAllowed) {
        availablePatterns.push({
            name: 'æ ‡å‡†å…«åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },   // å¼ºæ‹
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },   // å¼ºæ‹
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }   // å¼±æ‹
            ]
        });
        console.log(`âœ… æ·»åŠ å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆé€šè¿‡é¢‘ç‡æ§åˆ¶ï¼‰`);
    } else {
        console.log(`ğŸš« è·³è¿‡å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆè¢«é«˜çº§è®¾ç½®é˜»æ­¢ï¼‰`);
    }
    
    // ğŸ”¥ æ·»åŠ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰
    if (isDottedHalfAllowed) {
        availablePatterns.push({
            name: 'æ•´å°èŠ‚é™„ç‚¹äºŒåˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 12, type: 'half', dots: 1, isStrong: true } // æ•´å°èŠ‚: é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆ12ä¸ªdivisions = 3ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
            ]
        });
        console.log(`âœ… æ·»åŠ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼‰`);
    } else {
        console.log(`ğŸš« è·³è¿‡é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆè¢«4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡è®¾ç½®é˜»æ­¢ï¼‰`);
    }
    
    // å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰- ğŸ”¥ ä¿®å¤ï¼šåŒ…æ‹¬é™„ç‚¹å››åˆ†éŸ³ç¬¦
    if ((isQuarterAllowed || isDottedQuarterAllowed) && isEighthAllowed) {
        availablePatterns.push({
            name: 'å¼ºæ‹å››åˆ†éŸ³ç¬¦1',
            rhythm: [
                { position: 0.0, duration: 4, type: 'quarter', isStrong: true },  // å¼ºæ‹é•¿éŸ³
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },   // å¼ºæ‹
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }   // å¼±æ‹
            ]
        });
        
        availablePatterns.push({
            name: 'å¼ºæ‹å››åˆ†éŸ³ç¬¦2', 
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },   // å¼ºæ‹
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },  // å¼±æ‹
                { position: 1.5, duration: 4, type: 'quarter', isStrong: true },  // å¼ºæ‹é•¿éŸ³
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }   // å¼±æ‹
            ]
        });
    }
    
    // æ›´å¤šå››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰- ğŸ”¥ ä¿®å¤ï¼šåŒ…æ‹¬é™„ç‚¹å››åˆ†éŸ³ç¬¦
    if (isQuarterAllowed || isDottedQuarterAllowed) {
        // å››åˆ†éŸ³ç¬¦æ¨¡å¼3: é€‚åˆ6/8æ‹çš„å››åˆ†éŸ³ç¬¦å¼ºæ‹æ¨¡å¼
        availablePatterns.push({
            name: '6/8æ‹å››åˆ†éŸ³ç¬¦å¼ºæ‹',
            rhythm: [
                { position: 0.0, duration: 4, type: 'quarter', isStrong: true },     // ç¬¬1ç»„å¼ºæ‹é•¿éŸ³ (0-1æ‹)
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„å¼±æ‹ä¼‘æ­¢ (1-1.5æ‹ï¼Œè°ƒæ•´ä¸ºå…«åˆ†ä¼‘æ­¢ç¬¦)
                { position: 1.5, duration: 4, type: 'quarter', isStrong: true },     // ç¬¬2ç»„å¼ºæ‹é•¿éŸ³ (1.5-2.5æ‹)
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„å¼±æ‹ä¼‘æ­¢ (2.5-3æ‹ï¼Œè°ƒæ•´ä¸ºå…«åˆ†ä¼‘æ­¢ç¬¦)
            ]
        });

        // å››åˆ†éŸ³ç¬¦æ¨¡å¼4: ç¬¬ä¸€ç»„å››åˆ†éŸ³ç¬¦ï¼Œç¬¬äºŒç»„ç©º
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 4, type: 'quarter', isStrong: true },     // ç¬¬1ç»„: 1æ‹é•¿éŸ³
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢ (1-1.5æ‹ï¼Œè°ƒæ•´ä¸ºå…«åˆ†ä¼‘æ­¢ç¬¦)
                { position: 1.5, duration: 6, type: 'quarter', dots: 1, isStrong: true }  // ç¬¬2ç»„: æ•´ç»„é™„ç‚¹å››åˆ†éŸ³ç¬¦
            ]
        });

        // å››åˆ†éŸ³ç¬¦æ¨¡å¼5: ç¬¬äºŒç»„å››åˆ†éŸ³ç¬¦ï¼Œç¬¬ä¸€ç»„ç©º
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true }, // ç¬¬1ç»„: æ•´ç»„é™„ç‚¹å››åˆ†éŸ³ç¬¦
                { position: 1.5, duration: 4, type: 'quarter', isStrong: true },     // ç¬¬2ç»„: 1æ‹é•¿éŸ³ (1.5-2.5æ‹)
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„: 3æ‹ä¼‘æ­¢ (2.5-3æ‹ï¼Œè°ƒæ•´ä¸ºå…«åˆ†ä¼‘æ­¢ç¬¦)
            ]
        });

        // å››åˆ†éŸ³ç¬¦æ¨¡å¼6: åˆ†å¸ƒå¼å››åˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'åˆ†å¸ƒå¼å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 4, type: 'quarter', isStrong: true },     // ç¬¬1ç»„: 1-2æ‹é•¿éŸ³
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢
                { position: 1.5, duration: 2, type: 'eighth-rest', isStrong: true }, // ç¬¬2ç»„: 1æ‹ä¼‘æ­¢
                { position: 2.0, duration: 4, type: 'quarter', isStrong: false }     // ç¬¬2ç»„: 2-3æ‹é•¿éŸ³
            ]
        });
    }

    // äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰
    if (isHalfAllowed) {
        // äºŒåˆ†éŸ³ç¬¦æ¨¡å¼1: æ•´å°èŠ‚é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'æ•´å°èŠ‚é™„ç‚¹äºŒåˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 12, type: 'half', dots: 1, isStrong: true } // æ•´å°èŠ‚: é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆ12ä¸ªdivisions = 3ä¸ªå››åˆ†éŸ³ç¬¦ï¼‰
            ]
        });

        // äºŒåˆ†éŸ³ç¬¦æ¨¡å¼2: ç¬¬ä¸€ç»„é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼Œç¬¬äºŒç»„é™„ç‚¹å››åˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'åŒé™„ç‚¹å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true }, // ç¬¬1ç»„: é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼ˆ6ä¸ªdivisions = 3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
                { position: 1.5, duration: 6, type: 'quarter', dots: 1, isStrong: true }  // ç¬¬2ç»„: é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼ˆ6ä¸ªdivisions = 3ä¸ªå…«åˆ†éŸ³ç¬¦ï¼‰
            ]
        });

        // äºŒåˆ†éŸ³ç¬¦æ¨¡å¼3: æ··åˆé™„ç‚¹å››åˆ†éŸ³ç¬¦ä¸åˆ†è§£éŸ³ç¬¦
        availablePatterns.push({
            name: 'æ··åˆé™„ç‚¹å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true }, // ç¬¬1ç»„: é™„ç‚¹å››åˆ†éŸ³ç¬¦
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },           // ç¬¬2ç»„: 1æ‹å…«åˆ†éŸ³ç¬¦  
                { position: 2.0, duration: 4, type: 'quarter', isStrong: false }          // ç¬¬2ç»„: 2-3æ‹å››åˆ†éŸ³ç¬¦
            ]
        });
    }

    // é™„ç‚¹éŸ³ç¬¦æ¨¡å¼ï¼ˆå¦‚æœå…è®¸ï¼‰
    if (allowDottedNotes && hasQuarter && hasEighth) {
        availablePatterns.push({
            name: 'é™„ç‚¹å››åˆ†éŸ³ç¬¦',
            rhythm: [
                { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true },  // å¼ºæ‹é™„ç‚¹
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },            // å¼ºæ‹
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },           // å¼±æ‹
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }            // å¼±æ‹
            ]
        });
    }
    
    // åå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰- ä¸¥æ ¼éµå¾ª6/8æ‹3+3åˆ†ç»„åŸåˆ™
    if (is16thAllowed && isEighthAllowed) {
        // æ¨¡å¼1: ç¬¬ä¸€ç»„å†…è£…é¥°ï¼ˆ0-1.5èŒƒå›´å†…çš„3æ‹åˆ†ç»„ï¼‰
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„è£…é¥°',
            rhythm: [
                { position: 0.0, duration: 1, type: '16th', isStrong: true },        // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.25, duration: 1, type: '16th', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 0.5, duration: 1, type: '16th', isStrong: false },       // ç¬¬1ç»„: 3æ‹å¼±
                { position: 0.75, duration: 1, type: '16th', isStrong: false },      // ç¬¬1ç»„: ç»­è£…é¥°
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: ç»“æŸ
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });

        // æ¨¡å¼2: ç¬¬äºŒç»„å†…è£…é¥°ï¼ˆ1.5-3.0èŒƒå›´å†…çš„3æ‹åˆ†ç»„ï¼‰
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„è£…é¥°',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 1, type: '16th', isStrong: true },        // ç¬¬2ç»„: 1æ‹å¼º
                { position: 1.75, duration: 1, type: '16th', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.0, duration: 1, type: '16th', isStrong: false },       // ç¬¬2ç»„: 3æ‹å¼±
                { position: 2.25, duration: 1, type: '16th', isStrong: false },      // ç¬¬2ç»„: ç»­è£…é¥°
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: ç»“æŸ
            ]
        });

        // æ¨¡å¼3: ç¬¬ä¸€ç»„å†…ç»è¿‡éŸ³è£…é¥°
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„ç»è¿‡éŸ³',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 1, type: '16th', isStrong: false },       // ç¬¬1ç»„: 2æ‹å¼±è£…é¥°
                { position: 0.75, duration: 1, type: '16th', isStrong: false },      // ç¬¬1ç»„: ç»è¿‡éŸ³
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });

        // æ¨¡å¼4: ç¬¬äºŒç»„å†…ç»è¿‡éŸ³è£…é¥°  
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„ç»è¿‡éŸ³',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 1, type: '16th', isStrong: false },       // ç¬¬2ç»„: 2æ‹å¼±è£…é¥°
                { position: 2.25, duration: 1, type: '16th', isStrong: false },      // ç¬¬2ç»„: ç»è¿‡éŸ³
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });

        // æ¨¡å¼5: åŒç»„è£…é¥°ï¼ˆä¸¤ä¸ªç»„éƒ½æœ‰è£…é¥°ï¼Œä¸¥æ ¼éµå¾ª3+3ï¼‰
        availablePatterns.push({
            name: 'åŒç»„è£…é¥°',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 1, type: '16th', isStrong: false },       // ç¬¬1ç»„: 2æ‹å¼±è£…é¥°
                { position: 0.75, duration: 1, type: '16th', isStrong: false },      // ç¬¬1ç»„: è£…é¥°ç»­
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 1, type: '16th', isStrong: false },       // ç¬¬2ç»„: 2æ‹å¼±è£…é¥°
                { position: 2.25, duration: 1, type: '16th', isStrong: false },      // ç¬¬2ç»„: è£…é¥°ç»­
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
    }
    
    // ä¼‘æ­¢ç¬¦æ¨¡å¼ï¼ˆå¤§å¹…å¢åŠ ä¼‘æ­¢ç¬¦çš„æ¯”ä¾‹å’Œéšæœºæ€§ï¼‰
    if (hasEighth) {
        // ä¼‘æ­¢ç¬¦æ¨¡å¼1: ç¬¬ä¸€ç»„ç¬¬1æ‹ä¼‘æ­¢ï¼ˆå¼ºæ‹ä¼‘æ­¢ï¼Œåˆ›é€ æ„å¤–æ„Ÿï¼‰
        availablePatterns.push({
            name: 'å¼ºæ‹ä¼‘æ­¢1',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬1ç»„: 1æ‹ä¼‘æ­¢ï¼
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼2: ç¬¬ä¸€ç»„ç¬¬2æ‹ä¼‘æ­¢
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„ç¬¬2æ‹ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 2æ‹ä¼‘æ­¢
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼3: ç¬¬ä¸€ç»„ç¬¬3æ‹ä¼‘æ­¢
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„ç¬¬3æ‹ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼4: æ¬¡å¼ºæ‹ä¼‘æ­¢ï¼ˆç¬¬äºŒç»„ç¬¬1æ‹ï¼‰
        availablePatterns.push({
            name: 'æ¬¡å¼ºæ‹ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬2ç»„: 1æ‹ä¼‘æ­¢ï¼
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼5: ç¬¬äºŒç»„ç¬¬2æ‹ä¼‘æ­¢
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„ç¬¬2æ‹ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼6: ç¬¬äºŒç»„ç¬¬3æ‹ä¼‘æ­¢
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„ç¬¬3æ‹ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„: 3æ‹ä¼‘æ­¢
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼7: è¿ç»­ä¼‘æ­¢ç¬¦ï¼ˆåˆå¹¶ä¸ºå››åˆ†ä¼‘æ­¢ç¬¦ï¼‰
        availablePatterns.push({
            name: 'è¿ç»­ä¼‘æ­¢ç¬¦1',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 2æ‹ä¼‘æ­¢ (0.5-1æ‹)
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢ (1-1.5æ‹)
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼8: ç¬¬äºŒç»„è¿ç»­ä¼‘æ­¢ç¬¦ï¼ˆåˆå¹¶ä¸ºå››åˆ†ä¼‘æ­¢ç¬¦ï¼‰
        availablePatterns.push({
            name: 'è¿ç»­ä¼‘æ­¢ç¬¦2',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢ (2-2.5æ‹)
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„: 3æ‹ä¼‘æ­¢ (2.5-3æ‹)
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼9: åˆ†æ•£ä¼‘æ­¢ç¬¦ï¼ˆä¸¤ç»„å„æœ‰ä¸€ä¸ªï¼‰
        availablePatterns.push({
            name: 'åˆ†æ•£ä¼‘æ­¢ç¬¦1',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬1ç»„: 1æ‹ä¼‘æ­¢
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼10: åˆ†æ•£ä¼‘æ­¢ç¬¦ï¼ˆä¸åŒä½ç½®ï¼‰
        availablePatterns.push({
            name: 'åˆ†æ•£ä¼‘æ­¢ç¬¦2',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 2æ‹ä¼‘æ­¢
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬2ç»„: 1æ‹ä¼‘æ­¢
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼11: ä¸‰ä¸ªä¼‘æ­¢ç¬¦ï¼ˆé«˜å¯†åº¦ä¼‘æ­¢ï¼‰
        availablePatterns.push({
            name: 'é«˜å¯†åº¦ä¼‘æ­¢ç¬¦',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬1ç»„: 1æ‹ä¼‘æ­¢
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // ä¼‘æ­¢ç¬¦æ¨¡å¼12: æç®€æ¨¡å¼ï¼ˆåªæœ‰ä¸¤ä¸ªéŸ³ç¬¦ï¼Œåˆå¹¶è¿ç»­ä¼‘æ­¢ç¬¦ï¼‰
        availablePatterns.push({
            name: 'æç®€ä¼‘æ­¢ç¬¦',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 2æ‹ä¼‘æ­¢ (0.5-1æ‹)
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢ (1-1.5æ‹)
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢ (2-2.5æ‹)
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„: 3æ‹ä¼‘æ­¢ (2.5-3æ‹)
            ]
        });
    }
    
    // ä¼‘æ­¢ç¬¦+åå…­åˆ†éŸ³ç¬¦æ··åˆæ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰
    if (isEighthAllowed && is16thAllowed) {
        // æ··åˆæ¨¡å¼1: ä¼‘æ­¢ç¬¦ä¸å•ç‹¬åå…­åˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'ä¼‘æ­¢ç¬¦åå…­åˆ†æ··åˆ1',
            rhythm: [
                { position: 0.0, duration: 1, type: '16th', isStrong: true },         // ç¬¬1ç»„: 1æ‹åå…­åˆ†
                { position: 0.25, duration: 1, type: '16th-rest', isStrong: false },  // åå…­åˆ†ä¼‘æ­¢
                { position: 0.5, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 2æ‹ä¼‘æ­¢
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 1, type: '16th', isStrong: false },        // ç¬¬2ç»„: 2æ‹åå…­åˆ†
                { position: 2.25, duration: 1, type: '16th-rest', isStrong: false },  // åå…­åˆ†ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // æ··åˆæ¨¡å¼2: å¤æ‚åˆ‡åˆ†ä¸ä¼‘æ­¢ç¬¦
        availablePatterns.push({
            name: 'å¤æ‚åˆ‡åˆ†ä¼‘æ­¢',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth-rest', isStrong: true },  // ç¬¬1ç»„: 1æ‹ä¼‘æ­¢
                { position: 0.5, duration: 1, type: '16th', isStrong: false },        // ç¬¬1ç»„: 2æ‹åå…­åˆ†
                { position: 0.75, duration: 1, type: '16th-rest', isStrong: false },  // åå…­åˆ†ä¼‘æ­¢
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 1, type: '16th-rest', isStrong: true },    // æ¬¡å¼ºæ‹ä¼‘æ­¢ï¼
                { position: 1.75, duration: 1, type: '16th', isStrong: false },       // ç¬¬2ç»„: åå…­åˆ†æ¢å¤
                { position: 2.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬2ç»„: 2æ‹ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // æ··åˆæ¨¡å¼3: äº¤æ›¿ä¼‘æ­¢ç¬¦å’Œåå…­åˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'äº¤æ›¿ä¼‘æ­¢åå…­åˆ†',
            rhythm: [
                { position: 0.0, duration: 1, type: '16th', isStrong: true },         // ç¬¬1ç»„: 1æ‹åå…­åˆ†
                { position: 0.25, duration: 1, type: '16th-rest', isStrong: false },  // åå…­åˆ†ä¼‘æ­¢
                { position: 0.5, duration: 1, type: '16th', isStrong: false },        // ç¬¬1ç»„: 2æ‹åå…­åˆ†
                { position: 0.75, duration: 1, type: '16th-rest', isStrong: false },  // åå…­åˆ†ä¼‘æ­¢
                { position: 1.0, duration: 2, type: 'eighth-rest', isStrong: false }, // ç¬¬1ç»„: 3æ‹ä¼‘æ­¢
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth-rest', isStrong: false }  // ç¬¬2ç»„: 3æ‹ä¼‘æ­¢
            ]
        });
    }
    
    // å•ç‹¬åå…­åˆ†éŸ³ç¬¦syncopationæ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰
    if (is16thAllowed && isEighthAllowed) {
        // Syncopationæ¨¡å¼1: å•ç‹¬åå…­åˆ†éŸ³ç¬¦åœ¨å¼±æ‹åˆ›é€ åˆ‡åˆ†
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„åˆ‡åˆ†',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 1, type: '16th', isStrong: false },       // å•ç‹¬åå…­åˆ†éŸ³ç¬¦ï¼
                { position: 1.25, duration: 1, type: '16th-rest', isStrong: false }, // åå…­åˆ†ä¼‘æ­¢ç¬¦
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼ºï¼ˆåˆ‡åˆ†æ•ˆæœï¼‰
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // Syncopationæ¨¡å¼2: æ¬¡å¼ºæ‹å‰çš„å•ç‹¬åå…­åˆ†éŸ³ç¬¦
        availablePatterns.push({
            name: 'æ¬¡å¼ºæ‹å‰åˆ‡åˆ†',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.25, duration: 1, type: '16th', isStrong: false },      // Sixteenth note pattern
                { position: 1.5, duration: 1, type: '16th-rest', isStrong: true },   // å¼ºæ‹ä¼‘æ­¢ï¼ˆåˆ‡åˆ†ï¼ï¼‰
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // Syncopationæ¨¡å¼3: ç¬¬äºŒç»„å†…çš„å•ç‹¬åå…­åˆ†éŸ³ç¬¦åˆ‡åˆ†
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„å†…åˆ‡åˆ†',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 1, type: '16th', isStrong: false },       // å•ç‹¬åå…­åˆ†ï¼
                { position: 2.25, duration: 1, type: '16th-rest', isStrong: false }, // åå…­åˆ†ä¼‘æ­¢
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // Syncopationæ¨¡å¼4: å¤æ‚åˆ‡åˆ†ï¼ˆå¤šä¸ªå•ç‹¬åå…­åˆ†éŸ³ç¬¦ï¼‰
        availablePatterns.push({
            name: 'å¤æ‚åˆ‡åˆ†',
            rhythm: [
                { position: 0.0, duration: 1, type: '16th', isStrong: true },        // å¼ºæ‹åå…­åˆ†
                { position: 0.25, duration: 1, type: '16th-rest', isStrong: false }, // åå…­åˆ†ä¼‘æ­¢
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 1, type: '16th', isStrong: false },       // å•ç‹¬åå…­åˆ†
                { position: 1.25, duration: 1, type: '16th-rest', isStrong: false }, // åå…­åˆ†ä¼‘æ­¢
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // Syncopationæ¨¡å¼5: è·¨ç»„åˆ‡åˆ†ï¼ˆç ´å3+3ç•Œé™çš„é”™è§‰ï¼‰
        availablePatterns.push({
            name: 'è·¨ç»„åˆ‡åˆ†é”™è§‰',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },      // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 1, type: '16th', isStrong: false },       // ç¬¬1ç»„æœ«å°¾
                { position: 1.25, duration: 1, type: '16th', isStrong: false },      // åˆ‡åˆ†åˆ°ç¬¬2ç»„å‰
                { position: 1.5, duration: 1, type: '16th-rest', isStrong: true },   // æ¬¡å¼ºæ‹ä¼‘æ­¢ï¼
                { position: 1.75, duration: 1, type: '16th', isStrong: false },      // æ¢å¤
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },     // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }      // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
    }
    
    if (availablePatterns.length === 0) {
        console.error('âŒ æ²¡æœ‰å¯ç”¨çš„èŠ‚å¥æ¨¡å¼ï¼Œæ ¹æ®ç”¨æˆ·è®¾ç½®åˆ›å»ºæœ€åå¤‡ç”¨æ¨¡å¼');
        
        // ğŸ”¥ ä¸¥æ ¼éµå¾ªç”¨æˆ·èŠ‚å¥è®¾ç½®ï¼Œåˆ›å»ºæœ€åçš„å¤‡ç”¨æ¨¡å¼
        if (isEighthAllowed) {
            console.error('âŒ åˆ›å»ºå¤‡ç”¨å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰');
            availablePatterns = [{
                name: 'æœ€åå¤‡ç”¨å…«åˆ†éŸ³ç¬¦',
                rhythm: [
                    { position: 0.0, duration: 2, type: 'eighth', isStrong: true },
                    { position: 0.5, duration: 2, type: 'eighth', isStrong: false },
                    { position: 1.0, duration: 2, type: 'eighth', isStrong: false },
                    { position: 1.5, duration: 2, type: 'eighth', isStrong: true },
                    { position: 2.0, duration: 2, type: 'eighth', isStrong: false },
                    { position: 2.5, duration: 2, type: 'eighth', isStrong: false }
                ]
            }];
        } else if (isDottedHalfAllowed) {
            console.error('âŒ åˆ›å»ºå¤‡ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰');
            availablePatterns = [{
                name: 'æœ€åå¤‡ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦',
                rhythm: [
                    { position: 0.0, duration: 12, type: 'half', dots: 1, isStrong: true }
                ]
            }];
        } else if (isQuarterAllowed || isDottedQuarterAllowed) {
            console.error('âŒ åˆ›å»ºå¤‡ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰å››åˆ†éŸ³ç¬¦æˆ–é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰');
            availablePatterns = [{
                name: 'æœ€åå¤‡ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦',
                rhythm: [
                    { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true },
                    { position: 1.5, duration: 6, type: 'quarter', dots: 1, isStrong: true }
                ]
            }];
        } else {
            // ğŸš¨ ç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨çš„èŠ‚å¥ç±»å‹ï¼Œåˆ›å»ºå…¨ä¼‘æ­¢ç¬¦å°èŠ‚
            console.error('âŒ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨äº6/8æ‹çš„èŠ‚å¥ç±»å‹ï¼');
            console.error('âŒ åˆ›å»ºå…¨ä¼‘æ­¢ç¬¦å°èŠ‚é¿å…å´©æºƒ');
            availablePatterns = [{
                name: 'å…¨ä¼‘æ­¢ç¬¦å°èŠ‚',
                rhythm: [
                    { position: 0.0, duration: 12, type: 'half-rest', dots: 1, isRest: true, isStrong: true }
                ]
            }];
        }
    }
    
    // ğŸ”¥ äºŒè¿éŸ³æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶ä¸”ä¸ä¸å…¶ä»–èŠ‚å¥ç±»å‹å†²çªæ—¶æ‰å¯ç”¨ï¼‰ - 6/8æ‹ä¸“ç”¨
    if (isDupletAllowed && isEighthAllowed) {
        // äºŒè¿éŸ³æ¨¡å¼1: ç¬¬ä¸€ç»„äºŒè¿éŸ³ï¼ˆéœ€è¦å…«åˆ†éŸ³ç¬¦æ”¯æŒï¼‰
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„äºŒè¿éŸ³',
            rhythm: [
                { position: 0.0, duration: 3, type: 'eighth', isStrong: true, tuplet: { type: 'duplet', position: 0, total: 2, id: 1 } },  // ç¬¬1ç»„: 1æ‹ (0.75æ‹å®é™…)
                { position: 0.75, duration: 3, type: 'eighth', isStrong: false, tuplet: { type: 'duplet', position: 1, total: 2, id: 1 } }, // ç¬¬1ç»„: 2æ‹ (0.75æ‹å®é™…)
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }       // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // äºŒè¿éŸ³æ¨¡å¼2: ç¬¬äºŒç»„äºŒè¿éŸ³
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„äºŒè¿éŸ³',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },       // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },      // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 3, type: 'eighth', isStrong: true, tuplet: { type: 'duplet', position: 0, total: 2, id: 1 } },  // ç¬¬2ç»„: 1æ‹ (0.75æ‹å®é™…)
                { position: 2.25, duration: 3, type: 'eighth', isStrong: false, tuplet: { type: 'duplet', position: 1, total: 2, id: 1 } } // ç¬¬2ç»„: 2-3æ‹ (0.75æ‹å®é™…)
            ]
        });
    }
    
    // å››è¿éŸ³æ¨¡å¼ï¼ˆåªæœ‰å½“é«˜çº§è®¾ç½®å…è®¸æ—¶æ‰å¯ç”¨ï¼‰ - 6/8æ‹ä¸“ç”¨
    if (isQuadrupletAllowed) {
        // å››è¿éŸ³æ¨¡å¼1: ç¬¬ä¸€ç»„å››è¿éŸ³
        availablePatterns.push({
            name: 'ç¬¬ä¸€ç»„å››è¿éŸ³',
            rhythm: [
                { position: 0.0, duration: 1.5, type: 'eighth', isStrong: true, tuplet: { type: 'quadruplet', position: 0, total: 4, id: 1 } },   // ç¬¬1ç»„: 1æ‹ (0.375æ‹å®é™…)
                { position: 0.375, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 1, total: 4, id: 1 } }, // ç¬¬1ç»„: 2æ‹ (0.375æ‹å®é™…)
                { position: 0.75, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 2, total: 4, id: 1 } },  // ç¬¬1ç»„: 3æ‹ (0.375æ‹å®é™…)
                { position: 1.125, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 3, total: 4, id: 1 } }, // ç¬¬1ç»„: å‰©ä½™ (0.375æ‹å®é™…)
                { position: 1.5, duration: 2, type: 'eighth', isStrong: true },        // ç¬¬2ç»„: 1æ‹å¼º
                { position: 2.0, duration: 2, type: 'eighth', isStrong: false },       // ç¬¬2ç»„: 2æ‹å¼±
                { position: 2.5, duration: 2, type: 'eighth', isStrong: false }        // ç¬¬2ç»„: 3æ‹å¼±
            ]
        });
        
        // å››è¿éŸ³æ¨¡å¼2: ç¬¬äºŒç»„å››è¿éŸ³
        availablePatterns.push({
            name: 'ç¬¬äºŒç»„å››è¿éŸ³',
            rhythm: [
                { position: 0.0, duration: 2, type: 'eighth', isStrong: true },        // ç¬¬1ç»„: 1æ‹å¼º
                { position: 0.5, duration: 2, type: 'eighth', isStrong: false },       // ç¬¬1ç»„: 2æ‹å¼±
                { position: 1.0, duration: 2, type: 'eighth', isStrong: false },       // ç¬¬1ç»„: 3æ‹å¼±
                { position: 1.5, duration: 1.5, type: 'eighth', isStrong: true, tuplet: { type: 'quadruplet', position: 0, total: 4, id: 1 } },   // ç¬¬2ç»„: 1æ‹ (0.375æ‹å®é™…)
                { position: 1.875, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 1, total: 4, id: 1 } }, // ç¬¬2ç»„: 2æ‹ (0.375æ‹å®é™…)
                { position: 2.25, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 2, total: 4, id: 1 } },  // ç¬¬2ç»„: 3æ‹ (0.375æ‹å®é™…)
                { position: 2.625, duration: 1.5, type: 'eighth', isStrong: false, tuplet: { type: 'quadruplet', position: 3, total: 4, id: 1 } }  // ç¬¬2ç»„: å‰©ä½™ (0.375æ‹å®é™…)
            ]
        });
    }
    
    // ğŸµ å¦‚æœéœ€è¦ä¹å¥å‘¼å¸ï¼Œä¼˜å…ˆé€‰æ‹©æœ‰ä¼‘æ­¢ç¬¦çš„æ¨¡å¼æˆ–åœ¨ç»“å°¾æ·»åŠ ä¼‘æ­¢ç¬¦
    if (needsPhraseBreathe) {
        console.log(`ğŸµ ç¬¬${measureNumber}å°èŠ‚éœ€è¦ä¹å¥å‘¼å¸ï¼Œè°ƒæ•´æ¨¡å¼é€‰æ‹©`);
        
        // ä¼˜å…ˆé€‰æ‹©å·²æœ‰ä¼‘æ­¢ç¬¦çš„æ¨¡å¼
        const restPatterns = availablePatterns.filter(p => 
            p.name.includes('ä¼‘æ­¢ç¬¦') || p.name.includes('ä¼‘æ­¢') || p.name.includes('å‘¼å¸')
        );
        
        if (restPatterns.length > 0) {
            const selectedRestPattern = restPatterns[random.nextInt(0, restPatterns.length)];
            console.log(`ğŸµ é€‰æ‹©ä¹å¥å‘¼å¸æ¨¡å¼: ${selectedRestPattern.name}`);
            
            // ä½¿ç”¨ä¼‘æ­¢ç¬¦æ¨¡å¼
            var selectedPattern = selectedRestPattern;
        } else {
            // å¦‚æœæ²¡æœ‰ç°æˆçš„ä¼‘æ­¢ç¬¦æ¨¡å¼ï¼Œä¿®æ”¹ç°æœ‰æ¨¡å¼åœ¨æœ«å°¾æ·»åŠ ä¼‘æ­¢ç¬¦
            const basePattern = availablePatterns[random.nextInt(0, availablePatterns.length)];
            console.log(`ğŸµ ä¿®æ”¹æ¨¡å¼æ·»åŠ ä¹å¥å‘¼å¸: ${basePattern.name} -> æœ«å°¾ä¼‘æ­¢ç¬¦`);
            
            // åˆ›å»ºä¿®æ”¹åçš„æ¨¡å¼ï¼Œå°†æœ€åä¸€ä¸ªéŸ³ç¬¦æ”¹ä¸ºä¼‘æ­¢ç¬¦
            const modifiedRhythm = [...basePattern.rhythm];
            if (modifiedRhythm.length > 0) {
                const lastNote = modifiedRhythm[modifiedRhythm.length - 1];
                modifiedRhythm[modifiedRhythm.length - 1] = {
                    ...lastNote,
                    type: lastNote.type.includes('rest') ? lastNote.type : lastNote.type + '-rest',
                    isRest: true
                };
            }
            
            var selectedPattern = {
                ...basePattern,
                name: basePattern.name + ' (ä¹å¥å‘¼å¸)',
                rhythm: modifiedRhythm
            };
        }
    } else {
        // ä½¿ç”¨æƒé‡é€‰æ‹©èŠ‚å¥æ¨¡å¼ï¼Œç¡®ä¿å››åˆ†éŸ³ç¬¦20%é¢‘ç‡ï¼ŒäºŒåˆ†éŸ³ç¬¦å°‘é‡å‡ºç°
        const patternWeights = availablePatterns.map(pattern => {
            let weight = 10; // åŸºç¡€æƒé‡

            // ğŸ”¥ åº”ç”¨é¢‘ç‡æ§åˆ¶åˆ°æƒé‡è®¡ç®—
            
            // ğŸ¯ å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼šåº”ç”¨é¢‘ç‡æ§åˆ¶
            if (pattern.name.includes('å››åˆ†éŸ³ç¬¦') || pattern.name.includes('quarter')) {
                if (userSettings?.rhythmFrequencies?.quarter !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.quarter;
                    if (userFreq === 0) {
                        console.log(`ğŸš« é«˜çº§è®¾ç½®é˜»æ­¢ï¼šå››åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                        console.log(`ğŸ¯ å››åˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼š${userFreq}% -> æƒé‡${weight}`);
                    }
                } else {
                    weight = 25; // é»˜è®¤æƒé‡
                    console.log(`ğŸµ å››åˆ†éŸ³ç¬¦æ¨¡å¼é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }
            // ğŸ¯ äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼šåº”ç”¨é¢‘ç‡æ§åˆ¶
            else if (pattern.name.includes('äºŒåˆ†éŸ³ç¬¦') || pattern.name.includes('half')) {
                if (userSettings?.rhythmFrequencies?.half !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.half;
                    if (userFreq === 0) {
                        console.log(`ğŸš« é«˜çº§è®¾ç½®é˜»æ­¢ï¼šäºŒåˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                        console.log(`ğŸ¯ äºŒåˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼š${userFreq}% -> æƒé‡${weight}`);
                    }
                } else {
                    weight = 8; // é»˜è®¤æƒé‡ï¼Œè¾ƒä½
                    console.log(`ğŸµ äºŒåˆ†éŸ³ç¬¦æ¨¡å¼é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }
            // ğŸ”¥ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼š6/8æ‹ä¸­ä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡
            else if (pattern.name.includes('é™„ç‚¹äºŒåˆ†éŸ³ç¬¦') || pattern.name.includes('dotted-half')) {
                if (userSettings?.rhythmFrequencies?.whole !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.whole;
                    if (userFreq === 0) {
                        console.log(`ğŸš« 6/8æ‹é«˜çº§è®¾ç½®é˜»æ­¢ï¼šé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼ˆä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡${userFreq}%ï¼‰ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                        console.log(`ğŸ¯ 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼ˆä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡ï¼‰ï¼š${userFreq}% -> æƒé‡${weight}`);
                    }
                } else {
                    weight = 12; // é»˜è®¤æƒé‡
                    console.log(`ğŸµ 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }
            // ğŸ¯ å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼šåº”ç”¨é¢‘ç‡æ§åˆ¶
            else if (pattern.name.includes('å…«åˆ†éŸ³ç¬¦') || pattern.name.includes('eighth')) {
                if (userSettings?.rhythmFrequencies?.eighth !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.eighth;
                    if (userFreq === 0) {
                        console.log(`ğŸš« é«˜çº§è®¾ç½®é˜»æ­¢ï¼šå…«åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º0%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç›´æ¥æ˜ å°„ï¼Œé¢‘ç‡ç­‰äºæƒé‡
                        weight = userFreq;
                        console.log(`ğŸ¯ å…«åˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼ˆç›´æ¥æ˜ å°„ï¼‰ï¼š${userFreq}% -> æƒé‡${weight}`);
                    }
                } else {
                    weight = 15; // é»˜è®¤æƒé‡
                    console.log(`ğŸµ å…«åˆ†éŸ³ç¬¦æ¨¡å¼é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }
            // ğŸ¶ åå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼šä¸­ç­‰æƒé‡ï¼ˆä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼‰
            else if (pattern.name.includes('åå…­åˆ†éŸ³ç¬¦') || pattern.name.includes('16th')) {
                weight = 12; // åŸºç¡€æƒé‡
                
                // æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„åå…­åˆ†éŸ³ç¬¦é¢‘ç‡
                if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['16th'] !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies['16th'];
                    if (userFreq === 0) {
                        console.log(`ğŸš« 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šåå…­åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º 0%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡ï¼ˆé¢‘ç‡100% = æƒé‡30ï¼‰
                        console.log(`ğŸ¯ 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šåå…­åˆ†éŸ³ç¬¦ = ${userFreq}%ï¼Œæƒé‡ = ${weight}`);
                    }
                }
            }
            // ğŸ¼ ä¼‘æ­¢ç¬¦æ¨¡å¼ï¼šä¸­ç­‰æƒé‡
            else if (pattern.name.includes('ä¼‘æ­¢ç¬¦') || pattern.name.includes('ä¼‘æ­¢')) {
                weight = 18;
            }
            // ğŸµ åˆ‡åˆ†å’Œç‰¹æ®Šæ¨¡å¼ï¼šè¾ƒä½æƒé‡
            else if (pattern.name.includes('åˆ‡åˆ†') || pattern.name.includes('syncopation')) {
                weight = 8;
            }
            // ğŸ¶ äºŒè¿éŸ³æ¨¡å¼ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®
            else if (pattern.name.includes('äºŒè¿éŸ³') || pattern.name.includes('duplet')) {
                weight = 30; // åŸºç¡€æƒé‡
                
                // ğŸ”¥ ä¿®å¤ï¼šæ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„äºŒè¿éŸ³é¢‘ç‡
                if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.duplet !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.duplet;
                    if (userFreq === 0) {
                        console.log(`ğŸš« 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šäºŒè¿éŸ³é¢‘ç‡${userFreq}%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                        console.log(`ğŸ¯ 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šäºŒè¿éŸ³ = ${userFreq}%ï¼Œæƒé‡ = ${weight}`);
                    }
                } else {
                    console.log(`ğŸµ 6/8æ‹äºŒè¿éŸ³æ¨¡å¼ä½¿ç”¨é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }
            // ğŸ¹ å››è¿éŸ³æ¨¡å¼ï¼šä½¿ç”¨ç”¨æˆ·é¢‘ç‡è®¾ç½®
            else if (pattern.name.includes('å››è¿éŸ³') || pattern.name.includes('quadruplet')) {
                weight = 25; // åŸºç¡€æƒé‡
                
                // ğŸ”¥ ä¿®å¤ï¼šæ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„å››è¿éŸ³é¢‘ç‡
                if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.quadruplet !== undefined) {
                    const userFreq = userSettings.rhythmFrequencies.quadruplet;
                    if (userFreq === 0) {
                        console.log(`ğŸš« 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šå››è¿éŸ³é¢‘ç‡${userFreq}%ï¼Œæƒé‡è®¾ä¸º0`);
                        weight = 0;
                    } else {
                        weight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                        console.log(`ğŸ¯ 6/8æ‹ç”¨æˆ·é¢‘ç‡è®¾ç½®ï¼šå››è¿éŸ³ = ${userFreq}%ï¼Œæƒé‡ = ${weight}`);
                    }
                } else {
                    console.log(`ğŸµ 6/8æ‹å››è¿éŸ³æ¨¡å¼ä½¿ç”¨é»˜è®¤æƒé‡: ${pattern.name} -> ${weight}`);
                }
            }

            return weight;
        });

        // ğŸ”¥ è¿‡æ»¤æ‰æƒé‡ä¸º0çš„æ¨¡å¼ï¼ˆè¢«é«˜çº§è®¾ç½®é˜»æ­¢çš„æ¨¡å¼ï¼‰
        const validPatterns = [];
        const validWeights = [];
        
        for (let i = 0; i < availablePatterns.length; i++) {
            if (patternWeights[i] > 0) {
                validPatterns.push(availablePatterns[i]);
                validWeights.push(patternWeights[i]);
            } else {
                console.log(`ğŸš« è¿‡æ»¤æ‰æƒé‡ä¸º0çš„æ¨¡å¼: ${availablePatterns[i].name}`);
            }
        }
        
        console.log(`ğŸ” æœ‰æ•ˆæ¨¡å¼æ•°é‡ï¼š${validPatterns.length}/${availablePatterns.length}`);
        
        if (validPatterns.length === 0) {
            console.error(`âŒ æ‰€æœ‰æ¨¡å¼éƒ½è¢«é¢‘ç‡æ§åˆ¶é˜»æ­¢ï¼éœ€è¦ä¸¥æ ¼éµå¾ªç”¨æˆ·èŠ‚å¥é€‰æ‹©`);
            // ğŸ”¥ ä¸¥æ ¼éµå¾ªç”¨æˆ·é€‰æ‹©çš„ç´§æ€¥å›é€€ï¼šåªä½¿ç”¨ç”¨æˆ·å‹¾é€‰çš„èŠ‚å¥ç±»å‹
            if (isEighthAllowed) {
                console.error(`âœ… ä¸¥æ ¼ç´§æ€¥å›é€€ï¼šä½¿ç”¨å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰`);
                var selectedPattern = {
                    name: 'ä¸¥æ ¼å…«åˆ†éŸ³ç¬¦ç´§æ€¥æ¨¡å¼',
                    rhythm: [
                        { position: 0.0, duration: 2, type: 'eighth', isStrong: true },
                        { position: 0.5, duration: 2, type: 'eighth', isStrong: false },
                        { position: 1.0, duration: 2, type: 'eighth', isStrong: false },
                        { position: 1.5, duration: 2, type: 'eighth', isStrong: true },
                        { position: 2.0, duration: 2, type: 'eighth', isStrong: false },
                        { position: 2.5, duration: 2, type: 'eighth', isStrong: false }
                    ]
                };
            } else if (isDottedHalfAllowed) {
                console.error(`âœ… ä¸¥æ ¼ç´§æ€¥å›é€€ï¼šä½¿ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰`);
                var selectedPattern = {
                    name: 'ä¸¥æ ¼é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ç´§æ€¥æ¨¡å¼',
                    rhythm: [
                        { position: 0.0, duration: 12, type: 'half', dots: 1, isStrong: true }
                    ]
                };
            } else if (isQuarterAllowed || isDottedQuarterAllowed) {
                console.error(`âœ… ä¸¥æ ¼ç´§æ€¥å›é€€ï¼šä½¿ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰å››åˆ†éŸ³ç¬¦æˆ–é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰`);
                var selectedPattern = {
                    name: 'ä¸¥æ ¼é™„ç‚¹å››åˆ†éŸ³ç¬¦ç´§æ€¥æ¨¡å¼',
                    rhythm: [
                        { position: 0.0, duration: 6, type: 'quarter', dots: 1, isStrong: true },
                        { position: 1.5, duration: 6, type: 'quarter', dots: 1, isStrong: true }
                    ]
                };
            } else {
                // ğŸš¨ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨äº6/8æ‹çš„èŠ‚å¥ç±»å‹
                console.error(`âŒ è‡´å‘½é”™è¯¯ï¼šæ— æ³•åˆ›å»º6/8æ‹ç´§æ€¥æ¨¡å¼ï¼Œç”¨æˆ·æœªå‹¾é€‰ä»»ä½•é€‚ç”¨çš„èŠ‚å¥ç±»å‹`);
                console.error(`âŒ éœ€è¦çš„èŠ‚å¥ç±»å‹ä¹‹ä¸€ï¼šeighth, quarter, dotted-quarter, dotted-half`);
                console.error(`âŒ ç”¨æˆ·å®é™…è®¾ç½®ï¼šå…«åˆ†éŸ³ç¬¦=${isEighthAllowed}, å››åˆ†éŸ³ç¬¦=${isQuarterAllowed}, é™„ç‚¹å››åˆ†éŸ³ç¬¦=${isDottedQuarterAllowed}, é™„ç‚¹äºŒåˆ†éŸ³ç¬¦=${isDottedHalfAllowed}`);
                // è¿”å›nullï¼Œè®©ä¸Šçº§å¤„ç†è¿™ç§æƒ…å†µ
                return notes; // è¿”å›ç©ºçš„notesæ•°ç»„
            }
        } else {
            // ğŸ”¥ ä¿®å¤æƒé‡é€‰æ‹©ç®—æ³•ï¼šä½¿ç”¨ä¸€è‡´çš„åŠ æƒéšæœºé€‰æ‹©æ–¹æ³•
            const totalWeight = validWeights.reduce((sum, w) => sum + w, 0);
            console.log(`ğŸ¯ [æƒé‡é€‰æ‹©] æ€»æƒé‡: ${totalWeight}, æœ‰æ•ˆæ¨¡å¼: ${validPatterns.length}`);
            
            if (totalWeight > 0) {
                // ä½¿ç”¨æ ‡å‡†çš„weightedæ–¹æ³•ï¼Œä¸å…¶ä»–6/8æ‹é€‰æ‹©é€»è¾‘ä¿æŒä¸€è‡´
                var selectedPattern = random.weighted(validPatterns, validWeights);
                console.log(`ğŸµ [æƒé‡é€‰æ‹©] ä½¿ç”¨æ ‡å‡†åŠ æƒé€‰æ‹©: ${selectedPattern ? selectedPattern.name : 'null'}`);
            } else {
                // å¦‚æœæ€»æƒé‡ä¸º0ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å¼ä½œä¸ºå›é€€
                var selectedPattern = validPatterns.length > 0 ? validPatterns[0] : null;
                console.log(`âš ï¸ [æƒé‡é€‰æ‹©] æ€»æƒé‡ä¸º0ï¼Œä½¿ç”¨å›é€€é€‰æ‹©: ${selectedPattern ? selectedPattern.name : 'null'}`);
            }
        }
    }
    
    console.log(`âœ… é€‰æ‹©èŠ‚å¥æ¨¡å¼: ${selectedPattern.name}${needsPhraseBreathe ? ' [ä¹å¥å‘¼å¸]' : ''}`);
    
    // ğŸ¼ Cantus Firmusé£æ ¼æ—‹å¾‹ç”Ÿæˆ
    let currentMidiNote = currentMidi;
    if (!currentMidiNote) {
        // ğŸ”¥ 6/8æ‹æ™ºèƒ½èµ·å§‹éŸ³ç¬¦é€‰æ‹©ï¼šåœ¨ä¿æŒCantus Firmusé£æ ¼çš„å‰æä¸‹å¢åŠ éšæœºæ€§
        console.log(`ğŸµ 6/8æ‹æ™ºèƒ½èµ·å§‹éŸ³ç¬¦é€‰æ‹©å¼€å§‹`);
        
        // ç”ŸæˆéŸ³åŸŸå†…æ‰€æœ‰è°ƒå†…éŸ³ç¬¦
        const possibleStartNotes = [];
        for (let octave = Math.floor(safeUserRange.min / 12); octave <= Math.floor(safeUserRange.max / 12); octave++) {
            for (const scaleDegree of safeScale) {
                const midi = octave * 12 + scaleDegree;
                if (midi >= safeUserRange.min && midi <= safeUserRange.max) {
                    possibleStartNotes.push(midi);
                }
            }
        }
        
        if (possibleStartNotes.length > 0) {
            // Cantus Firmusé£æ ¼ï¼šä¼˜å…ˆé€‰æ‹©ä¸»éŸ³ã€ä¸‰éŸ³ã€äº”éŸ³ï¼Œä½†å¢åŠ å…¶ä»–è°ƒå†…éŸ³ç¬¦çš„éšæœºæ€§
            const preferredDegrees = [0, 4, 7]; // ä¸»éŸ³(Do)ã€å¤§ä¸‰åº¦(Mi)ã€å®Œå…¨äº”åº¦(Sol)
            const preferredNotes = possibleStartNotes.filter(midi => preferredDegrees.includes(midi % 12));
            const otherNotes = possibleStartNotes.filter(midi => !preferredDegrees.includes(midi % 12));
            
            // 70%æ¦‚ç‡é€‰æ‹©ä¼˜é€‰éŸ³ç¬¦(ä¸»éŸ³ã€ä¸‰éŸ³ã€äº”éŸ³)ï¼Œ30%æ¦‚ç‡é€‰æ‹©å…¶ä»–è°ƒå†…éŸ³ç¬¦
            if (preferredNotes.length > 0 && random.nextFloat() < 0.7) {
                currentMidiNote = preferredNotes[Math.floor(random.nextFloat() * preferredNotes.length)];
                console.log(`ğŸ¯ 6/8æ‹é€‰æ‹©ä¼˜é€‰èµ·å§‹éŸ³ç¬¦: MIDI ${currentMidiNote} (ä¸»éŸ³/ä¸‰éŸ³/äº”éŸ³)`);
            } else if (otherNotes.length > 0) {
                currentMidiNote = otherNotes[Math.floor(random.nextFloat() * otherNotes.length)];
                console.log(`ğŸ² 6/8æ‹é€‰æ‹©éšæœºè°ƒå†…èµ·å§‹éŸ³ç¬¦: MIDI ${currentMidiNote}`);
            } else {
                // å¤‡ç”¨æ–¹æ¡ˆï¼šé€‰æ‹©ä»»æ„ä¼˜é€‰éŸ³ç¬¦
                currentMidiNote = preferredNotes[Math.floor(random.nextFloat() * preferredNotes.length)];
                console.log(`ğŸ¼ 6/8æ‹å¤‡ç”¨èµ·å§‹éŸ³ç¬¦: MIDI ${currentMidiNote}`);
            }
        } else {
            // æç«¯å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨éŸ³åŸŸä¸­é—´å¹¶è°ƒæ•´åˆ°è°ƒå†…
            const rangeMid = Math.floor((safeUserRange.min + safeUserRange.max) / 2);
            currentMidiNote = adjustToScale(rangeMid, safeScale);
            console.log(`âš ï¸ 6/8æ‹ä½¿ç”¨å¤‡ç”¨èµ·å§‹éŸ³ç¬¦: MIDI ${currentMidiNote} (éŸ³åŸŸä¸­é—´è°ƒæ•´)`);
        }
    }
    
    const durationToBeats6_8 = (duration) => {
        switch (duration) {
            case 'whole': return 4;
            case 'half': return 2;
            case 'quarter': return 1;
            case 'eighth': return 0.5;
            case '16th': return 0.25;
            default: return 0;
        }
    };
    const totalPlayableNotesInPattern = selectedPattern.rhythm.filter(item => !item.type.includes('rest')).length;
    let generatedPlayableNoteCount = 0;

    selectedPattern.rhythm.forEach((rhythmNote, index) => {
        // æ£€æŸ¥æ˜¯å¦ä¸ºä¼‘æ­¢ç¬¦ç±»å‹
        if (rhythmNote.type.includes('rest')) {
            // å¤„ç†ä¼‘æ­¢ç¬¦
            notes.push({
                position: rhythmNote.position,
                type: rhythmNote.type,
                duration: rhythmNote.duration,
                dots: rhythmNote.dots || null,
                isRest: true,
                isStrong: rhythmNote.isStrong,
                tuplet: rhythmNote.tuplet || null  // ğŸµ ä¼‘æ­¢ç¬¦ä¹Ÿå¯èƒ½åœ¨è¿éŸ³ä¸­
            });
            
            console.log(`ä¼‘æ­¢ç¬¦${index + 1}: ${rhythmNote.type} - ${rhythmNote.isStrong ? 'å¼ºæ‹' : 'å¼±æ‹'} - æ—¶å€¼${rhythmNote.duration}`);
            return; // è·³è¿‡éŸ³ç¬¦ç”Ÿæˆ
        }
        
        const noteSequenceIndex = generatedPlayableNoteCount;
        generatedPlayableNoteCount++;

        let nextMidi;
        
        if (index === 0) {
            nextMidi = currentMidiNote;
        } else {
            // ğŸ¼ æ ¹æ®éŸ³ç¬¦ç±»å‹å’Œä¸Šä¸‹æ–‡ç”Ÿæˆåˆé€‚çš„éŸ³ç¬¦
            // ğŸ”¥ ä¿®å¤å‡½æ•°åå†²çªï¼šä½¿ç”¨é‡å‘½ååçš„è¯¦ç»†ç‰ˆæœ¬å‡½æ•°
            nextMidi = generateCantusFirmusNoteDetailed(
                currentMidiNote, 
                safeUserRange, 
                safeMaxJump, 
                safeScale, 
                rhythmNote.isStrong,
                rhythmNote.type,  // ä¼ é€’éŸ³ç¬¦ç±»å‹
                rhythmNote.position, // ä¼ é€’ä½ç½®ä¿¡æ¯
                isLastMeasure && index === selectedPattern.rhythm.length - 1,
                random,
                selectedPattern.rhythm, // ä¼ é€’æ•´ä¸ªèŠ‚å¥æ¨¡å¼
                index // ä¼ é€’å½“å‰ç´¢å¼•
            );
        }
        
        // è½¬æ¢ä¸ºéŸ³ç¬¦ä¿¡æ¯
        const noteInfo = midiToNoteInfoWithCorrectSpelling(nextMidi);
        
        // åˆ›å»ºéŸ³ç¬¦å¯¹è±¡
        const noteObject = {
            position: rhythmNote.position,
            step: noteInfo.step,
            octave: noteInfo.octave,
            alter: noteInfo.alter,
            duration: rhythmNote.duration,
            beats: durationToBeats6_8(rhythmNote.duration),
            type: rhythmNote.type,
            dots: rhythmNote.dots || null,
            midi: nextMidi,
            isStrong: rhythmNote.isStrong,
            isRest: false,
            tuplet: rhythmNote.tuplet || null  // ğŸµ ä¼ é€’è¿éŸ³ä¿¡æ¯
        };
        
        // ğŸ”¥ ä¸º6/8æ‹éŸ³ç¬¦æ·»åŠ articulationé€‰æ‹©ï¼ˆä¿®å¤ç¼ºå¤±çš„åŠŸèƒ½ï¼‰
        if (userSettings.articulations && userSettings.articulations.enabled) {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„éŸ³ç¬¦åˆ—è¡¨æ¥è°ƒç”¨selectArticulation
            const currentNotes = notes.filter(n => !n.isRest); // åªåŒ…å«éŸ³ç¬¦ï¼Œä¸åŒ…å«ä¼‘æ­¢ç¬¦
            let glissAssignedToPrevious = false;

            // 6/8æ‹æ™®é€šSlideå›å¡«ï¼šå½“å‰éŸ³ç¬¦ç”Ÿæˆæ—¶ï¼ŒæŠŠslideæ ‡è®°å›å¡«åˆ°å‰ä¸€ä¸ªç›¸é‚»éŸ³ç¬¦
            const prevGeneratedNote = currentNotes.length > 0 ? currentNotes[currentNotes.length - 1] : null;
            const prePrevGeneratedNote = currentNotes.length > 1 ? currentNotes[currentNotes.length - 2] : null;
            const wouldCreateConsecutiveSlide =
                prePrevGeneratedNote &&
                prePrevGeneratedNote.type === 'note' &&
                isSlideArticulationType(prePrevGeneratedNote.articulation);
            const prevSlideAllowed = isSlideDurationAllowed(prevGeneratedNote, durationToBeats6_8);
            const currentSlideAllowed = isSlideDurationAllowed(noteObject, durationToBeats6_8);
            if (
                clef === 'treble' &&
                Array.isArray(userSettings.articulations.guitar) &&
                userSettings.articulations.guitar.includes('glissando') &&
                canAssignSlideWithState(activeSlideState, 'glissando') &&
                prevGeneratedNote &&
                prevGeneratedNote.type === 'note' &&
                typeof prevGeneratedNote.midi === 'number' &&
                !prevGeneratedNote.articulation &&
                prevSlideAllowed &&
                currentSlideAllowed &&
                !wouldCreateConsecutiveSlide
            ) {
                const interval = Math.abs(noteObject.midi - prevGeneratedNote.midi);
                if (interval >= 1 && interval <= 12) {
                    const baseLinkChance = interval <= 2 ? 0.16 : 0.32;
                    const glissWeightBoost = 1 + getDefaultSlideTypeWeight('glissando');
                    const linkChance = Math.min(0.85, baseLinkChance * glissWeightBoost);
                    if (random.nextFloat() < linkChance) {
                        prevGeneratedNote.articulation = 'glissando';
                        if (consumeSlideWithState(activeSlideState, 'glissando')) {
                            glissAssignedToPrevious = true;
                            console.log(`ğŸ¸ 6/8æ‹å›å¡«Glissando: ${prevGeneratedNote.midi} -> ${noteObject.midi} (éŸ³ç¨‹${interval}åŠéŸ³)`);
                        } else {
                            prevGeneratedNote.articulation = null;
                        }
                    }
                }
            }
            
            console.log(`ğŸ¸ 6/8æ‹articulationæ£€æŸ¥: å½“å‰éŸ³ç¬¦ç´¢å¼•=${currentNotes.length}, MIDI=${nextMidi}`);
            
            // è°ƒç”¨selectArticulationå‡½æ•°ï¼ˆéœ€è¦åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„thisä¸Šä¸‹æ–‡ï¼‰
            const tempContext = {
                random: random,
                clef: clef,
                selectArticulation: function(note, noteIndex, measureNotes, measureIndex, clef) {
                    // ç›´æ¥è°ƒç”¨å…¨å±€çš„selectArticulationå‡½æ•°é€»è¾‘
                    if (!userSettings.articulations.enabled) {
                        return null;
                    }
                    
                    const artSettings = userSettings.articulations;
                    
                    // ğŸ”¥ 6/8æ‹ï¼šæ£€æŸ¥éŸ³ç¬¦æ˜¯å¦å·²ç»æœ‰slurè¿æ¥
                    let hasSlurConnection = false;
                    
                    // æ£€æŸ¥å½“å‰éŸ³ç¬¦æ˜¯å¦æ˜¯å‰ä¸€ä¸ªéŸ³ç¬¦slurçš„ç»“æŸç‚¹
                    if (noteIndex > 0) {
                        const prevNote = measureNotes[noteIndex - 1];
                        if (prevNote && !prevNote.isRest && prevNote.articulation &&
                            ['hammer-on', 'pull-off', 'glissando'].includes(prevNote.articulation)) {
                            hasSlurConnection = true;
                            console.log(`ğŸš« 6/8æ‹ï¼šéŸ³ç¬¦${noteIndex}å·²å‚ä¸å‰ä¸€ä¸ªéŸ³ç¬¦${prevNote.articulation}çš„åŒéŸ³æŠ€å·§ï¼Œè·³è¿‡articulationé€‰æ‹©`);
                        }
                    }
                    
                    // 6/8æ‹ï¼šå½“å‰éŸ³ç¬¦æ˜¯å¦ä¼šäº§ç”Ÿslurçš„é€»è¾‘å°†åœ¨articulationé€‰æ‹©è¿‡ç¨‹ä¸­å¤„ç†
                    const previousNoteHasSlide =
                        noteIndex > 0 && isSlideArticulationType(measureNotes[noteIndex - 1]?.articulation);
                    
                    if (hasSlurConnection) {
                        console.log(`ğŸš« 6/8æ‹è·³è¿‡articulationé€‰æ‹©ï¼šéŸ³ç¬¦${noteIndex}å·²ç»æœ‰slurè¿æ¥`);
                        return null;
                    }
                    
                    let selectedArticulation = null;
                    
                    // === 6/8æ‹å‰ä»–æŠ€å·§è§„åˆ™ (ä½¿ç”¨ä¼˜å…ˆçº§ç³»ç»Ÿ) ===
                    if (clef === 'treble' && artSettings.guitar.length > 0) {
                        const hammerOnAllowed = artSettings.guitar.includes('hammer-on');
                        const pullOffAllowed = artSettings.guitar.includes('pull-off');
                        
                        console.log(`ğŸ”’ 6/8æ‹ç‹¬ç«‹æŠ€å·§æ£€æŸ¥: hammer-on=${hammerOnAllowed}, pull-off=${pullOffAllowed}`);
                        
                        // ğŸ¸ HAMMER-ONæ£€æŸ¥ (6/8æ‹ç‰ˆæœ¬ - æœ€é«˜ä¼˜å…ˆçº§)
                        if (!selectedArticulation && hammerOnAllowed && noteIndex > 0) {
                            const prevNote = measureNotes[noteIndex - 1];
                            if (prevNote && !prevNote.isRest && prevNote.midi) {
                                const interval = note.midi - prevNote.midi;
                                const isValidHammerOn = (interval === 1 || interval === 2);
                                const prevHasHammerOn = prevNote.articulation === 'hammer-on';
                                
                                // ğŸ¯ 6/8æ‹æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸Šè¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                                const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, this.random);
                                
                                if (isValidHammerOn && !prevHasHammerOn && shouldGenerateSlur) {
                                    selectedArticulation = 'hammer-on';
                                    console.log(`âœ… 6/8æ‹é€‰æ‹©å‰ä»–æŠ€å·§: HAMMER-ONç”Ÿæˆ: ${prevNote.midi} -> ${note.midi} (+${interval}åŠéŸ³)`);
                                }
                            }
                        }
                        
                        // ğŸ¸ PULL-OFFæ£€æŸ¥ (6/8æ‹ç‰ˆæœ¬ - æœ€é«˜ä¼˜å…ˆçº§)
                        if (!selectedArticulation && pullOffAllowed && noteIndex > 0) {
                            const prevNote = measureNotes[noteIndex - 1];
                            if (prevNote && !prevNote.isRest && prevNote.midi) {
                                const interval = note.midi - prevNote.midi;
                                const isValidPullOff = (interval === -1 || interval === -2);
                                const prevHasPullOff = prevNote.articulation === 'pull-off';
                                
                                // ğŸ¯ 6/8æ‹æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸‹è¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                                const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, this.random);
                                
                                if (isValidPullOff && !prevHasPullOff && shouldGenerateSlur) {
                                    selectedArticulation = 'pull-off';
                                    console.log(`âœ… 6/8æ‹é€‰æ‹©å‰ä»–æŠ€å·§: PULL-OFFç”Ÿæˆ: ${prevNote.midi} -> ${note.midi} (${interval}åŠéŸ³)`);
                                }
                            }
                        }

                        // Slide In/Outï¼ˆ6/8æ‹ï¼‰ï¼šä¸å…è®¸å‡ºç°åœ¨æ¯”å…«åˆ†éŸ³ç¬¦æ›´å¿«çš„æ—¶å€¼ä¸Š
                        const noteBeats = typeof note.beats === 'number' ? note.beats : durationToBeats6_8(note.duration || 'quarter');
                        const isEighthOrLonger = noteBeats >= MIN_SLIDE_NOTE_BEATS;
                        const isLongNote = noteBeats > 1;
                        const isEntryPoint = noteSequenceIndex === 0;
                        const isEndingPoint = noteSequenceIndex === Math.max(0, totalPlayableNotesInPattern - 1);
                        const shortPatternDirectionalScale = totalPlayableNotesInPattern <= 2 ? 0.75 : 1;
                        const slideFrequency = activeSlideState?.slideFrequency ?? getUserFrequency('articulation', 'slide');

                        if (!selectedArticulation && !previousNoteHasSlide && isEighthOrLonger) {
                            const directionalCandidates = [];
                            if (artSettings.guitar.includes('slide-in') && canAssignSlideWithState(activeSlideState, 'slide-in') && isEntryPoint) {
                                directionalCandidates.push({
                                    type: 'slide-in',
                                    chance: getSlideInOutChance(slideFrequency, isLongNote, 'slide-in') * shortPatternDirectionalScale,
                                    beats: noteBeats
                                });
                            }
                            if (artSettings.guitar.includes('slide-out') && canAssignSlideWithState(activeSlideState, 'slide-out') && isEndingPoint) {
                                directionalCandidates.push({
                                    type: 'slide-out',
                                    chance: getSlideInOutChance(slideFrequency, isLongNote, 'slide-out') * shortPatternDirectionalScale,
                                    beats: noteBeats
                                });
                            }

                            const selectedDirectional = chooseWeightedSlideType(directionalCandidates, this.random);
                            if (selectedDirectional) {
                                selectedArticulation = selectedDirectional.type;
                                console.log(`âœ… 6/8æ‹é€‰æ‹©å‰ä»–æŠ€å·§: ${selectedDirectional.type} (beats=${noteBeats}, æƒé‡=${selectedDirectional.weight.toFixed(2)})`);
                            }
                        }
                    }
                    
                    // ğŸ”¥ 6/8æ‹é¢‘ç‡æ§åˆ¶ - æ¯ä¸¤å°èŠ‚å†…æœ€å¤š2ä¸ªarticulation
                    
                    if (selectedArticulation) {
                        // æ£€æŸ¥å…¨å±€articulationè®¡æ•°å™¨
                        if (!window.articulationCounter) {
                            window.articulationCounter = {
                                total: 0,
                                perTwoMeasures: 0,
                                currentMeasurePair: 0
                            };
                        }
                        
                        // 6/8æ‹é€šå¸¸measureIndexä¸º0ï¼Œéœ€è¦é€šè¿‡å…¶ä»–æ–¹å¼è·å–å®é™…å°èŠ‚å·
                        // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªä¸´æ—¶çš„æ–¹æ¡ˆï¼ŒåŸºäºæ€»articulationæ•°é‡ä¼°ç®—
                        const estimatedMeasureIndex = Math.floor(window.articulationCounter.total / 2);
                        const currentMeasurePair = Math.floor(estimatedMeasureIndex / 2);
                        
                        // å¦‚æœè¿›å…¥äº†æ–°çš„ä¸¤å°èŠ‚ç»„ï¼Œé‡ç½®è®¡æ•°å™¨
                        if (currentMeasurePair !== window.articulationCounter.currentMeasurePair) {
                            console.log(`ğŸ”„ 6/8æ‹è¿›å…¥æ–°çš„ä¸¤å°èŠ‚ç»„ï¼Œé‡ç½®è®¡æ•°å™¨`);
                            window.articulationCounter.perTwoMeasures = 0;
                            window.articulationCounter.currentMeasurePair = currentMeasurePair;
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é¢‘ç‡é™åˆ¶
                        if (window.articulationCounter.perTwoMeasures >= 2) {
                            console.log(`ğŸš« 6/8æ‹é¢‘ç‡é™åˆ¶: ${selectedArticulation}è¢«é˜»æ­¢ - å½“å‰ä¸¤å°èŠ‚ç»„å·²æœ‰${window.articulationCounter.perTwoMeasures}ä¸ªarticulation`);
                            selectedArticulation = null;
                        } else {
                            // å…è®¸ç”Ÿæˆï¼Œæ›´æ–°è®¡æ•°å™¨
                            window.articulationCounter.total++;
                            window.articulationCounter.perTwoMeasures++;
                            console.log(`âœ… 6/8æ‹é¢‘ç‡å…è®¸: æ·»åŠ ${selectedArticulation} - å½“å‰ä¸¤å°èŠ‚ç»„: ${window.articulationCounter.perTwoMeasures}/2`);
                            
                            // ğŸ”¥ 6/8æ‹ï¼šæ£€æŸ¥å¦‚æœé€‰æ‹©äº†ä¼šäº§ç”Ÿslurçš„articulationï¼Œæ ‡è®°ä¸‹ä¸€ä¸ªéŸ³ç¬¦ä¸åº”è¯¥æœ‰articulation
                            if (['hammer-on', 'pull-off'].includes(selectedArticulation) && noteIndex < measureNotes.length - 1) {
                                const nextNote = measureNotes[noteIndex + 1];
                                if (nextNote && !nextNote.isRest && nextNote.articulation) {
                                    console.log(`âš ï¸ 6/8æ‹è­¦å‘Šï¼šå½“å‰éŸ³ç¬¦${noteIndex}é€‰æ‹©${selectedArticulation}ä¼šäº§ç”Ÿslurï¼Œä½†ä¸‹ä¸€ä¸ªéŸ³ç¬¦${noteIndex + 1}å·²ç»æœ‰articulation: ${nextNote.articulation}`);
                                    console.log(`ğŸ”§ 6/8æ‹æ¸…é™¤ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„articulationä»¥é¿å…å†²çª`);
                                    nextNote.articulation = null;
                                }
                            }
                        }
                    }
                    if (selectedArticulation && isSlideArticulationType(selectedArticulation)) {
                        if (!consumeSlideWithState(activeSlideState, selectedArticulation)) {
                            console.log(`ğŸš« 6/8æ‹Slideé¢„ç®—é˜»æ­¢: ${selectedArticulation}`);
                            selectedArticulation = null;
                        }
                    }
                    
                    return selectedArticulation;
                }
            };
            
            const articulation = glissAssignedToPrevious
                ? null
                : tempContext.selectArticulation(
                    noteObject,
                    currentNotes.length,
                    [...currentNotes, noteObject], // åŒ…å«å½“å‰éŸ³ç¬¦çš„åˆ—è¡¨
                    0, // 6/8æ‹å‡½æ•°é€šå¸¸ç”¨äºå•ä¸ªå°èŠ‚
                    clef
                );
            
            if (articulation) {
                noteObject.articulation = articulation;
                console.log(`ğŸ¸ 6/8æ‹æ·»åŠ articulation: ${articulation} åˆ°éŸ³ç¬¦ MIDI ${nextMidi}`);
            }
        }
        
        notes.push(noteObject);
        
        currentMidiNote = nextMidi;
        
        console.log(`éŸ³ç¬¦${index + 1}: ${noteInfo.step}${noteInfo.octave} (MIDI ${nextMidi}) - ${rhythmNote.isStrong ? 'å¼ºæ‹' : 'å¼±æ‹'} - ${rhythmNote.type}`);
    });
    
    // ğŸ”¥ ä¿®å¤å‡½æ•°åå†²çªï¼šé‡å‘½åä¸ºè¯¦ç»†ç‰ˆæœ¬çš„Cantus FirmuséŸ³ç¬¦ç”Ÿæˆå‡½æ•°ï¼Œæ”¯æŒè£…é¥°æ€§åå…­åˆ†éŸ³ç¬¦
    function generateCantusFirmusNoteDetailed(lastMidi, range, maxJump, scale, isStrongBeat, noteType, position, isEnding, random, rhythmPattern, noteIndex) {
        const candidates = [];
        
        console.log(`ğŸµ ç”ŸæˆéŸ³ç¬¦: ä½ç½®${position}, ç±»å‹${noteType}, ${isStrongBeat ? 'å¼ºæ‹' : 'å¼±æ‹'}${isEnding ? ' [ç»“å°¾]' : ''}`);
        
        // åå…­åˆ†éŸ³ç¬¦çš„è£…é¥°æ€§å¤„ç†
        if (noteType === '16th') {
            return generateDecorativeSixteenth(lastMidi, range, maxJump, scale, position, rhythmPattern, noteIndex, random);
        }
        
        // éåå…­åˆ†éŸ³ç¬¦çš„Cantus Firmuså¤„ç†
        // ğŸ”¥ ä¿®å¤ï¼šæ ¹æ®ç”¨æˆ·maxJumpè®¾ç½®åŠ¨æ€è°ƒæ•´çº§è¿›åå¥½ï¼Œç¡®ä¿å……åˆ†åˆ©ç”¨éŸ³ç¨‹è·¨åº¦
        const baseStepwisePreference = isStrongBeat ? 0.6 : 0.8;
        // å½“ç”¨æˆ·è®¾ç½®è¾ƒå¤§è·³åº¦æ—¶ï¼Œé™ä½çº§è¿›åå¥½ï¼Œå¢åŠ è·³è·ƒæœºä¼š
        const jumpFactor = Math.min(maxJump / 12, 1.0); // maxJumpè¶Šå¤§ï¼ŒjumpFactorè¶Šæ¥è¿‘1
        const adjustedStepwise = baseStepwisePreference * (1 - jumpFactor * 0.4); // æœ€å¤šå‡å°‘40%çº§è¿›åå¥½
        const stepwisePreference = Math.max(adjustedStepwise, 0.3); // è‡³å°‘ä¿æŒ30%çº§è¿›åå¥½
        console.log(`ğŸ¯ 6/8æ‹çº§è¿›åå¥½è°ƒæ•´: åŸºç¡€${baseStepwisePreference} -> è°ƒæ•´å${stepwisePreference.toFixed(2)} (maxJump=${maxJump})`)
        
        if (random.nextFloat() < stepwisePreference) {
            // çº§è¿›è¿åŠ¨ï¼šä¸Šè¡Œæˆ–ä¸‹è¡Œ2åº¦
            [-2, -1, 1, 2].forEach(interval => {
                const candidate = lastMidi + interval;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ 
                            midi: candidate, 
                            weight: interval === 1 || interval === -1 ? 3 : 2 // åŠéŸ³çº§è¿›æƒé‡æ›´é«˜
                        });
                    }
                }
            });
        } else {
            // ğŸ”¥ ä¿®å¤éŸ³ç¨‹è·¨åº¦é™åˆ¶ï¼šå®Œå…¨éµå¾ªç”¨æˆ·maxJumpè®¾ç½®ï¼Œå¹¶ä¼˜åŒ–æƒé‡åˆ†é…
            for (let interval = 3; interval <= maxJump; interval++) {
                [-interval, interval].forEach(jump => {
                    const candidate = lastMidi + jump;
                    if (candidate >= range.min && candidate <= range.max) {
                        const pitchClass = candidate % 12;
                        if (scale.includes(pitchClass)) {
                            // ğŸ”¥ ä¼˜åŒ–æƒé‡åˆ†é…ï¼šæ ¹æ®ç”¨æˆ·maxJumpè®¾ç½®åŠ¨æ€è°ƒæ•´å„éŸ³ç¨‹çš„æƒé‡
                            let weight = 1;
                            if (interval === 3) weight = 3; // ä¸‰åº¦ä¿æŒè¾ƒé«˜æƒé‡
                            else if (interval === 4 || interval === 5) weight = 2; // å››äº”åº¦ä¸­ç­‰æƒé‡
                            else if (interval <= maxJump / 2) weight = 2; // ç”¨æˆ·å…è®¸èŒƒå›´å†…çš„ä¸­ç­‰éŸ³ç¨‹
                            else weight = 1; // è¾ƒå¤§éŸ³ç¨‹åŸºç¡€æƒé‡
                            
                            candidates.push({ 
                                midi: candidate, 
                                weight: weight
                            });
                        }
                    }
                });
            }
        }
        
        // å¦‚æœæ˜¯ç»“å°¾éŸ³ç¬¦ï¼Œå€¾å‘äºç¨³å®šéŸ³ï¼ˆä¸»éŸ³ã€äº”éŸ³ï¼‰
        if (isEnding && candidates.length > 0) {
            candidates.forEach(candidate => {
                const pitchClass = candidate.midi % 12;
                if (pitchClass === scale[0] || pitchClass === scale[4]) { // ä¸»éŸ³æˆ–äº”éŸ³
                    candidate.weight *= 3;
                }
            });
        }
        
        if (candidates.length === 0) {
            // å¤‡é€‰ï¼šä»»ä½•è°ƒå†…éŸ³ç¬¦
            for (let midi = range.min; midi <= range.max; midi++) {
                const pitchClass = midi % 12;
                if (scale.includes(pitchClass) && Math.abs(midi - lastMidi) <= maxJump) {
                    candidates.push({ midi: midi, weight: 1 });
                }
            }
        }
        
        if (candidates.length === 0) {
            return addAccidentalIfNeeded(lastMidi, lastMidi); // æœ€åçš„å¤‡é€‰
        }
        
        // æƒé‡éšæœºé€‰æ‹©
        const selectedNote = weightedRandomChoice(candidates, random);
        
        // ğŸš¨ 6/8æ‹æœ€ç»ˆéŸ³ç¨‹éªŒè¯ - æœ€é«˜ä¼˜å…ˆæƒ
        if (lastMidi !== null && lastMidi !== undefined) {
            const finalInterval = Math.abs(selectedNote - lastMidi);
            if (finalInterval > maxJump) {
                console.error(`ğŸš¨ 6/8æ‹éŸ³ç¨‹è·¨åº¦è¿è§„ï¼å®é™…: ${finalInterval}åŠéŸ³ > é™åˆ¶: ${maxJump}åŠéŸ³`);
                console.error(`   å‰éŸ³: ${lastMidi}, é€‰æ‹©éŸ³: ${selectedNote}`);
                // ğŸ”¥ å¼ºåˆ¶ä¿®æ­£ï¼šé€‰æ‹©æœ€æ¥è¿‘ä½†ä¸è¶…è¿‡é™åˆ¶çš„éŸ³ç¬¦
                for (const candidate of candidates) {
                    const candInterval = Math.abs(candidate.midi - lastMidi);
                    if (candInterval <= maxJump) {
                        console.log(`âœ… 6/8æ‹éŸ³ç¨‹ä¿®æ­£ï¼šé€‰æ‹©ç¬¦åˆé™åˆ¶çš„éŸ³ç¬¦ ${candidate.midi} (${candInterval}åŠéŸ³)`);
                        return addAccidentalIfNeeded(candidate.midi, lastMidi);
                    }
                }
                // å¦‚æœæ‰€æœ‰å€™é€‰éŸ³ç¬¦éƒ½è¶…é™ï¼Œè¿”å›åŸéŸ³ç¬¦ï¼ˆæç«¯æƒ…å†µï¼‰
                console.warn(`âš ï¸ 6/8æ‹æ— å¯ç”¨å€™é€‰éŸ³ç¬¦ï¼Œä¿æŒåŸéŸ³ ${lastMidi}`);
                return addAccidentalIfNeeded(lastMidi, lastMidi);
            } else {
                console.log(`âœ… 6/8æ‹éŸ³ç¨‹åˆè§„: ${finalInterval}åŠéŸ³ â‰¤ ${maxJump}åŠéŸ³`);
            }
        }
        
        return addAccidentalIfNeeded(selectedNote, lastMidi);
    }
    
    // è£…é¥°æ€§åå…­åˆ†éŸ³ç¬¦ç”Ÿæˆå‡½æ•° - ç†è§£6/8æ‹3+3åˆ†ç»„
    function generateDecorativeSixteenth(lastMidi, range, maxJump, scale, position, rhythmPattern, noteIndex, random) {
        console.log(`ğŸ¨ ç”Ÿæˆ6/8è£…é¥°æ€§åå…­åˆ†éŸ³ç¬¦: ä½ç½®${position}, ç´¢å¼•${noteIndex}`);
        
        // ç¡®å®šå½“å‰éŸ³ç¬¦åœ¨6/8æ‹ä¸­çš„åˆ†ç»„ä½ç½®
        const groupInfo = analyze68Grouping(position);
        console.log(`ğŸ“ åˆ†ç»„åˆ†æ: ${groupInfo.group}ç»„ç¬¬${groupInfo.beat}æ‹ (${groupInfo.function})`);
        
        // è·å–å‰åéŸ³ç¬¦ä¿¡æ¯ä»¥è¿›è¡Œä¸Šä¸‹æ–‡åˆ†æ
        const prevNote = noteIndex > 0 ? rhythmPattern[noteIndex - 1] : null;
        const nextNote = noteIndex < rhythmPattern.length - 1 ? rhythmPattern[noteIndex + 1] : null;
        
        // æ ¹æ®6/8æ‹åˆ†ç»„ç‰¹æ€§åˆ¤æ–­è£…é¥°ç±»å‹
        const decorationType = determine68DecorationType(groupInfo, prevNote, nextNote, random);
        
        switch (decorationType) {
            case 'group_head': // ç»„å¤´è£…é¥°
                return addAccidentalIfNeeded(generateGroupHeadDecoration(lastMidi, range, maxJump, scale, random), lastMidi);
                
            case 'subdivision': // ç»„å†…ç»†åˆ†
                return addAccidentalIfNeeded(generateSubdivisionDecoration(lastMidi, range, maxJump, scale, groupInfo, random), lastMidi);
                
            case 'passing_tone': // ç»è¿‡éŸ³
                return addAccidentalIfNeeded(generatePassingTone(lastMidi, range, maxJump, scale, prevNote, nextNote, random), lastMidi);
                
            case 'neighbor_tone': // è¾…åŠ©éŸ³
                return addAccidentalIfNeeded(generateNeighborTone(lastMidi, range, maxJump, scale, random), lastMidi);
                
            case 'approach_note': // è¶‹å‘éŸ³
                return addAccidentalIfNeeded(generateApproachNote(lastMidi, range, maxJump, scale, nextNote, random), lastMidi);
                
            default: // æ ‡å‡†çº§è¿›
                return addAccidentalIfNeeded(generateStepwiseDecoration(lastMidi, range, maxJump, scale, random), lastMidi);
        }
    }
    
    // åˆ†æ6/8æ‹åˆ†ç»„ä½ç½®
    function analyze68Grouping(position) {
        if (position < 1.5) {
            // ç¬¬ä¸€ç»„ (0.0-1.5)
            if (position === 0.0) return { group: 1, beat: 1, function: 'å¼ºæ‹' };
            if (position === 0.25) return { group: 1, beat: 2, function: 'å¼±æ‹ç»†åˆ†' };
            if (position === 0.5) return { group: 1, beat: 2, function: 'å¼±æ‹' };
            if (position === 0.75) return { group: 1, beat: 3, function: 'å¼±æ‹ç»†åˆ†' };
            if (position === 1.0) return { group: 1, beat: 3, function: 'å¼±æ‹' };
            return { group: 1, beat: Math.floor(position * 2) + 1, function: 'ç»„å†…' };
        } else {
            // ç¬¬äºŒç»„ (1.5-3.0)
            const relativePos = position - 1.5;
            if (position === 1.5) return { group: 2, beat: 1, function: 'æ¬¡å¼ºæ‹' };
            if (position === 1.75) return { group: 2, beat: 2, function: 'å¼±æ‹ç»†åˆ†' };
            if (position === 2.0) return { group: 2, beat: 2, function: 'å¼±æ‹' };
            if (position === 2.25) return { group: 2, beat: 3, function: 'å¼±æ‹ç»†åˆ†' };
            if (position === 2.5) return { group: 2, beat: 3, function: 'å¼±æ‹' };
            return { group: 2, beat: Math.floor(relativePos * 2) + 1, function: 'ç»„å†…' };
        }
    }
    
    // æ ¹æ®6/8æ‹ç‰¹æ€§ç¡®å®šè£…é¥°ç±»å‹
    function determine68DecorationType(groupInfo, prevNote, nextNote, random) {
        const rand = random.nextFloat();
        
        // ç»„å¤´ä½ç½® (å¼ºæ‹å’Œæ¬¡å¼ºæ‹)
        if (groupInfo.beat === 1) {
            return rand < 0.6 ? 'group_head' : 'subdivision';
        }
        
        // ç»„å†…ç»†åˆ†ä½ç½®
        if (groupInfo.function === 'å¼±æ‹ç»†åˆ†') {
            return rand < 0.5 ? 'subdivision' : 'passing_tone';
        }
        
        // å…¶ä»–ä½ç½®æ ¹æ®ä¸Šä¸‹æ–‡
        if (prevNote && nextNote) {
            return rand < 0.4 ? 'passing_tone' : rand < 0.7 ? 'neighbor_tone' : 'approach_note';
        } else {
            return rand < 0.5 ? 'neighbor_tone' : 'subdivision';
        }
    }
    
    // ç»„å¤´è£…é¥° (å¼ºæ‹å’Œæ¬¡å¼ºæ‹çš„è£…é¥°)
    function generateGroupHeadDecoration(lastMidi, range, maxJump, scale, random) {
        console.log(`ğŸ¯ ç”Ÿæˆç»„å¤´è£…é¥° (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        // ç»„å¤´è£…é¥°å€¾å‘äºç¨³å®šçš„çº§è¿›ï¼Œä½†ä¸¥æ ¼éµå¾ªmaxJumpé™åˆ¶
        const candidates = [];
        for (let interval = 1; interval <= Math.min(2, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ 
                            midi: candidate, 
                            weight: interval === 1 ? 4 : 2 // åŠéŸ³çº§è¿›æƒé‡æœ€é«˜
                        });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ ç»„å¤´è£…é¥°éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // ç»„å†…ç»†åˆ†è£…é¥°
    function generateSubdivisionDecoration(lastMidi, range, maxJump, scale, groupInfo, random) {
        console.log(`ğŸ¼ ç”Ÿæˆç¬¬${groupInfo.group}ç»„å†…ç»†åˆ†è£…é¥° (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        // ç»†åˆ†è£…é¥°æ›´å¤šæ ·åŒ–ï¼Œä½†ä¸¥æ ¼éµå¾ªmaxJumpé™åˆ¶
        const candidates = [];
        for (let interval = 1; interval <= Math.min(2, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ 
                            midi: candidate, 
                            weight: Math.abs(jump) === 1 ? 3 : 2
                        });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ ç»†åˆ†è£…é¥°éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // ç¡®å®šè£…é¥°ç±»å‹
    function determineDecorationType(position, prevNote, nextNote, random) {
        const rand = random.nextFloat();
        
        // æ ¹æ®ä½ç½®å’Œä¸Šä¸‹æ–‡ç¡®å®šè£…é¥°ç±»å‹
        if (position < 0.5 && nextNote && nextNote.isStrong) {
            return 'approach_note'; // anacrusis functionality removed
        } else if (prevNote && nextNote) {
            return rand < 0.3 ? 'passing_tone' : rand < 0.6 ? 'neighbor_tone' : 'approach_note';
        } else {
            return rand < 0.5 ? 'neighbor_tone' : 'stepwise';
        }
    }
    
    // anacrusis function removed
    
    // ç»è¿‡éŸ³ï¼ˆè¿æ¥ä¸¤ä¸ªéŸ³ç¬¦ï¼‰
    function generatePassingTone(lastMidi, range, maxJump, scale, prevNote, nextNote, random) {
        console.log(`ğŸš¶ ç”Ÿæˆç»è¿‡éŸ³ (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        // é€‰æ‹©åœ¨lastMidiåŸºç¡€ä¸Šçš„çº§è¿›éŸ³ï¼Œä½†ä¸¥æ ¼éµå¾ªmaxJumpé™åˆ¶
        const candidates = [];
        for (let interval = 1; interval <= Math.min(2, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ midi: candidate, weight: 2 });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ ç»è¿‡éŸ³éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // è¾…åŠ©éŸ³ï¼ˆå›´ç»•å½“å‰éŸ³ï¼‰
    function generateNeighborTone(lastMidi, range, maxJump, scale, random) {
        console.log(`ğŸ”„ ç”Ÿæˆè¾…åŠ©éŸ³ (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        const candidates = [];
        // ä¸Šä¸‹è¾…åŠ©éŸ³ï¼Œä½†ä¸¥æ ¼éµå¾ªmaxJumpé™åˆ¶
        for (let interval = 1; interval <= Math.min(1, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ midi: candidate, weight: 3 });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ è¾…åŠ©éŸ³éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // è¶‹å‘éŸ³ï¼ˆå‘ç›®æ ‡éŸ³è¶‹å‘ï¼‰
    function generateApproachNote(lastMidi, range, maxJump, scale, nextNote, random) {
        console.log(`â¡ï¸ ç”Ÿæˆè¶‹å‘éŸ³ (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        // ç”Ÿæˆå‘ä¸Šæˆ–å‘ä¸‹çš„çº§è¿›éŸ³ï¼Œä½†ä¸¥æ ¼éµå¾ªmaxJumpé™åˆ¶
        const candidates = [];
        for (let interval = 1; interval <= Math.min(2, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ midi: candidate, weight: 2 });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ è¶‹å‘éŸ³éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // æ ‡å‡†çº§è¿›è£…é¥°
    function generateStepwiseDecoration(lastMidi, range, maxJump, scale, random) {
        console.log(`ğŸ¼ ç”Ÿæˆæ ‡å‡†çº§è¿›è£…é¥° (é™åˆ¶: ${maxJump}åŠéŸ³)`);
        
        const candidates = [];
        // æ ‡å‡†çº§è¿›è£…é¥°é€šå¸¸åªä½¿ç”¨åŠéŸ³çº§è¿›ï¼Œä½†è¦éµå¾ªmaxJumpé™åˆ¶
        for (let interval = 1; interval <= Math.min(1, maxJump); interval++) {
            [-interval, interval].forEach(jump => {
                const candidate = lastMidi + jump;
                if (candidate >= range.min && candidate <= range.max) {
                    const pitchClass = candidate % 12;
                    if (scale.includes(pitchClass)) {
                        candidates.push({ midi: candidate, weight: 3 });
                    }
                }
            });
        }
        
        const selected = candidates.length > 0 ? weightedRandomChoice(candidates, random) : lastMidi;
        // ğŸš¨ æœ€ç»ˆéªŒè¯
        const finalInterval = Math.abs(selected - lastMidi);
        if (finalInterval > maxJump) {
            console.warn(`âš ï¸ æ ‡å‡†çº§è¿›è£…é¥°éŸ³ç¨‹è¶…é™: ${finalInterval} > ${maxJump}ï¼Œä½¿ç”¨åŸéŸ³`);
            return lastMidi;
        }
        return selected;
    }
    
    // ç”Ÿæˆ6/8æ‹çš„acciaccaturaè£…é¥°éŸ³ç¬¦
    function generateAcciaccaturaNote68(targetNote, scale, range, random) {
        console.log(`ğŸµ ä¸º6/8æ‹ç›®æ ‡éŸ³ç¬¦ MIDI ${targetNote.midi} ç”ŸæˆçŸ­å€šéŸ³`);
        
        try {
            const targetMidi = targetNote.midi;
            const targetPitchClass = targetMidi % 12;
            
            // å¯»æ‰¾è°ƒå†…çš„é‚»è¿‘éŸ³ä½œä¸ºè£…é¥°éŸ³ï¼ˆä¼˜å…ˆé€‰æ‹©ä¸‹æ–¹é‚»éŸ³ï¼‰
            let acciaccaturaMidi = null;
            
            // ä¼˜å…ˆå°è¯•ä¸‹æ–¹äºŒåº¦éŸ³ï¼ˆçŸ­å€šéŸ³çš„å¸¸è§å½¢å¼ï¼‰
            for (let interval of [-1, -2, 1, 2]) {
                const candidate = targetMidi + interval;
                if (candidate >= range.min && candidate <= range.max) {
                    const candidatePitchClass = candidate % 12;
                    if (scale.includes(candidatePitchClass)) {
                        acciaccaturaMidi = candidate;
                        break;
                    }
                }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°è°ƒå†…éŸ³ï¼Œä½¿ç”¨åŠéŸ³é‚»éŸ³
            if (!acciaccaturaMidi) {
                const candidate = targetMidi - 1; // ä¸‹æ–¹åŠéŸ³
                if (candidate >= range.min && candidate <= range.max) {
                    acciaccaturaMidi = candidate;
                } else {
                    const candidate2 = targetMidi + 1; // ä¸Šæ–¹åŠéŸ³
                    if (candidate2 >= range.min && candidate2 <= range.max) {
                        acciaccaturaMidi = candidate2;
                    }
                }
            }
            
            if (!acciaccaturaMidi) {
                console.log(`âš ï¸ æ— æ³•ä¸ºMIDI ${targetMidi}ç”Ÿæˆæœ‰æ•ˆçš„çŸ­å€šéŸ³`);
                return null;
            }
            
            // è½¬æ¢ä¸ºéŸ³ç¬¦ä¿¡æ¯
            const acciaccaturaInfo = midiToNoteInfoWithCorrectSpelling(acciaccaturaMidi);
            
            const acciaccaturaNote = {
                step: acciaccaturaInfo.step,
                octave: acciaccaturaInfo.octave,
                alter: acciaccaturaInfo.alter,
                midi: acciaccaturaMidi,
                type: 'eighth', // çŸ­å€šéŸ³é€šå¸¸ç”¨å…«åˆ†éŸ³ç¬¦è¡¨ç¤º
                slash: true // å¸¦æ–œçº¿çš„çŸ­å€šéŸ³
            };
            
            console.log(`ğŸµ 6/8æ‹çŸ­å€šéŸ³ç”ŸæˆæˆåŠŸ: MIDI ${acciaccaturaMidi} -> ${acciaccaturaInfo.step}${acciaccaturaInfo.octave}`);
            return acciaccaturaNote;
            
        } catch (error) {
            console.error(`ğŸš¨ ç”Ÿæˆ6/8æ‹çŸ­å€šéŸ³å¤±è´¥:`, error.message);
            return null;
        }
    }
    
    // ğŸ”¥ å¢å¼ºçš„å°è°ƒå¤„ç†å‡½æ•°ï¼šæ”¯æŒå’Œå£°å°è°ƒå’Œæ—‹å¾‹å°è°ƒ
    function adjustToScaleEnhanced(midi, scale, keySignature) {
        const pitchClass = midi % 12;
        
        // å¦‚æœå·²ç»åœ¨è°ƒå†…ï¼Œç›´æ¥è¿”å›
        if (scale.includes(pitchClass)) {
            return midi;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå°è°ƒ
        const isMinorKey = keySignature.includes('m');
        
        if (isMinorKey) {
            // ğŸµ å°è°ƒçš„å¢å¼ºå¤„ç†ï¼šè€ƒè™‘å’Œå£°å°è°ƒå’Œæ—‹å¾‹å°è°ƒ
            const enhancedScale = getEnhancedMinorScale(scale, keySignature);
            
            // å…ˆæ£€æŸ¥å¢å¼ºéŸ³é˜¶ï¼ˆåŒ…å«å’Œå£°å°è°ƒ/æ—‹å¾‹å°è°ƒå˜åŒ–éŸ³ï¼‰
            if (enhancedScale.includes(pitchClass)) {
                return midi;
            }
            
            // å¦‚æœä¸åœ¨å¢å¼ºéŸ³é˜¶ä¸­ï¼Œæ‰¾åˆ°æœ€è¿‘çš„éŸ³ç¬¦
            return findClosestScaleNote(midi, enhancedScale);
        } else {
            // å¤§è°ƒä½¿ç”¨åŸæœ‰é€»è¾‘
            return findClosestScaleNote(midi, scale);
        }
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè·å–å¢å¼ºçš„å°è°ƒéŸ³é˜¶ï¼ˆåŒ…å«å’Œå£°å°è°ƒå’Œæ—‹å¾‹å°è°ƒå˜åŒ–éŸ³ï¼‰
    function getEnhancedMinorScale(naturalMinorScale, keySignature) {
        // åŸºäºè‡ªç„¶å°è°ƒï¼Œæ·»åŠ å’Œå£°å°è°ƒå’Œæ—‹å¾‹å°è°ƒçš„å˜åŒ–éŸ³
        const enhanced = [...naturalMinorScale];
        
        // ç¡®å®šè°ƒå·çš„ä¸»éŸ³
        const keyToTonic = {
            'Am': 9, 'Em': 4, 'Bm': 11, 'F#m': 6, 'C#m': 1, 'G#m': 8, 'D#m': 3, 'A#m': 10,
            'Dm': 2, 'Gm': 7, 'Cm': 0, 'Fm': 5, 'Bbm': 10, 'Ebm': 3
        };
        
        const tonic = keyToTonic[keySignature];
        if (tonic !== undefined) {
            // æ·»åŠ å’Œå£°å°è°ƒçš„å¯¼éŸ³ï¼ˆå‡é«˜çš„ç¬¬7çº§ï¼‰
            const leadingTone = (tonic + 11) % 12; // ç¬¬7çº§éŸ³å‡é«˜
            if (!enhanced.includes(leadingTone)) {
                enhanced.push(leadingTone);
            }
            
            // æ·»åŠ æ—‹å¾‹å°è°ƒçš„ç¬¬6çº§å’Œç¬¬7çº§ï¼ˆä¸Šè¡Œæ—¶ï¼‰
            const sixthDegree = (tonic + 9) % 12; // ç¬¬6çº§éŸ³å‡é«˜
            if (!enhanced.includes(sixthDegree)) {
                enhanced.push(sixthDegree);
            }
        }
        
        return enhanced.sort((a, b) => a - b);
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šæ‰¾åˆ°æœ€æ¥è¿‘çš„è°ƒå†…éŸ³ç¬¦
    function findClosestScaleNote(midi, scale) {
        const pitchClass = midi % 12;
        let minDistance = 12;
        let bestMidi = midi;
        
        scale.forEach(scalePc => {
            const distance = Math.min(
                Math.abs(scalePc - pitchClass),
                Math.abs(scalePc + 12 - pitchClass),
                Math.abs(scalePc - (pitchClass + 12))
            );
            if (distance < minDistance) {
                minDistance = distance;
                bestMidi = midi + (scalePc - pitchClass);
            }
        });
        
        return bestMidi;
    }
    
    // ä¿æŒåŸå‡½æ•°åçš„å…¼å®¹æ€§
    function adjustToScale(midi, scale) {
        return adjustToScaleEnhanced(midi, scale, keySignature);
    }
    
    // ğŸ”¥ ä¿®å¤æƒé‡éšæœºé€‰æ‹©å‡½æ•°ï¼šä½¿ç”¨ä¸€è‡´çš„åŠ æƒé€‰æ‹©é€»è¾‘
    function weightedRandomChoice(candidates, random) {
        const totalWeight = candidates.reduce((sum, c) => sum + c.weight, 0);
        console.log(`ğŸ¯ [åŠ æƒé€‰æ‹©] å€™é€‰æ•°: ${candidates.length}, æ€»æƒé‡: ${totalWeight}`);
        
        if (totalWeight > 0) {
            // ä½¿ç”¨æ ‡å‡†çš„weightedæ–¹æ³•ï¼Œä¸å…¶ä»–6/8æ‹é€‰æ‹©é€»è¾‘ä¿æŒä¸€è‡´
            const weights = candidates.map(c => c.weight);
            const selected = random.weighted(candidates, weights);
            console.log(`ğŸµ [åŠ æƒé€‰æ‹©] é€‰æ‹©MIDI: ${selected ? selected.midi : 'null'}`);
            return selected ? selected.midi : candidates[candidates.length - 1].midi;
        } else {
            // å¦‚æœæ€»æƒé‡ä¸º0ï¼Œé€‰æ‹©æœ€åä¸€ä¸ªå€™é€‰ä½œä¸ºå›é€€
            const fallbackMidi = candidates.length > 0 ? candidates[candidates.length - 1].midi : null;
            console.log(`âš ï¸ [åŠ æƒé€‰æ‹©] æ€»æƒé‡ä¸º0ï¼Œä½¿ç”¨å›é€€MIDI: ${fallbackMidi}`);
            return fallbackMidi;
        }
    }
    
    // éªŒè¯æ€»æ—¶å€¼å¿…é¡»ä¸º12ï¼ˆ6/8æ‹ Ã— divisions=4ï¼‰
    const totalDuration = notes.reduce((sum, note) => sum + note.duration, 0);
    console.log(`æ€»duration: ${totalDuration} (å¿…é¡»æ˜¯12)`);
    
    if (totalDuration !== 12) {
        console.error(`âŒ æ—¶å€¼é”™è¯¯: ${totalDuration}, å¿…é¡»æ˜¯12`);
        console.error(`âŒ èŠ‚å¥æ¨¡å¼: ${selectedPattern.name}`);
        
        // ğŸ”¥ ä¸¥æ ¼éµå¾ªç”¨æˆ·èŠ‚å¥è®¾ç½®çš„å¤‡ç”¨æ¨¡å¼
        notes.length = 0;
        
        // æ ¹æ®ç”¨æˆ·å‹¾é€‰çš„èŠ‚å¥ç±»å‹åˆ›å»ºå¤‡ç”¨æ¨¡å¼
        if (isEighthAllowed) {
            console.error(`âŒ ä½¿ç”¨å¤‡ç”¨å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰å…«åˆ†éŸ³ç¬¦ï¼‰`);
            for (let i = 0; i < 6; i++) {
                const midi = safeUserRange.min + (i % (safeUserRange.max - safeUserRange.min));
                const adjustedMidi = adjustToScale(midi, safeScale);
                const noteInfo = midiToNoteInfoWithCorrectSpelling(adjustedMidi);
                
                notes.push({ 
                    position: i * 0.5,
                    step: noteInfo.step, 
                    octave: noteInfo.octave, 
                    alter: noteInfo.alter,
                    duration: 2, 
                    type: 'eighth',
                    midi: adjustedMidi,
                    isStrong: i === 0 || i === 3
                });
            }
        } else if (isDottedHalfAllowed) {
            console.error(`âŒ ä½¿ç”¨å¤‡ç”¨é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼‰`);
            const midi = safeUserRange.min;
            const adjustedMidi = adjustToScale(midi, safeScale);
            const noteInfo = midiToNoteInfoWithCorrectSpelling(adjustedMidi);
            
            notes.push({
                position: 0.0,
                step: noteInfo.step,
                octave: noteInfo.octave,
                alter: noteInfo.alter,
                duration: 12,
                type: 'half',
                dots: 1,
                midi: adjustedMidi,
                isStrong: true
            });
        } else if (isQuarterAllowed || isDottedQuarterAllowed) {
            console.error(`âŒ ä½¿ç”¨å¤‡ç”¨é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰å››åˆ†éŸ³ç¬¦æˆ–é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰`);
            for (let i = 0; i < 2; i++) {
                const midi = safeUserRange.min + (i % (safeUserRange.max - safeUserRange.min));
                const adjustedMidi = adjustToScale(midi, safeScale);
                const noteInfo = midiToNoteInfoWithCorrectSpelling(adjustedMidi);
                
                notes.push({
                    position: i * 1.5,
                    step: noteInfo.step,
                    octave: noteInfo.octave,
                    alter: noteInfo.alter,
                    duration: 6,
                    type: 'quarter',
                    dots: 1,
                    midi: adjustedMidi,
                    isStrong: true
                });
            }
        } else {
            // ğŸš¨ ç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•å¯ç”¨çš„èŠ‚å¥ç±»å‹ï¼Œæ— æ³•ç”Ÿæˆå¤‡ç”¨æ¨¡å¼
            console.error(`âŒ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨äº6/8æ‹çš„èŠ‚å¥ç±»å‹ï¼`);
            console.error(`âŒ éœ€è¦çš„èŠ‚å¥ç±»å‹ï¼šeighth, quarter, dotted-quarter, half, dotted-half`);
            console.error(`âŒ ç”¨æˆ·å‹¾é€‰çš„èŠ‚å¥ï¼š[${userRhythms.join(', ')}]`);
            
            // åˆ›å»ºä¸€ä¸ªä¼‘æ­¢ç¬¦å¡«å……æ•´ä¸ªå°èŠ‚ï¼Œé¿å…å´©æºƒ
            notes.push({
                position: 0.0,
                duration: 12,
                type: 'half-rest',
                dots: 1,
                isRest: true,
                isStrong: true
            });
        }
    }
    
    // ğŸµ æ·»åŠ åŸºæœ¬æ¼”å¥æ³•åˆ°éŸ³ç¬¦
    if (userSettings.articulations.enabled && userSettings.articulations.basic.length > 0) {
        const basicArticulations = userSettings.articulations.basic;
        
        notes.forEach((note, index) => {
            // è·³è¿‡ä¼‘æ­¢ç¬¦
            if (note.isRest) {
                return;
            }
            
            // æ ¹æ®æ¦‚ç‡æ·»åŠ åŸºæœ¬æ¼”å¥æ³•
            const articulationProbability = 0.15; // 15%çš„æ¦‚ç‡æ·»åŠ åŸºæœ¬æ¼”å¥æ³•
            
            if (random.nextFloat() < articulationProbability) {
                // æ ¹æ®éŸ³ç¬¦ç‰¹å¾é€‰æ‹©åˆé€‚çš„articulation
                let suitableArticulations = [...basicArticulations];
                
                // Staccatoé€‚åˆçŸ­éŸ³ç¬¦å’Œè½»å¿«çš„æ®µè½
                if (note.type === 'eighth' || note.type === '16th') {
                    if (suitableArticulations.includes('staccato') && random.nextFloat() < 0.4) {
                        note.articulation = 'staccato';
                        console.log(`ğŸµ 6/8æ‹ Staccato: ${note.step}${note.octave} (ä½ç½®: ${note.position})`);
                        return;
                    }
                }
                
                // Accenté€‚åˆå¼ºæ‹
                if (note.isStrong && suitableArticulations.includes('accent')) {
                    if (random.nextFloat() < 0.3) {
                        note.articulation = 'accent';
                        console.log(`ğŸµ 6/8æ‹ Accent: ${note.step}${note.octave} (å¼ºæ‹ä½ç½®: ${note.position})`);
                        return;
                    }
                }
                
                // Tenutoé€‚åˆè¾ƒé•¿çš„éŸ³ç¬¦
                if ((note.type === 'quarter' || note.type === 'quarter.') && suitableArticulations.includes('tenuto')) {
                    if (random.nextFloat() < 0.3) {
                        note.articulation = 'tenuto';
                        console.log(`ğŸµ 6/8æ‹ Tenuto: ${note.step}${note.octave} (ä½ç½®: ${note.position})`);
                        return;
                    }
                }
                
                // Marcatoé€‚åˆç‰¹åˆ«å¼ºè°ƒçš„éŸ³ç¬¦ï¼ˆå¼ºæ‹+è¾ƒé•¿éŸ³ç¬¦ï¼‰
                if (note.isStrong && (note.type === 'quarter' || note.type === 'quarter.') && suitableArticulations.includes('marcato')) {
                    if (random.nextFloat() < 0.15) {
                        note.articulation = 'marcato';
                        console.log(`ğŸµ 6/8æ‹ Marcato: ${note.step}${note.octave} (ä½ç½®: ${note.position})`);
                        return;
                    }
                }
                
                // Fermataé€‚åˆä¹å¥ç»“å°¾ï¼ˆæœ€åä¸€ä¸ªå°èŠ‚çš„æœ€åä¸€ä¸ªéŸ³ç¬¦ï¼‰
                if (isLastMeasure && index === notes.length - 1 && suitableArticulations.includes('fermata')) {
                    if (random.nextFloat() < 0.3) {
                        note.articulation = 'fermata';
                        console.log(`ğŸµ 6/8æ‹ Fermata: ${note.step}${note.octave} (ä¹å¥ç»“å°¾)`);
                        return;
                    }
                }
                
                // Acciaccaturaé€‚åˆè£…é¥°æ€§çš„éŸ³ç¬¦ï¼ˆä¸æ˜¯ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼‰
                if (index > 0 && suitableArticulations.includes('acciaccatura')) {
                    // ğŸ¯ ä½¿ç”¨6/8æ‹ä¸“ç”¨çš„å¢å¼ºé¢‘ç‡æ§åˆ¶å‡½æ•°ï¼Œæ›¿ä»£ç¡¬ç¼–ç çš„0.15
                    if (shouldGenerate68Articulation('acciaccatura', random)) {
                        note.articulation = 'acciaccatura';
                        
                        // ç”Ÿæˆacciaccaturaè£…é¥°éŸ³ç¬¦
                        const acciaccaturaNote = generateAcciaccaturaNote68(note, safeScale, safeUserRange, random);
                        if (acciaccaturaNote) {
                            note.graceNote = acciaccaturaNote;
                            console.log(`ğŸµ 6/8æ‹ Acciaccatura: ${acciaccaturaNote.step}${acciaccaturaNote.octave} -> ${note.step}${note.octave} (ä½ç½®: ${note.position})`);
                            return;
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰é€‰æ‹©ç‰¹å®šçš„articulationï¼Œä½¿ç”¨6/8æ‹ä¸“ç”¨é¢‘ç‡æ§åˆ¶é€ä¸ªæ£€æŸ¥
                if (!note.articulation && suitableArticulations.length > 0) {
                    // ğŸ¯ ä½¿ç”¨å¢å¼ºçš„é¢‘ç‡æ§åˆ¶ç³»ç»Ÿï¼Œè€Œä¸æ˜¯éšæœºé€‰æ‹©
                    for (const articulation of suitableArticulations) {
                        if (articulation !== 'fermata' && articulation !== 'acciaccatura') { // fermataåªç”¨äºç»“å°¾, acciaccaturaéœ€è¦ç‰¹æ®Šå¤„ç†
                            if (shouldGenerate68Articulation(articulation, random)) {
                                note.articulation = articulation;
                                console.log(`ğŸ¯ 6/8æ‹å¢å¼ºé¢‘ç‡æ§åˆ¶ ${articulation}: ${note.step}${note.octave} (ç”¨æˆ·è®¾ç½®ç”Ÿæ•ˆ)`);
                                break; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªé€šè¿‡é¢‘ç‡æ£€æŸ¥çš„articulationååœæ­¢
                            }
                        }
                    }
                }
            }
        });
    }
    
    // ğŸ¸ æ·»åŠ å‰ä»–æŠ€å·§articulationåˆ°éŸ³ç¬¦ï¼ˆåªæœ‰åœ¨æ²¡æœ‰åŸºæœ¬æ¼”å¥æ³•æ—¶æ‰æ·»åŠ ï¼‰
    console.log(`ğŸ”§ 6/8æ‹ç”¨æˆ·articulationè®¾ç½®æ£€æŸ¥:`);
    console.log(`  - enabled: ${userSettings.articulations.enabled}`);
    console.log(`  - guitaræŠ€å·§: [${userSettings.articulations.guitar.join(', ')}]`);
    console.log(`  - basicæŠ€å·§: [${userSettings.articulations.basic.join(', ')}]`);
    
    if (userSettings.articulations.enabled && userSettings.articulations.guitar.length > 0) {
        let lastArticulation = null; // è®°å½•ä¸Šä¸€ä¸ªarticulation
        
        // éå†æ‰€æœ‰éŸ³ç¬¦ï¼Œåªåœ¨çœŸæ­£ç›¸é‚»çš„éŸ³ç¬¦ä¹‹é—´æ·»åŠ articulation
        for (let i = 1; i < notes.length; i++) {
            const currentNote = notes[i];
            const prevNote = notes[i - 1];
            
            // è·³è¿‡ä¼‘æ­¢ç¬¦
            if (currentNote.isRest || prevNote.isRest) {
                continue;
            }
            
            // è·³è¿‡å·²ç»æœ‰articulationçš„éŸ³ç¬¦ï¼ˆåŸºæœ¬æ¼”å¥æ³•ä¼˜å…ˆï¼‰
            if (currentNote.articulation || prevNote.articulation) {
                continue;
            }
            
            // ä¸åœ¨æœ€åä¸€ä¸ªéŸ³ç¬¦æ·»åŠ articulationï¼ˆé˜²æ­¢è·¨å°èŠ‚ï¼‰
            if (i === notes.length - 1) {
                continue;
            }
            
            // åªæœ‰ä¸¤ä¸ªéŸ³ç¬¦çœŸæ­£ç›¸é‚»ï¼ˆä¸­é—´æ²¡æœ‰ä¼‘æ­¢ç¬¦ï¼‰æ—¶æ‰è€ƒè™‘æ·»åŠ articulation
            if (currentNote.midi && prevNote.midi) {
                const interval = currentNote.midi - prevNote.midi;
                
                // ç§»é™¤ç¬¦å¹²æ–¹å‘æ£€æŸ¥ï¼Œå› ä¸ºæˆ‘ä»¬å¼ºåˆ¶sluråœ¨ä¸Šæ–¹è¿æ¥éŸ³å¤´
                
                // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ï¼šå¦‚æœç”¨æˆ·æ²¡æœ‰é€‰æ‹©æŸä¸ªå‰ä»–æŠ€å·§ï¼Œå®Œå…¨ç¦æ­¢è¯¥æŠ€å·§
                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                
                console.log(`ğŸ”’ 6/8æ‹ä¸¥æ ¼æ£€æŸ¥: hammer-onå…è®¸: ${hammerOnAllowed}, pull-offå…è®¸: ${pullOffAllowed}`);
                console.log(`ğŸ”’ 6/8æ‹ä¸¥æ ¼æ£€æŸ¥: ç”¨æˆ·é€‰æ‹©çš„å‰ä»–æŠ€å·§: ${JSON.stringify(userSettings.articulations.guitar)}`);
                
                // æ£€æŸ¥ç”¨æˆ·é€‰æ‹©çš„å‰ä»–æŠ€å·§
                let articulationApplied = false;
                
                // Hammer-on: ä¸Šè¡ŒäºŒåº¦ï¼ˆ1-2åŠéŸ³ï¼‰ - ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…è®¸ï¼Œå¹¶ä½¿ç”¨é¢‘ç‡æ§åˆ¶
                if (!articulationApplied && hammerOnAllowed && 
                    interval > 0 && interval <= 2 && 
                    lastArticulation !== 'hammer-on') { // ä¸èƒ½è¿ç»­ä¸¤ä¸ªhammer-on
                    
                    // ğŸ¯ 6/8æ‹å¦ä¸€å¤„æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸Šè¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                    const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, random);
                    
                    if (shouldGenerateSlur) {
                        currentNote.articulation = 'hammer-on';
                        lastArticulation = 'hammer-on';
                        articulationApplied = true;
                        if (prevNote.articulation === 'staccato') {
                            prevNote.articulation = null;
                            console.log(`ğŸš« 6/8æ‹ç§»é™¤slurèµ·å§‹éŸ³çš„staccato: ä½ç½®${prevNote.position}`);
                        }
                        console.log(`âœ… 6/8æ‹å¦ä¸€å¤„ Hammer-on: ${prevNote.midi} -> ${currentNote.midi} (ä½ç½®: ${prevNote.position} -> ${currentNote.position}) - ç”¨æˆ·å·²é€‰æ‹©hammer-on`);
                    } else {
                        console.log(`âŒ 6/8æ‹å¦ä¸€å¤„ Hammer-onè·³è¿‡: é¢‘ç‡æ§åˆ¶é˜»æ­¢ (${interval > 0 ? '+' : ''}${interval}åŠéŸ³)`);
                    }
                } else if (!hammerOnAllowed && interval > 0 && interval <= 2) {
                    console.log(`ğŸ”’ 6/8æ‹ä¸¥æ ¼ç¦æ­¢: hammer-onæœªè¢«ç”¨æˆ·é€‰æ‹©ï¼Œè·³è¿‡ä¸Šè¡ŒäºŒåº¦: ${prevNote.midi} -> ${currentNote.midi}`);
                }
                
                // Pull-off: ä¸‹è¡ŒäºŒåº¦ï¼ˆ-1æˆ–-2åŠéŸ³ï¼‰ - ğŸ”¥ ä½¿ç”¨æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘
                if (!articulationApplied && pullOffAllowed && 
                    interval < 0 && interval >= -2 && 
                    lastArticulation !== 'pull-off') { // ä¸èƒ½è¿ç»­ä¸¤ä¸ªpull-off
                    
                    // ğŸ¯ 6/8æ‹å¦ä¸€å¤„æ–°çš„é¢‘ç‡æ§åˆ¶é€»è¾‘ï¼šæ§åˆ¶ä¸‹è¡ŒäºŒåº¦slurçš„ç”Ÿæˆ
                    const shouldGenerateSlur = shouldGenerateDirectionalSlur(interval, random);
                    
                    if (shouldGenerateSlur) {
                        currentNote.articulation = 'pull-off';
                        lastArticulation = 'pull-off';
                        articulationApplied = true;
                        if (prevNote.articulation === 'staccato') {
                            prevNote.articulation = null;
                            console.log(`ğŸš« 6/8æ‹ç§»é™¤slurèµ·å§‹éŸ³çš„staccato: ä½ç½®${prevNote.position}`);
                        }
                        console.log(`âœ… 6/8æ‹å¦ä¸€å¤„ Pull-off: ${prevNote.midi} -> ${currentNote.midi} (ä½ç½®: ${prevNote.position} -> ${currentNote.position}) - ç”¨æˆ·å·²é€‰æ‹©pull-off`);
                    } else {
                        console.log(`âŒ 6/8æ‹å¦ä¸€å¤„ Pull-offè·³è¿‡: é¢‘ç‡æ§åˆ¶é˜»æ­¢ (${interval}åŠéŸ³)`);
                    }
                } else if (!pullOffAllowed && interval < 0 && interval >= -2) {
                    console.log(`ğŸ”’ 6/8æ‹ä¸¥æ ¼ç¦æ­¢: pull-offæœªè¢«ç”¨æˆ·é€‰æ‹©ï¼Œè·³è¿‡ä¸‹è¡ŒäºŒåº¦: ${prevNote.midi} -> ${currentNote.midi}`);
                }
                // Glissando: è¾ƒå¤§éŸ³ç¨‹ï¼ˆ3-12åŠéŸ³ï¼‰ - ä»…å½“ç”¨æˆ·é€‰æ‹©äº†glissandoæ—¶
                // é¿å…è·¨å°èŠ‚ï¼šä½¿ç”¨ç®€å•ä½†æœ‰æ•ˆçš„æ£€æŸ¥
                const nextNote = i < notes.length - 1 ? notes[i + 1] : null;
                const hasImmediatePlayableNextNote = !!(nextNote && !nextNote.isRest && nextNote.midi);
                if (!articulationApplied && userSettings.articulations.guitar.includes('glissando') && 
                         Math.abs(interval) >= 3 && Math.abs(interval) <= 12 && 
                         canAssignSlideWithState(activeSlideState, 'glissando') &&
                         lastArticulation !== 'glissando' && // ä¸èƒ½è¿ç»­ä¸¤ä¸ªglissando
                         hasImmediatePlayableNextNote && // slideå¿…é¡»è¿æ¥åˆ°ç´§é‚»çš„ä¸‹ä¸€ä¸ªéä¼‘æ­¢ç¬¦
                         random.nextFloat() < 0.95) { // æé«˜æ¦‚ç‡ä»¥ä¾¿æµ‹è¯•
                    if (consumeSlideWithState(activeSlideState, 'glissando')) {
                        currentNote.articulation = 'glissando';
                        lastArticulation = 'glissando';
                        articulationApplied = true;
                        console.log(`ğŸ¸ 6/8æ‹ Glissando: ${prevNote.midi} -> ${currentNote.midi} (ä½ç½®: ${prevNote.position} -> ${currentNote.position}, éŸ³ç¨‹: ${interval}åŠéŸ³) - ç”¨æˆ·å·²é€‰æ‹©glissando`);
                    }
                }
                // å¦‚æœæ²¡æœ‰æ·»åŠ articulationï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®lastArticulation
                if (!articulationApplied && !currentNote.articulation) {
                    // å¦‚æœå½“å‰éŸ³ç¬¦æ²¡æœ‰articulationï¼Œå¹¶ä¸”å’Œå‰ä¸€ä¸ªéŸ³ç¬¦ä¹‹é—´æ²¡æœ‰ä¼‘æ­¢ç¬¦ï¼Œ
                    // åˆ™é‡ç½®lastArticulationï¼Œå…è®¸ä¸‹ä¸€ä¸ªéŸ³ç¬¦æ·»åŠ ä»»ä½•articulation
                    if (i > 1 && !notes[i-1].articulation) {
                        lastArticulation = null;
                    }
                }
            }
        }
    }
    
    // ğŸ¼ ç”ŸæˆMusicXML
    let measureXML = '';
    
    notes.forEach((note, index) => {
        if (note.isRest) {
            // ğŸµ ç”Ÿæˆä¼‘æ­¢ç¬¦MusicXML
            const restType = note.type.replace('-rest', '');
            measureXML += `
      <note>
        <rest>`;
            
            // ä¼‘æ­¢ç¬¦ä½ç½®ä¸è°±å·æ— å…³ï¼Œåªæ ¹æ®äº”çº¿è°±çº¿æ¡ç¼–å·ç¡®å®š
            switch(restType) {
                case 'whole':
                    // å…¨ä¼‘æ­¢ç¬¦æ°¸è¿œæŒ‚åœ¨ç¬¬å››çº¿ä¸‹æ–¹
                    measureXML += `<line>4</line>`;
                    break;
                case 'half':
                    // äºŒåˆ†ä¼‘æ­¢ç¬¦æ°¸è¿œé¡¶åœ¨ç¬¬ä¸‰çº¿ä¸Šæ–¹
                    measureXML += `<line>3</line>`;
                    break;
                case 'quarter':
                case 'eighth':
                case '16th':
                default:
                    // å…¶ä»–ä¼‘æ­¢ç¬¦éƒ½åœ¨ç¬¬ä¸‰çº¿åŒºåŸŸ
                    measureXML += `<line>3</line>`;
                    break;
            }
            
            measureXML += `</rest>
        <duration>${note.duration}</duration>
        <type>${restType}</type>`;
        
            // æ·»åŠ é™„ç‚¹
            if (note.dots) {
                measureXML += `
        <dot/>`;
            }
        } else {
            // ğŸµ å¦‚æœæœ‰grace noteï¼Œå…ˆç”Ÿæˆgrace noteçš„XML
            const isTiedContinuation = note.tied && (note.tieType === 'continue' || note.tieType === 'stop');
            if (note.graceNote && !isTiedContinuation) {
                console.log(`ğŸµ ç”Ÿæˆ6/8æ‹grace note: ${note.graceNote.step}${note.graceNote.octave} -> ${note.step}${note.octave}`);
                measureXML += `
      <note>
        <grace slash="yes"/>
        <pitch>
          <step>${note.graceNote.step}</step>`;
        
                // æ·»åŠ å‡é™å·
                if (note.graceNote.alter && note.graceNote.alter !== 0) {
                    measureXML += `
          <alter>${note.graceNote.alter}</alter>`;
                }
                
                measureXML += `
          <octave>${note.graceNote.octave}</octave>
        </pitch>
        <type>${note.graceNote.type}</type>
      </note>`;
            }
            
            // ğŸµ ç”Ÿæˆä¸»éŸ³ç¬¦MusicXML
            measureXML += `
      <note>
        <pitch>
          <step>${note.step}</step>`;
        
            // æ·»åŠ å‡é™å·
            if (note.alter && note.alter !== 0) {
                measureXML += `
          <alter>${note.alter}</alter>`;
            }
            
            measureXML += `
          <octave>${note.octave}</octave>
        </pitch>
        <duration>${note.duration}</duration>
        <type>${note.type}</type>`;
        
            // æ·»åŠ é™„ç‚¹
            if (note.dots) {
                measureXML += `
        <dot/>`;
            }
        }
        
        // ğŸ¶ å¤„ç†è¿éŸ³ä¿¡æ¯ï¼ˆäºŒè¿éŸ³ã€å››è¿éŸ³ï¼‰
        if (note.tuplet) {
            const tupletInfo = note.tuplet;
            
            // æ·»åŠ time-modificationæ ‡ç­¾
            let actualNotes, normalNotes;
            if (tupletInfo.type === 'duplet') {
                actualNotes = 2; 
                normalNotes = 3; // äºŒè¿éŸ³ï¼š2ä¸ªéŸ³ç¬¦å 3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´
            } else if (tupletInfo.type === 'quadruplet') {
                actualNotes = 4;
                normalNotes = 3; // å››è¿éŸ³ï¼š4ä¸ªéŸ³ç¬¦å 3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´
            }
            
            if (actualNotes && normalNotes) {
                measureXML += `
        <time-modification>
          <actual-notes>${actualNotes}</actual-notes>
          <normal-notes>${normalNotes}</normal-notes>
        </time-modification>`;
            }
        }
        
        // ğŸ”— 6/8æ‹æ­£ç¡®çš„beamè§„åˆ™ - è€ƒè™‘ä¼‘æ­¢ç¬¦æ‰“æ–­beamè¿æ¥
        if (!note.isRest && (note.type === 'eighth' || note.type === '16th')) {
            // æ ¹æ®éŸ³ç¬¦ä½ç½®å†³å®šbeamåˆ†ç»„ (6/8æ‹: 0-1.5ä¸ºç¬¬ä¸€ç»„, 1.5-3.0ä¸ºç¬¬äºŒç»„)
            const isFirstGroup = note.position < 1.5;
            const beamGroupId = isFirstGroup ? 1 : 2;
            
            // æ‰¾åˆ°åŒä¸€ç»„å†…çš„è¿ç»­å¯beaméŸ³ç¬¦ï¼ˆä¼‘æ­¢ç¬¦ä¼šæ‰“æ–­è¿æ¥ï¼‰
            const sameGroupNotes = findContinuousBeamableNotes(notes, note.position, isFirstGroup);
            
            const positionInGroup = sameGroupNotes.findIndex(n => n.position === note.position);
            const isFirstInGroup = positionInGroup === 0;
            const isLastInGroup = positionInGroup === sameGroupNotes.length - 1;
            
            if (sameGroupNotes.length > 1) { // åªæœ‰å¤šä¸ªéŸ³ç¬¦æ—¶æ‰beam
                if (note.type === '16th') {
                    // åå…­åˆ†éŸ³ç¬¦éœ€è¦åŒé‡beam
                    if (isFirstInGroup) {
                        measureXML += `
        <beam number="1">begin</beam>
        <beam number="2">begin</beam>`;
                    } else if (isLastInGroup) {
                        measureXML += `
        <beam number="1">end</beam>
        <beam number="2">end</beam>`;
                    } else {
                        measureXML += `
        <beam number="1">continue</beam>
        <beam number="2">continue</beam>`;
                    }
                } else if (note.type === 'eighth') {
                    // å…«åˆ†éŸ³ç¬¦åªéœ€è¦å•é‡beam
                    if (isFirstInGroup) {
                        measureXML += `
        <beam number="1">begin</beam>`;
                    } else if (isLastInGroup) {
                        measureXML += `
        <beam number="1">end</beam>`;
                    } else {
                        measureXML += `
        <beam number="1">continue</beam>`;
                    }
                }
            }
        }
        
        // ğŸ¸ å¤„ç†articulationå’Œslur
        let hasNotations = false;
        let notationsContent = '';
        const isTiedContinuation = note.tied && (note.tieType === 'continue' || note.tieType === 'stop');
        
        // å¤„ç†è¿éŸ³notations
        if (note.tuplet) {
            const tupletInfo = note.tuplet;
            hasNotations = true;
            
            // è¿éŸ³å¼€å§‹æˆ–ç»“æŸæ ‡è®°
            if (tupletInfo.position === 0) {
                // è¿éŸ³å¼€å§‹
                const showNumber = tupletInfo.type === 'duplet' ? '2' : tupletInfo.type === 'quadruplet' ? '4' : '3';
                notationsContent += `
          <tuplet type="start" number="${tupletInfo.id}" bracket="yes" show-number="${showNumber}" placement="above"/>`;
                console.log(`ğŸµ è¿éŸ³å¼€å§‹: ç±»å‹=${tupletInfo.type}, ID=${tupletInfo.id}, æ•°å­—=${showNumber}`);
            } else if (tupletInfo.position === tupletInfo.total - 1) {
                // è¿éŸ³ç»“æŸ
                notationsContent += `
          <tuplet type="stop" number="${tupletInfo.id}"/>`;
                console.log(`ğŸµ è¿éŸ³ç»“æŸ: ç±»å‹=${tupletInfo.type}, ID=${tupletInfo.id}`);
            }
        }
        
        // å¤„ç†articulation (åŒ…æ‹¬åŸºæœ¬æ¼”å¥æ³•å’Œå‰ä»–æŠ€å·§)
        if (!note.isRest && note.articulation && !isTiedContinuation) {
            hasNotations = true;
            
            // å¤„ç†åŸºæœ¬æ¼”å¥æ³•
            if (['staccato', 'accent', 'tenuto', 'marcato', 'fermata'].includes(note.articulation)) {
                notationsContent += `
          <articulations>`;
                
                // æ·»åŠ å¯¹åº”çš„articulationæ ‡è®°
                switch(note.articulation) {
                    case 'staccato':
                        notationsContent += `
            <staccato/>`;
                        break;
                    case 'accent':
                        notationsContent += `
            <accent/>`;
                        break;
                    case 'tenuto':
                        notationsContent += `
            <tenuto/>`;
                        break;
                    case 'marcato':
                        notationsContent += `
            <strong-accent/>`;
                        break;
                    case 'fermata':
                        // fermataåœ¨articulationså¤–
                        notationsContent = `
          <fermata/>` + notationsContent;
                        break;
                }
                
                if (note.articulation !== 'fermata') {
                    notationsContent += `
          </articulations>`;
                }
            }
            // å¤„ç†å‰ä»–æŠ€å·§
            else if (note.articulation === 'hammer-on') {
                // ğŸ”¥ ä¸¥æ ¼æƒé™æ£€æŸ¥
                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                if (hammerOnAllowed) {
                    notationsContent += `
          <articulations>
            <other-articulation>H</other-articulation>
          </articulations>`;
                    
                    // åªæœ‰åœ¨hammer-onè¢«å…è®¸æ—¶æ‰ç”Ÿæˆslurç»“æŸæ ‡è®°
                    notationsContent += `
          <slur type="stop" number="${index}"/>`;
                    console.log(`âœ… 6/8æ‹hammer-on slur stop: éŸ³ç¬¦${index} (MIDI ${note.midi})`);
                } else {
                    console.log(`ğŸ”’ 6/8æ‹hammer-onè¢«ç¦æ­¢ï¼Œä¸ç”Ÿæˆslur stop`);
                    // æ¸…é™¤ä¸è¢«å…è®¸çš„articulation
                    note.articulation = null;
                }
            } else if (note.articulation === 'pull-off') {
                // ğŸ”¥ ä¸¥æ ¼æƒé™æ£€æŸ¥
                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                if (pullOffAllowed) {
                    notationsContent += `
          <articulations>
            <other-articulation>P</other-articulation>
          </articulations>`;
                    
                    // åªæœ‰åœ¨pull-offè¢«å…è®¸æ—¶æ‰ç”Ÿæˆslurç»“æŸæ ‡è®°
                    notationsContent += `
          <slur type="stop" number="${index}"/>`;
                    console.log(`âœ… 6/8æ‹pull-off slur stop: éŸ³ç¬¦${index} (MIDI ${note.midi})`);
                } else {
                    console.log(`ğŸ”’ 6/8æ‹pull-offè¢«ç¦æ­¢ï¼Œä¸ç”Ÿæˆslur stop`);
                    // æ¸…é™¤ä¸è¢«å…è®¸çš„articulation
                    note.articulation = null;
                }
            }
        }
        
        // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„articulationæƒé™å†ç”Ÿæˆslur
        if (!note.isRest && index < notes.length - 1) {
            const nextNote = notes[index + 1];
            const nextIsTiedContinuation = nextNote.tied && (nextNote.tieType === 'continue' || nextNote.tieType === 'stop');
            if (nextNote && !nextNote.isRest && nextNote.articulation && !nextIsTiedContinuation) {
                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…è®¸è¯¥articulation
                const hammerOnAllowed = userSettings.articulations.guitar.includes('hammer-on');
                const pullOffAllowed = userSettings.articulations.guitar.includes('pull-off');
                
                let shouldGenerateSlur = false;
                
                if (nextNote.articulation === 'hammer-on' && hammerOnAllowed) {
                    shouldGenerateSlur = true;
                    console.log(`ğŸ” 6/8æ‹Slurå¼€å§‹: ä¸ºä¸‹ä¸€ä¸ªhammer-onç”Ÿæˆslurå¼€å§‹ (å½“å‰éŸ³ç¬¦MIDI ${note.midi})`);
                } else if (nextNote.articulation === 'pull-off' && pullOffAllowed) {
                    shouldGenerateSlur = true;
                    console.log(`ğŸ” 6/8æ‹Slurå¼€å§‹: ä¸ºä¸‹ä¸€ä¸ªpull-offç”Ÿæˆslurå¼€å§‹ (å½“å‰éŸ³ç¬¦MIDI ${note.midi})`);
                } else if (['staccato', 'accent', 'tenuto', 'marcato'].includes(nextNote.articulation)) {
                    // åŸºæœ¬æ¼”å¥æ³•ä¸éœ€è¦slur
                    shouldGenerateSlur = false;
                } else {
                    console.log(`ğŸ”’ 6/8æ‹Slurç¦æ­¢: ä¸‹ä¸€ä¸ªéŸ³ç¬¦çš„articulation '${nextNote.articulation}' ä¸è¢«å…è®¸ï¼Œä¸ç”Ÿæˆslur (ä¸‹ä¸€ä¸ªéŸ³ç¬¦MIDI ${nextNote.midi})`);
                    shouldGenerateSlur = false;
                }
                
                if (shouldGenerateSlur) {
                    hasNotations = true;
                    
                    // ğŸ”¥ FORCED DEBUG: è®°å½•6/8æ‹slurçš„ç”Ÿæˆ
                    console.log(`ğŸš¨ SLUR GENERATED at 6/8-branch: nextNote.articulation=${nextNote.articulation}`);
                    console.log(`ğŸš¨ 6/8æ‹ User settings check: hammer-on allowed=${hammerOnAllowed}, pull-off allowed=${pullOffAllowed}`);
                    
                    // ğŸ”¥ æ–¹å‘é™åˆ¶æ£€æŸ¥ï¼šåŸºäºç”¨æˆ·é€‰æ‹©é˜»æ­¢ç‰¹å®šæ–¹å‘çš„slur (6/8æ‹)
                    const interval68 = nextNote.midi - note.midi;
                    let shouldBlockByDirection68 = false;
                    
                    if (hammerOnAllowed && !pullOffAllowed) {
                        // åªé€‰æ‹©hammer-on: é˜»æ­¢æ‰€æœ‰ä¸‹è¡ŒäºŒåº¦çš„slur
                        if (interval68 < 0 && interval68 >= -2) {
                            shouldBlockByDirection68 = true;
                            console.log(`ğŸš« DIRECTION BLOCK (6/8): ç”¨æˆ·åªé€‰æ‹©hammer-onï¼Œé˜»æ­¢ä¸‹è¡ŒäºŒåº¦slur (${interval68}åŠéŸ³)`);
                        }
                    } else if (!hammerOnAllowed && pullOffAllowed) {
                        // åªé€‰æ‹©pull-off: é˜»æ­¢æ‰€æœ‰ä¸Šè¡ŒäºŒåº¦çš„slur
                        if (interval68 > 0 && interval68 <= 2) {
                            shouldBlockByDirection68 = true;
                            console.log(`ğŸš« DIRECTION BLOCK (6/8): ç”¨æˆ·åªé€‰æ‹©pull-offï¼Œé˜»æ­¢ä¸Šè¡ŒäºŒåº¦slur (+${interval68}åŠéŸ³)`);
                        }
                    }
                    
                    if (shouldBlockByDirection68) {
                        console.log(`ğŸ”’ æ–¹å‘é™åˆ¶é˜»æ­¢6/8æ‹slurç”Ÿæˆ: articulation=${nextNote.articulation}, interval=${interval68}`);
                        // å¼ºåˆ¶ä¸ç”Ÿæˆä»»ä½•slur XML
                    } else if (nextNote.articulation === 'hammer-on' && hammerOnAllowed && interval68 > 0) {
                        // åªå…è®¸ä¸Šè¡Œhammer-onç”Ÿæˆslur
                        notationsContent += `
          <slur type="start" number="${index + 1}"/>`;
                        console.log(`âœ… ALLOWED: 6/8æ‹hammer-on slur generated for ascending interval ${interval68}`);
                    } else if (nextNote.articulation === 'pull-off' && pullOffAllowed && interval68 < 0) {
                        // åªå…è®¸ä¸‹è¡Œpull-offç”Ÿæˆslur
                        notationsContent += `
          <slur type="start" number="${index + 1}"/>`;
                        console.log(`âœ… ALLOWED: 6/8æ‹pull-off slur generated for descending interval ${interval68}`);
                    } else {
                        console.log(`ğŸš« BLOCKED: 6/8æ‹slur blocked - articulation=${nextNote.articulation}, interval=${interval68}`);
                    }
                }
            }
        }
        
        // è¾“å‡ºnotationsæ ‡ç­¾
        if (hasNotations) {
            measureXML += `
        <notations>`;
            measureXML += notationsContent;
            measureXML += `
        </notations>`;
        }
        
        measureXML += `
      </note>`;
    });
    
    console.log(`âœ… Cantus Firmusé£æ ¼6/8æ‹ç”Ÿæˆå®Œæˆï¼`);
    console.log(`  - èŠ‚å¥æ¨¡å¼: ${selectedPattern.name}`);
    console.log(`  - åå…­åˆ†éŸ³ç¬¦æ•°é‡: ${notes.filter(n => n.type === '16th').length}`);
    console.log(`  - å…«åˆ†éŸ³ç¬¦æ•°é‡: ${notes.filter(n => n.type === 'eighth').length}`);
    console.log(`  - å››åˆ†éŸ³ç¬¦æ•°é‡: ${notes.filter(n => n.type === 'quarter').length}`);
    console.log(`  - å¼ºæ‹éŸ³ç¬¦: ${notes.filter(n => n.isStrong).length}`);
    console.log(`  - æœ€åéŸ³ç¬¦: MIDI ${currentMidiNote}`);
    console.log(`  - éŸ³åŸŸä½¿ç”¨: MIDI ${Math.min(...notes.map(n => n.midi))}-${Math.max(...notes.map(n => n.midi))}`);
    
    return {
        xml: measureXML,
        lastMidi: currentMidiNote,  // è¿”å›å®é™…çš„æœ€åä¸€ä¸ªéŸ³ç¬¦
        pattern: selectedPattern.name
    };
}

// ====== ä¸‹é¢çš„å‡½æ•°ä¸å†ä½¿ç”¨ï¼Œä¿ç•™ç”¨äºå…¼å®¹æ€§ ======

function createNoteInfo(midi) {
        // ç‰¹æ®Šæ£€æµ‹ MIDI 72 (B#4)
        if (midi === 72) {
            console.error(`ğŸ¯ğŸ¯ğŸ¯ [createNoteInfo] å¤„ç† MIDI 72 (B#4)!`);
            console.error(`ğŸ¯ æ ˆè¿½è¸ª:`, new Error().stack.split('\n').slice(1, 5).join('\n'));
            // æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°æ— æ³•è®¿é—® userRangeï¼Œæ‰€ä»¥ä¸èƒ½åœ¨è¿™é‡Œä¿®æ­£
            // ä½†è‡³å°‘å¯ä»¥è®°å½•å®ƒè¢«è°ƒç”¨äº†
        }
        
        const stepNames = ['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B'];
        const alters = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
        const noteIndex = midi % 12;
        const octave = Math.floor(midi / 12) - 1;
        
        return {
            midi: midi,
            step: stepNames[noteIndex],
            alter: alters[noteIndex] === 1 ? 1 : null,
            octave: octave
        };
    }
    
    // FIXME: ä¸‹é¢çš„ä»£ç æ˜¯å­¤ç«‹çš„ï¼Œä¸åœ¨ä»»ä½•å‡½æ•°å†…ï¼Œéœ€è¦é‡æ„æˆ–åˆ é™¤
    /*
    // è·å–ç”¨æˆ·çš„èŠ‚å¥è®¾ç½®ï¼ˆä»å…¨å±€userSettingsæˆ–ä¼ å…¥å‚æ•°ï¼‰
    const userRhythms = (typeof userSettings !== 'undefined' && Array.isArray(userSettings.allowedRhythms)) ? 
        userSettings.allowedRhythms : ['eighth'];
    
    console.log(`ğŸ›ï¸ ç”¨æˆ·èŠ‚å¥è®¾ç½®: [${userRhythms.join(', ')}]`);
    console.log(`ğŸ¯ éŸ³åŸŸè®¾ç½®: ${userRange.min}-${userRange.max}, æœ€å¤§è·³åº¦: ${maxJump}åŠéŸ³`);
    
    // ğŸ” è°ƒè¯•åå…­åˆ†éŸ³ç¬¦æ£€æµ‹
    const has16th = userRhythms.includes('16th');
    const hasSixteenth = userRhythms.includes('sixteenth');
    console.log(`ğŸ” [è°ƒè¯•] åå…­åˆ†éŸ³ç¬¦æ£€æµ‹: '16th'=${has16th}, 'sixteenth'=${hasSixteenth}`);
    if (has16th || hasSixteenth) {
        console.log(`âœ… [è°ƒè¯•] åå…­åˆ†éŸ³ç¬¦å·²å¯ç”¨ï¼Œå°†ç”Ÿæˆç›¸åº”æ¨¡å¼`);
    } else {
        console.log(`âŒ [è°ƒè¯•] åå…­åˆ†éŸ³ç¬¦æœªå¯ç”¨ï¼Œè·³è¿‡ç›¸åº”æ¨¡å¼`);
    }
    
    // 6/8æ‹å°èŠ‚ç»“æ„å®šä¹‰ - å¼ºè°ƒå¤åˆäºŒæ‹å­ç‰¹æ€§
    const MEASURE_STRUCTURE = {
        positions: [0.0, 0.5, 1.0, 1.5, 2.0, 2.5],  // å…­ä¸ªå…«åˆ†éŸ³ç¬¦ä½ç½®
        strongBeats: [0.0, 1.5],                      // ğŸ”¥ å¤åˆäºŒæ‹å­çš„ä¸¤ä¸ªå¼ºæ‹
        weakBeats: [0.5, 1.0, 2.0, 2.5],            // ç›¸å¯¹è¾ƒå¼±çš„æ‹ç‚¹
        groups: {
            first: [0, 1, 2],   // ç¬¬ä¸€ç»„: ä½ç½®0.0, 0.5, 1.0
            second: [3, 4, 5]   // ç¬¬äºŒç»„: ä½ç½®1.5, 2.0, 2.5
        },
        clarityBoundary: 1.5  // å…³é”®è¾¹ç•Œï¼šç¬¬4ä¸ªå…«åˆ†éŸ³ç¬¦å¿…é¡»æ¸…æ™°
    };
    
    // ğŸµ æ ¹æ®ç”¨æˆ·è®¾ç½®åŠ¨æ€ç”Ÿæˆ6/8æ‹èŠ‚å¥æ¨¡å¼
    function generateAdaptiveRhythmPatterns(userRhythms) {
        const patterns = [];
        
        // Pattern 1: å…­ä¸ªå…«åˆ†éŸ³ç¬¦ â™ªâ™ªâ™ª â™ªâ™ªâ™ª (å¦‚æœç”¨æˆ·å…è®¸å…«åˆ†éŸ³ç¬¦)
        if (userRhythms.includes('eighth')) {
            // ğŸ¯ æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„å…«åˆ†éŸ³ç¬¦é¢‘ç‡
            let eighthWeight = 50; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.eighth !== undefined) {
                const userFreq = userSettings.rhythmFrequencies.eighth;
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹å¦ä¸€å¤„å…«åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º 0%ï¼Œè·³è¿‡å…«åˆ†éŸ³ç¬¦æ¨¡å¼`);
                    eighthWeight = 0;
                } else {
                    eighthWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                    console.log(`ğŸ¯ 6/8æ‹å¦ä¸€å¤„å…«åˆ†éŸ³ç¬¦é¢‘ç‡ï¼š${userFreq}%ï¼Œæƒé‡ = ${eighthWeight}`);
                }
            }
            
            if (eighthWeight > 0) {
                patterns.push({
                    name: 'å…­ä¸ªå…«åˆ†éŸ³ç¬¦ - å¼ºè°ƒå¼ºæ‹',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },   // ç¬¬ä¸€å¼ºæ‹
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },   // ç¬¬äºŒå¼ºæ‹
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: eighthWeight,
                    emphasis: 'both_strong_beats'  // å¼ºè°ƒä¸¤ä¸ªå¼ºæ‹
                });
            }
        }
        
        // Pattern 2: é™„ç‚¹å››åˆ†éŸ³ç¬¦ â™©. â™©. (å¦‚æœç”¨æˆ·æ˜ç¡®å…è®¸é™„ç‚¹å››åˆ†éŸ³ç¬¦)
        // ğŸ”¥ 6/8æ‹ä¸­çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦å¯¹åº”4/4æ‹ä¸­çš„äºŒåˆ†éŸ³ç¬¦
        if (userRhythms.includes('quarter.')) {
            let quarterWeight = 60; // é»˜è®¤æƒé‡
            
            // ğŸ”¥ ä¿®å¤ï¼š6/8æ‹ä¸­çš„é™„ç‚¹å››åˆ†éŸ³ç¬¦ä½¿ç”¨è‡ªå·±çš„é¢‘ç‡è®¾ç½®
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['dotted-quarter'] !== undefined) {
                const userFreq = userSettings.rhythmFrequencies['dotted-quarter'];
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼šé¢‘ç‡${userFreq}%ï¼Œè·³è¿‡é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼`);
                    quarterWeight = 0;
                } else {
                    quarterWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                    console.log(`ğŸ¯ 6/8æ‹é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼šé¢‘ç‡${userFreq}%ï¼Œæƒé‡ = ${quarterWeight}`);
                }
            }
            
            if (quarterWeight > 0) {
                patterns.push({
                    name: 'é™„ç‚¹å››åˆ†éŸ³ç¬¦ - å®Œç¾å¼ºæ‹å¯¹åº”',
                    pattern: [
                        { position: 0.0, duration: 1.5, type: 'quarter', dots: 1, isStrongBeat: true },   // å æ»¡ç¬¬ä¸€å¤§æ‹
                        { position: 1.5, duration: 1.5, type: 'quarter', dots: 1, isStrongBeat: true }    // å æ»¡ç¬¬äºŒå¤§æ‹
                    ],
                    weight: quarterWeight,  // ä½¿ç”¨é¢‘ç‡æ§åˆ¶çš„æƒé‡
                    emphasis: 'perfect_compound_feel'
                });
            }
        }
        
        // Pattern 3: å¼ºæ‹ä¸Šçš„é•¿éŸ³ç¬¦æ¨¡å¼ â™©â™ª | â™©â™ª
        if (userRhythms.includes('quarter') && userRhythms.includes('eighth')) {
            // ğŸ¯ ä½¿ç”¨å››åˆ†éŸ³ç¬¦å’Œå…«åˆ†éŸ³ç¬¦é¢‘ç‡çš„è¾ƒå°å€¼
            let mixedWeight = 40; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies) {
                const quarterFreq = userSettings.rhythmFrequencies.quarter || 50;
                const eighthFreq = userSettings.rhythmFrequencies.eighth || 40;
                if (quarterFreq === 0 || eighthFreq === 0) {
                    mixedWeight = 0;
                    console.log(`ğŸš« 6/8æ‹æ··åˆæ¨¡å¼ï¼šå››åˆ†éŸ³ç¬¦(${quarterFreq}%)æˆ–å…«åˆ†éŸ³ç¬¦(${eighthFreq}%)é¢‘ç‡ä¸º0%ï¼Œè·³è¿‡æ··åˆæ¨¡å¼`);
                } else {
                    // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ç›´æ¥æ˜ å°„ï¼Œå–å¹³å‡å€¼ä½œä¸ºæƒé‡
                    mixedWeight = Math.round((quarterFreq + eighthFreq) / 2);
                    console.log(`ğŸ¯ 6/8æ‹æ··åˆæ¨¡å¼é¢‘ç‡ï¼šå¹³å‡å€¼ (${quarterFreq}% + ${eighthFreq}%) / 2 = ${mixedWeight}`);
                }
            }
            
            if (mixedWeight > 0) {
                patterns.push({
                    name: 'å¼ºæ‹å››åˆ†éŸ³ç¬¦æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 1.0, type: 'quarter', isStrongBeat: true },      // å¼ºæ‹é•¿éŸ³
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 1.0, type: 'quarter', isStrongBeat: true },      // å¼ºæ‹é•¿éŸ³
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: mixedWeight,
                    emphasis: 'strong_beat_length',
                    needsBeatClarity: true  // éœ€è¦Beat Clarityå¤„ç†
                });
                
                // Pattern 4: å¼ºæ‹å¼€å§‹çš„ç»„åˆ â™ªâ™© | â™ªâ™©
                patterns.push({
                    name: 'å¼ºæ‹å¯åŠ¨æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },       // å¼ºæ‹å¯åŠ¨
                        { position: 0.5, duration: 1.0, type: 'quarter', isStrongBeat: false },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },       // å¼ºæ‹å¯åŠ¨
                        { position: 2.0, duration: 1.0, type: 'quarter', isStrongBeat: false }
                    ],
                    weight: Math.floor(mixedWeight * 0.75),
                    emphasis: 'strong_beat_attack',
                    needsBeatClarity: true  // éœ€è¦Beat Clarityå¤„ç†
                });
            }
        }
        
        // Pattern 5: äºŒè¿éŸ³ (Duplets) - 2ä¸ªéŸ³ç¬¦å ç”¨3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´
        if (userRhythms.includes('duplet')) {
            // ğŸ¯ æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„äºŒè¿éŸ³é¢‘ç‡
            let dupletWeight = 25; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.duplet !== undefined) {
                const userFreq = userSettings.rhythmFrequencies.duplet;
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹å¦ä¸€å¤„äºŒè¿éŸ³é¢‘ç‡ä¸º 0%ï¼Œè·³è¿‡äºŒè¿éŸ³æ¨¡å¼`);
                    dupletWeight = 0;
                } else {
                    dupletWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                    console.log(`ğŸ¯ 6/8æ‹å¦ä¸€å¤„äºŒè¿éŸ³é¢‘ç‡ï¼š${userFreq}%ï¼Œæƒé‡ = ${dupletWeight}`);
                }
            }
            
            if (dupletWeight > 0) {
                // ç¬¬ä¸€å¤§æ‹äºŒè¿éŸ³
                patterns.push({
                    name: 'ç¬¬ä¸€å¤§æ‹äºŒè¿éŸ³',
                    pattern: [
                        { position: 0.0, duration: 0.75, type: 'eighth', isStrongBeat: true, tuplet: {type: 'duplet', number: 1, bracket: true} },
                        { position: 0.75, duration: 0.75, type: 'eighth', isStrongBeat: false, tuplet: {type: 'duplet', number: 1, bracket: true} },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: dupletWeight,
                    emphasis: 'first_beat_duplet'
                });
                
                // ç¬¬äºŒå¤§æ‹äºŒè¿éŸ³
                patterns.push({
                    name: 'ç¬¬äºŒå¤§æ‹äºŒè¿éŸ³',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.75, type: 'eighth', isStrongBeat: true, tuplet: {type: 'duplet', number: 1, bracket: true} },
                        { position: 2.25, duration: 0.75, type: 'eighth', isStrongBeat: false, tuplet: {type: 'duplet', number: 1, bracket: true} }
                    ],
                    weight: dupletWeight,
                    emphasis: 'second_beat_duplet'
                });
            }
        }
        
        // Pattern 6: å››è¿éŸ³ (Quadruplets) - 4ä¸ªéŸ³ç¬¦å ç”¨3ä¸ªå…«åˆ†éŸ³ç¬¦çš„æ—¶é—´
        if (userRhythms.includes('quadruplet')) {
            // ğŸ¯ æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„å››è¿éŸ³é¢‘ç‡
            let quadrupletWeight = 20; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.quadruplet !== undefined) {
                const userFreq = userSettings.rhythmFrequencies.quadruplet;
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹å¦ä¸€å¤„å››è¿éŸ³é¢‘ç‡ä¸º 0%ï¼Œè·³è¿‡å››è¿éŸ³æ¨¡å¼`);
                    quadrupletWeight = 0;
                } else {
                    quadrupletWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                    console.log(`ğŸ¯ 6/8æ‹å¦ä¸€å¤„å››è¿éŸ³é¢‘ç‡ï¼š${userFreq}%ï¼Œæƒé‡ = ${quadrupletWeight}`);
                }
            }
            
            if (quadrupletWeight > 0) {
                // ç¬¬ä¸€å¤§æ‹å››è¿éŸ³
                patterns.push({
                    name: 'ç¬¬ä¸€å¤§æ‹å››è¿éŸ³',
                    pattern: [
                        { position: 0.0, duration: 0.375, type: 'eighth', isStrongBeat: true, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 0.375, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 0.75, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 1.125, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: quadrupletWeight,
                    emphasis: 'first_beat_quadruplet'
                });
                
                // ç¬¬äºŒå¤§æ‹å››è¿éŸ³
                patterns.push({
                    name: 'ç¬¬äºŒå¤§æ‹å››è¿éŸ³',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.375, type: 'eighth', isStrongBeat: true, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 1.875, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 2.25, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} },
                        { position: 2.625, duration: 0.375, type: 'eighth', isStrongBeat: false, tuplet: {type: 'quadruplet', number: 1, bracket: true} }
                    ],
                    weight: quadrupletWeight,
                    emphasis: 'second_beat_quadruplet'
                });
            }
        }
        
        // Pattern 7: åå…­åˆ†éŸ³ç¬¦ (Sixteenth Notes) - ä¿®å¤ç©ºç™½å°èŠ‚é—®é¢˜
        console.log(`ğŸ” [æ¨¡å¼ç”Ÿæˆ] æ£€æŸ¥åå…­åˆ†éŸ³ç¬¦: userRhythms=[${userRhythms.join(', ')}]`);
        if (userRhythms.includes('16th') || userRhythms.includes('sixteenth')) {
            console.log(`âœ… [æ¨¡å¼ç”Ÿæˆ] å¼€å§‹åˆ›å»ºåå…­åˆ†éŸ³ç¬¦æ¨¡å¼...`);
            
            // ğŸ¯ æ£€æŸ¥ç”¨æˆ·è®¾ç½®çš„åå…­åˆ†éŸ³ç¬¦é¢‘ç‡
            let sixteenthWeight = 100; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies['16th'] !== undefined) {
                const userFreq = userSettings.rhythmFrequencies['16th'];
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹å¦ä¸€å¤„åå…­åˆ†éŸ³ç¬¦é¢‘ç‡ä¸º 0%ï¼Œè·³è¿‡åå…­åˆ†éŸ³ç¬¦æ¨¡å¼`);
                    sixteenthWeight = 0;
                } else {
                    sixteenthWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæƒé‡
                    console.log(`ğŸ¯ 6/8æ‹å¦ä¸€å¤„åå…­åˆ†éŸ³ç¬¦é¢‘ç‡ï¼š${userFreq}%ï¼Œæƒé‡ = ${sixteenthWeight}`);
                }
            }
            
            if (sixteenthWeight > 0) {
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåå…­åˆ†éŸ³ç¬¦æ¨¡å¼åº”è¯¥ç‹¬ç«‹å·¥ä½œï¼Œå³ä½¿ç”¨æˆ·æ²¡æœ‰é€‰æ‹©å…«åˆ†éŸ³ç¬¦
                // å½“ç”¨æˆ·é€‰æ‹©åå…­åˆ†éŸ³ç¬¦æ—¶ï¼Œæ¨¡å¼ä¸­çš„å…«åˆ†éŸ³ç¬¦æ˜¯ä½œä¸ºåå…­åˆ†éŸ³ç¬¦æ¨¡å¼çš„ä¸€éƒ¨åˆ†ï¼Œä¸éœ€è¦å•ç‹¬æ£€æŸ¥
                
                // å¼ºæ‹åå…­åˆ†è£…é¥° - æ€»æ—¶å€¼å¿…é¡»ä¸º3.0æ‹
                patterns.push({
                    name: 'å¼ºæ‹åå…­åˆ†è£…é¥°',
                    pattern: [
                        { position: 0.0, duration: 0.25, type: 'sixteenth', isStrongBeat: true },
                        { position: 0.25, duration: 0.25, type: 'sixteenth', isStrongBeat: false },
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: sixteenthWeight,
                    emphasis: 'strong_beat_sixteenth_decoration'
                    // âœ… æ€»æ—¶å€¼: 0.25+0.25+0.5+0.5+0.5+0.5+0.5 = 3.0æ‹
                });
                
                // æ¬¡å¼ºæ‹åå…­åˆ†è£…é¥° - æ€»æ—¶å€¼å¿…é¡»ä¸º3.0æ‹
                patterns.push({
                    name: 'æ¬¡å¼ºæ‹åå…­åˆ†è£…é¥°',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.25, type: 'sixteenth', isStrongBeat: true },
                        { position: 1.75, duration: 0.25, type: 'sixteenth', isStrongBeat: false },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: sixteenthWeight,
                    emphasis: 'second_strong_beat_sixteenth_decoration'
                    // âœ… æ€»æ—¶å€¼: 0.5+0.5+0.5+0.25+0.25+0.5+0.5 = 3.0æ‹
                });
                
                // ğŸ¯ æ·»åŠ æ›´å¤šåå…­åˆ†éŸ³ç¬¦å˜åŒ–æ¨¡å¼
                patterns.push({
                    name: 'å››ä¸ªåå…­åˆ†éŸ³ç¬¦å¼€å§‹',
                    pattern: [
                        { position: 0.0, duration: 0.25, type: 'sixteenth', isStrongBeat: true },
                        { position: 0.25, duration: 0.25, type: 'sixteenth', isStrongBeat: false },
                        { position: 0.5, duration: 0.25, type: 'sixteenth', isStrongBeat: false },
                        { position: 0.75, duration: 0.25, type: 'sixteenth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: Math.floor(sixteenthWeight * 0.9),
                    emphasis: 'four_sixteenths_start'
                    // âœ… æ€»æ—¶å€¼: 0.25*4 + 0.5*4 = 1.0 + 2.0 = 3.0æ‹
                });
            }
            
            console.log(`âœ… [æ¨¡å¼ç”Ÿæˆ] åå…­åˆ†éŸ³ç¬¦æ¨¡å¼åˆ›å»ºå®Œæˆï¼Œå…±æ·»åŠ äº†${3}ä¸ªæ¨¡å¼`);
        } else {
            console.log(`âŒ [æ¨¡å¼ç”Ÿæˆ] åå…­åˆ†éŸ³ç¬¦æœªå¯ç”¨ï¼Œè·³è¿‡æ¨¡å¼åˆ›å»º`);
        }
        
        // ğŸ”¥ ä¸¥æ ¼éµå¾ªç”¨æˆ·èŠ‚å¥é€‰æ‹©ï¼šåªåœ¨æ²¡æœ‰ä»»ä½•æ¨¡å¼æ—¶æ‰åˆ›å»ºç”¨æˆ·å…è®¸çš„åŸºç¡€æ¨¡å¼
        if (patterns.length === 0) {
            console.warn('âš ï¸ æ²¡æœ‰ç”Ÿæˆä»»ä½•6/8æ‹èŠ‚å¥æ¨¡å¼ï¼Œå°è¯•ä½¿ç”¨ç”¨æˆ·å‹¾é€‰çš„åŸºç¡€æ¨¡å¼');
            
            // ğŸ”¥ ä¸¥æ ¼æ£€æŸ¥ï¼šåªä½¿ç”¨ç”¨æˆ·å®é™…å‹¾é€‰çš„èŠ‚å¥ç±»å‹
            if (userRhythms.includes('eighth')) {
                console.warn('âœ… åˆ›å»ºåŸºç¡€å…«åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰');
                patterns.push({
                    name: 'ä¸¥æ ¼åŸºç¡€å…«åˆ†éŸ³ç¬¦æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 0.5, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 0.5, type: 'eighth', isStrongBeat: true },
                        { position: 2.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: 100,
                    emphasis: 'strict_basic_pattern'
                });
            } else if (userRhythms.includes('dotted-half') || userRhythms.includes('half.')) {
                console.warn('âœ… åˆ›å»ºåŸºç¡€é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰ï¼‰');
                patterns.push({
                    name: 'ä¸¥æ ¼åŸºç¡€é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 3.0, type: 'half', dots: 1, isStrongBeat: true }
                    ],
                    weight: 100,
                    emphasis: 'strict_dotted_half_pattern'
                });
            } else if (userRhythms.includes('quarter.')) {
                // ğŸ”¥ ä¿®å¤æ··æ·†é”™è¯¯ï¼šåªæœ‰ç”¨æˆ·æ˜ç¡®å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦æ—¶æ‰åˆ›å»ºé™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼
                console.warn('âœ… åˆ›å»ºåŸºç¡€é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰é™„ç‚¹å››åˆ†éŸ³ç¬¦ï¼‰');
                patterns.push({
                    name: 'ä¸¥æ ¼åŸºç¡€é™„ç‚¹å››åˆ†éŸ³ç¬¦æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 1.5, type: 'quarter', dots: 1, isStrongBeat: true },
                        { position: 1.5, duration: 1.5, type: 'quarter', dots: 1, isStrongBeat: true }
                    ],
                    weight: 100,
                    emphasis: 'strict_dotted_quarter_pattern'
                });
            } else if (userRhythms.includes('quarter') && userRhythms.includes('eighth')) {
                // ğŸ”¥ ä¿®å¤ï¼šä¸ºæ™®é€šå››åˆ†éŸ³ç¬¦ç”¨æˆ·åˆ›å»ºé€‚åˆ6/8æ‹çš„ç»„åˆæ¨¡å¼
                console.warn('âœ… åˆ›å»ºå››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦ç»„åˆæ¨¡å¼ï¼ˆç”¨æˆ·å·²å‹¾é€‰è¿™ä¸¤ç§èŠ‚å¥ï¼‰');
                patterns.push({
                    name: 'ä¸¥æ ¼åŸºç¡€å››åˆ†éŸ³ç¬¦+å…«åˆ†éŸ³ç¬¦æ¨¡å¼',
                    pattern: [
                        { position: 0.0, duration: 1.0, type: 'quarter', isStrongBeat: true },
                        { position: 1.0, duration: 0.5, type: 'eighth', isStrongBeat: false },
                        { position: 1.5, duration: 1.0, type: 'quarter', isStrongBeat: true },
                        { position: 2.5, duration: 0.5, type: 'eighth', isStrongBeat: false }
                    ],
                    weight: 80,
                    emphasis: 'strict_quarter_eighth_pattern'
                });
            } else {
                console.error('âŒ è‡´å‘½é”™è¯¯ï¼šç”¨æˆ·æ²¡æœ‰å‹¾é€‰ä»»ä½•é€‚ç”¨äº6/8æ‹çš„åŸºç¡€èŠ‚å¥ç±»å‹ï¼');
                console.error('âŒ 6/8æ‹éœ€è¦çš„èŠ‚å¥ç±»å‹ä¹‹ä¸€ï¼šeighth, quarter, dotted-quarter, dotted-half');
                console.error('âŒ ç”¨æˆ·å‹¾é€‰çš„èŠ‚å¥ç±»å‹ï¼š[' + userRhythms.join(', ') + ']');
                // è¿”å›ç©ºæ•°ç»„ï¼Œè®©ä¸Šçº§å¤„ç†
            }
        }
        
        // Pattern 8: é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ - æ•´å°èŠ‚é•¿éŸ³ç¬¦ (å¦‚æœç”¨æˆ·å…è®¸é™„ç‚¹äºŒåˆ†éŸ³ç¬¦)
        if (userRhythms.includes('dotted-half') || userRhythms.includes('half.')) {
            // ğŸ¯ 6/8æ‹ä¸­çš„é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦çš„é¢‘ç‡è®¾ç½®
            let dottedHalfWeight = 20; // é»˜è®¤æƒé‡
            if (userSettings && userSettings.rhythmFrequencies && userSettings.rhythmFrequencies.whole !== undefined) {
                const userFreq = userSettings.rhythmFrequencies.whole;
                if (userFreq === 0) {
                    console.log(`ğŸš« 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼šä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡${userFreq}%ï¼Œè·³è¿‡é™„ç‚¹äºŒåˆ†éŸ³ç¬¦æ¨¡å¼`);
                    dottedHalfWeight = 0;
                } else {
                    dottedHalfWeight = userFreq; // é¢‘ç‡ç›´æ¥ç­‰äºæš“é‡
                    console.log(`ğŸ¯ 6/8æ‹é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ï¼šä½¿ç”¨4/4æ‹å…¨éŸ³ç¬¦é¢‘ç‡${userFreq}%ï¼Œæƒé‡ = ${dottedHalfWeight}`);
                }
            }
            
            if (dottedHalfWeight > 0) {
                patterns.push({
                    name: 'é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ - æ•´å°èŠ‚æŒç»­',
                    pattern: [
                        { position: 0.0, duration: 3.0, type: 'dotted-half', dots: 1, isStrongBeat: true }   // å æ»¡æ•´ä¸ª6/8å°èŠ‚
                    ],
                    weight: dottedHalfWeight,
                    emphasis: 'whole_measure_sustain'
                });
            }
        }
        
        return patterns;
    }
    
    // ğŸ¼ å¤„ç†Beat Clarityè§„åˆ™ï¼ˆæ‹†åˆ†è·¨è¶Š1.5è¾¹ç•Œçš„éŸ³ç¬¦ï¼‰
    function applyBeatClarity(pattern) {
        const processedPattern = [];
        
        pattern.pattern.forEach((noteData) => {
            const endPosition = noteData.position + noteData.duration;
            const tolerance = 0.001; // å®¹å·®ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
            
            // ğŸ”¥ åå…­åˆ†éŸ³ç¬¦ä¸éœ€è¦Beat Clarityå¤„ç† - å®ƒä»¬å¤ªçŸ­ï¼Œä¸ä¼šè·¨ç•Œ
            if (noteData.type === 'sixteenth') {
                console.log(`ğŸ¼ [Beat Clarity] è·³è¿‡åå…­åˆ†éŸ³ç¬¦: ä½ç½®${noteData.position}`);
                processedPattern.push(noteData);
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦è·¨è¶Š1.5æ‹è¾¹ç•Œï¼ˆä½¿ç”¨å®¹å·®ï¼‰
            if (noteData.position < 1.5 - tolerance && endPosition > 1.5 + tolerance) {
                console.log(`ğŸ”„ [Beat Clarity] æ‹†åˆ†è·¨ç•ŒéŸ³ç¬¦: ä½ç½®${noteData.position}, æ—¶é•¿${noteData.duration} (ç±»å‹: ${noteData.type})`);
                
                // æ‹†åˆ†ä¸ºä¸¤ä¸ªéŸ³ç¬¦
                const firstPart = {
                    ...noteData,
                    duration: 1.5 - noteData.position,  // ç¬¬ä¸€éƒ¨åˆ†åˆ°1.5æ‹
                    type: 'eighth',  // æ‹†åˆ†åéƒ½æ˜¯å…«åˆ†éŸ³ç¬¦
                    tie: 'start'
                };
                
                const secondPart = {
                    ...noteData,
                    position: 1.5,
                    duration: endPosition - 1.5,  // ç¬¬äºŒéƒ¨åˆ†ä»1.5æ‹å¼€å§‹
                    type: 'eighth',
                    tie: 'stop',
                    isStrongBeat: true  // 1.5æ˜¯å¼ºæ‹ä½ç½®
                };
                
                console.log(`  âœ ç¬¬ä¸€éƒ¨åˆ†: ä½ç½®${firstPart.position}, æ—¶é•¿${firstPart.duration}`);
                console.log(`  âœ ç¬¬äºŒéƒ¨åˆ†: ä½ç½®${secondPart.position}, æ—¶é•¿${secondPart.duration}`);
                
                processedPattern.push(firstPart);
                processedPattern.push(secondPart);
            } else {
                console.log(`ğŸ¼ [Beat Clarity] ä¿æŒåŸæ ·: ${noteData.type}, ä½ç½®${noteData.position}, æ—¶é•¿${noteData.duration}`);
                processedPattern.push(noteData);
            }
        });
        
        return {
            ...pattern,
            pattern: processedPattern
        };
    }
    
    // ç”Ÿæˆé€‚åˆç”¨æˆ·è®¾ç½®çš„èŠ‚å¥æ¨¡å¼
    const availablePatterns = generateAdaptiveRhythmPatterns(userRhythms);
    console.log(`ğŸµ ç”Ÿæˆäº†${availablePatterns.length}ä¸ªé€‚åˆç”¨æˆ·è®¾ç½®çš„6/8æ‹æ¨¡å¼`);
    availablePatterns.forEach(p => {
        console.log(`  - ${p.name} (æƒé‡: ${p.weight})`);
        if (p.name.includes('åå…­åˆ†')) {
            console.log(`    ğŸ” [è°ƒè¯•] è¿™æ˜¯åå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼Œpatterné•¿åº¦: ${p.pattern.length}`);
        }
    });
    
    // ğŸ”¥ ä¿®å¤èŠ‚å¥æ¨¡å¼é€‰æ‹©é€»è¾‘ï¼šä½¿ç”¨ä¸€è‡´çš„åŠ æƒéšæœºé€‰æ‹©æ–¹æ³•
    const totalWeight = availablePatterns.reduce((sum, p) => sum + p.weight, 0);
    console.log(`ğŸ¯ [æ¨¡å¼é€‰æ‹©] æ€»æƒé‡: ${totalWeight}, å¯ç”¨æ¨¡å¼: ${availablePatterns.length}`);
    
    let selectedPattern;
    if (totalWeight > 0) {
        // ä½¿ç”¨æ ‡å‡†çš„weightedæ–¹æ³•ï¼Œä¸å…¶ä»–6/8æ‹é€‰æ‹©é€»è¾‘ä¿æŒä¸€è‡´
        const weights = availablePatterns.map(p => p.weight);
        selectedPattern = random.weighted(availablePatterns, weights);
        console.log(`ğŸµ [æ¨¡å¼é€‰æ‹©] ä½¿ç”¨æ ‡å‡†åŠ æƒé€‰æ‹©: ${selectedPattern ? selectedPattern.name : 'null'}`);
    } else {
        // å¦‚æœæ€»æƒé‡ä¸º0ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨æ¨¡å¼ä½œä¸ºå›é€€
        selectedPattern = availablePatterns.length > 0 ? availablePatterns[0] : null;
        console.log(`âš ï¸ [æ¨¡å¼é€‰æ‹©] æ€»æƒé‡ä¸º0ï¼Œä½¿ç”¨å›é€€é€‰æ‹©: ${selectedPattern ? selectedPattern.name : 'null'}`);
    }
    
    // åº”ç”¨Beat Clarityè§„åˆ™ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (selectedPattern.needsBeatClarity) {
        selectedPattern = applyBeatClarity(selectedPattern);
        console.log(`ğŸ”„ [Beat Clarity] å·²å¤„ç†è·¨ç•ŒéŸ³ç¬¦: ${selectedPattern.name}`);
    }
    
    console.log(`ğŸµ é€‰æ‹©èŠ‚å¥æ¨¡å¼: ${selectedPattern.name} (å¼ºè°ƒ: ${selectedPattern.emphasis})`);
    if (selectedPattern.name.includes('åå…­åˆ†')) {
        console.log(`ğŸ” [è°ƒè¯•] é€‰ä¸­äº†åå…­åˆ†éŸ³ç¬¦æ¨¡å¼ï¼patternè¯¦æƒ…:`);
        selectedPattern.pattern.forEach((note, i) => {
            console.log(`    éŸ³ç¬¦${i}: position=${note.position}, duration=${note.duration}, type=${note.type}`);
        });
    }
    
    // ğŸ¼ å®ç°Cantus Firmusé£æ ¼çš„éŸ³ç¬¦ç”Ÿæˆ - ä¸ºå¼ºæ‹ä½ç½®ç”Ÿæˆæ›´ç¨³å®šçš„éŸ³ç¬¦
    function generateCantusFirmusNote(position, isStrongBeat, lastMidi, isEnding = false) {
        console.log(`ğŸ¶ [Cantus Firmus] ä½ç½®${position}: ${isStrongBeat ? 'å¼ºæ‹' : 'å¼±æ‹'}éŸ³ç¬¦ç”Ÿæˆ`);
        
        if (lastMidi === null) {
            // ç¬¬ä¸€ä¸ªéŸ³ç¬¦ï¼šé€‰æ‹©éŸ³åŸŸä¸­å¤®é™„è¿‘çš„è°ƒå†…éŸ³ç¬¦
            const centerMidi = Math.floor((userRange.min + userRange.max) / 2);
            const scaleNotes = [];
            for (let octave = Math.floor(userRange.min / 12); octave <= Math.floor(userRange.max / 12); octave++) {
                for (const scaleDegree of scale) {
                    const midi = octave * 12 + scaleDegree;
                    if (midi >= userRange.min && midi <= userRange.max) {
                        scaleNotes.push(midi);
                    }
                }
            }
            
            // é€‰æ‹©æœ€æ¥è¿‘ä¸­å¤®çš„éŸ³ç¬¦
            const startNote = scaleNotes.reduce((closest, note) => 
                Math.abs(note - centerMidi) < Math.abs(closest - centerMidi) ? note : closest
            );
            
            console.log(`ğŸ¯ [Cantus Firmus] èµ·å§‹éŸ³ç¬¦: MIDI ${startNote} (ä¸­å¤®: ${centerMidi})`);
            // ğŸ”¥ ä¿®å¤ï¼šåº”ç”¨ä¸´æ—¶è®°å·å¤„ç† - ä¸4/4æ‹ä¿æŒä¸€è‡´
            const finalStartNote = addAccidentalIfNeeded(startNote, lastMidi);
            return midiToNoteInfoWithCorrectSpelling(finalStartNote);
        }
        
        // Cantus Firmusè§„åˆ™ï¼š
        // 1. å¼ºæ‹ä½ç½®å€¾å‘äºç¨³å®šéŸ³ç¬¦ï¼ˆçº§è¿›æˆ–ä¿æŒï¼‰
        // 2. å¼±æ‹ä½ç½®å¯ä»¥æœ‰æ›´å¤šå˜åŒ–ï¼Œä½†ä»ä»¥çº§è¿›ä¸ºä¸»
        // 3. è·³è¿›åå¿…é¡»åå‘çº§è¿›å›å½’
        // 4. ä¸¥æ ¼éµå¾ªç”¨æˆ·çš„æœ€å¤§è·³è·ƒé™åˆ¶
        
        const candidates = [];
        
        if (isStrongBeat) {
            // ğŸ”¥ å¼ºæ‹ä¼˜å…ˆç­–ç•¥ï¼šçº§è¿› > ä¿æŒ > å°è·³ > å¤§è·³
            
            // 1. çº§è¿›éŸ³ç¬¦ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
            for (let step = 1; step <= 2; step++) {
                [1, -1].forEach(direction => {
                    const targetMidi = lastMidi + (direction * step);
                    if (targetMidi >= userRange.min && 
                        targetMidi <= userRange.max && 
                        step <= maxJump &&
                        scale.includes(targetMidi % 12)) {
                        // å¼ºæ‹çº§è¿›è·å¾—æœ€é«˜æƒé‡
                        for (let i = 0; i < 10; i++) candidates.push(targetMidi);
                    }
                });
            }
            
            // 2. ä¿æŒéŸ³ç¬¦ï¼ˆæ¬¡é«˜ä¼˜å…ˆçº§ï¼‰
            if (scale.includes(lastMidi % 12)) {
                for (let i = 0; i < 8; i++) candidates.push(lastMidi);
            }
            
            // 3. å°è·³éŸ³ç¬¦ï¼ˆä¸‰åº¦ã€å››åº¦ï¼‰
            for (let interval = 3; interval <= 5; interval++) {
                [1, -1].forEach(direction => {
                    const targetMidi = lastMidi + (direction * interval);
                    if (targetMidi >= userRange.min && 
                        targetMidi <= userRange.max && 
                        interval <= maxJump &&
                        scale.includes(targetMidi % 12)) {
                        // å¼ºæ‹å°è·³è·å¾—ä¸­ç­‰æƒé‡
                        for (let i = 0; i < 3; i++) candidates.push(targetMidi);
                    }
                });
            }
            
        } else {
            // ğŸµ å¼±æ‹ç­–ç•¥ï¼šæ›´å¤šå˜åŒ–ï¼Œä½†ä»ä»¥çº§è¿›ä¸ºä¸»
            
            // 1. çº§è¿›éŸ³ç¬¦ï¼ˆä»æ˜¯ä¸»è¦é€‰æ‹©ï¼‰
            for (let step = 1; step <= 2; step++) {
                [1, -1].forEach(direction => {
                    const targetMidi = lastMidi + (direction * step);
                    if (targetMidi >= userRange.min && 
                        targetMidi <= userRange.max && 
                        step <= maxJump &&
                        scale.includes(targetMidi % 12)) {
                        for (let i = 0; i < 6; i++) candidates.push(targetMidi);
                    }
                });
            }
            
            // 2. ä¸‰åº¦è·³è·ƒï¼ˆå¼±æ‹å…è®¸æ›´å¤šè·³è·ƒï¼‰
            for (let interval = 3; interval <= 4; interval++) {
                [1, -1].forEach(direction => {
                    const targetMidi = lastMidi + (direction * interval);
                    if (targetMidi >= userRange.min && 
                        targetMidi <= userRange.max && 
                        interval <= maxJump &&
                        scale.includes(targetMidi % 12)) {
                        for (let i = 0; i < 4; i++) candidates.push(targetMidi);
                    }
                });
            }
            
            // 3. ä¿æŒéŸ³ç¬¦ï¼ˆæƒé‡è¾ƒä½ï¼‰
            if (scale.includes(lastMidi % 12)) {
                for (let i = 0; i < 2; i++) candidates.push(lastMidi);
            }
        }
        
        // å¦‚æœæ˜¯ç»“å°¾éŸ³ç¬¦ï¼Œå€¾å‘äºå›åˆ°ç¨³å®šéŸ³ç¬¦
        if (isEnding) {
            console.log(`ğŸ [Cantus Firmus] ç»“å°¾éŸ³ç¬¦å¤„ç†`);
            // ä¼˜å…ˆé€‰æ‹©ä¸»éŸ³ã€ä¸‰éŸ³ã€äº”éŸ³
            const preferredDegrees = [0, 2, 4]; // ä¸»éŸ³ã€ä¸‰éŸ³ã€äº”éŸ³åœ¨å¤§è°ƒä¸­çš„ä½ç½®
            preferredDegrees.forEach(degree => {
                if (degree < scale.length) {
                    const scaleDegree = scale[degree];
                    for (let octave = Math.floor(userRange.min / 12); octave <= Math.floor(userRange.max / 12); octave++) {
                        const midi = octave * 12 + scaleDegree;
                        if (midi >= userRange.min && midi <= userRange.max && Math.abs(midi - lastMidi) <= maxJump) {
                            for (let i = 0; i < 15; i++) candidates.push(midi); // å¾ˆé«˜çš„æƒé‡
                        }
                    }
                }
            });
        }
        
        if (candidates.length === 0) {
            console.warn(`âš ï¸ [Cantus Firmus] æ— åˆé€‚å€™é€‰éŸ³ç¬¦ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ`);
            return generateIntelligentNote(lastMidi, isEnding);
        }
        
        // éšæœºé€‰æ‹©å€™é€‰éŸ³ç¬¦
        const selectedMidi = candidates[Math.floor(random.nextFloat() * candidates.length)];
        const interval = Math.abs(selectedMidi - lastMidi);
        
        // ç‰¹æ®Šæ£€æµ‹ MIDI 72 (B#4)
        if (selectedMidi === 72) {
            console.error(`ğŸ¯ğŸ¯ğŸ¯ [6/8 Cantus Firmus] ç”Ÿæˆäº† MIDI 72 (B#4)!`);
            console.error(`ğŸ¯ å½“å‰éŸ³åŸŸ: ${userRange.min}-${userRange.max}`);
            console.error(`ğŸ¯ è°ƒå·: ${keySignature}`);
            if (userRange.max <= 60) {
                console.error(`ğŸš¨ğŸš¨ğŸš¨ é”™è¯¯ï¼šMIDI 72 è¶…å‡º C3-C4 éŸ³åŸŸ (${userRange.min}-${userRange.max})`);
                // å¼ºåˆ¶ä¿®æ­£åˆ°éŸ³åŸŸå†…
                const correctedMidi = Math.min(selectedMidi, userRange.max);
                console.error(`ğŸ”§ ä¿®æ­£ MIDI 72 -> ${correctedMidi}`);
                const finalCorrected72 = addAccidentalIfNeeded(correctedMidi, lastMidi);
                return midiToNoteInfoWithCorrectSpelling(finalCorrected72);
            }
        }
        
        // é¢å¤–çš„èŒƒå›´éªŒè¯
        if (selectedMidi < userRange.min || selectedMidi > userRange.max) {
            console.error(`ğŸš¨ [6/8 Cantus Firmus] éŸ³ç¬¦è¶…å‡ºèŒƒå›´: MIDI ${selectedMidi} (éŸ³åŸŸ: ${userRange.min}-${userRange.max})`);
            const correctedMidi = Math.max(userRange.min, Math.min(userRange.max, selectedMidi));
            console.error(`ğŸ”§ ä¿®æ­£ä¸º: MIDI ${correctedMidi}`);
            const finalCorrectedMidi = addAccidentalIfNeeded(correctedMidi, lastMidi);
            return midiToNoteInfoWithCorrectSpelling(finalCorrectedMidi);
        }
        
        console.log(`âœ… [Cantus Firmus] é€‰æ‹©éŸ³ç¬¦: MIDI ${selectedMidi} (é—´è·: ${interval}åŠéŸ³, ${isStrongBeat ? 'å¼ºæ‹' : 'å¼±æ‹'})`);
        
        // ğŸ”¥ ä¿®å¤ï¼šåº”ç”¨ä¸´æ—¶è®°å·å¤„ç† - ä¸4/4æ‹ä¿æŒä¸€è‡´
        const finalSelectedMidi = addAccidentalIfNeeded(selectedMidi, lastMidi);
        return midiToNoteInfoWithCorrectSpelling(finalSelectedMidi);
    }
    
    // ç”Ÿæˆå°èŠ‚XMLï¼ŒåŒ…å«beamingä¿¡æ¯
    let measureXML = '';
    let lastMidi = currentMidi;
    let tieId = 1; // è¿éŸ³çº¿IDè®¡æ•°å™¨
    
    // å¤„ç†æ¯ä¸ªéŸ³ç¬¦
    selectedPattern.pattern.forEach((noteData, index) => {
        const isEnding = isLastMeasure && index === selectedPattern.pattern.length - 1;
        
        // ğŸ¼ ä½¿ç”¨Cantus Firmusé£æ ¼ç”ŸæˆéŸ³ç¬¦
        const noteInfo = generateCantusFirmusNote(
            noteData.position, 
            noteData.isStrongBeat, 
            lastMidi, 
            isEnding
        );
        lastMidi = noteInfo.midi;
        
        // è®¡ç®—MusicXMLæ—¶å€¼
        let xmlDuration, xmlType, hasDot = false;
        
        if (noteData.type === 'sixteenth') {
            xmlDuration = 1;  // åå…­åˆ†éŸ³ç¬¦ = 0.25 * 4 = 1
            xmlType = 'sixteenth';
        } else if (noteData.type === 'eighth') {
            xmlDuration = 2;  // å…«åˆ†éŸ³ç¬¦ = 0.5 * 4 = 2
            xmlType = 'eighth';
        } else if (noteData.type === 'quarter') {
            // ğŸ”¥ ä¿®å¤ï¼šç»Ÿä¸€ä½¿ç”¨dotså±æ€§ï¼ˆæ”¯æŒdots:1å’Œdot:trueä¸¤ç§æ ¼å¼ï¼‰
            if (noteData.dots === 1 || noteData.dot === true) {
                xmlDuration = 6;  // é™„ç‚¹å››åˆ†éŸ³ç¬¦ = 1.5 * 4 = 6
                xmlType = 'quarter';
                hasDot = true;
                console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹å››åˆ†éŸ³ç¬¦: ${noteData.dots === 1 ? 'dots=1' : 'dot=true'}`);
            } else {
                xmlDuration = 4;  // å››åˆ†éŸ³ç¬¦ = 1.0 * 4 = 4
                xmlType = 'quarter';
            }
        } else if (noteData.type === 'half') {
            // ğŸ”¥ æ”¯æŒé™„ç‚¹äºŒåˆ†éŸ³ç¬¦
            if (noteData.dots === 1 || noteData.dot === true) {
                xmlDuration = 12;  // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = 3.0 * 4 = 12
                xmlType = 'half';
                hasDot = true;
                console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹äºŒåˆ†éŸ³ç¬¦: ${noteData.dots === 1 ? 'dots=1' : 'dot=true'}`);
            } else {
                xmlDuration = 8;  // äºŒåˆ†éŸ³ç¬¦ = 2.0 * 4 = 8
                xmlType = 'half';
            }
        } else if (noteData.type === 'dotted-half') {
            // ğŸ”¥ æ”¯æŒdotted-halfç±»å‹è¡¨ç¤ºæ³•
            xmlDuration = 12;  // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = 3.0 * 4 = 12
            xmlType = 'half';
            hasDot = true;
            console.log(`ğŸµ æ£€æµ‹åˆ°é™„ç‚¹äºŒåˆ†éŸ³ç¬¦(dotted-halfç±»å‹)`);
        } else if (noteData.type === 'whole') {
            xmlDuration = 16;  // å…¨éŸ³ç¬¦ = 4.0 * 4 = 16
            xmlType = 'whole';
        } else {
            // é»˜è®¤ä½¿ç”¨å…«åˆ†éŸ³ç¬¦
            xmlDuration = 2;  // å…«åˆ†éŸ³ç¬¦ = 0.5 * 4 = 2
            xmlType = 'eighth';
        }
        
        // æ„å»ºéŸ³ç¬¦XML
        let noteXML = `
      <note>
        <pitch>
          <step>${noteInfo.step}</step>
          ${noteInfo.alter ? `<alter>${noteInfo.alter}</alter>` : ''}
          <octave>${noteInfo.octave}</octave>
        </pitch>
        <duration>${xmlDuration}</duration>
        <type>${xmlType}</type>${hasDot ? '\n        <dot/>' : ''}`;
        
        // å¤„ç†tupletå’Œtieä¿¡æ¯
        let hasNotations = false;
        let notationsXML = '';
        
        // æ·»åŠ è¿éŸ³çº¿ä¿¡æ¯
        if (noteData.tie === 'start') {
            noteXML += `\n        <tie type="start"/>`;
            notationsXML += `\n          <tied type="start"/>`;
            hasNotations = true;
            console.log(`ğŸ”— æ·»åŠ è¿éŸ³çº¿å¼€å§‹: ä½ç½®${noteData.position}`);
        } else if (noteData.tie === 'stop') {
            noteXML += `\n        <tie type="stop"/>`;
            notationsXML += `\n          <tied type="stop"/>`;
            hasNotations = true;
            console.log(`ğŸ”— æ·»åŠ è¿éŸ³çº¿ç»“æŸ: ä½ç½®${noteData.position}`);
        }
        
        // æ·»åŠ tupletä¿¡æ¯ (äºŒè¿éŸ³å’Œå››è¿éŸ³)
        if (noteData.tuplet) {
            const tuplet = noteData.tuplet;
            let actualNotes, normalNotes, tupletType;
            
            if (tuplet.type === 'duplet') {
                actualNotes = 2;
                normalNotes = 3;
                tupletType = 'duplet';
            } else if (tuplet.type === 'quadruplet') {
                actualNotes = 4;
                normalNotes = 3;
                tupletType = 'quadruplet';
            }
            
            if (actualNotes && normalNotes) {
                // æ·»åŠ time-modification
                noteXML += `\n        <time-modification>
          <actual-notes>${actualNotes}</actual-notes>
          <normal-notes>${normalNotes}</normal-notes>
        </time-modification>`;
                
                // ç¡®å®štupletåœ¨ç»„ä¸­çš„ä½ç½®
                const tupletNotes = selectedPattern.pattern.filter(n => 
                    n.tuplet && n.tuplet.type === tuplet.type && n.tuplet.number === tuplet.number
                );
                const tupletIndex = tupletNotes.findIndex(n => n.position === noteData.position);
                const isFirst = tupletIndex === 0;
                const isLast = tupletIndex === tupletNotes.length - 1;
                
                // æ·»åŠ tupletæ ‡è®°åˆ°notations
                if (isFirst) {
                    notationsXML += `\n          <tuplet bracket="${tuplet.bracket ? 'yes' : 'no'}" number="${tuplet.number}" placement="above" type="start"/>`;
                    console.log(`ğŸµ [${tupletType}] å¼€å§‹: ä½ç½®${noteData.position}`);
                } else if (isLast) {
                    notationsXML += `\n          <tuplet bracket="${tuplet.bracket ? 'yes' : 'no'}" number="${tuplet.number}" placement="above" type="stop"/>`;
                    console.log(`ğŸµ [${tupletType}] ç»“æŸ: ä½ç½®${noteData.position}`);
                }
                
                hasNotations = true;
            }
        }
        
        // å¦‚æœæœ‰notationså†…å®¹ï¼Œæ·»åŠ notationsæ ‡ç­¾
        if (hasNotations) {
            noteXML += `\n        <notations>${notationsXML}\n        </notations>`;
        }
        
        noteXML += `
      </note>`;
        
        measureXML += noteXML;
    });
    
    // æ·»åŠ beamingä¿¡æ¯ï¼ˆé€šè¿‡notationså®ç°3+3åˆ†ç»„ï¼‰
    measureXML = addBeamingNotations(measureXML, selectedPattern);
    
    console.log(`âœ… [6/8 Beat Clarity] å°èŠ‚ç”Ÿæˆå®Œæˆ: ${selectedPattern.name}`);
    
    // ğŸ” éªŒè¯æ€»æ—¶å€¼
    const durationMatches = measureXML.match(/<duration>(\d+)<\/duration>/g) || [];
    let totalDuration = 0;
    durationMatches.forEach(match => {
        const value = parseInt(match.match(/\d+/)[0]);
        totalDuration += value;
    });
    
    const expectedDuration = 12; // 6/8æ‹ï¼Œdivisions=4æ—¶ï¼Œæ€»durationåº”è¯¥æ˜¯12
    if (totalDuration !== expectedDuration) {
        console.error(`âŒ [éªŒè¯å¤±è´¥] æ€»æ—¶å€¼é”™è¯¯: ${totalDuration} (æœŸæœ›: ${expectedDuration})`);
        console.error(`âŒ è¿™ä¼šå¯¼è‡´ç©ºç™½å°èŠ‚ï¼æ¨¡å¼: ${selectedPattern.name}`);
        
        // è¾“å‡ºè¯¦ç»†è°ƒè¯•ä¿¡æ¯
        console.log('ğŸ” æ¨¡å¼è¯¦æƒ…:');
        selectedPattern.pattern.forEach((note, i) => {
            console.log(`  éŸ³ç¬¦${i+1}: position=${note.position}, duration=${note.duration}, type=${note.type}`);
        });
        
        // å°è¯•è‡ªåŠ¨ä¿®å¤ï¼šå¡«å……ç¼ºå¤±çš„æ—¶å€¼
        const missingDuration = expectedDuration - totalDuration;
        if (missingDuration > 0) {
            console.log(`ğŸ”§ å°è¯•è‡ªåŠ¨ä¿®å¤: æ·»åŠ ${missingDuration}å•ä½çš„ä¼‘æ­¢ç¬¦`);
            // æ·»åŠ ä¼‘æ­¢ç¬¦å¡«å……å‰©ä½™æ—¶å€¼
            const restType = missingDuration === 2 ? 'eighth' : missingDuration === 1 ? '16th' : 'quarter';
            const restXML = `
      <note>
        <rest>`;
            
            let restPositionXML = '';
            // ä¼‘æ­¢ç¬¦ä½ç½®ä¸è°±å·æ— å…³ï¼Œåªæ ¹æ®äº”çº¿è°±çº¿æ¡ç¼–å·ç¡®å®š
            // ä½¿ç”¨<line>å…ƒç´ ç›´æ¥æŒ‡å®šçº¿æ¡ä½ç½®ï¼ˆä»åº•éƒ¨å¼€å§‹è®¡æ•°ï¼‰
            switch(restType) {
                case 'whole':
                    // å…¨ä¼‘æ­¢ç¬¦æ°¸è¿œæŒ‚åœ¨ç¬¬å››çº¿ä¸‹æ–¹
                    restPositionXML = '<line>4</line>';
                    break;
                case 'half':
                    // äºŒåˆ†ä¼‘æ­¢ç¬¦æ°¸è¿œé¡¶åœ¨ç¬¬ä¸‰çº¿ä¸Šæ–¹
                    restPositionXML = '<line>3</line>';
                    break;
                case 'quarter':
                case 'eighth':
                case '16th':
                default:
                    // å…¶ä»–ä¼‘æ­¢ç¬¦éƒ½åœ¨ç¬¬ä¸‰çº¿åŒºåŸŸ
                    restPositionXML = '<line>3</line>';
                    break;
            }
            
            const finalRestXML = restXML + restPositionXML + `</rest>
        <duration>${missingDuration}</duration>
        <type>${restType}</type>
      </note>`;
            measureXML += finalRestXML;
        }
    } else {
        console.log(`âœ… [éªŒè¯é€šè¿‡] æ€»æ—¶å€¼æ­£ç¡®: ${totalDuration}`);
    }
    
    return {
        xml: measureXML,
        lastMidi: lastMidi,
        pattern: selectedPattern.name
    };
}
*/

/**
 * ä¸º6/8æ‹å°èŠ‚æ·»åŠ ä¸¥æ ¼çš„3+3 beamingåˆ†ç»„
 */
function addBeamingNotations(measureXML, selectedPattern) {
    console.log('ğŸ”— [6/8 Beaming] å¼€å§‹æ·»åŠ 3+3åˆ†ç»„ä¿¡æ¯');
    
    // åˆ†æèŠ‚å¥æ¨¡å¼ä¸­çš„å¯beaméŸ³ç¬¦ä½ç½®ï¼ˆå…«åˆ†éŸ³ç¬¦å’Œåå…­åˆ†éŸ³ç¬¦ï¼‰
    const beamableNotePositions = [];
    selectedPattern.pattern.forEach((noteData, index) => {
        if (noteData.type === 'eighth' || noteData.type === 'sixteenth') {
            beamableNotePositions.push({
                index: index,
                position: noteData.position,
                type: noteData.type,
                group: noteData.position < 1.5 ? 1 : 2  // ä¸¥æ ¼æŒ‰1.5æ‹è¾¹ç•Œåˆ†ç»„
            });
        }
    });
    
    console.log(`ğŸµ å‘ç°${beamableNotePositions.length}ä¸ªå¯beaméŸ³ç¬¦éœ€è¦beaming`);
    beamableNotePositions.forEach(note => {
        console.log(`  - éŸ³ç¬¦${note.index + 1}: ${note.type}, ä½ç½®${note.position}, åˆ†ç»„${note.group}`);
    });
    
    // å¦‚æœæœ‰è¶³å¤Ÿçš„å¯beaméŸ³ç¬¦ï¼Œæ·»åŠ beamingæ ‡è®°
    if (beamableNotePositions.length >= 2) {
        const group1Notes = beamableNotePositions.filter(n => n.group === 1);
        const group2Notes = beamableNotePositions.filter(n => n.group === 2);
        
        if (group1Notes.length >= 2) {
            console.log(`ğŸ”— ç¬¬ä¸€ç»„beam: ${group1Notes.length}ä¸ªéŸ³ç¬¦ (0-1.5æ‹)`);
            measureXML = addBeamToNotes(measureXML, group1Notes, 1);
        }
        if (group2Notes.length >= 2) {
            console.log(`ğŸ”— ç¬¬äºŒç»„beam: ${group2Notes.length}ä¸ªéŸ³ç¬¦ (1.5-3.0æ‹)`);
            measureXML = addBeamToNotes(measureXML, group2Notes, 2);
        }
    }
    
    return measureXML;
}

// ğŸ”— å¯»æ‰¾è¿ç»­çš„å¯beaméŸ³ç¬¦ï¼ˆä¸¥æ ¼éµå¾ª6/8æ‹3+3åˆ†ç»„è§„åˆ™ï¼‰
function findContinuousBeamableNotes(allNotes, currentPosition, isFirstGroup) {
    console.log(`ğŸ” æŸ¥æ‰¾è¿ç»­beaméŸ³ç¬¦: ä½ç½®${currentPosition}, ${isFirstGroup ? 'ç¬¬ä¸€ç»„' : 'ç¬¬äºŒç»„'}`);
    
    // ğŸš« 6/8æ‹æ ¸å¿ƒè§„åˆ™ï¼šå¼ºæ‹å’Œæ¬¡å¼ºæ‹ä¹‹é—´æ°¸è¿œä¸èƒ½beamè¿æ¥
    // ç¬¬ä¸€ç»„è¾¹ç•Œ: 0.0 - 1.5 (ä¸åŒ…å«1.5)
    // ç¬¬äºŒç»„è¾¹ç•Œ: 1.5 - 3.0 
    const groupStart = isFirstGroup ? 0.0 : 1.5;
    const groupEnd = isFirstGroup ? 1.5 : 3.0;
    
    console.log(`  ğŸ¯ ä¸¥æ ¼ç»„è¾¹ç•Œ: ${groupStart} - ${groupEnd} (${isFirstGroup ? 'ç¬¬ä¸€ç»„' : 'ç¬¬äºŒç»„'})`);
    
    // æŒ‰ä½ç½®æ’åºæ‰€æœ‰éŸ³ç¬¦
    const sortedNotes = [...allNotes].sort((a, b) => a.position - b.position);
    
    // è¿‡æ»¤å‡ºå½“å‰ç»„å†…çš„éŸ³ç¬¦ï¼ˆä¸¥æ ¼è¾¹ç•Œæ£€æŸ¥ï¼‰
    const groupNotes = sortedNotes.filter(n => {
        if (isFirstGroup) {
            return n.position >= groupStart && n.position < groupEnd; // ä¸åŒ…å«1.5
        } else {
            return n.position >= groupStart && n.position < groupEnd; // 1.5åŠä»¥å
        }
    });
    
    console.log(`  ç»„å†…éŸ³ç¬¦: ${groupNotes.map(n => `${n.position}(${n.isRest ? 'R' : n.type})`).join(', ')}`);
    
    // æ‰¾åˆ°å½“å‰éŸ³ç¬¦çš„ç´¢å¼•
    const currentIndex = groupNotes.findIndex(n => n.position === currentPosition);
    if (currentIndex === -1) {
        console.warn(`  âš ï¸ å½“å‰éŸ³ç¬¦${currentPosition}ä¸åœ¨ç»„å†…ï¼Œè¿”å›å•ç‹¬éŸ³ç¬¦`);
        return [allNotes.find(n => n.position === currentPosition)];
    }
    
    // ğŸ”¥ å…³é”®ï¼šæ£€æŸ¥æ˜¯å¦è·¨è¶Šäº†1.5æ‹è¾¹ç•Œ
    const currentNote = groupNotes[currentIndex];
    if (currentNote.position >= 1.5 && isFirstGroup) {
        console.warn(`  ğŸš« éŸ³ç¬¦ä½ç½®${currentNote.position}è¶…å‡ºç¬¬ä¸€ç»„è¾¹ç•Œ1.5`);
        return [currentNote];
    }
    if (currentNote.position < 1.5 && !isFirstGroup) {
        console.warn(`  ğŸš« éŸ³ç¬¦ä½ç½®${currentNote.position}è¶…å‡ºç¬¬äºŒç»„è¾¹ç•Œ1.5`);
        return [currentNote];
    }
    
    // ä»å½“å‰éŸ³ç¬¦å‘å‰æŸ¥æ‰¾è¿ç»­çš„beaméŸ³ç¬¦
    let startIndex = currentIndex;
    while (startIndex > 0) {
        const prevNote = groupNotes[startIndex - 1];
        
        // ğŸ”¥ å¼ºåˆ¶æ£€æŸ¥ï¼šç»ä¸è·¨è¶Š1.5æ‹è¾¹ç•Œ
        if (isFirstGroup && prevNote.position >= 1.5) {
            console.log(`  ğŸš« å‘å‰æœç´¢é‡åˆ°1.5æ‹è¾¹ç•Œï¼Œåœæ­¢`);
            break;
        }
        if (!isFirstGroup && prevNote.position < 1.5) {
            console.log(`  ğŸš« å‘å‰æœç´¢é‡åˆ°1.5æ‹è¾¹ç•Œï¼Œåœæ­¢`);
            break;
        }
        
        // å¦‚æœå‰ä¸€ä¸ªéŸ³ç¬¦æ˜¯ä¼‘æ­¢ç¬¦æˆ–ä¸å¯beamï¼Œåœæ­¢
        if (prevNote.isRest || (prevNote.type !== 'eighth' && prevNote.type !== '16th')) {
            console.log(`  ğŸ›‘ å‘å‰æœç´¢é‡åˆ°ä¼‘æ­¢ç¬¦æˆ–ä¸å¯beaméŸ³ç¬¦ï¼Œåœæ­¢`);
            break;
        }
        startIndex--;
    }
    
    // ä»å½“å‰éŸ³ç¬¦å‘åæŸ¥æ‰¾è¿ç»­çš„beaméŸ³ç¬¦
    let endIndex = currentIndex;
    while (endIndex < groupNotes.length - 1) {
        const nextNote = groupNotes[endIndex + 1];
        
        // ğŸ”¥ å¼ºåˆ¶æ£€æŸ¥ï¼šç»ä¸è·¨è¶Š1.5æ‹è¾¹ç•Œ
        if (isFirstGroup && nextNote.position >= 1.5) {
            console.log(`  ğŸš« å‘åæœç´¢é‡åˆ°1.5æ‹è¾¹ç•Œï¼Œåœæ­¢`);
            break;
        }
        if (!isFirstGroup && nextNote.position < 1.5) {
            console.log(`  ğŸš« å‘åæœç´¢é‡åˆ°1.5æ‹è¾¹ç•Œï¼Œåœæ­¢`);
            break;
        }
        
        // å¦‚æœä¸‹ä¸€ä¸ªéŸ³ç¬¦æ˜¯ä¼‘æ­¢ç¬¦æˆ–ä¸å¯beamï¼Œåœæ­¢
        if (nextNote.isRest || (nextNote.type !== 'eighth' && nextNote.type !== '16th')) {
            console.log(`  ğŸ›‘ å‘åæœç´¢é‡åˆ°ä¼‘æ­¢ç¬¦æˆ–ä¸å¯beaméŸ³ç¬¦ï¼Œåœæ­¢`);
            break;
        }
        endIndex++;
    }
    
    // æå–è¿ç»­çš„å¯beaméŸ³ç¬¦
    const continuousBeamNotes = [];
    for (let i = startIndex; i <= endIndex; i++) {
        const note = groupNotes[i];
        if (!note.isRest && (note.type === 'eighth' || note.type === '16th')) {
            // ğŸ”¥ æœ€åä¸€æ¬¡è¾¹ç•Œæ£€æŸ¥
            if (isFirstGroup && note.position >= 1.5) {
                console.warn(`  ğŸš« è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„éŸ³ç¬¦${note.position}`);
                continue;
            }
            if (!isFirstGroup && note.position < 1.5) {
                console.warn(`  ğŸš« è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„éŸ³ç¬¦${note.position}`);
                continue;
            }
            continuousBeamNotes.push(note);
        }
    }
    
    console.log(`  âœ… è¿ç»­beaméŸ³ç¬¦: ${continuousBeamNotes.map(n => `${n.position}(${n.type})`).join(', ')}`);
    console.log(`  ğŸ”’ è¾¹ç•Œæ£€æŸ¥: æ‰€æœ‰éŸ³ç¬¦éƒ½åœ¨${isFirstGroup ? '0.0-1.5' : '1.5-3.0'}èŒƒå›´å†…`);
    
    return continuousBeamNotes;
}

/**
 * ä¸ºæŒ‡å®šçš„éŸ³ç¬¦æ·»åŠ MusicXML beamæ ‡è®° - ä¿®å¤ç‰ˆ
 */
function addBeamToNotes(measureXML, notePositions, beamGroupNumber) {
    console.log(`ğŸ”— ä¸ºbeamç»„${beamGroupNumber}æ·»åŠ MusicXMLæ ‡è®°`);
    console.log(`  éŸ³ç¬¦ä½ç½®åˆ—è¡¨:`, notePositions.map(n => `index=${n.index}, type=${n.type}`));
    
    // å°†measureXMLæŒ‰éŸ³ç¬¦åˆ†å‰²
    const noteXMLs = measureXML.split('<note>').slice(1); // å»æ‰ç¬¬ä¸€ä¸ªç©ºå…ƒç´ 
    console.log(`  XMLä¸­æ€»å…±æœ‰${noteXMLs.length}ä¸ªéŸ³ç¬¦`);
    
    let result = '';
    
    // åˆ¤æ–­ç»„å†…æ˜¯å¦æœ‰åå…­åˆ†éŸ³ç¬¦ï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†æ··åˆbeamï¼‰
    const hasSixteenth = notePositions.some(n => n.type === 'sixteenth');
    console.log(`  ç»„å†…${hasSixteenth ? 'åŒ…å«' : 'ä¸åŒ…å«'}åå…­åˆ†éŸ³ç¬¦`);
    
    noteXMLs.forEach((noteXML, xmlIndex) => {
        let modifiedNoteXML = '<note>' + noteXML;
        
        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä½¿ç”¨xmlIndexåŒ¹é…ï¼Œè€Œä¸æ˜¯processedNoteIndex
        const matchingNote = notePositions.find(n => n.index === xmlIndex);
        
        if (matchingNote) {
            const positionInGroup = notePositions.indexOf(matchingNote);
            const isFirst = positionInGroup === 0;
            const isLast = positionInGroup === notePositions.length - 1;
            
            let beamXML = '';
            
            // å¤„ç†æ··åˆbeamç»„ï¼ˆåŒ…å«åå…­åˆ†éŸ³ç¬¦å’Œå…«åˆ†éŸ³ç¬¦ï¼‰
            if (hasSixteenth) {
                // æ‰€æœ‰éŸ³ç¬¦éƒ½éœ€è¦ä¸»beam (beam number="1")
                if (isFirst) {
                    beamXML = `
        <beam number="1">begin</beam>`;
                } else if (isLast) {
                    beamXML = `
        <beam number="1">end</beam>`;
                } else {
                    beamXML = `
        <beam number="1">continue</beam>`;
                }
                
                // åªæœ‰åå…­åˆ†éŸ³ç¬¦éœ€è¦æ¬¡beam (beam number="2")
                if (matchingNote.type === 'sixteenth') {
                    // æ£€æŸ¥ç›¸é‚»éŸ³ç¬¦ç±»å‹ï¼Œå†³å®šæ¬¡beamçš„å½¢å¼
                    const prevNote = positionInGroup > 0 ? notePositions[positionInGroup - 1] : null;
                    const nextNote = positionInGroup < notePositions.length - 1 ? notePositions[positionInGroup + 1] : null;
                    
                    const prevIsSixteenth = prevNote && prevNote.type === 'sixteenth';
                    const nextIsSixteenth = nextNote && nextNote.type === 'sixteenth';
                    
                    if (isFirst && nextIsSixteenth) {
                        // ç¬¬ä¸€ä¸ªåå…­åˆ†éŸ³ç¬¦ï¼Œä¸”åé¢ä¹Ÿæ˜¯åå…­åˆ†éŸ³ç¬¦
                        beamXML += `
        <beam number="2">begin</beam>`;
                    } else if (isLast && prevIsSixteenth) {
                        // æœ€åä¸€ä¸ªåå…­åˆ†éŸ³ç¬¦ï¼Œä¸”å‰é¢ä¹Ÿæ˜¯åå…­åˆ†éŸ³ç¬¦
                        beamXML += `
        <beam number="2">end</beam>`;
                    } else if (prevIsSixteenth && nextIsSixteenth) {
                        // ä¸­é—´çš„åå…­åˆ†éŸ³ç¬¦ï¼Œå‰åéƒ½æ˜¯åå…­åˆ†éŸ³ç¬¦
                        beamXML += `
        <beam number="2">continue</beam>`;
                    } else if (prevIsSixteenth && !nextIsSixteenth) {
                        // åå…­åˆ†éŸ³ç¬¦ç»„çš„ç»“å°¾
                        beamXML += `
        <beam number="2">end</beam>`;
                    } else if (!prevIsSixteenth && nextIsSixteenth) {
                        // åå…­åˆ†éŸ³ç¬¦ç»„çš„å¼€å§‹
                        beamXML += `
        <beam number="2">begin</beam>`;
                    } else {
                        // å­¤ç«‹çš„åå…­åˆ†éŸ³ç¬¦ï¼Œä½¿ç”¨hook
                        beamXML += `
        <beam number="2">backward hook</beam>`;
                    }
                }
                
                console.log(`  ğŸµ ${matchingNote.type}éŸ³ç¬¦ (xmlä½ç½®${xmlIndex}, patternä½ç½®${matchingNote.index}): ${isFirst ? 'begin' : isLast ? 'end' : 'continue'}`);
            } else {
                // çº¯å…«åˆ†éŸ³ç¬¦ç»„
                if (isFirst) {
                    beamXML = `
        <beam number="1">begin</beam>`;
                } else if (isLast) {
                    beamXML = `
        <beam number="1">end</beam>`;
                } else {
                    beamXML = `
        <beam number="1">continue</beam>`;
                }
                console.log(`  ğŸµ å…«åˆ†éŸ³ç¬¦ (xmlä½ç½®${xmlIndex}, patternä½ç½®${matchingNote.index}): ${isFirst ? 'begin' : isLast ? 'end' : 'continue'}`);
            }
            
            // åœ¨</note>å‰æ’å…¥beamä¿¡æ¯
            modifiedNoteXML = modifiedNoteXML.replace('</note>', beamXML + '\n      </note>');
        }
        
        result += modifiedNoteXML;
    });
    
    return result;
}

// ====== 6/8æ‹èŠ‚å¥é€‰é¡¹åŠ¨æ€åˆ‡æ¢ ======

/**
 * æ ¹æ®æ‹å·åˆ‡æ¢èŠ‚å¥é€‰é¡¹çš„å¯è§æ€§
 */
function updateRhythmOptionsForTimeSignature(timeSignature) {
    console.log(`ğŸ›ï¸ æ ¹æ®æ‹å·æ›´æ–°èŠ‚å¥é€‰é¡¹: ${timeSignature}`);
    
    // è·å–èŠ‚å¥ç±»å‹ç›¸å…³çš„å…ƒç´ 
    const wholeLabel = document.getElementById('rhythm-whole-label');
    const dottedHalfLabel = document.getElementById('rhythm-dotted-half-label');
    const halfLabel = document.getElementById('rhythm-half-label');
    const dottedQuarterLabel = document.getElementById('rhythm-dotted-quarter-label');
    const quarterLabel = document.getElementById('rhythm-quarter-label');
    const dottedEighthLabel = document.getElementById('rhythm-dotted-eighth-label');
    const eighthLabel = document.getElementById('rhythm-eighth-label');
    const sixteenthLabel = document.getElementById('rhythm-16th-label');

    const tripletLabel = document.getElementById('rhythm-triplet-label');
    const dupletLabel = document.getElementById('rhythm-duplet-label');
    const quadrupletLabel = document.getElementById('rhythm-quadruplet-label');

    // è·å–å¤é€‰æ¡†å…ƒç´ 
    const wholeCheckbox = document.getElementById('rhythm-whole');
    const dottedHalfCheckbox = document.getElementById('rhythm-dotted-half');
    const halfCheckbox = document.getElementById('rhythm-half');
    const dottedQuarterCheckbox = document.getElementById('rhythm-dotted-quarter');
    const quarterCheckbox = document.getElementById('rhythm-quarter');
    const dottedEighthCheckbox = document.getElementById('rhythm-dotted-eighth');
    const eighthCheckbox = document.getElementById('rhythm-eighth');
    const sixteenthCheckbox = document.getElementById('rhythm-16th');
    const tripletCheckbox = document.getElementById('rhythm-triplet');
    const dupletCheckbox = document.getElementById('rhythm-duplet');
    const quadrupletCheckbox = document.getElementById('rhythm-quadruplet');

    // è·å–é«˜çº§è®¾ç½®ä¸­çš„é¢‘ç‡æ§åˆ¶å…ƒç´ 
    const dottedOptionsSection = document.getElementById('dottedOptionsSection');
    const freqWholeItem = document.getElementById('freq-whole-item');
    const freqDottedItem = document.getElementById('freq-dotted-item');
    const freqDottedHalfItem = document.getElementById('freq-dotted-half-item');
    const freqHalfItem = document.getElementById('freq-half-item');
    const freqDottedQuarterItem = document.getElementById('freq-dotted-quarter-item');
    const freqQuarterItem = document.getElementById('freq-quarter-item');
    const freqDottedEighthItem = document.getElementById('freq-dotted-eighth-item');
    const freqEighthItem = document.getElementById('freq-eighth-item');
    const freqSixteenthItem = document.getElementById('freq-16th-item');
    const freqTripletItem = document.getElementById('freq-triplet-item');
    const freqDupletItem = document.getElementById('freq-duplet-item');
    const freqQuadrupletItem = document.getElementById('freq-quadruplet-item');

    const isCustomTimeSignature = !isBuiltInTimeSignature(timeSignature) && timeSignature !== 'multi';
    const isCustomCompound = isCustomTimeSignature && isCompoundTimeSignature(timeSignature);
    
    if (timeSignature === '6/8') {
        if (dottedOptionsSection) {
            dottedOptionsSection.style.display = 'none';
        }
        if (freqDottedItem) {
            freqDottedItem.style.display = 'none';
        }
        // 6/8æ‹ï¼šè‡ªåŠ¨æ›¿æ¢èŠ‚å¥é€‰é¡¹
        console.log('ğŸµ åˆ‡æ¢åˆ°6/8æ‹ï¼Œè‡ªåŠ¨è°ƒæ•´èŠ‚å¥é€‰é¡¹...');
        const allowDottedNotesCheckbox = document.getElementById('allowDottedNotes');
        const allowDotted = allowDottedNotesCheckbox && allowDottedNotesCheckbox.checked;
        
        // å…¨éŸ³ç¬¦ â†’ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦çš„æ›¿æ¢
        if (wholeLabel && wholeCheckbox && dottedHalfLabel && dottedHalfCheckbox) {
            const wasWholeChecked = wholeCheckbox.checked;
            wholeLabel.style.display = 'none';
            dottedHalfLabel.style.display = 'flex';
            
            if (wasWholeChecked) {
                wholeCheckbox.checked = false;
                if (allowDotted) {
                    dottedHalfCheckbox.checked = true;
                    console.log('âœ… 6/8æ‹æ›¿æ¢ï¼šå…¨éŸ³ç¬¦ â†’ é™„ç‚¹äºŒåˆ†éŸ³ç¬¦');
                } else {
                    dottedHalfCheckbox.checked = false;
                    console.log('ğŸš« 6/8æ‹æ›¿æ¢è¢«é˜»æ­¢ï¼ˆé™„ç‚¹æ€»å¼€å…³å…³é—­ï¼‰ï¼šå…¨éŸ³ç¬¦ä¸æ›¿æ¢ä¸ºé™„ç‚¹äºŒåˆ†');
                }
            }
        }
        
        // äºŒåˆ†éŸ³ç¬¦ â†’ é™„ç‚¹å››åˆ†éŸ³ç¬¦çš„æ›¿æ¢
        if (halfLabel && halfCheckbox && dottedQuarterLabel && dottedQuarterCheckbox) {
            const wasHalfChecked = halfCheckbox.checked;
            halfLabel.style.display = 'none';
            dottedQuarterLabel.style.display = 'flex';
            
            if (wasHalfChecked) {
                halfCheckbox.checked = false;
                if (allowDotted) {
                    dottedQuarterCheckbox.checked = true;
                    console.log('âœ… 6/8æ‹æ›¿æ¢ï¼šäºŒåˆ†éŸ³ç¬¦ â†’ é™„ç‚¹å››åˆ†éŸ³ç¬¦');
                } else {
                    dottedQuarterCheckbox.checked = false;
                    console.log('ğŸš« 6/8æ‹æ›¿æ¢è¢«é˜»æ­¢ï¼ˆé™„ç‚¹æ€»å¼€å…³å…³é—­ï¼‰ï¼šäºŒåˆ†éŸ³ç¬¦ä¸æ›¿æ¢ä¸ºé™„ç‚¹å››åˆ†');
                }
            }
        }
        
        // ä¸‰è¿éŸ³ â†’ äºŒè¿éŸ³å’Œå››è¿éŸ³çš„æ›¿æ¢
        if (tripletLabel && tripletCheckbox && dupletLabel && dupletCheckbox && quadrupletLabel && quadrupletCheckbox) {
            const wasTripletChecked = tripletCheckbox.checked;
            tripletLabel.style.display = 'none';
            dupletLabel.style.display = 'flex';
            quadrupletLabel.style.display = 'flex';
            
            if (wasTripletChecked) {
                tripletCheckbox.checked = false;
                dupletCheckbox.checked = true;
                quadrupletCheckbox.checked = true;
                console.log('âœ… 6/8æ‹æ›¿æ¢ï¼šä¸‰è¿éŸ³ â†’ äºŒè¿éŸ³ + å››è¿éŸ³');
            }
        }
        
        // é«˜çº§è®¾ç½®ï¼šéšè—å…¨éŸ³ç¬¦å’Œä¸‰è¿éŸ³é¢‘ç‡ï¼Œæ˜¾ç¤ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ã€äºŒè¿éŸ³å’Œå››è¿éŸ³é¢‘ç‡
        if (freqDottedItem) {
            freqDottedItem.style.display = 'none';
        }
        if (freqWholeItem) {
            freqWholeItem.style.display = 'none';
        }
        if (freqDottedHalfItem) {
            freqDottedHalfItem.style.display = 'block';
        }
        
        // ğŸ”¥ 6/8æ‹ï¼šéšè—äºŒåˆ†éŸ³ç¬¦é¢‘ç‡ï¼Œæ˜¾ç¤ºé™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡
        if (freqHalfItem) {
            freqHalfItem.style.display = 'none';
        }
        if (freqDottedQuarterItem) {
            freqDottedQuarterItem.style.display = 'block';
        }
        
        if (freqTripletItem) {
            freqTripletItem.style.display = 'none';
        }
        if (freqDupletItem) {
            freqDupletItem.style.display = 'block';
        }
        if (freqQuadrupletItem) {
            freqQuadrupletItem.style.display = 'block';
        }
        
        console.log('ğŸµ 6/8æ‹æ¨¡å¼ï¼šæ˜¾ç¤ºé™„ç‚¹äºŒåˆ†éŸ³ç¬¦ã€é™„ç‚¹å››åˆ†éŸ³ç¬¦ã€äºŒè¿éŸ³å’Œå››è¿éŸ³ï¼Œéšè—å…¨éŸ³ç¬¦ã€äºŒåˆ†éŸ³ç¬¦å’Œä¸‰è¿éŸ³ï¼ˆåŒ…æ‹¬é¢‘ç‡æ§åˆ¶ï¼‰');
    } else if (timeSignature === 'multi') {
        // ğŸ”¥ å¤šæ‹å·æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³
        console.log('ğŸµ å¤šæ‹å·æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³');
        if (dottedOptionsSection) {
            dottedOptionsSection.style.display = 'block';
        }
        if (freqDottedItem) {
            freqDottedItem.style.display = 'none';
        }

        // æ˜¾ç¤ºæ‰€æœ‰åŸºæœ¬èŠ‚å¥é€‰é¡¹
        if (wholeLabel) wholeLabel.style.display = 'flex';
        if (dottedHalfLabel) dottedHalfLabel.style.display = 'flex';
        if (halfLabel) halfLabel.style.display = 'flex';
        if (dottedQuarterLabel) dottedQuarterLabel.style.display = 'flex';
        if (quarterLabel) quarterLabel.style.display = 'flex';
        if (dottedEighthLabel) dottedEighthLabel.style.display = 'flex';
        if (eighthLabel) eighthLabel.style.display = 'flex';
        if (sixteenthLabel) sixteenthLabel.style.display = 'flex';

        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ˆä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³ï¼‰
        // å½“é€‰æ‹©å¤šä¸ªæ‹å·æ—¶ï¼Œæ˜¾ç¤ºæ‰€æœ‰å¯èƒ½çš„èŠ‚å¥é€‰é¡¹ï¼Œè®©ç”¨æˆ·è‡ªç”±é€‰æ‹©
        if (tripletLabel) tripletLabel.style.display = 'flex';
        if (dupletLabel) dupletLabel.style.display = 'flex';
        if (quadrupletLabel) quadrupletLabel.style.display = 'flex';

        // æ˜¾ç¤ºæ‰€æœ‰é¢‘ç‡æ§åˆ¶
        if (freqDottedItem) freqDottedItem.style.display = 'none';
        if (freqWholeItem) freqWholeItem.style.display = 'block';
        if (freqDottedHalfItem) freqDottedHalfItem.style.display = 'block';
        if (freqHalfItem) freqHalfItem.style.display = 'block';
        if (freqDottedQuarterItem) freqDottedQuarterItem.style.display = 'block';
        if (freqQuarterItem) freqQuarterItem.style.display = 'block';
        if (freqDottedEighthItem) freqDottedEighthItem.style.display = 'block';
        if (freqEighthItem) freqEighthItem.style.display = 'block';
        if (freqSixteenthItem) freqSixteenthItem.style.display = 'block';
        if (freqTripletItem) freqTripletItem.style.display = 'block';
        if (freqDupletItem) freqDupletItem.style.display = 'block';
        if (freqQuadrupletItem) freqQuadrupletItem.style.display = 'block';

        console.log('ğŸµ å¤šæ‹å·æ¨¡å¼ï¼šæ‰€æœ‰èŠ‚å¥é€‰é¡¹å·²æ˜¾ç¤ºï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³');
    } else if (isCustomCompound) {
        console.log('ğŸµ è‡ªå®šä¹‰å¤æ‹å­æ¨¡å¼ï¼šä¿ç•™åŸºç¡€èŠ‚å¥é€‰é¡¹ï¼Œæ˜¾ç¤ºäºŒè¿éŸ³/å››è¿éŸ³ï¼Œéšè—ä¸‰è¿éŸ³');
        if (dottedOptionsSection) {
            dottedOptionsSection.style.display = 'block';
        }
        if (freqDottedItem) {
            freqDottedItem.style.display = 'none';
        }

        // åŸºç¡€èŠ‚å¥é€‰é¡¹ï¼šæ²¿ç”¨é6/8æ‹é»˜è®¤æ˜¾ç¤º
        if (wholeLabel) wholeLabel.style.display = 'flex';
        if (dottedHalfLabel) dottedHalfLabel.style.display = 'flex';
        if (halfLabel) halfLabel.style.display = 'flex';
        if (dottedQuarterLabel) dottedQuarterLabel.style.display = 'flex';
        if (quarterLabel) quarterLabel.style.display = 'flex';
        if (dottedEighthLabel) dottedEighthLabel.style.display = 'flex';
        if (eighthLabel) eighthLabel.style.display = 'flex';
        if (sixteenthLabel) sixteenthLabel.style.display = 'flex';

        if (tripletLabel && tripletCheckbox && dupletLabel && dupletCheckbox && quadrupletLabel && quadrupletCheckbox) {
            const wasTripletChecked = tripletCheckbox.checked;
            tripletLabel.style.display = 'none';
            dupletLabel.style.display = 'flex';
            quadrupletLabel.style.display = 'flex';

            if (wasTripletChecked) {
                tripletCheckbox.checked = false;
                if (!dupletCheckbox.checked) dupletCheckbox.checked = true;
                if (!quadrupletCheckbox.checked) quadrupletCheckbox.checked = true;
                console.log('âœ… è‡ªå®šä¹‰å¤æ‹å­æ›¿æ¢ï¼šä¸‰è¿éŸ³ â†’ äºŒè¿éŸ³ + å››è¿éŸ³');
            }
        }

        // é«˜çº§è®¾ç½®ï¼šéšè—ä¸‰è¿éŸ³é¢‘ç‡ï¼Œæ˜¾ç¤ºäºŒ/å››è¿éŸ³é¢‘ç‡
        if (freqWholeItem) {
            freqWholeItem.style.display = 'block';
        }
        if (freqDottedHalfItem) {
            freqDottedHalfItem.style.display = 'block';
        }
        if (freqHalfItem) {
            freqHalfItem.style.display = 'block';
        }
        if (freqDottedQuarterItem) {
            freqDottedQuarterItem.style.display = 'block';
        }
        if (freqQuarterItem) {
            freqQuarterItem.style.display = 'block';
        }
        if (freqDottedEighthItem) {
            freqDottedEighthItem.style.display = 'block';
        }
        if (freqEighthItem) {
            freqEighthItem.style.display = 'block';
        }
        if (freqSixteenthItem) {
            freqSixteenthItem.style.display = 'block';
        }
        if (freqTripletItem) {
            freqTripletItem.style.display = 'none';
        }
        if (freqDupletItem) {
            freqDupletItem.style.display = 'block';
        }
        if (freqQuadrupletItem) {
            freqQuadrupletItem.style.display = 'block';
        }

        console.log('ğŸµ è‡ªå®šä¹‰å¤æ‹å­æ¨¡å¼ï¼šæ˜¾ç¤ºäºŒè¿éŸ³ã€å››è¿éŸ³ï¼Œéšè—ä¸‰è¿éŸ³ï¼ˆå«é¢‘ç‡æ§åˆ¶ï¼‰');
    } else {
        // å…¶ä»–æ‹å·ï¼šæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼Œä¿æŒç”¨æˆ·é€‰æ‹©
        console.log(`ğŸµ åˆ‡æ¢åˆ°${timeSignature}æ‹ï¼Œæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹å¹¶ä¿æŒç”¨æˆ·é€‰æ‹©...`);
        if (dottedOptionsSection) {
            dottedOptionsSection.style.display = 'block';
        }
        if (freqDottedItem) {
            freqDottedItem.style.display = timeSignature === '4/4' ? 'block' : 'none';
        }

        // æ˜¾ç¤ºåŸºæœ¬èŠ‚å¥é€‰é¡¹ï¼Œä½†åœ¨4/4æ‹ä¸­éšè—å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦é€‰é¡¹
        if (wholeLabel && dottedHalfLabel) {
            wholeLabel.style.display = 'flex';
            // åœ¨4/4æ‹ä¸­éšè—é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é€‰é¡¹ï¼Œç”±é€šç”¨çš„"é™„ç‚¹éŸ³ç¬¦"å¼€å…³æ§åˆ¶
            if (timeSignature === '4/4' || timeSignature === '2/4' || timeSignature === '3/4') {
                dottedHalfLabel.style.display = 'none';
            } else {
                dottedHalfLabel.style.display = 'flex';
            }
        }

        // æ˜¾ç¤ºåŸºæœ¬èŠ‚å¥é€‰é¡¹ï¼Œä½†åœ¨4/4æ‹ä¸­éšè—å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦é€‰é¡¹
        if (halfLabel && dottedQuarterLabel) {
            halfLabel.style.display = 'flex';
            // åœ¨4/4æ‹ä¸­éšè—é™„ç‚¹å››åˆ†éŸ³ç¬¦é€‰é¡¹ï¼Œç”±é€šç”¨çš„"é™„ç‚¹éŸ³ç¬¦"å¼€å…³æ§åˆ¶
            if (timeSignature === '4/4' || timeSignature === '2/4' || timeSignature === '3/4') {
                dottedQuarterLabel.style.display = 'none';
            } else {
                dottedQuarterLabel.style.display = 'flex';
            }
        }
        
        // äºŒè¿éŸ³å’Œå››è¿éŸ³ â†’ ä¸‰è¿éŸ³çš„æ¢å¤
        if (tripletLabel && tripletCheckbox && dupletLabel && dupletCheckbox && quadrupletLabel && quadrupletCheckbox) {
            const wasDupletChecked = dupletCheckbox.checked;
            const wasQuadrupletChecked = quadrupletCheckbox.checked;
            tripletLabel.style.display = 'flex';
            dupletLabel.style.display = 'none';
            quadrupletLabel.style.display = 'none';
            
            if (wasDupletChecked || wasQuadrupletChecked) {
                dupletCheckbox.checked = false;
                quadrupletCheckbox.checked = false;
                tripletCheckbox.checked = true;
                console.log(`âœ… ${timeSignature}æ‹æ¢å¤ï¼šäºŒè¿éŸ³ + å››è¿éŸ³ â†’ ä¸‰è¿éŸ³`);
            }
        }
        
        // é«˜çº§è®¾ç½®ï¼šæ˜¾ç¤ºé¢‘ç‡æ§åˆ¶é€‰é¡¹ï¼Œä½†åœ¨æ ‡å‡†æ‹å·ä¸­éšè—å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦é¢‘ç‡æ§åˆ¶
        if (freqDottedItem) {
            freqDottedItem.style.display = timeSignature === '4/4' ? 'block' : 'none';
        }
        if (freqWholeItem) {
            freqWholeItem.style.display = 'block';
        }
        if (freqDottedHalfItem) {
            // åœ¨4/4ã€2/4ã€3/4æ‹ä¸­éšè—é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼Œç”±é€šç”¨çš„é™„ç‚¹éŸ³ç¬¦é€»è¾‘å¤„ç†
            if (timeSignature === '4/4' || timeSignature === '2/4' || timeSignature === '3/4') {
                freqDottedHalfItem.style.display = 'none';
            } else {
                freqDottedHalfItem.style.display = 'block';
            }
        }

        // æ˜¾ç¤ºèŠ‚å¥é¢‘ç‡æ§åˆ¶ï¼Œä½†åœ¨æ ‡å‡†æ‹å·ä¸­éšè—å…·ä½“çš„é™„ç‚¹éŸ³ç¬¦é¢‘ç‡æ§åˆ¶
        if (freqHalfItem) {
            freqHalfItem.style.display = 'block';
        }
        if (freqDottedQuarterItem) {
            // åœ¨4/4ã€2/4ã€3/4æ‹ä¸­éšè—é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡æ§åˆ¶ï¼Œç”±é€šç”¨çš„é™„ç‚¹éŸ³ç¬¦é€»è¾‘å¤„ç†
            if (timeSignature === '4/4' || timeSignature === '2/4' || timeSignature === '3/4') {
                freqDottedQuarterItem.style.display = 'none';
            } else {
                freqDottedQuarterItem.style.display = 'block';
            }
        }
        
        if (freqTripletItem) {
            freqTripletItem.style.display = 'block';
        }
        if (freqDupletItem) {
            freqDupletItem.style.display = 'none';
        }
        if (freqQuadrupletItem) {
            freqQuadrupletItem.style.display = 'none';
        }
        
        console.log(`ğŸµ ${timeSignature}æ‹æ¨¡å¼ï¼šæ˜¾ç¤ºåŸºæœ¬èŠ‚å¥é€‰é¡¹ï¼Œå…·ä½“é™„ç‚¹éŸ³ç¬¦ç”±é€šç”¨"é™„ç‚¹éŸ³ç¬¦"å¼€å…³æ§åˆ¶`);
    }
    
    // æ›´æ–°ç”¨æˆ·è®¾ç½®
    updateRhythmSettingsRealTime();
}

/**
 * ğŸ”„ åˆå§‹åŒ–å¤é€‰æ¡†ä¸é«˜çº§è®¾ç½®æ»‘å—çš„åŒå‘åŒæ­¥æœºåˆ¶
 */
function initializeCheckboxSliderSync() {
    console.log('ğŸ”„ åˆå§‹åŒ–å¤é€‰æ¡†ä¸æ»‘å—åŒæ­¥æœºåˆ¶');
    
    // èŠ‚å¥è®¾ç½®åŒæ­¥
    initializeRhythmCheckboxSync();
    
    // æ¼”å¥æ³•è®¾ç½®åŒæ­¥
    initializeArticulationCheckboxSync();
}

/**
 * ğŸµ åˆå§‹åŒ–èŠ‚å¥å¤é€‰æ¡†åŒæ­¥
 */
function initializeRhythmCheckboxSync() {
    const rhythmTypes = ['dotted', 'whole', 'dotted-half', 'half', 'dotted-quarter', 'quarter', 'dotted-eighth', 'eighth', '16th', 'triplet', 'duplet', 'quadruplet'];
    
    rhythmTypes.forEach(type => {
        const checkbox = document.getElementById(`rhythm-${type}`);
        const slider = document.getElementById(`freq-${type}`);
        const valueSpan = document.getElementById(`freq-${type}-value`);
        
        if (checkbox && slider && valueSpan) {
            // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
            checkbox.removeEventListener('change', checkbox._syncHandler);
            
            // åˆ›å»ºåŒæ­¥å¤„ç†å‡½æ•°
            checkbox._syncHandler = function() {
                if (!this.checked) {
                    // ğŸ”¥ å½“å¤é€‰æ¡†å–æ¶ˆå‹¾é€‰æ—¶ï¼Œå°†å¯¹åº”çš„é¢‘ç‡æ»‘å—è®¾ä¸º0%
                    slider.value = 0;
                    valueSpan.textContent = '0%';
                    
                    // æ›´æ–°userSettings
                    if (!userSettings.rhythmFrequencies) {
                        userSettings.rhythmFrequencies = {};
                    }
                    userSettings.rhythmFrequencies[type] = 0;
                    
                    console.log(`ğŸ”„ å¤é€‰æ¡†å–æ¶ˆå‹¾é€‰ï¼š${type} é¢‘ç‡è‡ªåŠ¨è®¾ä¸º 0%`);
                } else {
                    // ğŸ”¥ å½“å¤é€‰æ¡†å‹¾é€‰æ—¶ï¼Œå¦‚æœé¢‘ç‡ä¸º0%ï¼Œæ¢å¤ä¸ºé»˜è®¤é¢‘ç‡
                    if (parseInt(slider.value) === 0) {
                        const defaultFreq = getDefaultRhythmFrequency(type);
                        slider.value = defaultFreq;
                        valueSpan.textContent = defaultFreq + '%';
                        
                        // æ›´æ–°userSettings
                        if (!userSettings.rhythmFrequencies) {
                            userSettings.rhythmFrequencies = {};
                        }
                        userSettings.rhythmFrequencies[type] = defaultFreq;
                        
                        console.log(`ğŸ”„ å¤é€‰æ¡†å‹¾é€‰ï¼š${type} é¢‘ç‡è‡ªåŠ¨æ¢å¤ä¸º ${defaultFreq}%`);
                    }
                }
            };
            
            checkbox.addEventListener('change', checkbox._syncHandler);
        }
    });
}

/**
 * ğŸµ åˆå§‹åŒ–æ¼”å¥æ³•å¤é€‰æ¡†åŒæ­¥
 */
function initializeArticulationCheckboxSync() {
    // åŸºæœ¬æ¼”å¥æ³•åŒæ­¥
    const basicTypes = [
        { checkboxId: 'art-staccato', sliderType: 'staccato' },
        { checkboxId: 'art-accent', sliderType: 'accent' },
        { checkboxId: 'art-acciaccatura', sliderType: 'acciaccatura' }
    ];
    
    basicTypes.forEach(({ checkboxId, sliderType }) => {
        const checkbox = document.getElementById(checkboxId);
        const slider = document.getElementById(`freq-${sliderType}`);
        const valueSpan = document.getElementById(`freq-${sliderType}-value`);
        
        if (checkbox && slider && valueSpan) {
            // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
            checkbox.removeEventListener('change', checkbox._syncHandler);
            
            // åˆ›å»ºåŒæ­¥å¤„ç†å‡½æ•°
            checkbox._syncHandler = function() {
                if (!this.checked) {
                    // ğŸ”¥ å½“å¤é€‰æ¡†å–æ¶ˆå‹¾é€‰æ—¶ï¼Œå°†å¯¹åº”çš„é¢‘ç‡æ»‘å—è®¾ä¸º0%
                    slider.value = 0;
                    valueSpan.textContent = '0%';
                    
                    // æ›´æ–°userSettings
                    if (!userSettings.articulations) {
                        userSettings.articulations = { frequencies: {} };
                    }
                    if (!userSettings.articulations.frequencies) {
                        userSettings.articulations.frequencies = {};
                    }
                    userSettings.articulations.frequencies[sliderType] = 0;
                    
                    console.log(`ğŸ”„ å¤é€‰æ¡†å–æ¶ˆå‹¾é€‰ï¼š${sliderType} é¢‘ç‡è‡ªåŠ¨è®¾ä¸º 0%`);
                } else {
                    // ğŸ”¥ å½“å¤é€‰æ¡†å‹¾é€‰æ—¶ï¼Œå¦‚æœé¢‘ç‡ä¸º0%ï¼Œæ¢å¤ä¸ºé»˜è®¤é¢‘ç‡
                    if (parseInt(slider.value) === 0) {
                        const defaultFreq = getDefaultArticulationFrequency(sliderType);
                        slider.value = defaultFreq;
                        valueSpan.textContent = defaultFreq + '%';
                        
                        // æ›´æ–°userSettings
                        if (!userSettings.articulations) {
                            userSettings.articulations = { frequencies: {} };
                        }
                        if (!userSettings.articulations.frequencies) {
                            userSettings.articulations.frequencies = {};
                        }
                        userSettings.articulations.frequencies[sliderType] = defaultFreq;
                        
                        console.log(`ğŸ”„ å¤é€‰æ¡†å‹¾é€‰ï¼š${sliderType} é¢‘ç‡è‡ªåŠ¨æ¢å¤ä¸º ${defaultFreq}%`);
                    }
                }
            };
            
            checkbox.addEventListener('change', checkbox._syncHandler);
        }
    });
    
    // ğŸ¸ å‰ä»–æŠ€å·§åŒæ­¥ - hammerå’Œpullå…±åŒæ§åˆ¶sluré¢‘ç‡
    const hammerCheckbox = document.getElementById('gtr-hammer');
    const pullCheckbox = document.getElementById('gtr-pull');
    const slurSlider = document.getElementById('freq-slur');
    const slurValueSpan = document.getElementById('freq-slur-value');
    
    if (hammerCheckbox && pullCheckbox && slurSlider && slurValueSpan) {
        // åˆ›å»ºå…±åŒçš„å¤„ç†å‡½æ•°
        const handleGuitarCheckboxChange = function() {
            const hammerChecked = hammerCheckbox.checked;
            const pullChecked = pullCheckbox.checked;
            
            if (!hammerChecked && !pullChecked) {
                // ğŸ”¥ ä¸¤ä¸ªå¤é€‰æ¡†éƒ½å–æ¶ˆå‹¾é€‰æ—¶ï¼Œsluré¢‘ç‡è®¾ä¸º0%
                slurSlider.value = 0;
                slurValueSpan.textContent = '0%';
                
                // æ›´æ–°userSettings
                if (!userSettings.articulations) {
                    userSettings.articulations = { frequencies: {} };
                }
                if (!userSettings.articulations.frequencies) {
                    userSettings.articulations.frequencies = {};
                }
                userSettings.articulations.frequencies.slur = 0;
                
                console.log(`ğŸ”„ hammerå’Œpulléƒ½å–æ¶ˆå‹¾é€‰ï¼šsluré¢‘ç‡è‡ªåŠ¨è®¾ä¸º 0%`);
            } else if ((hammerChecked || pullChecked) && parseInt(slurSlider.value) === 0) {
                // ğŸ”¥ è‡³å°‘ä¸€ä¸ªå‹¾é€‰ä¸”sluré¢‘ç‡ä¸º0%æ—¶ï¼Œæ¢å¤é»˜è®¤é¢‘ç‡
                const defaultFreq = getDefaultArticulationFrequency('slur');
                slurSlider.value = defaultFreq;
                slurValueSpan.textContent = defaultFreq + '%';
                
                // æ›´æ–°userSettings
                if (!userSettings.articulations) {
                    userSettings.articulations = { frequencies: {} };
                }
                if (!userSettings.articulations.frequencies) {
                    userSettings.articulations.frequencies = {};
                }
                userSettings.articulations.frequencies.slur = defaultFreq;
                
                console.log(`ğŸ”„ hammeræˆ–pullå‹¾é€‰ï¼šsluré¢‘ç‡è‡ªåŠ¨æ¢å¤ä¸º ${defaultFreq}%`);
            }
        };
        
        // ç§»é™¤ç°æœ‰ç›‘å¬å™¨é˜²æ­¢é‡å¤ç»‘å®š
        hammerCheckbox.removeEventListener('change', hammerCheckbox._syncHandler);
        pullCheckbox.removeEventListener('change', pullCheckbox._syncHandler);
        
        // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
        hammerCheckbox._syncHandler = handleGuitarCheckboxChange;
        pullCheckbox._syncHandler = handleGuitarCheckboxChange;
        
        hammerCheckbox.addEventListener('change', hammerCheckbox._syncHandler);
        pullCheckbox.addEventListener('change', pullCheckbox._syncHandler);
    }

    // ğŸ¸ SlideæŠ€å·§åŒæ­¥ - glissando/slide-in/slide-out å…±åŒæ§åˆ¶ slide é¢‘ç‡
    const glissCheckbox = document.getElementById('gtr-glissando');
    const slideInCheckbox = document.getElementById('gtr-slide-in');
    const slideOutCheckbox = document.getElementById('gtr-slide-out');
    const slideSlider = document.getElementById('freq-slide');
    const slideValueSpan = document.getElementById('freq-slide-value');

    if (glissCheckbox && slideInCheckbox && slideOutCheckbox && slideSlider && slideValueSpan) {
        const handleSlideCheckboxChange = function() {
            const anySlideChecked = glissCheckbox.checked || slideInCheckbox.checked || slideOutCheckbox.checked;

            if (!anySlideChecked) {
                slideSlider.value = 0;
                slideValueSpan.textContent = '0%';

                if (!userSettings.articulations) {
                    userSettings.articulations = { frequencies: {} };
                }
                if (!userSettings.articulations.frequencies) {
                    userSettings.articulations.frequencies = {};
                }
                userSettings.articulations.frequencies.slide = 0;
                console.log('ğŸ”„ æ‰€æœ‰slideæŠ€å·§å–æ¶ˆå‹¾é€‰ï¼šslideé¢‘ç‡è‡ªåŠ¨è®¾ä¸º 0%');
            } else if (parseInt(slideSlider.value) === 0) {
                const defaultFreq = getDefaultArticulationFrequency('slide');
                slideSlider.value = defaultFreq;
                slideValueSpan.textContent = `${defaultFreq}%`;

                if (!userSettings.articulations) {
                    userSettings.articulations = { frequencies: {} };
                }
                if (!userSettings.articulations.frequencies) {
                    userSettings.articulations.frequencies = {};
                }
                userSettings.articulations.frequencies.slide = defaultFreq;
                console.log(`ğŸ”„ å¯ç”¨slideæŠ€å·§ï¼šslideé¢‘ç‡è‡ªåŠ¨æ¢å¤ä¸º ${defaultFreq}%`);
            }
        };

        glissCheckbox.removeEventListener('change', glissCheckbox._slideSyncHandler);
        slideInCheckbox.removeEventListener('change', slideInCheckbox._slideSyncHandler);
        slideOutCheckbox.removeEventListener('change', slideOutCheckbox._slideSyncHandler);

        glissCheckbox._slideSyncHandler = handleSlideCheckboxChange;
        slideInCheckbox._slideSyncHandler = handleSlideCheckboxChange;
        slideOutCheckbox._slideSyncHandler = handleSlideCheckboxChange;

        glissCheckbox.addEventListener('change', glissCheckbox._slideSyncHandler);
        slideInCheckbox.addEventListener('change', slideInCheckbox._slideSyncHandler);
        slideOutCheckbox.addEventListener('change', slideOutCheckbox._slideSyncHandler);
    }
}

/**
 * è·å–é»˜è®¤èŠ‚å¥é¢‘ç‡
 */
function getDefaultRhythmFrequency(type) {
    const defaults = {
        dotted: 20,
        whole: 10,
        'dotted-half': 15,
        half: 30,
        'dotted-quarter': 35,
        quarter: 50,
        'dotted-eighth': 25,   // ğŸ”¥ æ·»åŠ ç¼ºå¤±çš„dotted-eighthé»˜è®¤é¢‘ç‡
        eighth: 40,
        '16th': 20,
        triplet: 35,
        duplet: 30,
        quadruplet: 25
    };
    return defaults[type] || 20;
}

/**
 * ğŸ§ª æµ‹è¯•ä¸´æ—¶è®°å·ç”Ÿæˆé€»è¾‘
 */
function testAccidentalGeneration() {
    console.log('ğŸ§ª å¼€å§‹æµ‹è¯•ä¸´æ—¶è®°å·ç”Ÿæˆé€»è¾‘...');

    // åˆ›å»ºæµ‹è¯•ç”¨çš„ç”Ÿæˆå™¨
    const testRange = { min: 60, max: 79 }; // C4-C5
    const testRules = {
        range: testRange,
        accidentalRate: 1.0, // 100%æ¦‚ç‡ç”Ÿæˆä¸´æ—¶è®°å·
        maxJump: 12
    };

    // ä¸“é—¨æµ‹è¯•ç”¨æˆ·æåˆ°çš„é—®é¢˜
    console.log('\nğŸ” æµ‹è¯•Cå¤§è°ƒï¼ˆå‡è®°å·è°ƒå·ï¼‰:');
    const cMajorGenerator = new IntelligentMelodyGenerator(1, 'C', '4/4', 'treble', 12345);
    cMajorGenerator.rules = testRules;

    // æµ‹è¯•å¤šæ¬¡ä»¥è§‚å¯Ÿéšæœºæ€§
    for (let i = 0; i < 10; i++) {
        const result = cMajorGenerator.addAccidental(60); // CéŸ³ç¬¦
        if (result === 61) {
            console.log(`  âœ… ç”Ÿæˆäº†å‡å·: C â†’ C#`);
        } else if (result === 59) {
            console.log(`  âœ… ç”Ÿæˆäº†é™å·: C â†’ B`);
        } else {
            console.log(`  âŒ æ— å˜åŒ–: C â†’ C`);
        }
    }

    console.log('\nğŸ” æµ‹è¯•Gå¤§è°ƒï¼ˆå‡è®°å·è°ƒå·ï¼‰:');
    const gMajorGenerator = new IntelligentMelodyGenerator(1, 'G', '4/4', 'treble', 12345);
    gMajorGenerator.rules = testRules;

    for (let i = 0; i < 10; i++) {
        const result = gMajorGenerator.addAccidental(62); // DéŸ³ç¬¦
        if (result === 63) {
            console.log(`  âœ… ç”Ÿæˆäº†å‡å·: D â†’ D#`);
        } else if (result === 61) {
            console.log(`  âœ… ç”Ÿæˆäº†é™å·: D â†’ Db`);
        } else {
            console.log(`  âŒ æ— å˜åŒ–: D â†’ D`);
        }
    }

    console.log('\nğŸ” æµ‹è¯•Få¤§è°ƒï¼ˆé™è®°å·è°ƒå·ï¼‰:');
    const fMajorGenerator = new IntelligentMelodyGenerator(1, 'F', '4/4', 'treble', 12345);
    fMajorGenerator.rules = testRules;

    for (let i = 0; i < 10; i++) {
        const result = fMajorGenerator.addAccidental(62); // DéŸ³ç¬¦
        if (result === 63) {
            console.log(`  âœ… ç”Ÿæˆäº†å‡å·: D â†’ D#`);
        } else if (result === 61) {
            console.log(`  âœ… ç”Ÿæˆäº†é™å·: D â†’ Db`);
        } else {
            console.log(`  âŒ æ— å˜åŒ–: D â†’ D`);
        }
    }

    console.log('\nğŸ§ª ä¸´æ—¶è®°å·æµ‹è¯•å®Œæˆ');
}

/**
 * ğŸ” è°ƒè¯•ç‰ˆæœ¬çš„ä¸´æ—¶è®°å·ç”Ÿæˆé€»è¾‘
 */
function debugAddAccidental(midi, keySignature) {
    console.log(`\nğŸ” è°ƒè¯•ä¸´æ—¶è®°å·ç”Ÿæˆ: MIDI ${midi}, è°ƒå· ${keySignature}`);

    const accidentalChoices = [];
    const noteClass = midi % 12;
    const keySignatureInfo = isNoteAffectedByKeySignature(noteClass, keySignature);

    console.log(`  åŸéŸ³ç¬¦ç±»åˆ«: ${noteClass}, è°ƒå·å½±å“: ${JSON.stringify(keySignatureInfo)}`);

    // æµ‹è¯•å‡å·
    const sharpNote = midi + 1;
    const sharpNoteClass = sharpNote % 12;
    const sharpKeyInfo = isNoteAffectedByKeySignature(sharpNoteClass, keySignature);

    console.log(`  å‡å·æµ‹è¯•: ${midi} + 1 = ${sharpNote} (ç±»åˆ« ${sharpNoteClass})`);
    console.log(`  å‡å·éŸ³ç¬¦è°ƒå·å½±å“: ${JSON.stringify(sharpKeyInfo)}`);
    console.log(`  å‡å·æ¡ä»¶: sharpNote <= 72 (${sharpNote <= 72}) && !sharpKeyInfo.isFlat (${!sharpKeyInfo.isFlat})`);

    if (sharpNote <= 72 && !sharpKeyInfo.isFlat) {
        accidentalChoices.push(sharpNote);
        console.log(`  âœ… å‡å·å¯ç”¨: ${sharpNote}`);
    } else {
        console.log(`  âŒ å‡å·ä¸å¯ç”¨`);
    }

    // æµ‹è¯•é™å·
    const flatNote = midi - 1;
    const flatNoteClass = flatNote % 12;
    const flatKeyInfo = isNoteAffectedByKeySignature(flatNoteClass, keySignature);

    console.log(`  é™å·æµ‹è¯•: ${midi} - 1 = ${flatNote} (ç±»åˆ« ${flatNoteClass})`);
    console.log(`  é™å·éŸ³ç¬¦è°ƒå·å½±å“: ${JSON.stringify(flatKeyInfo)}`);
    console.log(`  é™å·æ¡ä»¶: flatNote >= 60 (${flatNote >= 60}) && !flatKeyInfo.isSharp (${!flatKeyInfo.isSharp})`);

    if (flatNote >= 60 && !flatKeyInfo.isSharp) {
        accidentalChoices.push(flatNote);
        console.log(`  âœ… é™å·å¯ç”¨: ${flatNote}`);
    } else {
        console.log(`  âŒ é™å·ä¸å¯ç”¨`);
    }

    console.log(`  å¯é€‰ä¸´æ—¶è®°å·: [${accidentalChoices.join(', ')}]`);

    if (accidentalChoices.length === 0) {
        console.log(`  ç»“æœ: æ— ä¸´æ—¶è®°å·ï¼Œè¿”å›åŸéŸ³ç¬¦ ${midi}`);
        return midi;
    }

    const selected = accidentalChoices[0]; // é€‰æ‹©ç¬¬ä¸€ä¸ªç”¨äºæµ‹è¯•
    console.log(`  ç»“æœ: é€‰æ‹©ä¸´æ—¶è®°å· ${selected}`);
    return selected;
}

/**
 * è·å–é»˜è®¤æ¼”å¥æ³•é¢‘ç‡
 */
function getDefaultArticulationFrequency(type) {
    const defaults = {
        staccato: 20,
        accent: 15,
        acciaccatura: 10,
        slur: 15,
        slide: 10
    };
    return defaults[type] ?? 15;
}

/**
 * è·å–é»˜è®¤çš„èŠ‚å¥é¢‘ç‡åˆ†æ¡£å€¼ï¼ˆç”¨äºæ–°çš„åˆ†æ¡£é€‰æ‹©å™¨ç³»ç»Ÿï¼‰
 * 0: ç¦ç”¨ (0%), 1: ä½é¢‘ç‡ (15%), 2: ä¸­é¢‘ç‡ (40%), 3: é«˜é¢‘ç‡ (75%), 4: æœ€é«˜é¢‘ç‡ (100%)
 */
function getDefaultRhythmTier(type) {
    const defaults = {
        whole: 0,      // 10% -> 0 (ç¦ç”¨)
        'dotted-half': 1,  // 15% -> 1 (ä½é¢‘ç‡)  
        half: 2,       // 30% -> 2 (ä¸­é¢‘ç‡)
        'dotted-quarter': 2, // 35% -> 2 (ä¸­é¢‘ç‡)
        quarter: 2,    // 50% -> 2 (ä¸­é¢‘ç‡)
        eighth: 2,     // 40% -> 2 (ä¸­é¢‘ç‡)
        '16th': 1,     // 20% -> 1 (ä½é¢‘ç‡)
        triplet: 2,    // 35% -> 2 (ä¸­é¢‘ç‡)
        duplet: 2,     // 30% -> 2 (ä¸­é¢‘ç‡)
        quadruplet: 1  // 25% -> 1 (ä½é¢‘ç‡)
    };
    return defaults[type] ?? 1; // é»˜è®¤ä¸ºä½é¢‘ç‡
}

/**
 * è·å–é»˜è®¤çš„æ¼”å¥æ³•é¢‘ç‡åˆ†æ¡£å€¼ï¼ˆç”¨äºæ–°çš„åˆ†æ¡£é€‰æ‹©å™¨ç³»ç»Ÿï¼‰
 * 0: ç¦ç”¨ (0%), 1: ä½é¢‘ç‡ (15%), 2: ä¸­é¢‘ç‡ (40%), 3: é«˜é¢‘ç‡ (75%), 4: æœ€é«˜é¢‘ç‡ (100%)
 */
function getDefaultArticulationTier(type) {
    const defaults = {
        staccato: 1,      // 20% -> 1 (ä½é¢‘ç‡)
        accent: 1,        // 15% -> 1 (ä½é¢‘ç‡)
        acciaccatura: 0,  // 10% -> 0 (ç¦ç”¨)
        slur: 1,          // 15% -> 1 (ä½é¢‘ç‡)
        slide: 0          // 10% -> 0 (æœ€ä½æ¡£)
    };
    return defaults[type] ?? 1; // é»˜è®¤ä¸ºä½é¢‘ç‡
}

/**
 * ğŸµ åˆå§‹åŒ–æ‹å·å¤é€‰æ¡†çš„å®æ—¶ç›‘å¬å™¨
 */
function initializeTimeSignatureListeners() {
    console.log('ğŸµ åˆå§‹åŒ–æ‹å·å¤é€‰æ¡†å®æ—¶ç›‘å¬å™¨');
    
    const timeSignatureIds = ['time-2/4', 'time-3/4', 'time-4/4', 'time-6/8', 'time-custom'];
    
    timeSignatureIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.addEventListener('change', function() {
                console.log(`ğŸ¼ æ‹å·å¤é€‰æ¡†å˜åŒ–: ${id} = ${this.checked}`);
                if (id === 'time-custom') {
                    updateCustomTimeSignatureFields(this.checked);
                }
                
                // ğŸ”¥ ç§»é™¤å®æ—¶æ›´æ–°é€»è¾‘ï¼Œåªåœ¨ä¿å­˜æ—¶æ›´æ–°èŠ‚å¥é€‰é¡¹
                // è¿™æ ·å¯ä»¥é¿å…åœ¨ç”¨æˆ·é€‰æ‹©è¿‡ç¨‹ä¸­é¢‘ç¹åˆ‡æ¢ï¼Œç¡®ä¿å¤šæ‹å·æ¨¡å¼æ­£å¸¸å·¥ä½œ
                console.log(`ğŸµ æ‹å·${this.value}å‹¾é€‰çŠ¶æ€: ${this.checked}ï¼ˆå°†åœ¨ä¿å­˜æ—¶ç»Ÿä¸€æ›´æ–°èŠ‚å¥é€‰é¡¹ï¼‰`);
            });
        } else {
            console.warn(`âš ï¸ æ‰¾ä¸åˆ°æ‹å·å¤é€‰æ¡†: ${id}`);
        }
    });
}

// ğŸ”¥ åœ¨é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨åˆå§‹åŒ–åŒæ­¥æœºåˆ¶å’ŒæŒ‰é’®æ˜¾ç¤º
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        initializeCheckboxSliderSync();
        console.log('âœ… å¤é€‰æ¡†ä¸æ»‘å—åŒæ­¥æœºåˆ¶å·²åˆå§‹åŒ–');
        
        // åˆå§‹åŒ–æŒ‰é’®æ˜¾ç¤º
        initializeButtonDisplays();
        console.log('âœ… æŒ‰é’®æ˜¾ç¤ºå·²åˆå§‹åŒ–');
        
        // ğŸµ åˆå§‹åŒ–æ‹å·å¤é€‰æ¡†çš„å®æ—¶ç›‘å¬å™¨
        initializeTimeSignatureListeners();
        console.log('âœ… æ‹å·å®æ—¶ç›‘å¬å™¨å·²åˆå§‹åŒ–');
    }, 1000);
});

/**
 * åˆå§‹åŒ–æ‰€æœ‰æŒ‰é’®çš„æ˜¾ç¤ºæ–‡æœ¬
 */
function initializeButtonDisplays() {
    // è°ƒå·æŒ‰é’®
    updateButtonDisplay('keySettingsBtn', userSettings.allowedKeys, 'è°ƒå·');
    
    // æ‹å·æŒ‰é’®
    updateButtonDisplay('timeSignatureSettingsBtn', userSettings.allowedTimeSignatures, 'æ‹å·');
    
    // éŸ³ç¨‹è·¨åº¦æŒ‰é’®ï¼ˆå•é€‰æ¨¡å¼ï¼‰
    const intervalMap = {
        1: 'å°äºŒåº¦', 2: 'å¤§äºŒåº¦', 3: 'å°ä¸‰åº¦', 4: 'å¤§ä¸‰åº¦',
        5: 'å®Œå…¨å››åº¦', 6: 'å¢å››åº¦/å‡äº”åº¦', 7: 'å®Œå…¨äº”åº¦', 8: 'å°å…­åº¦',
        9: 'å¤§å…­åº¦', 10: 'å°ä¸ƒåº¦', 11: 'å¤§ä¸ƒåº¦', 12: 'å®Œå…¨å…«åº¦'
    };
    const selectedInterval = userSettings.allowedIntervals[0] || 12; // å–ç¬¬ä¸€ä¸ªï¼ˆä¹Ÿæ˜¯å”¯ä¸€çš„ï¼‰å€¼
    const intervalName = intervalMap[selectedInterval] || `${selectedInterval}åº¦`;
    document.getElementById('intervalSettingsBtn').textContent = intervalName;
    
    // è°±å·æŒ‰é’®
    const clefNames = userSettings.allowedClefs.map(clef => {
        const clefMap = {
            'treble': 'é«˜éŸ³è°±å·',
            'bass': 'ä½éŸ³è°±å·', 
            'alto': 'ä¸­éŸ³è°±å·'
        };
        return clefMap[clef] || clef;
    });
    updateButtonDisplay('clefSettingsBtn', clefNames, 'è°±å·');
}

// ====== ğŸµ è°ƒå·è®¾ç½®å¼¹çª—ç®¡ç† ======

/**
 * æ‰“å¼€è°ƒå·è®¾ç½®å¼¹çª—
 */
function openKeySettings() {
    console.log('ğŸµ æ‰“å¼€è°ƒå·è®¾ç½®å¼¹çª—');
    
    // æ¢å¤å½“å‰è®¾ç½®åˆ°UI
    const allowedKeys = userSettings.allowedKeys || ['C'];
    
    // è·å–æ‰€æœ‰è°ƒå·å¤é€‰æ¡†
    const keyInputs = document.querySelectorAll('#keySignatureModal input[type="checkbox"]');
    keyInputs.forEach(input => {
        input.checked = allowedKeys.includes(input.value);
    });
    
    document.getElementById('keySignatureModal').style.display = 'flex';
    syncSelectAllState(
        'majorKeys',
        ['key-C', 'key-G', 'key-D', 'key-A', 'key-E', 'key-B', 'key-F#', 'key-F', 'key-Bb', 'key-Eb', 'key-Ab', 'key-Db', 'key-Gb'],
        'button[onclick="selectAllMajorKeys()"]'
    );
    syncSelectAllState(
        'minorKeys',
        ['key-Am', 'key-Em', 'key-Bm', 'key-F#m', 'key-C#m', 'key-G#m', 'key-D#m', 'key-Dm', 'key-Gm', 'key-Cm', 'key-Fm', 'key-Bbm', 'key-Ebm'],
        'button[onclick="selectAllMinorKeys()"]'
    );
}

/**
 * å…³é—­è°ƒå·è®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰
 */
function closeKeySettingsWithSave() {
    console.log('âŒ å…³é—­è°ƒå·è®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    const selectedKeys = [];
    const keyInputs = document.querySelectorAll('#keySignatureModal input[type="checkbox"]');
    keyInputs.forEach(input => {
        if (input.checked) {
            selectedKeys.push(input.value);
        }
    });
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (selectedKeys.length > 0) {
        userSettings.allowedKeys = selectedKeys;
        console.log(`âœ… è°ƒå·è®¾ç½®å·²é™é»˜ä¿å­˜: ${selectedKeys.join(', ')}`);
        updateButtonDisplay('keySettingsBtn', selectedKeys, 'è°ƒå·');
    }
    
    document.getElementById('keySignatureModal').style.display = 'none';
    resetSelectAllStates();
}

/**
 * å…³é—­è°ƒå·è®¾ç½®å¼¹çª—
 */
function closeKeySettings() {
    console.log('âŒ å…³é—­è°ƒå·è®¾ç½®å¼¹çª—');
    closeKeySettingsWithSave();
}

/**
 * ä¿å­˜è°ƒå·è®¾ç½®
 */
function saveKeySettings() {
    console.log('ğŸ’¾ ä¿å­˜è°ƒå·è®¾ç½®');
    
    const selectedKeys = [];
    const keyInputs = document.querySelectorAll('#keySignatureModal input[type="checkbox"]');
    keyInputs.forEach(input => {
        if (input.checked) {
            selectedKeys.push(input.value);
        }
    });
    
    if (selectedKeys.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè°ƒå·ï¼');
        return;
    }
    
    userSettings.allowedKeys = selectedKeys;
    console.log(`âœ… è°ƒå·è®¾ç½®å·²ä¿å­˜: ${selectedKeys.join(', ')}`);
    
    // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
    updateButtonDisplay('keySettingsBtn', selectedKeys, 'è°ƒå·');
    
    closeKeySettings();
}

/**
 * å…¨é€‰å¤§è°ƒ
 */
function selectAllMajorKeys() {
    const majorKeyIds = [
        'key-C', 'key-G', 'key-D', 'key-A', 'key-E', 'key-B', 'key-F#',
        'key-F', 'key-Bb', 'key-Eb', 'key-Ab', 'key-Db', 'key-Gb'
    ];
    
    toggleSelectAll(
        'majorKeys', 
        majorKeyIds, 
        'button[onclick="selectAllMajorKeys()"]',
        'å¤§è°ƒ'
    );
}

/**
 * å…¨é€‰å°è°ƒ
 */
function selectAllMinorKeys() {
    const minorKeyIds = [
        'key-Am', 'key-Em', 'key-Bm', 'key-F#m', 'key-C#m', 'key-G#m', 'key-D#m',
        'key-Dm', 'key-Gm', 'key-Cm', 'key-Fm', 'key-Bbm', 'key-Ebm'
    ];
    
    toggleSelectAll(
        'minorKeys', 
        minorKeyIds, 
        'button[onclick="selectAllMinorKeys()"]',
        'å°è°ƒ'
    );
}

// ====== ğŸ¥ æ‹å·è®¾ç½®å¼¹çª—ç®¡ç† ======

function updateCustomTimeSignatureFields(show) {
    const section = document.getElementById('customTimeSignatureFields');
    const beatsInput = document.getElementById('customTimeBeats');
    const beatTypeSelect = document.getElementById('customTimeBeatValue');
    if (section) {
        section.style.display = show ? 'block' : 'none';
    }
    if (!show) return;
    if (beatsInput && (!beatsInput.value || parseInt(beatsInput.value, 10) <= 0)) {
        beatsInput.value = '5';
    }
    if (beatTypeSelect && !beatTypeSelect.value) {
        beatTypeSelect.value = '4';
    }
}

function getCustomTimeSignatureInput() {
    const beatsInput = document.getElementById('customTimeBeats');
    const beatTypeSelect = document.getElementById('customTimeBeatValue');
    const beats = beatsInput ? parseInt(beatsInput.value, 10) : NaN;
    const beatType = beatTypeSelect ? parseInt(beatTypeSelect.value, 10) : NaN;

    if (!Number.isInteger(beats) || beats <= 0) {
        return { valid: false, message: 'è¯·è¾“å…¥æ­£ç¡®çš„æ‹æ•°ï¼ˆå¿…é¡»ä¸ºå¤§äº0çš„æ•´æ•°ï¼‰' };
    }
    if (![2, 4, 8, 16].includes(beatType)) {
        return { valid: false, message: 'æ‹å·å•ä½ä»…æ”¯æŒ 2/4/8/16' };
    }
    return { valid: true, value: `${beats}/${beatType}`, beats, beatType };
}

function findCustomTimeSignature(allowedTimeSignatures) {
    if (!Array.isArray(allowedTimeSignatures)) return null;
    return allowedTimeSignatures.find(ts => !isBuiltInTimeSignature(ts)) || null;
}

function collectTimeSignatureSelection() {
    const selectedTimeSignatures = [];
    const timeInputs = document.querySelectorAll('#timeSignatureModal input[type="checkbox"]');
    const customToggle = document.getElementById('time-custom');
    const customSelected = customToggle ? customToggle.checked : false;

    timeInputs.forEach(input => {
        if (!input.checked) return;
        if (input.value === 'custom') return;
        selectedTimeSignatures.push(input.value);
    });

    if (customSelected) {
        const customInput = getCustomTimeSignatureInput();
        if (!customInput.valid) {
            alert(customInput.message);
            return null;
        }
        userSettings.customTimeSignature = customInput.value;
        if (isBuiltInTimeSignature(customInput.value)) {
            if (!selectedTimeSignatures.includes(customInput.value)) {
                selectedTimeSignatures.push(customInput.value);
            }
            if (customToggle) {
                customToggle.checked = false;
                updateCustomTimeSignatureFields(false);
            }
            const builtInCheckbox = document.querySelector(`#timeSignatureModal input[value="${customInput.value}"]`);
            if (builtInCheckbox) builtInCheckbox.checked = true;
        } else {
            selectedTimeSignatures.push(customInput.value);
        }
    }

    return selectedTimeSignatures;
}

/**
 * æ‰“å¼€æ‹å·è®¾ç½®å¼¹çª—
 */
function openTimeSignatureSettings() {
    console.log('ğŸ¥ æ‰“å¼€æ‹å·è®¾ç½®å¼¹çª—');
    
    // æ¢å¤å½“å‰è®¾ç½®åˆ°UI
    const allowedTimeSignatures = userSettings.allowedTimeSignatures || ['4/4'];
    
    // è·å–æ‰€æœ‰æ‹å·å¤é€‰æ¡†
    const timeInputs = document.querySelectorAll('#timeSignatureModal input[type="checkbox"]');
    timeInputs.forEach(input => {
        input.checked = allowedTimeSignatures.includes(input.value);
    });

    const customToggle = document.getElementById('time-custom');
    const customFromSelection = findCustomTimeSignature(allowedTimeSignatures);
    const customValue = customFromSelection || userSettings.customTimeSignature;
    if (customToggle) {
        customToggle.checked = !!customFromSelection;
        customToggle.onchange = () => {
            updateCustomTimeSignatureFields(customToggle.checked);
        };
        updateCustomTimeSignatureFields(customToggle.checked);
    }
    if (customValue) {
        const parsed = parseTimeSignatureString(customValue);
        if (parsed) {
            const beatsInput = document.getElementById('customTimeBeats');
            const beatTypeSelect = document.getElementById('customTimeBeatValue');
            if (beatsInput) beatsInput.value = String(parsed.beats);
            if (beatTypeSelect) beatTypeSelect.value = String(parsed.beatType);
        }
    }
    
    document.getElementById('timeSignatureModal').style.display = 'flex';
    syncSelectAllState(
        'timeSignatures',
        ['time-2/4', 'time-3/4', 'time-4/4', 'time-6/8'],
        'button[onclick="selectAllTimeSignatures()"]'
    );
}

/**
 * å…³é—­æ‹å·è®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰
 */
function closeTimeSignatureSettingsWithSave() {
    console.log('âŒ å…³é—­æ‹å·è®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    const selectedTimeSignatures = collectTimeSignatureSelection();
    if (!selectedTimeSignatures) return;
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (selectedTimeSignatures.length > 0) {
        userSettings.allowedTimeSignatures = selectedTimeSignatures;
        console.log(`âœ… æ‹å·è®¾ç½®å·²é™é»˜ä¿å­˜: ${selectedTimeSignatures.join(', ')}`);
        
        // ğŸµ æ ¹æ®é€‰æ‹©çš„æ‹å·è°ƒæ•´èŠ‚å¥é€‰é¡¹ï¼ˆä¸saveTimeSignatureSettingsä¿æŒä¸€è‡´ï¼‰
        if (selectedTimeSignatures.length === 1) {
            // å¦‚æœåªé€‰æ‹©äº†ä¸€ä¸ªæ‹å·ï¼Œè‡ªåŠ¨è°ƒæ•´èŠ‚å¥é€‰é¡¹
            const singleTimeSignature = selectedTimeSignatures[0];
            console.log(`ğŸ›ï¸ å•ä¸€æ‹å·é€‰æ‹©ï¼Œè‡ªåŠ¨è°ƒæ•´èŠ‚å¥é€‰é¡¹: ${singleTimeSignature}`);
            updateRhythmOptionsForTimeSignature(singleTimeSignature);
        } else {
            // ğŸ”¥ ä¿®å¤ï¼šå¤šæ‹å·é€‰æ‹©æ—¶æ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³
            console.log('ğŸ›ï¸ å¤šæ‹å·é€‰æ‹©ï¼Œæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ˆåŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³ï¼‰');
            updateRhythmOptionsForTimeSignature('multi'); // ä½¿ç”¨ç‰¹æ®Šçš„å¤šæ‹å·æ¨¡å¼
        }
        
        updateButtonDisplay('timeSignatureSettingsBtn', selectedTimeSignatures, 'æ‹å·');
    }
    
    document.getElementById('timeSignatureModal').style.display = 'none';
    resetSelectAllStates();
}

/**
 * å…³é—­æ‹å·è®¾ç½®å¼¹çª—
 */
function closeTimeSignatureSettings() {
    console.log('âŒ å…³é—­æ‹å·è®¾ç½®å¼¹çª—');
    closeTimeSignatureSettingsWithSave();
}

/**
 * ä¿å­˜æ‹å·è®¾ç½®
 */
function saveTimeSignatureSettings() {
    console.log('ğŸ’¾ ä¿å­˜æ‹å·è®¾ç½® - å‡½æ•°è¢«è°ƒç”¨');

    try {
        const timeInputs = document.querySelectorAll('#timeSignatureModal input[type="checkbox"]');
        console.log(`ğŸ” æ‰¾åˆ°${timeInputs.length}ä¸ªæ‹å·å¤é€‰æ¡†`);

        const selectedTimeSignatures = collectTimeSignatureSelection();
        if (!selectedTimeSignatures) return;
        
        console.log(`ğŸ” é€‰ä¸­çš„æ‹å·: ${selectedTimeSignatures.join(', ')}`);

        if (selectedTimeSignatures.length === 0) {
            alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ‹å·ï¼');
            return;
        }

        userSettings.allowedTimeSignatures = selectedTimeSignatures;
        console.log(`âœ… æ‹å·è®¾ç½®å·²ä¿å­˜: ${selectedTimeSignatures.join(', ')}`);

        // ğŸµ æ ¹æ®é€‰æ‹©çš„æ‹å·è°ƒæ•´èŠ‚å¥é€‰é¡¹
        if (selectedTimeSignatures.length === 1) {
            // å¦‚æœåªé€‰æ‹©äº†ä¸€ä¸ªæ‹å·ï¼Œè‡ªåŠ¨è°ƒæ•´èŠ‚å¥é€‰é¡¹
            const singleTimeSignature = selectedTimeSignatures[0];
            console.log(`ğŸ›ï¸ å•ä¸€æ‹å·é€‰æ‹©ï¼Œè‡ªåŠ¨è°ƒæ•´èŠ‚å¥é€‰é¡¹: ${singleTimeSignature}`);
            updateRhythmOptionsForTimeSignature(singleTimeSignature);
        } else {
            // ğŸ”¥ ä¿®å¤ï¼šå¤šæ‹å·é€‰æ‹©æ—¶æ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ŒåŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³
            console.log('ğŸ›ï¸ å¤šæ‹å·é€‰æ‹©ï¼Œæ˜¾ç¤ºæ‰€æœ‰èŠ‚å¥é€‰é¡¹ï¼ˆåŒ…æ‹¬ä¸‰è¿éŸ³ã€äºŒè¿éŸ³ã€å››è¿éŸ³ï¼‰');
            updateRhythmOptionsForTimeSignature('multi'); // ä½¿ç”¨ç‰¹æ®Šçš„å¤šæ‹å·æ¨¡å¼
        }

        // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
        console.log('ğŸ” å¼€å§‹æ›´æ–°æŒ‰é’®æ˜¾ç¤º');
        updateButtonDisplay('timeSignatureSettingsBtn', selectedTimeSignatures, 'æ‹å·');
        console.log('ğŸ” æŒ‰é’®æ˜¾ç¤ºæ›´æ–°å®Œæˆ');

        console.log('ğŸ” å¼€å§‹å…³é—­è®¾ç½®å¼¹çª—');
        document.getElementById('timeSignatureModal').style.display = 'none';
        console.log('ğŸ” è®¾ç½®å¼¹çª—å…³é—­å®Œæˆ');

    } catch (error) {
        console.error('âŒ ä¿å­˜æ‹å·è®¾ç½®æ—¶å‡ºé”™:', error);
        alert(`ä¿å­˜æ‹å·è®¾ç½®æ—¶å‡ºé”™: ${error.message}`);
    }
}

/**
 * å…¨é€‰æ‹å·
 */
function selectAllTimeSignatures() {
    const timeSignatureIds = [
        'time-2/4', 'time-3/4', 'time-4/4', 'time-6/8'
    ];
    
    toggleSelectAll(
        'timeSignatures', 
        timeSignatureIds, 
        'button[onclick="selectAllTimeSignatures()"]',
        'æ‹å·'
    );
}

// ====== ğŸ¯ éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—ç®¡ç† ======

/**
 * æ‰“å¼€éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—
 */
function openIntervalSettings() {
    console.log('ğŸ¯ æ‰“å¼€éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—');
    
    // æ¢å¤å½“å‰è®¾ç½®åˆ°UIï¼ˆå•é€‰æ¨¡å¼ï¼šåªæ¢å¤ç¬¬ä¸€ä¸ªå€¼ï¼‰
    const selectedInterval = userSettings.allowedIntervals[0] || 12;
    
    // è·å–æ‰€æœ‰éŸ³ç¨‹å¤é€‰æ¡†ï¼Œåªé€‰ä¸­å½“å‰è®¾ç½®çš„é‚£ä¸ª
    const intervalInputs = document.querySelectorAll('#intervalModal input[type="checkbox"]');
    intervalInputs.forEach(input => {
        input.checked = (parseInt(input.value) === selectedInterval);
    });
    
    console.log(`ğŸ¯ æ¢å¤éŸ³ç¨‹è·¨åº¦è®¾ç½®: ${selectedInterval}åŠéŸ³`);
    
    document.getElementById('intervalModal').style.display = 'flex';
}

/**
 * å…³é—­éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰
 */
function closeIntervalSettingsWithSave() {
    console.log('âŒ å…³é—­éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    // è·å–å”¯ä¸€é€‰ä¸­çš„checkboxï¼ˆå•é€‰é€»è¾‘ï¼‰
    const checkedInput = document.querySelector('#intervalModal input[type="checkbox"]:checked');
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (checkedInput) {
        const selectedInterval = parseInt(checkedInput.value);
        userSettings.allowedIntervals = [selectedInterval];
        console.log(`âœ… éŸ³ç¨‹è·¨åº¦è®¾ç½®å·²é™é»˜ä¿å­˜: ${selectedInterval}åŠéŸ³`);
        
        // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
        const intervalMap = {
            1: 'å°äºŒåº¦', 2: 'å¤§äºŒåº¦', 3: 'å°ä¸‰åº¦', 4: 'å¤§ä¸‰åº¦',
            5: 'å®Œå…¨å››åº¦', 6: 'å¢å››åº¦/å‡äº”åº¦', 7: 'å®Œå…¨äº”åº¦', 8: 'å°å…­åº¦',
            9: 'å¤§å…­åº¦', 10: 'å°ä¸ƒåº¦', 11: 'å¤§ä¸ƒåº¦', 12: 'å®Œå…¨å…«åº¦'
        };
        const intervalName = intervalMap[selectedInterval] || `${selectedInterval}åº¦`;
        document.getElementById('intervalSettingsBtn').textContent = intervalName;
    }
    
    document.getElementById('intervalModal').style.display = 'none';
}

/**
 * å…³é—­éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—
 */
function closeIntervalSettings() {
    console.log('âŒ å…³é—­éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª—');
    closeIntervalSettingsWithSave();
}

/**
 * ä¿å­˜éŸ³ç¨‹è·¨åº¦è®¾ç½®
 */
function saveIntervalSettings() {
    console.log('ğŸ’¾ ä¿å­˜éŸ³ç¨‹è·¨åº¦è®¾ç½®');
    
    // è·å–å”¯ä¸€é€‰ä¸­çš„checkboxï¼ˆå•é€‰é€»è¾‘ï¼‰
    const checkedInput = document.querySelector('#intervalModal input[type="checkbox"]:checked');
    
    if (!checkedInput) {
        alert('è¯·é€‰æ‹©ä¸€ä¸ªéŸ³ç¨‹è·¨åº¦ï¼');
        return;
    }
    
    const selectedInterval = parseInt(checkedInput.value);
    
    // ä¿å­˜ä¸ºå•ä¸ªå€¼çš„æ•°ç»„ï¼ˆä¿æŒä¸ç°æœ‰æ¥å£å…¼å®¹ï¼‰
    userSettings.allowedIntervals = [selectedInterval];
    console.log(`âœ… éŸ³ç¨‹è·¨åº¦è®¾ç½®å·²ä¿å­˜: ${selectedInterval}åŠéŸ³`);
    
    // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
    const intervalMap = {
        1: 'å°äºŒåº¦', 2: 'å¤§äºŒåº¦', 3: 'å°ä¸‰åº¦', 4: 'å¤§ä¸‰åº¦',
        5: 'å®Œå…¨å››åº¦', 6: 'å¢å››åº¦/å‡äº”åº¦', 7: 'å®Œå…¨äº”åº¦', 8: 'å°å…­åº¦',
        9: 'å¤§å…­åº¦', 10: 'å°ä¸ƒåº¦', 11: 'å¤§ä¸ƒåº¦', 12: 'å®Œå…¨å…«åº¦'
    };
    const intervalName = intervalMap[selectedInterval] || `${selectedInterval}åº¦`;
    document.getElementById('intervalSettingsBtn').textContent = intervalName;
    
    closeIntervalSettings();
}

/**
 * å¤„ç†éŸ³ç¨‹è·¨åº¦checkboxçš„å•é€‰è¡Œä¸º
 */
function handleIntervalCheckboxChange(clickedCheckbox) {
    // å¦‚æœå½“å‰checkboxè¢«å‹¾é€‰ï¼Œåˆ™å–æ¶ˆå‹¾é€‰å…¶ä»–æ‰€æœ‰checkbox
    if (clickedCheckbox.checked) {
        const allIntervalCheckboxes = document.querySelectorAll('#intervalModal input[type="checkbox"]');
        allIntervalCheckboxes.forEach(checkbox => {
            if (checkbox !== clickedCheckbox) {
                checkbox.checked = false;
            }
        });
        console.log(`ğŸ¯ éŸ³ç¨‹è·¨åº¦å•é€‰: é€‰æ‹©äº†${clickedCheckbox.value}åŠéŸ³`);
    } else {
        // å¦‚æœç”¨æˆ·å–æ¶ˆå‹¾é€‰ï¼Œç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªé€‰é¡¹è¢«é€‰ä¸­ï¼ˆé˜²æ­¢å…¨éƒ¨ä¸ºç©ºï¼‰
        const allIntervalCheckboxes = document.querySelectorAll('#intervalModal input[type="checkbox"]');
        const hasAnyChecked = Array.from(allIntervalCheckboxes).some(cb => cb.checked);
        if (!hasAnyChecked) {
            // å¦‚æœæ²¡æœ‰ä»»ä½•é€‰é¡¹è¢«å‹¾é€‰ï¼Œé‡æ–°å‹¾é€‰å½“å‰é€‰é¡¹
            clickedCheckbox.checked = true;
            console.log(`âš ï¸ éŸ³ç¨‹è·¨åº¦ä¸èƒ½ä¸ºç©ºï¼Œä¿æŒ${clickedCheckbox.value}åŠéŸ³é€‰ä¸­`);
        }
    }
}

// ====== ğŸ¼ è°±å·è®¾ç½®å¼¹çª—ç®¡ç† ======

/**
 * æ‰“å¼€è°±å·è®¾ç½®å¼¹çª—
 */
function openClefSettings() {
    console.log('ğŸ¼ æ‰“å¼€è°±å·è®¾ç½®å¼¹çª—');
    
    // æ¢å¤å½“å‰è®¾ç½®åˆ°UI
    const allowedClefs = userSettings.allowedClefs || ['treble'];
    
    // è·å–æ‰€æœ‰è°±å·å¤é€‰æ¡†
    const clefInputs = document.querySelectorAll('#clefModal input[type="checkbox"]');
    clefInputs.forEach(input => {
        input.checked = allowedClefs.includes(input.value);
    });
    
    document.getElementById('clefModal').style.display = 'flex';
    syncSelectAllState(
        'clefs',
        ['clef-treble', 'clef-bass', 'clef-alto'],
        'button[onclick="selectAllClefs()"]'
    );
}

/**
 * å…³é—­è°±å·è®¾ç½®å¼¹çª—ï¼ˆé™é»˜ä¿å­˜ï¼‰
 */
function closeClefSettingsWithSave() {
    console.log('âŒ å…³é—­è°±å·è®¾ç½®å¼¹çª—ï¼ˆè‡ªåŠ¨ä¿å­˜ï¼‰');
    
    const selectedClefs = [];
    const clefInputs = document.querySelectorAll('#clefModal input[type="checkbox"]');
    clefInputs.forEach(input => {
        if (input.checked) {
            selectedClefs.push(input.value);
        }
    });
    
    // å¦‚æœæœ‰é€‰æ‹©ï¼Œåˆ™ä¿å­˜
    if (selectedClefs.length > 0) {
        userSettings.allowedClefs = selectedClefs;
        console.log(`âœ… è°±å·è®¾ç½®å·²é™é»˜ä¿å­˜: ${selectedClefs.join(', ')}`);
        
        const clefNames = selectedClefs.map(clef => {
            const clefMap = {
                'treble': 'é«˜éŸ³è°±å·',
                'bass': 'ä½éŸ³è°±å·', 
                'alto': 'ä¸­éŸ³è°±å·'
            };
            return clefMap[clef] || clef;
        });
        updateButtonDisplay('clefSettingsBtn', clefNames, 'è°±å·');
    }
    
    document.getElementById('clefModal').style.display = 'none';
    resetSelectAllStates();
}

/**
 * å…³é—­è°±å·è®¾ç½®å¼¹çª—
 */
function closeClefSettings() {
    console.log('âŒ å…³é—­è°±å·è®¾ç½®å¼¹çª—');
    closeClefSettingsWithSave();
}

/**
 * ä¿å­˜è°±å·è®¾ç½®
 */
function saveClefSettings() {
    console.log('ğŸ’¾ ä¿å­˜è°±å·è®¾ç½®');
    
    const selectedClefs = [];
    const clefInputs = document.querySelectorAll('#clefModal input[type="checkbox"]');
    clefInputs.forEach(input => {
        if (input.checked) {
            selectedClefs.push(input.value);
        }
    });
    
    if (selectedClefs.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè°±å·ï¼');
        return;
    }
    
    userSettings.allowedClefs = selectedClefs;
    console.log(`âœ… è°±å·è®¾ç½®å·²ä¿å­˜: ${selectedClefs.join(', ')}`);
    
    // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
    const clefNames = selectedClefs.map(clef => {
        const clefMap = {
            'treble': 'é«˜éŸ³è°±å·',
            'bass': 'ä½éŸ³è°±å·', 
            'alto': 'ä¸­éŸ³è°±å·'
        };
        return clefMap[clef] || clef;
    });
    updateButtonDisplay('clefSettingsBtn', clefNames, 'è°±å·');
    
    closeClefSettings();
}

/**
 * å…¨é€‰è°±å·
 */
function selectAllClefs() {
    const clefIds = [
        'clef-treble', 'clef-bass', 'clef-alto'
    ];
    
    toggleSelectAll(
        'clefs', 
        clefIds, 
        'button[onclick="selectAllClefs()"]',
        'è°±å·'
    );
}

// ====== ğŸ”§ è¾…åŠ©å‡½æ•° ======

/**
 * æ›´æ–°æŒ‰é’®æ˜¾ç¤ºæ–‡æœ¬
 */
function updateButtonDisplay(buttonId, selectedItems, category) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    let displayText;
    if (selectedItems.length === 1) {
        displayText = selectedItems[0];
    } else if (selectedItems.length <= 3) {
        displayText = selectedItems.join(', ');
    } else {
        displayText = `${selectedItems.length}ä¸ª${category}`;
    }
    
    // ä¿æŒå›¾æ ‡ï¼Œæ›´æ–°æ–‡æœ¬
    const iconMap = {
        'keySettingsBtn': '',
        'timeSignatureSettingsBtn': '', 
        'intervalSettingsBtn': '',
        'clefSettingsBtn': ''
    };
    
    const icon = iconMap[buttonId] || '';
    button.textContent = icon ? `${icon} ${displayText}` : displayText;
}

/**
 * ä»å…è®¸çš„é€‰é¡¹ä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
 */
function getRandomFromArray(array) {
    if (!array || array.length === 0) return null;
    return array[Math.floor(Math.random() * array.length)];
}

// ====== ğŸ¯ ç²¾å‡†é¢‘ç‡æ§åˆ¶ç³»ç»Ÿ ======

/**
 * ç²¾å‡†çš„èŠ‚å¥æ—¶å€¼æƒé‡è®¡ç®—å™¨
 * å°†ç”¨æˆ·è®¾ç½®çš„ç™¾åˆ†æ¯”ç²¾ç¡®è½¬æ¢ä¸ºæƒé‡ç³»ç»Ÿ
 */
function calculatePreciseRhythmWeight(duration) {
    const mappedDuration = mapDurationToFrequencyKey(duration);
    let userFreq = getUserFrequency('rhythm', mappedDuration);
    const isJianpuTool = typeof window !== 'undefined' && window.location && window.location.href.includes('jianpu-generator.html');
    if (isJianpuTool && mappedDuration === 'dotted-eighth') {
        userFreq = Math.max(1, Math.round(userFreq * 0.5));
    }
    
    if (userFreq === 0) {
        return 0; // å®Œå…¨ç¦ç”¨
    }
    
    // ğŸ”¥ ä½¿ç”¨å¹³æ»‘çš„å¹‚æ¬¡æ›²çº¿ï¼šä¿ç•™ç›¸å¯¹æ¯”ä¾‹ï¼ŒåŒæ—¶å‹åˆ¶ä½é¢‘è¿‡åº¦æ”¾å¤§
    // ç›´æ¥ä½¿ç”¨ç™¾åˆ†æ¯” (0-100) è¿›è¡Œå½’ä¸€åŒ–ï¼Œé¿å…ä½é¢‘è¢«æŠ¬é«˜å¯¼è‡´16åˆ†éŸ³ç¬¦è¿‡å¤š
    return Math.pow(userFreq / 100, 1.6);
}

/**
 * ç²¾å‡†çš„articulationé¢‘ç‡æ£€æŸ¥å™¨
 * ä½¿ç”¨çœŸå®çš„ç™¾åˆ†æ¯”æ¦‚ç‡ï¼Œä¸å—å…¶ä»–æ¡ä»¶ä¿®é¥°
 */
function shouldGenerateArticulation(articulationType, randomGenerator = null) {
    const userFreq = getUserFrequency('articulation', articulationType);
    
    if (userFreq === 0) {
        return false; // å®Œå…¨ç¦ç”¨
    }
    
    const random = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    const shouldGenerate = (random * 100) < userFreq;
    
    // è¯¦ç»†æ—¥å¿—ç”¨äºè°ƒè¯•
    console.log(`ğŸ¯ ç²¾å‡†é¢‘ç‡æ§åˆ¶ ${articulationType}: ${userFreq}% -> ${shouldGenerate ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'} (éšæœºå€¼: ${(random * 100).toFixed(1)}%)`);
    
    return shouldGenerate;
}

/**
 * å°†æ»‘å—ç™¾åˆ†æ¯”å€¼æ˜ å°„åˆ°åˆ†æ¡£ç³»ç»Ÿ
 * 0%: ç¦ç”¨, 1-20%: ä½é¢‘ç‡ (15%), 21-50%: ä¸­é¢‘ç‡ (40%), 51-80%: é«˜é¢‘ç‡ (75%), 81-100%: æœ€é«˜é¢‘ç‡ (100%)
 */
function mapSliderPercentageToTier(sliderValue) {
    const percentage = parseInt(sliderValue);
    
    if (percentage === 0) return 0;           // ç¦ç”¨ (0%)
    if (percentage >= 1 && percentage <= 20) return 15;  // ä½é¢‘ç‡ (15%)
    if (percentage >= 21 && percentage <= 50) return 40; // ä¸­é¢‘ç‡ (40%)
    if (percentage >= 51 && percentage <= 80) return 75; // é«˜é¢‘ç‡ (75%)
    if (percentage >= 81 && percentage <= 100) return 100; // æœ€é«˜é¢‘ç‡ (100%)
    
    return 15; // é»˜è®¤ä¸ºä½é¢‘ç‡
}

/**
 * å°†ä»»æ„é¢‘ç‡å€¼è§„èŒƒä¸º 0-100 çš„æ•´æ•°ç™¾åˆ†æ¯”
 */
function normalizeFrequencyPercentage(value, fallbackValue = 15) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) return fallbackValue;
    return Math.max(0, Math.min(100, Math.round(numeric)));
}

/**
 * ç»Ÿä¸€çš„ç”¨æˆ·é¢‘ç‡è·å–å™¨ - ä½¿ç”¨çœŸå®ç™¾åˆ†æ¯”
 */
function getUserFrequency(category, item) {
    let rawValue;
    let fallbackValue = 15;
    
    if (category === 'rhythm') {
        rawValue = userSettings?.rhythmFrequencies?.[item] ?? getDefaultRhythmFrequency(item);
        fallbackValue = getDefaultRhythmFrequency(item);
    } else if (category === 'articulation') {
        rawValue = userSettings?.articulations?.frequencies?.[item] ?? getDefaultArticulationFrequency(item);
        fallbackValue = getDefaultArticulationFrequency(item);
    } else {
        return fallbackValue; // é»˜è®¤ä¸ºä½é¢‘ç‡
    }

    let normalized = normalizeFrequencyPercentage(rawValue, fallbackValue);
    const currentTimeSignature = typeof window !== 'undefined' ? window.currentTimeSignature : null;
    if (category === 'rhythm' && item.startsWith('dotted-') && currentTimeSignature === '4/4') {
        const dottedGlobal = normalizeFrequencyPercentage(
            userSettings?.rhythmFrequencies?.dotted ?? getDefaultRhythmFrequency('dotted'),
            getDefaultRhythmFrequency('dotted')
        );
        normalized = Math.round((normalized * dottedGlobal) / 100);
    }
    
    return normalized;
}

/**
 * æ˜ å°„å†…éƒ¨durationæ ¼å¼åˆ°ç”¨æˆ·è®¾ç½®é”®
 */
function mapDurationToFrequencyKey(duration) {
    const mapping = {
        'quarter.': 'dotted-quarter',
        'half.': 'dotted-half', 
        'eighth.': 'dotted-eighth'
    };
    return mapping[duration] || duration;
}

/**
 * é‡å»ºçš„æƒé‡é€‰æ‹©ç³»ç»Ÿï¼ˆç”¨äºèŠ‚å¥æ—¶å€¼ï¼‰
 * åŸºäºçœŸå®çš„æ¦‚ç‡åˆ†å¸ƒè€Œéç®€å•çš„æƒé‡æ¯”è¾ƒ
 * ğŸ”¥ é€‚ç”¨äºæ‰€æœ‰æ‹å·ï¼š2/4, 3/4, 4/4, 6/8
 */
function selectDurationByPreciseFrequency(availableDurations, randomGenerator = null) {
    // è®¡ç®—æ¯ä¸ªdurationçš„çœŸå®æƒé‡
    const weightedOptions = availableDurations.map(duration => ({
        duration,
        weight: calculatePreciseRhythmWeight(duration)
    })).filter(option => option.weight > 0); // ç§»é™¤è¢«ç¦ç”¨çš„é€‰é¡¹
    
    if (weightedOptions.length === 0) {
        // æ‰€æœ‰é€‰é¡¹éƒ½è¢«ç¦ç”¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„duration
        console.warn('âš ï¸ æ‰€æœ‰èŠ‚å¥é€‰é¡¹éƒ½è¢«ç”¨æˆ·é¢‘ç‡è®¾ç½®ç¦ç”¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨é€‰é¡¹');
        return availableDurations[0];
    }
    
    // ğŸ”¥ è®¡ç®—ç´¯ç§¯æƒé‡åˆ†å¸ƒï¼Œç¡®ä¿ç²¾ç¡®çš„ç™¾åˆ†æ¯”æ§åˆ¶
    const totalWeight = weightedOptions.reduce((sum, option) => sum + option.weight, 0);
    const random = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    const target = random * totalWeight;
    
    let accumulator = 0;
    for (const option of weightedOptions) {
        accumulator += option.weight;
        if (accumulator >= target) {
            const mappedDuration = mapDurationToFrequencyKey(option.duration);
            const userFreq = getUserFrequency('rhythm', mappedDuration);
            console.log(`ğŸ¯ ç²¾å‡†èŠ‚å¥é€‰æ‹©: ${option.duration} (ç”¨æˆ·é¢‘ç‡: ${userFreq}%, æƒé‡: ${option.weight.toFixed(2)}, æ‹å·æ— å…³)`);
            return option.duration;
        }
    }
    
    // åå¤‡æ–¹æ¡ˆ
    return weightedOptions[weightedOptions.length - 1].duration;
}

/**
 * 6/8æ‹ä¸“ç”¨ï¼šçµæ•çš„é¢‘ç‡è½¬æƒé‡è®¡ç®—å‡½æ•°
 * è§£å†³ä½é¢‘ç‡è®¾ç½®ï¼ˆå¦‚8%ï¼‰æ—¶å…«åˆ†éŸ³ç¬¦ä»å¤§é‡å‡ºç°çš„é—®é¢˜
 */
function calculate68FrequencyWeight(userFrequency, baseWeight = 10, rhythmType = 'unknown') {
    if (userFrequency === undefined) {
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: æ— ç”¨æˆ·è®¾ç½®ï¼Œä½¿ç”¨åŸºç¡€æƒé‡ ${baseWeight}`);
        return baseWeight;
    }
    
    if (userFrequency === 0) {
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: ç”¨æˆ·è®¾ç½®0%ï¼Œæƒé‡=0`);
        return 0;
    }
    
    let finalWeight;
    
    // ğŸ”¥ æ–°çš„çµæ•åº¦ç®—æ³•ï¼šéçº¿æ€§æƒé‡è®¡ç®—
    if (userFrequency <= 15) {
        // æä½é¢‘ç‡(â‰¤15%)ï¼šæŒ‡æ•°è¡°å‡ï¼Œæå¤§æŠ‘åˆ¶
        finalWeight = Math.max(0.1, baseWeight * Math.pow(userFrequency / 100, 2.5));
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: æä½é¢‘ç‡${userFrequency}% -> æŒ‡æ•°æŠ‘åˆ¶ -> æƒé‡=${finalWeight.toFixed(2)}`);
    } else if (userFrequency <= 30) {
        // ä½é¢‘ç‡(16%-30%)ï¼šå¹³æ–¹è¡°å‡ï¼Œå¼ºåŠ›æŠ‘åˆ¶
        finalWeight = baseWeight * Math.pow(userFrequency / 100, 2);
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: ä½é¢‘ç‡${userFrequency}% -> å¹³æ–¹æŠ‘åˆ¶ -> æƒé‡=${finalWeight.toFixed(2)}`);
    } else if (userFrequency <= 60) {
        // ä¸­ç­‰é¢‘ç‡(31%-60%)ï¼šçº¿æ€§ä½†åŠ æƒæŠ‘åˆ¶
        finalWeight = baseWeight * (userFrequency / 100) * 0.8;
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: ä¸­ç­‰é¢‘ç‡${userFrequency}% -> çº¿æ€§æŠ‘åˆ¶ -> æƒé‡=${finalWeight.toFixed(2)}`);
    } else {
        // é«˜é¢‘ç‡(>60%)ï¼šæ¥è¿‘çº¿æ€§ï¼Œè½»å¾®åŠ æƒ
        finalWeight = baseWeight * (userFrequency / 100) * 1.1;
        console.log(`  [6/8é¢‘ç‡è®¡ç®—] ${rhythmType}: é«˜é¢‘ç‡${userFrequency}% -> è½»å¾®åŠ æƒ -> æƒé‡=${finalWeight.toFixed(2)}`);
    }
    
    return Math.round(finalWeight * 10) / 10; // ä¿ç•™ä¸€ä½å°æ•°
}

/**
 * 6/8æ‹ä¸“ç”¨ï¼šçµæ•çš„æ¼”å¥æŠ€å·§é¢‘ç‡æ§åˆ¶å‡½æ•°
 * è§£å†³æ¼”å¥æŠ€å·§ï¼ˆå¦‚acciaccaturaï¼‰é¢‘ç‡è®¾ç½®ä¸å¤Ÿçµæ•çš„é—®é¢˜
 */
function calculate68ArticulationFrequency(userFrequency, articulationType = 'unknown') {
    if (userFrequency === undefined || userFrequency === null) {
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: æ— ç”¨æˆ·è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤é¢‘ç‡ 15%`);
        return 15;
    }
    
    if (userFrequency === 0) {
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: ç”¨æˆ·è®¾ç½®0%ï¼Œå®Œå…¨ç¦ç”¨`);
        return 0;
    }
    
    let finalFrequency;
    
    // ğŸ”¥ æ–°çš„çµæ•åº¦ç®—æ³•ï¼šéçº¿æ€§é¢‘ç‡æ˜ å°„ï¼Œå¢å¼ºä½é¢‘å’Œé«˜é¢‘çš„åŒºåˆ†åº¦
    if (userFrequency <= 15) {
        // æä½é¢‘ç‡(â‰¤15%)ï¼šè½»å¾®å‹ç¼©ï¼Œé¿å…è¿‡äºç¨€å°‘
        finalFrequency = Math.max(3, userFrequency * 0.8);
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: æä½é¢‘ç‡${userFrequency}% -> è½»å¾®å‹ç¼© -> ${finalFrequency.toFixed(1)}%`);
    } else if (userFrequency <= 30) {
        // ä½é¢‘ç‡(16%-30%)ï¼šæ¥è¿‘çº¿æ€§ï¼Œä¿æŒçµæ•åº¦
        finalFrequency = userFrequency * 0.9;
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: ä½é¢‘ç‡${userFrequency}% -> è½»å¾®æŠ‘åˆ¶ -> ${finalFrequency.toFixed(1)}%`);
    } else if (userFrequency <= 60) {
        // ä¸­ç­‰é¢‘ç‡(31%-60%)ï¼šç›´æ¥ä½¿ç”¨ç”¨æˆ·è®¾ç½®
        finalFrequency = userFrequency;
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: ä¸­ç­‰é¢‘ç‡${userFrequency}% -> ç›´æ¥ä½¿ç”¨ -> ${finalFrequency.toFixed(1)}%`);
    } else if (userFrequency <= 80) {
        // é«˜é¢‘ç‡(61%-80%)ï¼šé€‚åº¦å¢å¼º
        finalFrequency = userFrequency * 1.1;
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: é«˜é¢‘ç‡${userFrequency}% -> é€‚åº¦å¢å¼º -> ${finalFrequency.toFixed(1)}%`);
    } else {
        // æé«˜é¢‘ç‡(>80%)ï¼šæ˜¾è‘—å¢å¼ºï¼Œç¡®ä¿æ˜æ˜¾æ•ˆæœ
        finalFrequency = Math.min(95, userFrequency * 1.2);
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: æé«˜é¢‘ç‡${userFrequency}% -> æ˜¾è‘—å¢å¼º -> ${finalFrequency.toFixed(1)}%`);
    }
    
    return Math.round(finalFrequency * 10) / 10; // ä¿ç•™ä¸€ä½å°æ•°
}

/**
 * 6/8æ‹ä¸“ç”¨ï¼šçµæ•çš„æ¼”å¥æŠ€å·§ç”Ÿæˆåˆ¤æ–­å‡½æ•°
 * æ›¿ä»£é€šç”¨çš„shouldGenerateArticulationï¼Œä¸º6/8æ‹æä¾›æ›´çµæ•çš„æ§åˆ¶
 */
function shouldGenerate68Articulation(articulationType, randomGenerator = null) {
    // è·å–åŸå§‹ç”¨æˆ·è®¾ç½®å€¼ï¼ˆä¸ç»è¿‡åˆ†æ¡£æ˜ å°„ï¼‰
    const rawUserFreq = userSettings?.articulations?.frequencies?.[articulationType] ?? 15;
    
    if (rawUserFreq === 0) {
        console.log(`  [6/8æ¼”å¥æŠ€å·§] ${articulationType}: ç”¨æˆ·è®¾ç½®0%ï¼Œå®Œå…¨ç¦ç”¨`);
        return false; // å®Œå…¨ç¦ç”¨
    }
    
    // ä½¿ç”¨6/8æ‹ä¸“ç”¨çš„é¢‘ç‡è®¡ç®—
    const enhancedFreq = calculate68ArticulationFrequency(rawUserFreq, articulationType);
    
    const random = randomGenerator ? randomGenerator.nextFloat() : Math.random();
    const shouldGenerate = (random * 100) < enhancedFreq;
    
    // è¯¦ç»†æ—¥å¿—ç”¨äºè°ƒè¯•
    console.log(`ğŸ¯ 6/8æ‹æ¼”å¥æŠ€å·§æ§åˆ¶ ${articulationType}: ç”¨æˆ·è®¾ç½®${rawUserFreq}% -> å¢å¼ºå${enhancedFreq}% -> ${shouldGenerate ? 'âœ…ç”Ÿæˆ' : 'âŒè·³è¿‡'} (éšæœºå€¼: ${(random * 100).toFixed(1)}%)`);
    
    return shouldGenerate;
}

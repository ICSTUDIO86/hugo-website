<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
<script>
    (function() {
      var isFile = location.protocol === 'file:' || location.origin === 'null';
      if (!isFile) return;
      try {
        console.warn('ğŸš« æ£€æµ‹åˆ°file://åè®®ï¼Œå·²é˜»æ­¢');
      } catch (e) {}
      var html = '<!doctype html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>æ— æ³•ç¦»çº¿ä½¿ç”¨</title><style>body{margin:0;font-family:-apple-system,'Helvetica Neue','PingFang SC','Segoe UI',sans-serif;background:#f5f6f8;color:#111;} .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px;} .card{max-width:560px;background:#fff;border:1px solid #e6e8ec;border-radius:16px;box-shadow:0 20px 40px rgba(0,0,0,.08);padding:28px;} h1{font-size:20px;margin:0 0 12px;} p{margin:0 0 16px;color:#444;line-height:1.6;} a{display:inline-block;background:#1a8cff;color:#fff;text-decoration:none;padding:10px 16px;border-radius:10px;font-weight:600;}</style></head><body><div class="wrap"><div class="card"><h1>âš ï¸ æ— æ³•ç¦»çº¿ä½¿ç”¨</h1><p>ICè§†å¥å·¥å…·éœ€è¦åœ¨çº¿ä½¿ç”¨ä»¥éªŒè¯æˆæƒã€‚</p><p>è¯·è®¿é—®åœ¨çº¿ç‰ˆæœ¬ä»¥è·å¾—å®Œæ•´ä½“éªŒã€‚</p><a href="https://icstudio.club/tools/">è®¿é—®åœ¨çº¿ç‰ˆæœ¬ â†’</a></div></div></body></html>';
      document.open();
      document.write(html);
      document.close();
      throw new Error('file-protocol-blocked');
    })();
  </script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary SEO Meta Tags -->
    <title>Jianpu Sight Reading Generator | Cognote - Professional Music Practice Tool</title>
    <meta name="description" content="Professional online sight reading tool for numbered notation (jianpu) practice. Generate random melodies with the same engine as the staff version, customize range, time signatures, rhythms, and keys. Render clean red-themed jianpu instantly. | ä¸“ä¸šåœ¨çº¿ç®€è°±è§†å¥è®­ç»ƒå·¥å…·ï¼Œå¤ç”¨æ—‹å¾‹ç”Ÿæˆå¼•æ“ï¼Œæ”¯æŒè‡ªå®šä¹‰éŸ³åŸŸã€æ‹å·ã€èŠ‚å¥ã€è°ƒå·ï¼Œçº¢è‰²ä¸»é¢˜çš„ç®€è°±æ¸²æŸ“ã€‚">
    <meta name="keywords" content="jianpu, numbered notation, sight reading, melody generator, sight reading tool, music practice, ç®€è°±, ç®€è°±è§†å¥, è§†å¥å·¥å…·, æ—‹å¾‹ç”Ÿæˆå™¨, è§†å¥è®­ç»ƒ, ä¹è°±ç”Ÿæˆ, éŸ³ä¹ç†è®º, èŠ‚å¥ç»ƒä¹ , å¬åŠ›è®­ç»ƒ, IC è§†å¥å·¥å…·, Cognote">
    <meta name="author" content="Igor Chen - Cognote">
    <link rel="canonical" href="https://icstudio.club/tools/jianpu-generator.html">
    <link rel="icon" type="image/svg+xml" href="assets/icon/cognote.svg">
    <link rel="icon" type="image/png" href="assets/icon/cognote.png">

    <!-- Open Graph / Facebook / WeChat -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://icstudio.club/tools/jianpu-generator.html">
    <meta property="og:title" content="Jianpu Sight Reading Generator | Cognote">
    <meta property="og:description" content="Professional online numbered-notation sight reading tool. Generate random melodies with customizable settings and render them as jianpu. Free 20 trials. | ä¸“ä¸šç®€è°±è§†å¥è®­ç»ƒå·¥å…·ï¼Œéšæœºæ—‹å¾‹ç”Ÿæˆï¼Œçº¢è‰²ä¸»é¢˜çš„ç®€è°±æ¸²æŸ“ã€‚">
    <meta property="og:image" content="https://icstudio.club/images/ICLOGO.png">
    <meta property="og:image:alt" content="Cognote Jianpu Sight Reading Generator Interface">
    <meta property="og:site_name" content="Cognote">
    <meta property="og:locale" content="zh_CN">
    <meta property="og:locale:alternate" content="en_US">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://icstudio.club/tools/jianpu-generator.html">
    <meta name="twitter:title" content="Jianpu Sight Reading Generator | Cognote">
    <meta name="twitter:description" content="Professional numbered-notation sight reading tool for melody practice. Customizable range, rhythms, keys. Piano audio playback.">
    <meta name="twitter:image" content="https://icstudio.club/images/ICLOGO.png">

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Cognote Jianpu Sight Reading Generator",
      "alternateName": ["IC è§†å¥å·¥å…·", "ç®€è°±è§†å¥ç”Ÿæˆå™¨"],
      "description": "Professional online sight reading tool for generating random melodies with customizable parameters including range, time signatures, rhythms, keys, and dynamics, and rendering them as numbered notation (jianpu) with a red theme.",
      "url": "https://icstudio.club/tools/jianpu-generator.html",
      "applicationCategory": "MusicApplication",
      "operatingSystem": "Web Browser",
      "browserRequirements": "Requires JavaScript. HTML5 compatible browser.",
      "offers": {
        "@type": "Offer",
        "price": "30",
        "priceCurrency": "EUR",
        "description": "Full version with unlimited access",
        "availability": "https://schema.org/InStock"
      },
      "featureList": [
        "Random melody generation (shared engine with staff version)",
        "Customizable pitch range (C2-C7)",
        "Multiple time signatures (2/4, 3/4, 4/4, 6/8, etc.)",
        "Rhythm customization (whole notes to sixteenth notes)",
        "Key signature selection (all major and minor keys)",
        "Dynamic markings",
        "Real-time piano audio playback",
        "Professional numbered notation rendering",
        "Treble and bass clef support",
        "Free trial (20 uses)",
        "Downloadable sheet music"
      ],
      "creator": {
        "@type": "Person",
        "name": "Igor Chen",
        "url": "https://icstudio.club"
      },
      "provider": {
        "@type": "Organization",
        "name": "Cognote",
        "url": "https://icstudio.club",
        "logo": "https://icstudio.club/images/ICLOGO.png",
        "sameAs": [
          "https://www.youtube.com/@ICStudio86",
          "https://space.bilibili.com/376362605"
        ]
      },
      "audience": {
        "@type": "EducationalAudience",
        "educationalRole": "music student, piano student, guitar student, music teacher"
      },
      "inLanguage": ["zh-CN", "en-US"],
      "potentialAction": {
        "@type": "UseAction",
        "target": {
          "@type": "EntryPoint",
          "urlTemplate": "https://icstudio.club/tools/jianpu-generator.html"
        }
      }
    }
    </script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com/">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
    <link href="./IC ç®€è°±è§†å¥å·¥å…·_files/css2" rel="stylesheet">
    
    <!-- OpenSheetMusicDisplay -->
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/opensheetmusicdisplay.min.js"></script>

    <!-- Preload simple-notation (å®˜æ–¹æ¨èï¼šCDN ESM)ï¼Œæš´éœ²åˆ° window.SN -->
    <script type="module">
      const cdnUrl = 'https://unpkg.com/simple-notation@latest/dist/simple-notation.js';
      import(cdnUrl)
        .then((SN) => { window.SN = SN; })
        .catch(async (e) => {
          console.warn('simple-notation CDN é¢„åŠ è½½å¤±è´¥ï¼Œå›é€€æœ¬åœ°', e);
          try {
            const SN = await import('./assets/js/simple-notation.js');
            window.SN = SN;
          } catch (err) {
            console.error('simple-notation æœ¬åœ°é¢„åŠ è½½å¤±è´¥', err);
          }
        });
    </script>

    <!-- åˆ é™¤SpessaSynth - æ”¹ç”¨æ›´ç®€å•çš„Web Audio APIæ–¹æ¡ˆ -->

    <link rel="stylesheet" href="./IC ç®€è°±è§†å¥å·¥å…·_files/apple-ui-styles.css">
    <link rel="stylesheet" href="assets/css/midi-input.css">
    <script src="assets/js/sample-player.js?v=6"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function(){
        try {
          if (!window.__icSamplePlayer && window.ICSamplePlayer) {
            window.__icSamplePlayer = new ICSamplePlayer({ rootPath: 'assets/samples/piano-ogg-full' });
            window.__icSamplePlayer.load();
          }
        } catch(e) { console.warn('é‡‡æ ·å™¨åˆå§‹åŒ–å¤±è´¥:', e); }
      });
    </script>
    <!-- Jianpu red theme overrides -->
    <style>
      body.jianpu-theme {
        --primary-blue: #111111;
        --secondary-blue: #333333;
        --accent-green: #111111;
        --accent-orange: #111111;
      }
      body.jianpu-theme .container { border-top: 8px solid rgba(183, 28, 28, 0.6); }
      body.jianpu-theme .header { background: rgba(17, 17, 17, 0.02); }
      body.jianpu-theme .header .header-text h1,
      body.jianpu-theme .header .header-text p { color: #1d1d1f; }
      body.jianpu-theme .function-btn {
        background: #e53935;
        border-color: #e53935;
        box-shadow: 0 3px 10px rgba(229, 57, 53, 0.32);
      }
      body.jianpu-theme .function-btn:hover {
        background: #c62828;
        border-color: #c62828;
        box-shadow: 0 4px 16px rgba(229, 57, 53, 0.4);
      }
      body.jianpu-theme #currentFunction { color: #f66b69; }
      body.jianpu-theme .function-btn:active { background: #b71c1c; }
      body.jianpu-theme .metronome-play-btn {
        background: #e53935;
        color: #ffffff;
      }
      body.jianpu-theme .metronome-play-btn:hover {
        background: #c62828;
      }
      body.jianpu-theme .metronome-play-btn.active {
        background: #f57c00;
      }
      body.jianpu-theme .metronome-pattern-step.beat-start {
        border-color: #e53935;
        color: #e53935;
      }
      body.jianpu-theme .metronome-pattern-step.active {
        background: #e53935;
        border-color: #e53935;
        color: #ffffff;
      }
      body.jianpu-theme .metronome-pattern-step.active.beat-start,
      body.jianpu-theme .metronome-pattern-step.bar-start,
      body.jianpu-theme .metronome-pattern-step.active.bar-start {
        border-color: #e53935;
      }
      body.jianpu-theme .btn-primary {
        background: #e53935;
        border-color: #e53935;
        box-shadow: 0 3px 6px rgba(229, 57, 53, 0.32);
      }
      body.jianpu-theme .btn-primary:hover {
        background: #c62828;
        border-color: #c62828;
        box-shadow: 0 8px 24px rgba(229, 57, 53, 0.35);
      }
      body.jianpu-theme .btn-primary:active {
        box-shadow: 0 4px 16px rgba(229, 57, 53, 0.28);
      }
      body.jianpu-theme .toggle-input:checked + .toggle-slider {
        background: #e53935 !important;
      }
      body.jianpu-theme .toggle-input:checked + .toggle-slider .toggle-button {
        box-shadow: 0 4px 10px rgba(229, 57, 53, 0.35);
      }
      body.jianpu-theme .switch input:checked + .slider {
        background-color: #e53935 !important;
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.04);
      }
      body.jianpu-theme .switch input:focus + .slider {
        box-shadow: 0 0 1px #e53935;
      }
      body.jianpu-theme input[type="radio"]:checked {
        background-color: #e53935;
        border-color: #e53935;
      }
      body.jianpu-theme .function-menu .function-option:hover,
      body.jianpu-theme .function-menu .function-option:focus {
        background: rgba(229, 57, 53, 0.12);
        color: #b71c1c;
      }
      body.jianpu-theme .settings-menu .settings-section-title { color: #b71c1c; }
      body.jianpu-theme .settings-menu .language-option:hover,
      body.jianpu-theme .settings-menu .theme-option:hover {
        background: rgba(229, 57, 53, 0.08);
      }
      body.jianpu-theme input[type="checkbox"],
      body.jianpu-theme .checkbox-item input[type="checkbox"] {
        accent-color: #e53935;
        border-color: rgba(229, 57, 53, 0.6);
      }
      body.jianpu-theme input[type="checkbox"]:checked,
      body.jianpu-theme .checkbox-item input[type="checkbox"]:checked {
        background-color: #e53935;
        border-color: #e53935;
      }
      body.jianpu-theme input[type="radio"],
      body.jianpu-theme .radio-item input[type="radio"] {
        accent-color: #e53935;
      }
      body.jianpu-theme input[type="radio"]:checked,
      body.jianpu-theme .radio-item input[type="radio"]:checked {
        background-color: #e53935;
        border-color: #e53935;
      }
      /* Range sliders (e.g., accidental rate) - only thumb goes red */
      body.jianpu-theme input[type="range"] {
        accent-color: #e53935;
      }
      body.jianpu-theme input[type="range"]::-webkit-slider-thumb {
        background: #ffffff;
        border: 4px solid #e53935;
        box-shadow:
          0 2px 8px rgba(0, 0, 0, 0.08),
          0 4px 16px rgba(229, 57, 53, 0.16);
      }
      body.jianpu-theme input[type="range"]::-moz-range-thumb {
        background: #ffffff;
        border: 2px solid #e53935;
        box-shadow:
          0 2px 8px rgba(0, 0, 0, 0.08),
          0 4px 16px rgba(229, 57, 53, 0.16);
      }
      /* Modal header accent override */
      body.jianpu-theme .modal-header {
        border-top-color: rgba(229, 57, 53, 0.35) !important;
      }
      body.jianpu-theme .modal-header::before {
        background: linear-gradient(90deg, #e53935, #ff6f61) !important;
      }
      body.jianpu-theme .modal-content {
        border-top: 6px solid rgba(229, 57, 53, 0.24);
        box-shadow: 0 16px 48px rgba(229, 57, 53, 0.12);
      }
      body.jianpu-theme .modal-content h3,
      body.jianpu-theme .modal-content .modal-title,
      body.jianpu-theme .modal-content label,
      body.jianpu-theme .modal-content span,
      body.jianpu-theme .modal-content p { color: #1d1d1f !important; }
      body.jianpu-theme .modal-buttons .btn-secondary:hover {
        border-color: rgba(229, 57, 53, 0.35) !important;
        color: #b71c1c !important;
      }
      body.jianpu-theme #score {
        border-color: rgba(0, 0, 0, 0.12);
        display: flex;
        justify-content: center;
        align-items: flex-start;
      }
      body.jianpu-theme #score > svg {
        margin: 0 auto;
        display: block;
      }
      /* Hide clef and notation toggles in Jianpu mode */
      body.jianpu-theme .control-group.clef-group,
      body.jianpu-theme .control-group.notation-toggle-group {
        display: none !important;
      }
      /* Jianpu visual layer */
      .jianpu-score {
        background: var(--neutral-white);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 16px;
        padding: 18px 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        color: #111111;
      }
      .jianpu-topline {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #111111;
        margin-bottom: 8px;
        gap: 8px;
        flex-wrap: wrap;
      }
      .jianpu-topline .badge {
        background: rgba(0, 0, 0, 0.06);
        color: #111111;
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 13px;
      }
      .jianpu-staff {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        grid-template-columns: repeat(4, minmax(120px, 1fr));
      }
      .jianpu-measure {
        background: rgba(0, 0, 0, 0.02);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        gap: 10px;
        position: relative;
      }
      .jianpu-measure::after {
        content: '';
        position: absolute;
        right: 6px;
        top: 8px;
        bottom: 8px;
        width: 2px;
        background: rgba(0, 0, 0, 0.15);
        border-radius: 1px;
      }
      .jianpu-note {
        position: relative;
        min-width: 34px;
        text-align: center;
        color: #111111;
        font-weight: 700;
        padding: 4px 2px 2px;
        line-height: 1.1;
      }
      .jianpu-note .note-body {
        position: relative;
        font-size: 24px;
        display: inline-block;
        padding: 2px 6px;
      }
      .jianpu-note .duration-mark {
        position: absolute;
        pointer-events: none;
      }
      .jianpu-note.whole .duration-mark {
        left: 6px;
        right: 6px;
        top: -12px;
        height: 12px;
        border-top: 2px solid currentColor;
        border-bottom: 2px solid currentColor;
      }
      .jianpu-note.half .duration-mark {
        left: 8px;
        right: 8px;
        top: -10px;
        border-top: 2px solid currentColor;
      }
      .jianpu-note.eighth .duration-mark,
      .jianpu-note.sixteenth .duration-mark {
        right: -4px;
        top: 12px;
        width: 14px;
        height: 14px;
        border-right: 2px solid currentColor;
        transform: skew(-15deg);
        border-radius: 8px;
      }
      .jianpu-note.sixteenth .duration-mark {
        box-shadow: -4px -6px 0 0 currentColor;
      }
      .jianpu-note.is-dotted .note-body::after {
        content: 'â€¢';
        position: absolute;
        right: -10px;
        top: 6px;
        font-size: 12px;
        color: currentColor;
      }
      .jianpu-note.rest {
        color: #333333;
        font-weight: 600;
        opacity: 0.9;
      }
      .jianpu-note .english-hint {
        display: block;
        font-size: 12px;
        color: #8c1d18;
        margin-top: 4px;
        letter-spacing: 0.02em;
      }
      /* simple-notation é¢œè‰²ä¸ä¿¡æ¯æ˜¾ç¤ºè°ƒæ•´ */
      .sn-score text,
      .sn-score .note-text,
      .sn-score .lyric-text,
      .sn-score .info,
      .sn-score .sn-note text,
      .sn-score .sn-rest text {
        fill: #111111 !important;
        color: #111111 !important;
      }
      #score svg text { fill: #111111 !important; color: #111111 !important; }
      /* çº¿æ¡/å»¶éŸ³ä¿æŒå¯è§ï¼Œç»Ÿä¸€æ”¹ä¸ºæ·±è‰² */
      #score svg path,
      #score svg line,
      #score svg rect {
        stroke: #111111 !important;
        fill: transparent;
      }
      /* ç¡¬è¦†ç›–æ‰€æœ‰ SVG èŠ‚ç‚¹é¢œè‰²ï¼Œæ¶ˆé™¤æ®‹ç•™çº¢è‰² */
      #score svg * {
        color: #111111 !important;
        fill: #111111 !important;
        stroke: #111111 !important;
      }
      #score svg #challengeOverlayG #challengeCursor {
        fill: rgba(229,57,53,0.25) !important;
        stroke: rgba(229,57,53,0.45) !important;
      }
      /* éšè— tempo æ˜¾ç¤º */
      .sn-score .info tspan:has(> .sn-tempo),
      .sn-score .info .sn-tempo {
        display: none;
      }
      /* å¦‚æœ info ç»„ä»¶ä½¿ç”¨ class è€ŒéåµŒå¥— tspanï¼Œå…œåº•éšè—åŒ…å« BPM çš„ç‰‡æ®µ */
      .sn-score .info tspan {
        unicode-bidi: plaintext;
      }
    @media (max-width: 599px) {
        .jianpu-note .note-body { font-size: 20px; }
        .jianpu-staff { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
      }
    </style>
    <!-- Prefetch sibling tools to reduce switch latency -->
    <link rel="prefetch" href="melody-generator.html">
    <link rel="prefetch" href="interval-generator.html">
    <link rel="prefetch" href="chord-generator.html">
    <script src="https://cdn.jsdelivr.net/npm/ml5@1/dist/ml5.min.js"></script>
</head>
<body class="jianpu-theme">
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-text">
                    <h1 data-i18n="app.title">Cognote - ç®€è°±è§†å¥ç”Ÿæˆå™¨</h1>
                    <p data-i18n="app.subtitle">ä¸“ä¸šçº§ä¹è°±æ¸²æŸ“ä¸éŸ³ä¹ç†è®ºå·¥å…·</p>
                </div>
                <div class="header-controls">
                    <div class="function-selector">
                        <button class="function-btn" id="functionBtn" onclick="toggleFunctionSelector()">
                            ğŸ”¢ <span id="currentFunction" data-i18n="app.jianpuMode">ç®€è°±è§†å¥</span>
                        </button>
                        <div class="function-menu" id="functionMenu">
                            <div class="function-option" onclick="switchFunction('melody')">
                                <span class="function-icon">ğŸµ</span>
                                <span data-i18n="app.melodyMode">æ—‹å¾‹è§†å¥</span>
                            </div>
                            <div class="function-option" onclick="switchFunction('jianpu')">
                                <span class="function-icon">ğŸ”¢</span>
                                <span data-i18n="app.jianpuMode">ç®€è°±è§†å¥</span>
                            </div>
                            <div class="function-option" onclick="switchFunction('interval')">
                                <span class="function-icon">ğŸ¼</span>
                                <span data-i18n="app.intervalMode">éŸ³ç¨‹è§†å¥</span>
                            </div>
                            <div class="function-option" onclick="switchFunction('chord')">
                                <span class="function-icon">ğŸ¹</span>
                                <span data-i18n="app.chordMode">å’Œå¼¦è§†å¥</span>
                            </div>
                            <div class="function-option" onclick="switchFunction('rhythm')">
                                <span class="function-icon">ğŸ¥</span>
                                <span data-i18n="app.rhythmMode">èŠ‚å¥è§†å¥</span>
                            </div>
                        </div>
                    </div>
                    <div class="settings-dropdown">
                        <button class="settings-btn" id="settingsBtn" onclick="toggleSettings()">
                            âš™ï¸ <span data-i18n="settings.title">è®¾ç½®</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label data-i18n="controls.interval">éŸ³ç¨‹è·¨åº¦</label>
                    <button class="btn-secondary" onclick="openIntervalSettings()" id="intervalSettingsBtn" data-i18n="controls.intervalSettings">éŸ³ç¨‹è®¾ç½®</button>
                </div>

                <div class="control-group">
                    <label data-i18n="controls.measures">å°èŠ‚æ•°</label>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="measures-2" name="measures" value="2">
                            <label for="measures-2" data-i18n="controls.measures2">2å°èŠ‚</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="measures-4" name="measures" value="4" checked="">
                            <label for="measures-4" data-i18n="controls.measures4">4å°èŠ‚</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="measures-8" name="measures" value="8">
                            <label for="measures-8" data-i18n="controls.measures8">8å°èŠ‚</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label data-i18n="controls.key">è°ƒå·</label>
                    <button class="btn-secondary" onclick="openKeySettings()" id="keySettingsBtn" data-i18n="controls.keySettings">è°ƒå·è®¾ç½®</button>
                </div>

                <div class="control-group">
                    <label data-i18n="controls.time">æ‹å·</label>
                    <button class="btn-secondary" onclick="openTimeSignatureSettings()" id="timeSignatureSettingsBtn" data-i18n="controls.timeSettings">æ‹å·è®¾ç½®</button>
                </div>

                <div class="control-group clef-group">
                    <label data-i18n="controls.clef">è°±å·</label>
                    <button class="btn-secondary" onclick="openClefSettings()" id="clefSettingsBtn" data-i18n="controls.clefSettings">è°±å·è®¾ç½®</button>
                </div>

                <!-- æ¨¡å¼åˆ‡æ¢ï¼ˆè‡ªç”±/æŒ‘æˆ˜ï¼‰ -->
                <div class="control-group">
                    <label data-i18n="controls.mode">æ¨¡å¼</label>
                    <div class="mode-toggle" style="display: flex; align-items: center; gap: 10px;">
                        <span id="modeLabelFree" data-i18n="mode.free" style="font-size: 14px; opacity: 0.8;">è‡ªç”±</span>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeModeToggle" style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                        <span id="modeLabelChallenge" data-i18n="mode.challenge" style="font-size: 14px; opacity: 0.8;">æŒ‘æˆ˜</span>
                    </div>
                </div>
            </div>

            <!-- æ–°å¢ï¼šéŸ³åŸŸè®¾ç½® -->
            <div class="control-row">
                <div class="control-group">
                    <label for="rangeMin" data-i18n="controls.rangeMin">æœ€ä½éŸ³</label>
                    <select id="rangeMin">
                        <option value="33">A1</option>
                        <option value="35">B1</option>
                        <option value="36">C2</option>
                        <option value="38">D2</option>
                        <option value="40">E2</option>
                        <option value="41">F2</option>
                        <option value="43">G2</option>
                        <option value="45">A2</option>
                        <option value="47">B2</option>
                        <option value="48">C3</option>
                        <option value="50">D3</option>
                        <option value="52">E3</option>
                        <option value="53">F3</option>
                        <option value="55">G3</option>
                        <option value="57">A3</option>
                        <option value="59">B3</option>
                        <option value="60" selected="">C4</option>
                        <option value="62">D4</option>
                        <option value="64">E4</option>
                        <option value="65">F4</option>
                        <option value="67">G4</option>
                        <option value="69">A4</option>
                        <option value="71">B4</option>
                        <option value="72">C5</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="rangeMax" data-i18n="controls.rangeMax">æœ€é«˜éŸ³</label>
                    <select id="rangeMax">
                        <option value="48">C3</option>
                        <option value="50">D3</option>
                        <option value="52">E3</option>
                        <option value="53">F3</option>
                        <option value="55">G3</option>
                        <option value="57">A3</option>
                        <option value="59">B3</option>
                        <option value="60">C4</option>
                        <option value="62">D4</option>
                        <option value="64">E4</option>
                        <option value="65">F4</option>
                        <option value="67">G4</option>
                        <option value="69">A4</option>
                        <option value="71">B4</option>
                        <option value="72">C5</option>
                        <option value="74">D5</option>
                        <option value="76">E5</option>
                        <option value="77">F5</option>
                        <option value="79" selected="">G5</option>
                        <option value="81">A5</option>
                        <option value="82">B5</option>
                        <option value="83">C6</option>
                        <option value="84">D6</option>
                        <option value="85">E6</option>
                    </select>
                </div>

                <div class="control-group notation-toggle-group" style="flex: none; width: 140px; margin-right: 4px;">
                    <label data-i18n="controls.jianpu">ç®€è°±</label>
                    <div class="toggle-container">
                        <input type="checkbox" id="jianpuToggle" class="toggle-input" checked="">
                        <label for="jianpuToggle" class="toggle-slider">
                            <span class="toggle-button"></span>
                        </label>
                    </div>
                </div>

                <div class="control-group notation-toggle-group" style="flex: none; width: 140px; margin-right: 0px;">
                    <label data-i18n="controls.englishNames">éŸ³å</label>
                    <div class="toggle-container">
                        <input type="checkbox" id="englishNameToggle" class="toggle-input">
                        <label for="englishNameToggle" class="toggle-slider">
                            <span class="toggle-button"></span>
                        </label>
                    </div>
                </div>

                <div class="control-group" style="flex: none; width: 140px;">
                    <label for="accidentalRate" data-i18n="controls.accidental">ä¸´æ—¶è®°å·</label>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="range" id="accidentalRate" min="0" max="100" value="0" step="10" style="width: 90px;">
                        <span id="accidentalRateValue" style="font-weight: 400; min-width: 30px;">0%</span>
                    </div>
                </div>

                <div class="control-group metronome-group" style="flex: none; width: 160px;">
                    <div class="metronome-label-row">
                        <button class="metronome-settings-btn" id="metronomePatternBtn" onclick="openMetronomePatternSettings()" title="èŠ‚æ‹å™¨èŠ‚å¥è®¾ç½®" aria-label="èŠ‚æ‹å™¨èŠ‚å¥è®¾ç½®">
                            âš™ï¸
                        </button>
                        <label for="headerMetronomeBpm" data-i18n="controls.metronome">èŠ‚æ‹å™¨</label>
                    </div>
                    <div class="metronome-control">
                        <input type="number" id="headerMetronomeBpm" min="1" max="999" value="60" class="bpm-input-control">
                        <button class="metronome-play-btn" id="headerMetronomeBtn" onclick="toggleMetronome()" title="å¼€å§‹/åœæ­¢èŠ‚æ‹å™¨">
                            ğŸµ
                        </button>
                        <div class="metronome-beat-indicator" id="headerBeatIndicator"></div>
                    </div>
                </div>
            </div>

            <div class="control-row">
                <div class="buttons">
                    <div id="challengeCountdownUI" style="display:none; align-items: center; gap:6px; margin-right:10px; padding:6px 10px; border:1px solid var(--border-color); border-radius:999px; background: var(--neutral-white); color: var(--text-color); font-size:14px; line-height:1;">
                        <span id="challengeCountdownLabel" data-i18n="challenge.preparingLabel" style="opacity:0.7;">å‡†å¤‡</span>
                        <strong id="challengeCountdownValue">10</strong>
                        <span data-i18n="challenge.seconds" style="opacity:0.7;">ç§’</span>
                    </div>
                    <button class="btn-primary" onclick="generateMelody()" data-i18n="controls.generate">ç”Ÿæˆæ—‹å¾‹</button>
                    <div class="button-group">
                        <button class="btn-secondary" onclick="previousMelody()" data-i18n="controls.previous">ä¸Šä¸€æ¡</button>
                        <button class="btn-secondary" onclick="nextMelody()" data-i18n="controls.next">ä¸‹ä¸€æ¡</button>
                    </div>
                        <div class="button-group">
                            <button class="btn-secondary" id="playMelodyBtn" onclick="directPlayTest()" data-i18n="controls.play">æ’­æ”¾</button>
                            <button class="melody-visibility-btn" id="melodyVisibilityBtn" onclick="toggleMelodyVisibility()" title="éšè—/æ˜¾ç¤ºæ—‹å¾‹">
                                ğŸ‘€
                            </button>
                            
                        </div>
                    <div class="button-group">
                        <button class="btn-secondary" onclick="openRhythmSettings()" data-i18n="controls.rhythm">èŠ‚å¥è®¾ç½®</button>
                        <button class="btn-secondary" onclick="openArticulationSettings()" data-i18n="controls.articulation" style="display:none;">æ¼”å¥æŠ€å·§</button>
                    </div>
                    <div class="practice-counter">
                        <label for="practiceCountValue" data-i18n="controls.practiceCounter">ç»ƒä¹ è®¡æ•°</label>
                        <div class="practice-counter-actions">
                            <span id="practiceCountValue">0</span>
                            <button class="btn-secondary" id="practiceCountBtn" onclick="incrementPracticeCount()" data-i18n="controls.practiceAdd">+</button>
                            <button class="btn-secondary" id="practiceResetBtn" onclick="decrementPracticeCount()" data-i18n="controls.practiceReset">-</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="score-container">
            <div id="score" title="ç‚¹å‡»ç”Ÿæˆæ–°æ—‹å¾‹" style="cursor: pointer; position: relative;">
                <div class="empty-score-message" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center;">
                    <p data-i18n="score.empty" style="margin:0; text-align:center;">ç‚¹å‡»ç”Ÿæˆæ—‹å¾‹å¼€å§‹ç»ƒä¹ </p>
                </div>
            </div>
        </div>
        
        <!-- Copyright Information -->
        <div style="
            padding: 5px 0;
            text-align: center;
            font-size: 14px;
            color: var(--neutral-dark);
            opacity: 0.7;
            border-top: 1px solid var(--border-color);
            margin-top: 7.5px;
        ">
            <p style="margin: 0; line-height: 1.5;">
                <strong>Cognote</strong> - ä¸“ä¸šçº§è§†å¥æ—‹å¾‹ç”Ÿæˆå™¨
            </p>
            <p style="margin: 8px 0 0 0; font-size: 13px; opacity: 0.8;">
                Copyright Â© 2026. All rights reserved. Igor Chen - 
                <a href="https://icstudio.club/" target="_blank" style="color: var(--primary-blue); text-decoration: none;">icstudio.club</a>
            </p>
        </div>

    </div>

    <!-- èŠ‚å¥è®¾ç½®å¼¹çª— -->
    <!-- æŒ‘æˆ˜æ¨¡å¼å¼¹çª— -->
    <div id="challengeModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">
                <h3 data-i18n="modal.challenge.title">æŒ‘æˆ˜æ¨¡å¼</h3>
                <button class="close-btn" onclick="closeChallengeModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="control-row" style="margin-top: 8px;">
                    <div class="control-group">
                        <label for="challengeModeToggleModal" data-i18n="challenge.modeToggle">æŒ‘æˆ˜æ¨¡å¼</label>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeModeToggleModal" style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                    </div>
                    <div class="control-group">
                        <label for="challengeCalibrationToggle" data-i18n="challenge.calibration">è¾“å…¥æ ¡å‡†</label>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeCalibrationToggle" style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                    </div>
                </div>
                <div class="control-row" style="margin-top: 8px;">
                    <div class="control-group">
                        <label for="challengePrepTime" data-i18n="challenge.prepTime">å‡†å¤‡æ—¶é—´ï¼ˆç§’ï¼‰</label>
                        <input type="number" id="challengePrepTime" min="0" max="60" step="1" value="10" style="width: 120px; padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--neutral-white); color: var(--text-color);">
                    </div>
                    <div class="control-group">
                        <label for="challengeBPM" data-i18n="challenge.bpm">BPM</label>
                        <input type="number" id="challengeBPM" min="40" max="240" step="1" value="80" style="width: 120px; padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--neutral-white); color: var(--text-color);">
                    </div>
                </div>
                <div class="control-row" style="margin-top: 12px;">
                    <div class="control-group">
                        <label for="challengeCursorToggle" data-i18n="challenge.cursor">å…‰æ ‡</label>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeCursorToggle" checked style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                    </div>
                    <div class="control-group">
                        <label for="challengeMetronomeToggle" data-i18n="challenge.metronome">èŠ‚æ‹å™¨</label>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeMetronomeToggle" checked style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                    </div>
                    <div class="control-group">
                        <label for="challengeHideToggle" data-i18n="challenge.hide">éšè—</label>
                        <label class="switch" style="position: relative; display: inline-block; width: 60px; height: 34px;">
                            <input type="checkbox" id="challengeHideToggle" style="opacity: 0; width: 0; height: 0;">
                            <span class="slider" style="position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: 0.4s; border-radius: 34px;">
                                <span class="slider-button" style="position: absolute; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%; transform: translateX(0px);"></span>
                            </span>
                        </label>
                    </div>
                </div>
                <p class="modal-hint">
                    <span data-i18n="challenge.cursorHint">å…‰æ ‡å¼€å…³ï¼šå…‰æ ‡ç”¨äºæç¤ºå½“å‰åº”æ¼”å¥çš„ä½ç½®ï¼Œcount-inç»“æŸåå‡ºç°å¹¶éšæ—‹å¾‹è·³åŠ¨ã€‚</span>
                    <span data-i18n="challenge.hideHint" style="display: block; margin-top: 6px;">éšè—å¼€å…³ï¼šå¼€å¯åï¼Œç³»ç»Ÿåœ¨è¿›å…¥ä¸‹ä¸€å°èŠ‚æ—¶ä¼šè‡ªåŠ¨é®æŒ¡ä¸Šä¸€å°èŠ‚ï¼Œä»…ä¿ç•™å½“å‰é˜…è¯»åŒºã€‚</span>
                </p>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="cancelChallengeSetup()" data-i18n="button.cancel">å–æ¶ˆ</button>
                <button class="btn-primary" onclick="confirmChallengeSetup()" data-i18n="button.start">å¼€å§‹</button>
            </div>
        </div>
    </div>

    <div id="metronomePatternModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.metronomePattern.title">èŠ‚æ‹å™¨èŠ‚å¥å‹</h3>
                <button class="close-btn" onclick="closeMetronomePatternSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="metronome-pattern-row">
                    <div class="control-group metronome-pattern-toggle-group" style="flex: 1; min-width: 160px;">
                        <div class="toggle-container">
                            <input type="checkbox" id="metronomePatternEnable" class="toggle-input">
                            <label for="metronomePatternEnable" class="toggle-slider">
                                <span class="toggle-button"></span>
                            </label>
                        </div>
                        <label for="metronomePatternEnable" data-i18n="metronomePattern.enable">å¯ç”¨è‡ªå®šä¹‰èŠ‚å¥</label>
                    </div>
                    <div class="control-group" style="flex: 1; min-width: 180px;">
                        <label data-i18n="metronomePattern.subdivision">ç»†åˆ†</label>
                        <select id="metronomePatternSubdivision" class="metronome-pattern-select">
                            <option value="1" data-i18n="metronomePattern.subdivision.beat">æ¯æ‹1ä¸‹</option>
                            <option value="2" data-i18n="metronomePattern.subdivision.eighth">æ¯æ‹2åˆ† (å…«åˆ†)</option>
                            <option value="3" data-i18n="metronomePattern.subdivision.triplet">æ¯æ‹3åˆ† (ä¸‰è¿)</option>
                            <option value="4" data-i18n="metronomePattern.subdivision.sixteenth">æ¯æ‹4åˆ† (åå…­åˆ†)</option>
                        </select>
                    </div>
                    <div class="control-group" style="flex: 1; min-width: 140px;">
                        <label data-i18n="metronomePattern.bars">å°èŠ‚æ•°</label>
                        <select id="metronomePatternBars" class="metronome-pattern-select">
                            <option value="1" data-i18n="metronomePattern.bars.1">1å°èŠ‚</option>
                            <option value="2" data-i18n="metronomePattern.bars.2">2å°èŠ‚</option>
                            <option value="4" data-i18n="metronomePattern.bars.4">4å°èŠ‚</option>
                        </select>
                    </div>
                    <div class="metronome-pattern-info">
                        <span data-i18n="metronomePattern.timeSig">å½“å‰æ‹å·</span>
                        <strong id="metronomePatternTimeSig">4/4</strong>
                    </div>
                </div>

                <div class="metronome-pattern-grid" id="metronomePatternGrid"></div>
                <p class="modal-hint" data-i18n="metronomePattern.hint">ç‚¹å‡»æ–¹æ ¼å¯ç”¨/é™éŸ³èŠ‚æ‹</p>

                <div class="modal-buttons">
                    <button class="btn-secondary" onclick="resetMetronomePattern()" data-i18n="metronomePattern.resetBeats">é‡ç½®ä¸ºæ¯æ‹</button>
                    <button class="btn-secondary" onclick="clearMetronomePattern()" data-i18n="metronomePattern.clear">å…¨éƒ¨é™éŸ³</button>
                    <button class="btn-primary" onclick="saveMetronomePatternSettingsAndClose()" data-i18n="button.saveOnly">ä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="settings.title">è®¾ç½®</h3>
                <button class="close-btn" onclick="closeSettingsModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="settings-menu show" id="settingsMenu" style="position: static; opacity: 1; visibility: visible; transform: none; box-shadow: none; border: 0; min-width: 0; background: transparent;">
                    <!-- ä¸»é¢˜è®¾ç½® -->
                    <div class="settings-section">
                        <div class="settings-section-title" data-i18n="settings.theme">ä¸»é¢˜</div>
                        <div class="theme-options">
                            <div class="theme-option" onclick="setTheme('light')">
                                <span class="theme-icon">â˜€ï¸</span>
                                <span data-i18n="settings.lightMode">æµ…è‰²æ¨¡å¼</span>
                            </div>
                            <div class="theme-option" onclick="setTheme('dark')">
                                <span class="theme-icon">ğŸŒ™</span>
                                <span data-i18n="settings.darkMode">æ·±è‰²æ¨¡å¼</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- è¯­è¨€è®¾ç½® -->
                    <div class="settings-section">
                        <div class="settings-section-title" data-i18n="settings.language">è¯­è¨€</div>
                        <div class="language-options">
                            <div class="language-option" onclick="switchLanguage('zh-CN')">
                                ç®€ä½“ä¸­æ–‡
                            </div>
                            <div class="language-option" onclick="switchLanguage('zh-TW')">
                                ç¹é«”ä¸­æ–‡
                            </div>
                            <div class="language-option" onclick="switchLanguage('en')">
                                English
                            </div>
                        </div>
                    </div>

                    <!-- MIDI è¾“å…¥ -->
                    <div class="settings-section" id="midiSettingsSection">
                        <div class="settings-section-title" data-i18n="settings.midi">MIDI è¾“å…¥</div>
                        <div class="midi-settings-row">
                            <span data-i18n="midi.enable">å¯ç”¨</span>
                            <label class="toggle-container">
                                <input type="checkbox" id="midiEnableToggle" class="toggle-input">
                                <span class="toggle-slider"><span class="toggle-button"></span></span>
                            </label>
                        </div>
                        <div class="midi-settings-row" style="flex-direction: column; align-items: stretch;">
                            <label for="midiDeviceSelect" data-i18n="midi.device">è®¾å¤‡</label>
                            <select id="midiDeviceSelect" class="midi-select" disabled>
                                <option value="">-</option>
                            </select>
                        </div>
                        <div class="midi-status" id="midiStatusText" data-i18n="midi.status.disabled">MIDI å·²å…³é—­</div>
                    </div>
                    <!-- éº¦å…‹é£è¾“å…¥ -->
                    <div class="settings-section" id="micSettingsSection">
                        <div class="settings-section-title" data-i18n="settings.mic">éº¦å…‹é£è¾“å…¥</div>
                        <div class="midi-settings-row">
                            <span data-i18n="mic.enable">å¯ç”¨</span>
                            <label class="toggle-container">
                                <input type="checkbox" id="micEnableToggle" class="toggle-input">
                                <span class="toggle-slider"><span class="toggle-button"></span></span>
                            </label>
                        </div>
                        <div class="midi-settings-row" style="flex-direction: column; align-items: stretch;">
                            <label for="micDeviceSelect" data-i18n="mic.device">è®¾å¤‡</label>
                            <select id="micDeviceSelect" class="midi-select" disabled>
                                <option value="">-</option>
                            </select>
                        </div>
                        <div class="midi-status" id="micStatusText" data-i18n="mic.status.disabled">éº¦å…‹é£å·²å…³é—­</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="rhythmModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.rhythm.title">èŠ‚å¥è®¾ç½®</h3>
                <button class="close-btn" onclick="closeRhythmSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="modal.rhythm.basicUnit">åŸºæœ¬èŠ‚å¥å•ä½</h4>
                        <button class="btn-select-all" onclick="selectAllRhythms()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAll">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item" id="rhythm-whole-label">
                            <input type="checkbox" id="rhythm-whole" value="whole">
                            <span data-i18n="rhythm.whole">å…¨éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-dotted-half-label" style="display: none;">
                            <input type="checkbox" id="rhythm-dotted-half" value="half.">
                            <span data-i18n="rhythm.dottedHalf">é™„ç‚¹äºŒåˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-half-label">
                            <input type="checkbox" id="rhythm-half" value="half" checked="">
                            <span data-i18n="rhythm.half">äºŒåˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-dotted-quarter-label" style="display: none;">
                            <input type="checkbox" id="rhythm-dotted-quarter" value="quarter.">
                            <span data-i18n="rhythm.dottedQuarter">é™„ç‚¹å››åˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="rhythm-quarter" value="quarter" checked="">
                            <span data-i18n="rhythm.quarter">å››åˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="rhythm-eighth" value="eighth" checked="">
                            <span data-i18n="rhythm.eighth">å…«åˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="rhythm-16th" value="16th">
                            <span data-i18n="rhythm.sixteenth">åå…­åˆ†éŸ³ç¬¦</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-triplet-label" style="display: flex;">
                            <input type="checkbox" id="rhythm-triplet" value="triplet">
                            <span data-i18n="rhythm.triplet">ä¸‰è¿éŸ³</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-duplet-label" style="display: none;">
                            <input type="checkbox" id="rhythm-duplet" value="duplet">
                            <span data-i18n="rhythm.duplet">äºŒè¿éŸ³</span>
                        </label>
                        <label class="checkbox-item" id="rhythm-quadruplet-label" style="display: none;">
                            <input type="checkbox" id="rhythm-quadruplet" value="quadruplet">
                            <span data-i18n="rhythm.quadruplet">å››è¿éŸ³</span>
                        </label>
                    </div>
                </div>

                <!-- ğŸ”¥ é€šç”¨é™„ç‚¹éŸ³ç¬¦é€‰é¡¹ -->
                <div class="rhythm-section" id="dottedOptionsSection" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--info-border);">
                    <h4 style="margin-bottom: 15px;" data-i18n="rhythm.dottedOptions">é™„ç‚¹éŸ³ç¬¦é€‰é¡¹</h4>
                    <div style="background: var(--info-bg); padding: 15px; border-radius: 8px;">
                        <label class="checkbox-item" style="margin-bottom: 10px;">
                            <input type="checkbox" id="allowDottedNotes" value="dotted" checked>
                            <span data-i18n="rhythm.allowDotted">å…è®¸é™„ç‚¹éŸ³ç¬¦ (æ ¹æ®å·²é€‰èŠ‚å¥è‡ªåŠ¨ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬)</span>
                        </label>
                        <p style="font-size: 0.85rem; color: var(--secondary-text); margin: 0; line-height: 1.4;">
                            <span data-i18n="rhythm.dottedDesc">å‹¾é€‰åå°†è‡ªåŠ¨ä¸ºå·²é€‰æ‹©çš„èŠ‚å¥ç±»å‹ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬</span><br>
                            <span data-i18n="rhythm.dottedExample">ä¾‹å¦‚ï¼šå‹¾é€‰å››åˆ†éŸ³ç¬¦+é™„ç‚¹éŸ³ç¬¦ â†’ å¯ç”Ÿæˆå››åˆ†éŸ³ç¬¦å’Œé™„ç‚¹å››åˆ†éŸ³ç¬¦</span>
                        </p>
                    </div>
                </div>

                <!-- é«˜çº§è®¾ç½®åŒºåŸŸ -->
                <div id="rhythmAdvancedSettings" style="display: none; margin-top: 20px; padding: 20px; background: var(--info-bg); border-radius: 8px; border: 2px solid var(--info-border);">
                    <h4 style="margin-bottom: 15px; color: var(--heading-text);" data-i18n="rhythm.advancedFreq">é«˜çº§é¢‘ç‡è®¾ç½®</h4>
                    <p style="font-size: 0.9rem; color: var(--secondary-text); margin-bottom: 20px;" data-i18n="rhythm.freqDesc">è°ƒæ•´å„èŠ‚å¥å•ä½åœ¨æ—‹å¾‹ä¸­çš„å‡ºç°é¢‘ç‡ (0% = ä¸ä½¿ç”¨, 100% = ä¼˜å…ˆä½¿ç”¨)</p>
                    
                    <div class="rhythm-frequency-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="frequency-item" id="freq-dotted-item">
                            <label for="freq-dotted" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.dottedOverall">é™„ç‚¹éŸ³ç¬¦æ€»ä½“é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-dotted" min="0" max="100" value="20" style="flex: 1;">
                                <span id="freq-dotted-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">20%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-whole-item">
                            <label for="freq-whole" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.whole">å…¨éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-whole" min="0" max="100" value="20" style="flex: 1;">
                                <span id="freq-whole-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">20%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-dotted-half-item" style="display: none;">
                            <label for="freq-dotted-half" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.dottedHalf">é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-dotted-half" min="0" max="100" value="12" style="flex: 1;">
                                <span id="freq-dotted-half-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">12%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-half-item">
                            <label for="freq-half" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.half">äºŒåˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-half" min="0" max="100" value="8" style="flex: 1;">
                                <span id="freq-half-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">8%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-dotted-quarter-item" style="display: none;">
                            <label for="freq-dotted-quarter" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.dottedQuarter">é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-dotted-quarter" min="0" max="100" value="60" style="flex: 1;">
                                <span id="freq-dotted-quarter-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">60%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-dotted-eighth-item" style="display: none;">
                            <label for="freq-dotted-eighth" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.dottedEighth">é™„ç‚¹å…«åˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-dotted-eighth" min="0" max="100" value="25" style="flex: 1;">
                                <span id="freq-dotted-eighth-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">25%</span>
                            </div>
                        </div>
                        <div class="frequency-item">
                            <label for="freq-quarter" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.quarter">å››åˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-quarter" min="0" max="100" value="25" style="flex: 1;">
                                <span id="freq-quarter-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">25%</span>
                            </div>
                        </div>
                        <div class="frequency-item">
                            <label for="freq-eighth" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.eighth">å…«åˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-eighth" min="0" max="100" value="15" style="flex: 1;">
                                <span id="freq-eighth-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">15%</span>
                            </div>
                        </div>
                        <div class="frequency-item">
                            <label for="freq-16th" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.sixteenth">åå…­åˆ†éŸ³ç¬¦é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-16th" min="0" max="100" value="6" style="flex: 1;">
                                <span id="freq-16th-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">6%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-triplet-item">
                            <label for="freq-triplet" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="rhythm.freq.triplet">ä¸‰è¿éŸ³é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-triplet" min="0" max="100" value="15" style="flex: 1;">
                                <span id="freq-triplet-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">15%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-duplet-item" style="display: none;">
                            <label for="freq-duplet" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;">äºŒè¿éŸ³é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-duplet" min="0" max="100" value="25" style="flex: 1;">
                                <span id="freq-duplet-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">25%</span>
                            </div>
                        </div>
                        <div class="frequency-item" id="freq-quadruplet-item" style="display: none;">
                            <label for="freq-quadruplet" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;">å››è¿éŸ³é¢‘ç‡:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <input type="range" id="freq-quadruplet" min="0" max="100" value="20" style="flex: 1;">
                                <span id="freq-quadruplet-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">20%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="btn-secondary" onclick="resetRhythmFrequencies()" style="margin-right: 10px;" data-i18n="button.resetDefault">è¿”å›é»˜è®¤</button>
                    </div>
                </div>
                
                <div class="modal-buttons">
                    <button class="btn-secondary" onclick="toggleRhythmAdvancedSettings()" id="rhythmAdvancedBtn" data-i18n="button.advanced">é«˜çº§è®¾ç½®</button>
                    <button class="btn-primary" onclick="saveRhythmSettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeRhythmSettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Articulations å¼¹çª— -->
    <div id="articulationModal" class="modal" style="display: none; visibility: hidden;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.articulation.title">Articulations</h3>
                <button class="close-btn" onclick="closeArticulationSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <!-- åŸºæœ¬ArticulationæŠ€å·§ -->
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="articulation.basic.title">åŸºæœ¬æ¼”å¥æ³• (Basic Articulations)</h4>
                        <button class="btn-select-all" onclick="selectAllBasicArticulations()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAll">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item" title="æ–­å¥ - éŸ³ç¬¦æ—¶å€¼å‡åŠï¼Œè½»å¿«åœ°æ¼”å¥">
                            <input type="checkbox" id="art-staccato" value="staccato">
                            <span data-i18n="articulation.staccato">Staccato (æ–­å¥) â€¢</span>
                        </label>
                        <label class="checkbox-item" title="é‡éŸ³ - å¼ºè°ƒæŸäº›éŸ³ç¬¦">
                            <input type="checkbox" id="art-accent" value="accent">
                            <span data-i18n="articulation.accent">Accent (é‡éŸ³) &gt;</span>
                        </label>
                        <label class="checkbox-item" title="çŸ­å€šéŸ³ - å¿«é€Ÿçš„è£…é¥°éŸ³">
                            <input type="checkbox" id="art-acciaccatura" value="acciaccatura">
                            <span data-i18n="articulation.acciaccatura">Acciaccatura (çŸ­å€šéŸ³)</span>
                        </label>
                    </div>
                </div>


                <!-- å‰ä»–ç‰¹æœ‰æŠ€å·§ -->
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="articulation.guitar.title">å‰ä»–æŠ€å·§ (Guitar Techniques)</h4>
                        <button class="btn-select-all" onclick="selectAllGuitarTechniques()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAll">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item" title="å‡»å¼¦ - ç”¨å·¦æ‰‹æ•²å‡»äº§ç”ŸéŸ³ç¬¦">
                            <input type="checkbox" id="gtr-hammer" value="hammer-on">
                            <span data-i18n="articulation.hammer">Hammer-on (å‡»å¼¦) H</span>
                        </label>
                        <label class="checkbox-item" title="å‹¾å¼¦ - ç”¨å·¦æ‰‹å‹¾ç¦»äº§ç”ŸéŸ³ç¬¦">
                            <input type="checkbox" id="gtr-pull" value="pull-off">
                            <span data-i18n="articulation.pulloff">Pull-off (å‹¾å¼¦) P</span>
                        </label>
                        <!-- æš‚æ—¶éšè—glissandoç›¸å…³é€‰é¡¹ï¼Œå› ä¸ºOSMDä¸æ”¯æŒæ¸²æŸ“ -->
                        <label class="checkbox-item" title="æ»‘éŸ³ - åœ¨å“æ ¼é—´æ»‘åŠ¨ï¼ˆæ³¨ï¼šOSMDæš‚ä¸æ”¯æŒæ¸²æŸ“ï¼‰" style="display: none;">
                            <input type="checkbox" id="gtr-glissando" value="glissando">
                            <span>Glissando (æ»‘éŸ³) /</span>
                        </label>
                        <label class="checkbox-item" title="æ»‘å…¥ - ä»ä¸‹æ–¹æ»‘å…¥ä¸»éŸ³ï¼ˆæ³¨ï¼šOSMDæš‚ä¸æ”¯æŒæ¸²æŸ“ï¼‰" style="display: none;">
                            <input type="checkbox" id="gtr-slide-in" value="slide-in">
                            <span>Slide In (æ»‘å…¥)</span>
                        </label>
                        <label class="checkbox-item" title="æ»‘å‡º - ä»ä¸»éŸ³æ»‘å‡ºï¼ˆæ³¨ï¼šOSMDæš‚ä¸æ”¯æŒæ¸²æŸ“ï¼‰" style="display: none;">
                            <input type="checkbox" id="gtr-slide-out" value="slide-out">
                            <span>Slide Out (æ»‘å‡º)</span>
                        </label>
                    </div>
                </div>

                <!-- æš‚æ—¶éšè—glissandoç›¸å…³è¯´æ˜ -->
                <div style="padding: 10px 20px; color: #666; font-size: 12px; border-top: 1px solid #eee; margin-top: 10px; display: none;">
                    <small>* æ³¨ï¼šæ ‡æœ‰æ˜Ÿå·çš„æŠ€å·§ï¼ˆGlissandoã€Slide In/Outï¼‰ç”±äºOSMDæ¸²æŸ“å¼•æ“é™åˆ¶ï¼Œæš‚æ—¶ä¼šæ˜¾ç¤ºä¸ºæ–‡æœ¬æç¤ºã€‚</small>
                </div>

                <!-- é«˜çº§è®¾ç½®åŒºåŸŸ -->
                <div id="articulationAdvancedSettings" style="display: none; margin-top: 20px; padding: 20px; background: var(--info-bg); border-radius: 8px; border: 2px solid var(--info-border);">
                    <h4 style="margin-bottom: 15px; color: var(--heading-text);" data-i18n="articulation.advancedFreq">é«˜çº§é¢‘ç‡è®¾ç½®</h4>
                    <p style="font-size: 0.9rem; color: var(--secondary-text); margin-bottom: 20px;" data-i18n="articulation.freqDesc">è°ƒæ•´å„æ¼”å¥æ³•åœ¨æ—‹å¾‹ä¸­çš„å‡ºç°é¢‘ç‡ (0% = ä¸ä½¿ç”¨, 100% = ç»å¸¸ä½¿ç”¨)</p>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: #495057; margin-bottom: 10px;" data-i18n="articulation.basicFreq">åŸºæœ¬æ¼”å¥æ³•é¢‘ç‡</h5>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                            <div class="frequency-item">
                                <label for="freq-staccato" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="articulation.freq.staccato">Staccato (æ–­å¥) é¢‘ç‡:</label>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="range" id="freq-staccato" min="0" max="100" value="20" style="flex: 1;">
                                    <span id="freq-staccato-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">20%</span>
                                </div>
                            </div>
                            <div class="frequency-item">
                                <label for="freq-accent" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="articulation.freq.accent">Accent (é‡éŸ³) é¢‘ç‡:</label>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="range" id="freq-accent" min="0" max="100" value="15" style="flex: 1;">
                                    <span id="freq-accent-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">15%</span>
                                </div>
                            </div>
                            <div class="frequency-item">
                                <label for="freq-acciaccatura" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="articulation.freq.acciaccatura">Acciaccatura (çŸ­å€šéŸ³) é¢‘ç‡:</label>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="range" id="freq-acciaccatura" min="0" max="100" value="10" style="flex: 1;">
                                    <span id="freq-acciaccatura-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">10%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h5 style="color: #495057; margin-bottom: 10px;" data-i18n="articulation.guitarFreq">å‰ä»–æŠ€å·§é¢‘ç‡</h5>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                            <div class="frequency-item">
                                <label for="freq-slur" style="font-size: 0.9rem; color: #495057; margin-bottom: 5px;" data-i18n="articulation.freq.slur">å‡»å‹¾å¼¦é¢‘ç‡:</label>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="range" id="freq-slur" min="0" max="100" value="15" style="flex: 1;">
                                    <span id="freq-slur-value" style="min-width: 40px; font-size: 0.9rem; font-weight: 600; color: #667eea;">15%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="btn-secondary" onclick="resetArticulationFrequencies()" style="margin-right: 10px;" data-i18n="button.resetDefault">è¿”å›é»˜è®¤</button>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="btn-secondary" onclick="toggleArticulationAdvancedSettings()" id="articulationAdvancedBtn" data-i18n="button.advanced">é«˜çº§è®¾ç½®</button>
                    <button class="btn-primary" onclick="saveArticulationSettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeArticulationSettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- è°ƒå·è®¾ç½®å¼¹çª— -->
    <div id="keySignatureModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.keySignature.title">è°ƒå·è®¾ç½®</h3>
                <button class="close-btn" onclick="closeKeySettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="modal.keySignature.major">å¤§è°ƒ (Major)</h4>
                        <button class="btn-select-all" onclick="selectAllMajorKeys()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAllMajor">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-C" value="C" checked="">
                            <span>C å¤§è°ƒ</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-G" value="G">
                            <span>G å¤§è°ƒ (1#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-D" value="D">
                            <span>D å¤§è°ƒ (2#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-A" value="A">
                            <span>A å¤§è°ƒ (3#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-E" value="E">
                            <span>E å¤§è°ƒ (4#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-B" value="B">
                            <span>B å¤§è°ƒ (5#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-F#" value="F#">
                            <span>F# å¤§è°ƒ (6#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-F" value="F">
                            <span>F å¤§è°ƒ (1b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Bb" value="Bb">
                            <span>Bb å¤§è°ƒ (2b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Eb" value="Eb">
                            <span>Eb å¤§è°ƒ (3b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Ab" value="Ab">
                            <span>Ab å¤§è°ƒ (4b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Db" value="Db">
                            <span>Db å¤§è°ƒ (5b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Gb" value="Gb">
                            <span>Gb å¤§è°ƒ (6b)</span>
                        </label>
                    </div>
                </div>

                <div class="rhythm-section" style="margin-top: 30px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="modal.keySignature.minor">å°è°ƒ (Minor)</h4>
                        <button class="btn-select-all" onclick="selectAllMinorKeys()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAllMinor">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Am" value="Am">
                            <span>A å°è°ƒ</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Em" value="Em">
                            <span>E å°è°ƒ (1#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Bm" value="Bm">
                            <span>B å°è°ƒ (2#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-F#m" value="F#m">
                            <span>F# å°è°ƒ (3#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-C#m" value="C#m">
                            <span>C# å°è°ƒ (4#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-G#m" value="G#m">
                            <span>G# å°è°ƒ (5#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-D#m" value="D#m">
                            <span>D# å°è°ƒ (6#)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Dm" value="Dm">
                            <span>D å°è°ƒ (1b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Gm" value="Gm">
                            <span>G å°è°ƒ (2b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Cm" value="Cm">
                            <span>C å°è°ƒ (3b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Fm" value="Fm">
                            <span>F å°è°ƒ (4b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Bbm" value="Bbm">
                            <span>Bb å°è°ƒ (5b)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="key-Ebm" value="Ebm">
                            <span>Eb å°è°ƒ (6b)</span>
                        </label>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="btn-primary" onclick="saveKeySettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeKeySettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- æ‹å·è®¾ç½®å¼¹çª— -->
    <div id="timeSignatureModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.timeSignature.title">æ‹å·è®¾ç½®</h3>
                <button class="close-btn" onclick="closeTimeSignatureSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="modal.timeSignature.selection">æ‹å·é€‰é¡¹</h4>
                        <button class="btn-select-all" onclick="selectAllTimeSignatures()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAll">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="time-2/4" value="2/4">
                            <span data-i18n="time.2-4">2/4 æ‹</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="time-3/4" value="3/4">
                            <span data-i18n="time.3-4">3/4 æ‹</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="time-4/4" value="4/4" checked="">
                            <span data-i18n="time.4-4">4/4 æ‹</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="time-6/8" value="6/8">
                            <span data-i18n="time.6-8">6/8 æ‹</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="time-custom" value="custom">
                            <span data-i18n="time.custom">è‡ªå®šä¹‰</span>
                        </label>
                    </div>
                    <div id="customTimeSignatureFields" style="display: none; margin-top: 12px; padding: 12px; border: 1px dashed var(--border-color); border-radius: 10px; background: var(--neutral-white);">
                        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                            <label for="customTimeBeats" style="min-width: 80px;" data-i18n="time.custom.beats">æ‹æ•°</label>
                            <input type="number" id="customTimeBeats" min="1" step="1" value="5" style="width: 90px;">
                            <label for="customTimeBeatValue" style="min-width: 80px;" data-i18n="time.custom.denominator">å•ä½</label>
                            <select id="customTimeBeatValue" style="min-width: 120px;">
                                <option value="2">2</option>
                                <option value="4" selected>4</option>
                                <option value="8">8</option>
                                <option value="16">16</option>
                            </select>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px; color: var(--neutral-dark);" data-i18n="time.custom.hint">ç¤ºä¾‹ï¼š5/4ã€7/4ã€5/8ã€7/8</div>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="btn-primary" onclick="saveTimeSignatureSettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeTimeSignatureSettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- éŸ³ç¨‹è·¨åº¦è®¾ç½®å¼¹çª— -->
    <div id="intervalModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.interval.title">éŸ³ç¨‹è·¨åº¦è®¾ç½®</h3>
                <button class="close-btn" onclick="closeIntervalSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="modal.interval.selection">æœ€å¤§éŸ³ç¨‹è·¨åº¦é€‰é¡¹</h4>
                        <small style="color: #666; font-size: 12px;" data-i18n="interval.singleSelect">åªèƒ½é€‰æ‹©ä¸€ä¸ªéŸ³ç¨‹ä½œä¸ºæœ€å¤§è·¨åº¦</small>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-1" value="1" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.minor2nd">å°äºŒåº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-2" value="2" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.major2nd">å¤§äºŒåº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-3" value="3" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.minor3rd">å°ä¸‰åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-4" value="4" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.major3rd">å¤§ä¸‰åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-5" value="5" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.perfect4th">å®Œå…¨å››åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-6" value="6" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.tritone">å¢å››åº¦/å‡äº”åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-7" value="7" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.perfect5th">å®Œå…¨äº”åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-8" value="8" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.minor6th">å°å…­åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-9" value="9" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.major6th">å¤§å…­åº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-10" value="10" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.minor7th">å°ä¸ƒåº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-11" value="11" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.major7th">å¤§ä¸ƒåº¦</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="interval-12" value="12" checked="" onchange="handleIntervalCheckboxChange(this)">
                            <span data-i18n="interval.perfect8th">å®Œå…¨å…«åº¦</span>
                        </label>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="btn-primary" onclick="saveIntervalSettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeIntervalSettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- è°±å·è®¾ç½®å¼¹çª— -->
    <div id="clefModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 data-i18n="modal.clef.title">è°±å·è®¾ç½®</h3>
                <button class="close-btn" onclick="closeClefSettings()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="rhythm-section">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <h4 data-i18n="clef.options">è°±å·é€‰é¡¹</h4>
                        <button class="btn-select-all" onclick="selectAllClefs()" style="padding: 5px 10px; font-size: 12px; background: rgb(40, 167, 69); color: white; border: none; border-radius: 4px; cursor: pointer; transition: 0.3s;" data-i18n="button.selectAll">å…¨é€‰</button>
                    </div>
                    <div class="checkbox-grid">
                        <label class="checkbox-item">
                            <input type="checkbox" id="clef-treble" value="treble" checked="">
                            <span data-i18n="clef.treble">é«˜éŸ³è°±å· (Gè°±å·)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="clef-bass" value="bass">
                            <span data-i18n="clef.bass">ä½éŸ³è°±å· (Fè°±å·)</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="clef-alto" value="alto">
                            <span data-i18n="clef.alto">ä¸­éŸ³è°±å· (Cè°±å·)</span>
                        </label>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="btn-primary" onclick="saveClefSettings()" data-i18n="button.save">ä¿å­˜è®¾ç½®</button>
                    <button class="btn-secondary" onclick="closeClefSettings()" data-i18n="button.cancel">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/minor-scale-spelling.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/jianpu-sight-reading-final.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/jianpu-68.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/minor-alterations.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/emergency-fix.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/jianpu-normalize.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/jianpurender.bundle.js"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/jianpu-sight-reading.js?v=tie3"></script>
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/disable-unused-ui.js"></script>

    <!-- å¢å¼ºçš„å…¨é€‰åˆ‡æ¢åŠŸèƒ½ -->
    <!-- <script src="enhanced-select-all.js"></script> -->
    
    <!-- ä¸»é¢˜åˆ‡æ¢ç³»ç»Ÿ -->
    <script>
        // ä¸»é¢˜åˆ‡æ¢ç›¸å…³å˜é‡å’ŒåŠŸèƒ½
        const savedTheme = localStorage.getItem('preferredTheme');
        const legacyTheme = localStorage.getItem('jianpuPreferredTheme');
        let currentTheme = savedTheme || legacyTheme || 'light';
        if (!savedTheme && legacyTheme) {
            localStorage.setItem('preferredTheme', legacyTheme);
        }
        
        // ä¸»é¢˜å›¾æ ‡
        const themeIcons = {
            'light': 'ğŸŒ™', // åœ¨lightæ¨¡å¼æ˜¾ç¤ºæœˆäº®å›¾æ ‡ï¼Œç‚¹å‡»åˆ‡æ¢åˆ°dark
            'dark': 'â˜€ï¸'   // åœ¨darkæ¨¡å¼æ˜¾ç¤ºå¤ªé˜³å›¾æ ‡ï¼Œç‚¹å‡»åˆ‡æ¢åˆ°light
        };
        
        // åˆ‡æ¢ä¸»é¢˜ (ä¿ç•™å‘åå…¼å®¹æ€§)
        function toggleTheme() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }
        
        // è®¾ç½®ä¸»é¢˜ (æ–°ç‰ˆæœ¬ï¼Œç”¨äºè®¾ç½®èœå•)
        function setTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('preferredTheme', theme);

            // è®¾ç½®HTMLçš„data-themeå±æ€§
            document.documentElement.setAttribute('data-theme', theme);

            // è§¦å‘ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ (åŒæ ‡ç­¾é¡µå†…å®æ—¶åŒæ­¥)
            if (window.ICStudioSync) {
                window.ICStudioSync.syncTheme(theme, 'jianpu-tool');
            }

            // å…³é—­è®¾ç½®å¼¹çª—
            closeSettings();

            if (window.__icMidi && typeof window.__icMidi.refreshStatus === 'function') {
                window.__icMidi.refreshStatus();
            }

            console.log(`ğŸ¨ ä¸»é¢˜å·²è®¾ç½®ä¸º: ${theme}`);
        }
        
        // åº”ç”¨ä¸»é¢˜ (ä¿ç•™å‘åå…¼å®¹æ€§)
        function switchTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('preferredTheme', theme);
            
            // è®¾ç½®HTMLçš„data-themeå±æ€§
            document.documentElement.setAttribute('data-theme', theme);
            
            // æ›´æ–°æŒ‰é’®å›¾æ ‡ (å¦‚æœå­˜åœ¨æ—§çš„ä¸»é¢˜åˆ‡æ¢å™¨)
            const themeSwitcher = document.getElementById('themeSwitcher');
            if (themeSwitcher) {
                themeSwitcher.textContent = themeIcons[theme];
            }
            
            console.log(`ğŸ¨ ä¸»é¢˜å·²åˆ‡æ¢åˆ°: ${theme}`);
        }
        
        // è®¾ç½®å¼¹çª—æ§åˆ¶
        function toggleSettings() {
            const modal = document.getElementById('settingsModal');
            const isVisible = modal && (modal.style.display === 'flex' || modal.style.display === 'block');

            if (isVisible) {
                closeSettingsModal();
            } else {
                openSettingsModal();
            }
        }

        function openSettingsModal() {
            const modal = document.getElementById('settingsModal');
            if (!modal) return;
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            if (!modal) return;
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }

        function closeSettings() {
            closeSettingsModal();
        }
        
        // åŠŸèƒ½é€‰æ‹©å™¨æ§åˆ¶
        function toggleFunctionSelector() {
            const functionMenu = document.getElementById('functionMenu');
            const isVisible = functionMenu.classList.contains('show');
            
            if (isVisible) {
                closeFunctionSelector();
            } else {
                openFunctionSelector();
            }
        }
        
        function openFunctionSelector() {
            const functionMenu = document.getElementById('functionMenu');
            functionMenu.classList.add('show');
            
            // æ·»åŠ ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­èœå•çš„ç›‘å¬å™¨
            setTimeout(() => {
                document.addEventListener('click', handleFunctionClickOutside);
            }, 10);
        }
        
        function closeFunctionSelector() {
            const functionMenu = document.getElementById('functionMenu');
            functionMenu.classList.remove('show');
            
            // ç§»é™¤ç‚¹å‡»å¤–éƒ¨åŒºåŸŸçš„ç›‘å¬å™¨
            document.removeEventListener('click', handleFunctionClickOutside);
        }
        
        // å¤„ç†ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­åŠŸèƒ½èœå•
        function handleFunctionClickOutside(event) {
            const functionSelector = document.querySelector('.function-selector');
            
            if (functionSelector && !functionSelector.contains(event.target)) {
                closeFunctionSelector();
            }
        }
        
        // å½“å‰åŠŸèƒ½æ¨¡å¼
        let currentFunctionMode = 'jianpu';
        
        // åˆ‡æ¢åŠŸèƒ½
        function switchFunction(mode) {
            function navigateTo(targetFile) {
                try {
                    const url = new URL(window.location.href);
                    url.pathname = url.pathname.replace(/[^/]+$/, targetFile);
                    window.location.href = url.toString();
                } catch(_) {
                    window.location.href = targetFile; // å…œåº•
                }
            }
            if (mode === 'jianpu') {
                closeFunctionSelector();
                console.log('å·²åœ¨ç®€è°±è§†å¥æ¨¡å¼');
            } else if (mode === 'melody') {
                navigateTo('melody-generator.html');
            } else if (mode === 'interval') {
                navigateTo('interval-generator.html');
            } else if (mode === 'chord') {
                navigateTo('chord-generator.html');
            } else if (mode === 'rhythm') {
                navigateTo('rhythm.html');
            }
        }
        
        // è®¾ç½®å·²æ”¹ä¸ºå¼¹çª—ï¼Œä¸å†ä½¿ç”¨ä¸‹æ‹‰å¤–éƒ¨ç‚¹å‡»å…³é—­

        // èŠ‚æ‹å™¨ç›¸å…³å˜é‡å’ŒåŠŸèƒ½
        let metronomeInterval = null;
        let metronomeAudioContext = null;
        let metronomeOscillator = null;
        let isMetronomeRunning = false;
        let metronomeTempo = 60; // é»˜è®¤60 BPM

        // ğŸ”§ ç²¾ç¡®åŒæ­¥ï¼šè®°å½•èŠ‚æ‹å™¨å¯åŠ¨æ—¶é—´å’Œå½“å‰èŠ‚æ‹
        let metronomeStartTime = null;
        let metronomeCurrentBeat = 0;
        let metronomeSchedulerInterval = null;

        const metronomePatternStorageKey = 'ic_jianpu_metronome_pattern';
        const metronomeSubdivisionOptions = [1, 2, 3, 4];
        const metronomeBarsOptions = [1, 2, 4];
        let metronomePattern = {
            enabled: false,
            subdivision: 1,
            bars: 1,
            steps: []
        };

        function normalizeMetronomeSubdivision(value) {
            const normalized = parseInt(value, 10);
            return metronomeSubdivisionOptions.includes(normalized) ? normalized : 1;
        }

        function normalizeMetronomeBars(value) {
            const normalized = parseInt(value, 10);
            return metronomeBarsOptions.includes(normalized) ? normalized : 1;
        }

        function buildDefaultMetronomePattern(stepsPerPattern, subdivision) {
            const steps = new Array(stepsPerPattern).fill(0);
            for (let i = 0; i < stepsPerPattern; i += subdivision) {
                steps[i] = 1;
            }
            return steps;
        }

        function ensureMetronomePatternSteps(stepsPerPattern, subdivision) {
            if (!Array.isArray(metronomePattern.steps) || metronomePattern.steps.length !== stepsPerPattern) {
                metronomePattern.steps = buildDefaultMetronomePattern(stepsPerPattern, subdivision);
                saveMetronomePatternSettings();
            }
            metronomePattern.steps = metronomePattern.steps.map(step => (step ? 1 : 0));
            return metronomePattern.steps;
        }

        function loadMetronomePatternSettings() {
            try {
                const raw = localStorage.getItem(metronomePatternStorageKey);
                if (!raw) return;
                const data = JSON.parse(raw);
                if (data && typeof data === 'object') {
                    metronomePattern.enabled = !!data.enabled;
                    metronomePattern.subdivision = normalizeMetronomeSubdivision(data.subdivision);
                    metronomePattern.bars = normalizeMetronomeBars(data.bars);
                    metronomePattern.steps = Array.isArray(data.steps) ? data.steps.map(step => (step ? 1 : 0)) : [];
                }
            } catch (error) {
                console.warn('âš ï¸ èŠ‚æ‹å™¨èŠ‚å¥å‹è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®', error);
            }
        }

        function saveMetronomePatternSettings() {
            try {
                const payload = {
                    enabled: !!metronomePattern.enabled,
                    subdivision: normalizeMetronomeSubdivision(metronomePattern.subdivision),
                    bars: normalizeMetronomeBars(metronomePattern.bars),
                    steps: Array.isArray(metronomePattern.steps) ? metronomePattern.steps.map(step => (step ? 1 : 0)) : []
                };
                localStorage.setItem(metronomePatternStorageKey, JSON.stringify(payload));
            } catch (error) {
                console.warn('âš ï¸ èŠ‚æ‹å™¨èŠ‚å¥å‹ä¿å­˜å¤±è´¥', error);
            }
        }

        function getMetronomeTimeSignatureInfo() {
            let beats = 4;
            let den = 4;
            try {
                if (typeof userSettings !== 'undefined' && Array.isArray(userSettings.allowedTimeSignatures) && userSettings.allowedTimeSignatures.length === 1) {
                    const parts = String(userSettings.allowedTimeSignatures[0]).split('/');
                    beats = parseInt(parts[0] || '4', 10) || beats;
                    den = parseInt(parts[1] || '4', 10) || den;
                    return { beats, den };
                }
                if (typeof window !== 'undefined' && window.currentTimeSignature) {
                    const parts = String(window.currentTimeSignature).split('/');
                    beats = parseInt(parts[0] || '4', 10) || beats;
                    den = parseInt(parts[1] || '4', 10) || den;
                }
            } catch (error) {
                console.warn('âš ï¸ æ— æ³•è¯»å–å½“å‰æ‹å·ï¼Œä½¿ç”¨é»˜è®¤4/4æ‹', error);
            }
            return { beats, den };
        }

        function getMetronomePatternInfo(tempoOverride) {
            const tempo = Math.max(1, tempoOverride || metronomeTempo);
            if (!metronomePattern.enabled) {
                return {
                    usePattern: false,
                    stepDuration: 60.0 / tempo
                };
            }

            const tsInfo = getMetronomeTimeSignatureInfo();
            const subdivision = normalizeMetronomeSubdivision(metronomePattern.subdivision);
            const bars = normalizeMetronomeBars(metronomePattern.bars);
            const beatDuration = (60.0 / tempo) * (4 / tsInfo.den);
            const stepDuration = beatDuration / subdivision;
            const stepsPerBar = tsInfo.beats * subdivision;
            const stepsPerPattern = stepsPerBar * bars;
            const steps = ensureMetronomePatternSteps(stepsPerPattern, subdivision);

            return {
                usePattern: true,
                stepDuration,
                stepsPerBar,
                stepsPerPattern,
                steps,
                subdivision,
                bars
            };
        }

        function restartMetronomeIfRunning() {
            if (isMetronomeRunning) {
                stopMetronome();
                startMetronome();
            }
        }

        function updateMetronomePatternTimeSig() {
            const label = document.getElementById('metronomePatternTimeSig');
            if (!label) return;
            const tsInfo = getMetronomeTimeSignatureInfo();
            label.textContent = `${tsInfo.beats}/${tsInfo.den}`;
        }

        function renderMetronomePatternGrid() {
            const grid = document.getElementById('metronomePatternGrid');
            if (!grid) return;
            const tsInfo = getMetronomeTimeSignatureInfo();
            const subdivision = normalizeMetronomeSubdivision(metronomePattern.subdivision);
            const bars = normalizeMetronomeBars(metronomePattern.bars);
            const stepsPerBar = tsInfo.beats * subdivision;
            const stepsPerPattern = stepsPerBar * bars;
            const steps = ensureMetronomePatternSteps(stepsPerPattern, subdivision);

            grid.classList.toggle('disabled', !metronomePattern.enabled);
            grid.style.gridTemplateColumns = `repeat(${stepsPerBar}, minmax(32px, 1fr))`;
            grid.style.gridAutoFlow = 'row';
            grid.innerHTML = '';

            for (let i = 0; i < stepsPerPattern; i++) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'metronome-pattern-step';
                if (steps[i]) btn.classList.add('active');
                if (i % subdivision === 0) btn.classList.add('beat-start');
                if (i % stepsPerBar === 0) btn.classList.add('bar-start');
                btn.dataset.step = String(i);
                btn.setAttribute('aria-pressed', steps[i] ? 'true' : 'false');
                if (i % subdivision === 0) {
                    const beatNumber = (Math.floor(i / subdivision) % tsInfo.beats) + 1;
                    btn.textContent = String(beatNumber);
                } else {
                    btn.textContent = '';
                }
                grid.appendChild(btn);
            }
        }

        function updateMetronomePatternUI() {
            const enableToggle = document.getElementById('metronomePatternEnable');
            const subdivisionSelect = document.getElementById('metronomePatternSubdivision');
            const barsSelect = document.getElementById('metronomePatternBars');

            if (enableToggle) enableToggle.checked = !!metronomePattern.enabled;
            if (subdivisionSelect) subdivisionSelect.value = String(normalizeMetronomeSubdivision(metronomePattern.subdivision));
            if (barsSelect) barsSelect.value = String(normalizeMetronomeBars(metronomePattern.bars));

            updateMetronomePatternTimeSig();
            renderMetronomePatternGrid();
        }

        function openMetronomePatternSettings() {
            const modal = document.getElementById('metronomePatternModal');
            if (!modal) return;
            updateMetronomePatternUI();
            modal.style.display = 'flex';
        }

        function closeMetronomePatternSettings() {
            const modal = document.getElementById('metronomePatternModal');
            if (modal) modal.style.display = 'none';
        }

        function resetMetronomePattern() {
            const subdivision = normalizeMetronomeSubdivision(metronomePattern.subdivision);
            const bars = normalizeMetronomeBars(metronomePattern.bars);
            const tsInfo = getMetronomeTimeSignatureInfo();
            const stepsPerPattern = tsInfo.beats * subdivision * bars;
            metronomePattern.steps = buildDefaultMetronomePattern(stepsPerPattern, subdivision);
            renderMetronomePatternGrid();
            saveMetronomePatternSettings();
            restartMetronomeIfRunning();
        }

        function clearMetronomePattern() {
            const subdivision = normalizeMetronomeSubdivision(metronomePattern.subdivision);
            const bars = normalizeMetronomeBars(metronomePattern.bars);
            const tsInfo = getMetronomeTimeSignatureInfo();
            const stepsPerPattern = tsInfo.beats * subdivision * bars;
            metronomePattern.steps = new Array(stepsPerPattern).fill(0);
            renderMetronomePatternGrid();
            saveMetronomePatternSettings();
            restartMetronomeIfRunning();
        }

        function saveMetronomePatternSettingsAndClose() {
            saveMetronomePatternSettings();
            restartMetronomeIfRunning();
            closeMetronomePatternSettings();
        }

        function initializeMetronomePatternUI() {
            loadMetronomePatternSettings();
            const enableToggle = document.getElementById('metronomePatternEnable');
            const subdivisionSelect = document.getElementById('metronomePatternSubdivision');
            const barsSelect = document.getElementById('metronomePatternBars');
            const grid = document.getElementById('metronomePatternGrid');

            if (enableToggle) {
                enableToggle.checked = !!metronomePattern.enabled;
                enableToggle.addEventListener('change', function() {
                    metronomePattern.enabled = !!this.checked;
                    renderMetronomePatternGrid();
                    saveMetronomePatternSettings();
                    restartMetronomeIfRunning();
                });
            }

            if (subdivisionSelect) {
                subdivisionSelect.value = String(normalizeMetronomeSubdivision(metronomePattern.subdivision));
                subdivisionSelect.addEventListener('change', function() {
                    metronomePattern.subdivision = normalizeMetronomeSubdivision(this.value);
                    renderMetronomePatternGrid();
                    saveMetronomePatternSettings();
                    restartMetronomeIfRunning();
                });
            }

            if (barsSelect) {
                barsSelect.value = String(normalizeMetronomeBars(metronomePattern.bars));
                barsSelect.addEventListener('change', function() {
                    metronomePattern.bars = normalizeMetronomeBars(this.value);
                    renderMetronomePatternGrid();
                    saveMetronomePatternSettings();
                    restartMetronomeIfRunning();
                });
            }

            if (grid) {
                grid.addEventListener('click', function(event) {
                    const target = event.target;
                    if (!target || !target.classList.contains('metronome-pattern-step')) return;
                    const index = parseInt(target.dataset.step, 10);
                    if (isNaN(index)) return;
                    if (!metronomePattern.enabled) {
                        metronomePattern.enabled = true;
                        if (enableToggle) enableToggle.checked = true;
                        grid.classList.remove('disabled');
                    }
                    metronomePattern.steps[index] = metronomePattern.steps[index] ? 0 : 1;
                    target.classList.toggle('active', !!metronomePattern.steps[index]);
                    target.setAttribute('aria-pressed', metronomePattern.steps[index] ? 'true' : 'false');
                    saveMetronomePatternSettings();
                    restartMetronomeIfRunning();
                });
            }

            updateMetronomePatternUI();
        }
        // æä¾›ç»™æŒ‘æˆ˜æ¨¡å¼çš„åªè¯»çŠ¶æ€
        window.getMetronomeState = function(){
            try {
                return {
                    audioContext: metronomeAudioContext || null,
                    tempo: metronomeTempo || 60,
                    isRunning: !!isMetronomeRunning
                };
            } catch(_) { return null; }
        }
        // æä¾›èŠ‚æ‹ç½‘æ ¼ä¿¡æ¯ç»™æŒ‘æˆ˜æ¨¡å¼ä½¿ç”¨
        window.getMetronomePhase = function(){
            try {
                const patternInfo = getMetronomePatternInfo(metronomeTempo);
                return {
                    audioContext: metronomeAudioContext || null,
                    tempo: metronomeTempo || 60,
                    beatDuration: patternInfo ? patternInfo.stepDuration : (metronomeTempo ? (60 / metronomeTempo) : 1),
                    startTime: metronomeStartTime ?? 0,
                    currentBeat: metronomeCurrentBeat || 0,
                    isRunning: !!isMetronomeRunning
                };
            } catch(_) { return null; }
        }
        let metronomeUIBeatTimeouts = [];

        // ğŸ”§ å…³é”®ä¿®å¤ï¼šä½¿ç”¨ä¸æ—‹å¾‹æ’­æ”¾ç›¸åŒçš„ AudioContext
        // è¿™æ ·å¯ä»¥ç¡®ä¿èŠ‚æ‹å™¨å’Œæ—‹å¾‹ä½¿ç”¨åŒä¸€ä¸ªæ—¶é’Ÿï¼Œå®ç°å®Œç¾åŒæ­¥
        function initializeMetronomeAudio() {
            try {
                // ä¼˜å…ˆä½¿ç”¨æ—‹å¾‹æ’­æ”¾çš„ AudioContext
                if (window.melodyAudioCtx) {
                    metronomeAudioContext = window.melodyAudioCtx;
                    console.log('ğŸµ èŠ‚æ‹å™¨ä½¿ç”¨æ—‹å¾‹çš„ AudioContextï¼ˆå…±äº«æ—¶é’Ÿï¼‰');
                } else {
                    metronomeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // åå‘å…±äº«ï¼šè®©æ—‹å¾‹ä¹Ÿä½¿ç”¨è¿™ä¸ª AudioContext
                    window.melodyAudioCtx = metronomeAudioContext;
                    console.log('ğŸµ èŠ‚æ‹å™¨åˆ›å»ºæ–° AudioContextï¼ˆå…±äº«ç»™æ—‹å¾‹ï¼‰');
                }
                return true;
            } catch (error) {
                console.error('âŒ Web Audio API ä¸æ”¯æŒ:', error);
                return false;
            }
        }

        // UIæŒ‡ç¤ºå™¨ï¼šåœ¨æŒ‡å®šAudioContextæ—¶é—´ç‚¹è§¦å‘ä¸€æ¬¡â€œäº®èµ·â€
        function triggerBeatIndicatorAt(time) {
            try {
                const headerIndicator = document.getElementById('headerBeatIndicator');
                if (!metronomeAudioContext || !headerIndicator) return;
                const now = metronomeAudioContext.currentTime;
                const delayMs = Math.max(0, Math.round((time - now) * 1000));
                const onTimeout = setTimeout(() => {
                    headerIndicator.classList.add('beat');
                    const offTimeout = setTimeout(() => {
                        headerIndicator.classList.remove('beat');
                    }, 150);
                    metronomeUIBeatTimeouts.push(offTimeout);
                }, delayMs);
                metronomeUIBeatTimeouts.push(onTimeout);
            } catch(e) { /* noop */ }
        }

        // æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³ - æ”¯æŒç²¾ç¡®è°ƒåº¦
        function playMetronomeSound(time) {
            if (!metronomeAudioContext) {
                if (!initializeMetronomeAudio()) return;
            }

            try {
                // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆç”¨æˆ·äº¤äº’åï¼‰
                if (metronomeAudioContext.state === 'suspended') {
                    metronomeAudioContext.resume();
                }

                // ğŸ”§ ä½¿ç”¨ä¼ å…¥çš„ç²¾ç¡®æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å½“å‰æ—¶é—´
                const scheduleTime = time !== undefined ? time : metronomeAudioContext.currentTime;

                const oscillator = metronomeAudioContext.createOscillator();
                const gainNode = metronomeAudioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(metronomeAudioContext.destination);

                // ä½¿ç”¨æ–¹æ³¢å’Œè‡ªç„¶éŸ³é«˜ (å‚è€ƒNiceChordèŠ‚æ‹å™¨)
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(523.25, scheduleTime); // C5éŸ³é«˜

                // è®¾ç½®è‡ªç„¶çš„éŸ³é‡åŒ…ç»œ (æ›´å¥½çš„release time)
                gainNode.gain.setValueAtTime(0.5, scheduleTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, scheduleTime + 0.05);

                oscillator.start(scheduleTime);
                oscillator.stop(scheduleTime + 0.05);

                // è§†è§‰åé¦ˆï¼šè‹¥æ˜¯æå‰è°ƒåº¦çš„æ‹å­ï¼Œåˆ™å®‰æ’UIåŒæ­¥é—ªçƒ
                if (time !== undefined) {
                    triggerBeatIndicatorAt(scheduleTime);
                } else {
                    // ç«‹å³æ’­æ”¾çš„æ‹å­ï¼Œç›´æ¥é—ªçƒ
                    const headerIndicator = document.getElementById('headerBeatIndicator');
                    if (headerIndicator) {
                        headerIndicator.classList.add('beat');
                        setTimeout(() => headerIndicator.classList.remove('beat'), 150);
                    }
                }

            } catch (error) {
                console.error('âŒ èŠ‚æ‹å™¨å£°éŸ³æ’­æ”¾å¤±è´¥:', error);
            }
        }

        // è®¾ç½®èŠ‚æ‹å™¨é€Ÿåº¦
        function setMetronomeTempo(bpm) {
            metronomeTempo = Math.max(1, Math.min(999, bpm));
            
            // åŒæ­¥æ›´æ–°headerè¾“å…¥æ¡†
            const headerInput = document.getElementById('headerMetronomeBpm');
            if (headerInput) headerInput.value = metronomeTempo;
            
            // å¦‚æœèŠ‚æ‹å™¨æ­£åœ¨è¿è¡Œï¼Œé‡æ–°å¯åŠ¨ä»¥åº”ç”¨æ–°é€Ÿåº¦
            if (isMetronomeRunning) {
                stopMetronome();
                startMetronome();
            }
            
            console.log(`ğŸµ èŠ‚æ‹å™¨é€Ÿåº¦è®¾ç½®ä¸º: ${metronomeTempo} BPM`);
        }

        // ğŸ”§ ç²¾ç¡®èŠ‚æ‹å™¨è°ƒåº¦å™¨ - ä½¿ç”¨ Web Audio API æ—¶é’Ÿ
        function scheduleMetronomeBeat() {
            if (!metronomeAudioContext) {
                if (!initializeMetronomeAudio()) return;
            }

            const patternInfo = getMetronomePatternInfo(metronomeTempo);
            const stepDuration = patternInfo.stepDuration; // æ¯æ­¥çš„ç§’æ•°
            const lookahead = 0.1; // æå‰ 100ms è°ƒåº¦
            const scheduleAheadTime = 0.2; // è°ƒåº¦æœªæ¥ 200ms çš„èŠ‚æ‹

            while (metronomeStartTime + metronomeCurrentBeat * stepDuration <
                   metronomeAudioContext.currentTime + scheduleAheadTime) {

                const beatTime = metronomeStartTime + metronomeCurrentBeat * stepDuration;
                let shouldPlay = true;
                if (patternInfo.usePattern && patternInfo.stepsPerPattern) {
                    const stepIndex = metronomeCurrentBeat % patternInfo.stepsPerPattern;
                    shouldPlay = patternInfo.steps[stepIndex] === 1;
                }

                // è°ƒåº¦è¿™ä¸€æ‹ï¼ˆå£°éŸ³ + UIæŒ‡ç¤ºï¼‰
                if (shouldPlay) {
                    playMetronomeSound(beatTime);
                    triggerBeatIndicatorAt(beatTime);
                }

                metronomeCurrentBeat++;
            }
        }

        // å¯åŠ¨èŠ‚æ‹å™¨ - ä½¿ç”¨ç²¾ç¡® Web Audio API è°ƒåº¦
        function startMetronome() {
            loadMetronomePatternSettings();
            const headerInput = document.getElementById('headerMetronomeBpm');
            const tempo = parseInt(headerInput ? headerInput.value : metronomeTempo) || 60;
            metronomeTempo = tempo;

            // åŒæ­¥æ›´æ–°headerè¾“å…¥æ¡†
            if (headerInput) headerInput.value = metronomeTempo;

            if (isMetronomeRunning) return;

            if (!metronomeAudioContext) {
                if (!initializeMetronomeAudio()) return;
            }

            // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (metronomeAudioContext.state === 'suspended') {
                metronomeAudioContext.resume();
            }

            isMetronomeRunning = true;

            // ğŸ”§ å…³é”®ä¿®å¤ï¼šä½¿ç”¨ AudioContext æ—¶é—´ 0 ä½œä¸ºå…¨å±€èŠ‚æ‹ç½‘æ ¼çš„èµ·ç‚¹
            // è¿™æ ·æ‰€æœ‰éŸ³ä¹å’ŒèŠ‚æ‹å™¨éƒ½åœ¨åŒä¸€ä¸ªç½‘æ ¼ä¸Š
            metronomeStartTime = 0; // å…¨å±€ç½‘æ ¼èµ·ç‚¹

            const patternInfo = getMetronomePatternInfo(metronomeTempo);
            const beatDuration = patternInfo.stepDuration;
            const now = metronomeAudioContext.currentTime;

            // è®¡ç®—å½“å‰åº”è¯¥åœ¨ç¬¬å‡ æ‹ï¼ˆä»æ—¶é—´ 0 å¼€å§‹ï¼‰
            const currentBeatNumber = Math.floor(now / beatDuration);
            const nextBeatNumber = currentBeatNumber + 1;
            const nextBeatTime = nextBeatNumber * beatDuration;

            // ç¡®ä¿ä¸‹ä¸€æ‹è‡³å°‘åœ¨æœªæ¥ 50msï¼Œå¦åˆ™è·³è¿‡
            const minLookahead = 0.05;
            if (nextBeatTime < now + minLookahead) {
                metronomeCurrentBeat = nextBeatNumber + 1;
            } else {
                metronomeCurrentBeat = nextBeatNumber;
            }

            console.log(`ğŸµ èŠ‚æ‹å™¨å¯¹é½å…¨å±€ç½‘æ ¼: ${metronomeTempo} BPM, å½“å‰=${now.toFixed(3)}s, ä»ç¬¬${metronomeCurrentBeat}æ­¥å¼€å§‹ (æ—¶é—´=${(metronomeCurrentBeat * beatDuration).toFixed(3)}s)`);

            // ç«‹å³è°ƒåº¦ç¬¬ä¸€æ‰¹èŠ‚æ‹
            scheduleMetronomeBeat();

            // ğŸ”§ ä½¿ç”¨æ›´é¢‘ç¹çš„å®šæ—¶å™¨æ¥æ£€æŸ¥å’Œè°ƒåº¦ï¼ˆ25msï¼‰ï¼Œè€Œä¸æ˜¯ç”¨å®ƒæ¥æ’­æ”¾å£°éŸ³
            // è¿™æ ·å¯ä»¥ç¡®ä¿èŠ‚æ‹æ€»æ˜¯æå‰è°ƒåº¦å¥½
            metronomeSchedulerInterval = setInterval(scheduleMetronomeBeat, 25);

            // æ›´æ–°UI
            updateMetronomeUI();
        }

        // åœæ­¢èŠ‚æ‹å™¨
        function stopMetronome() {
            if (metronomeInterval) {
                clearInterval(metronomeInterval);
                metronomeInterval = null;
            }

            // ğŸ”§ æ¸…é™¤è°ƒåº¦å™¨å®šæ—¶å™¨
            if (metronomeSchedulerInterval) {
                clearInterval(metronomeSchedulerInterval);
                metronomeSchedulerInterval = null;
            }
            // æ¸…ç†æ‰€æœ‰å¾…è§¦å‘çš„UIèŠ‚æ‹å®šæ—¶å™¨
            if (metronomeUIBeatTimeouts && metronomeUIBeatTimeouts.length) {
                for (const tid of metronomeUIBeatTimeouts) { try { clearTimeout(tid); } catch(_) {} }
                metronomeUIBeatTimeouts = [];
            }
            const headerIndicator = document.getElementById('headerBeatIndicator');
            if (headerIndicator) headerIndicator.classList.remove('beat');

            isMetronomeRunning = false;

            // é‡ç½®èŠ‚æ‹è®¡æ•°
            metronomeStartTime = null;
            metronomeCurrentBeat = 0;

            updateMetronomeUI();

            console.log('ğŸ”‡ èŠ‚æ‹å™¨å·²åœæ­¢');
        }

        // åˆ‡æ¢èŠ‚æ‹å™¨å¼€å…³
        function toggleMetronome() {
            if (isMetronomeRunning) {
                stopMetronome();
            } else {
                startMetronome();
            }
        }

        // æ›´æ–°èŠ‚æ‹å™¨UI
        function updateMetronomeUI() {
            const headerToggleBtn = document.getElementById('headerMetronomeBtn');
            
            // æ›´æ–°headerä¸­çš„æŒ‰é’®
            if (headerToggleBtn) {
                if (isMetronomeRunning) {
                    headerToggleBtn.classList.add('active');
                    headerToggleBtn.textContent = 'ğŸµ';
                    headerToggleBtn.title = 'åœæ­¢èŠ‚æ‹å™¨';
                } else {
                    headerToggleBtn.classList.remove('active');
                    headerToggleBtn.textContent = 'ğŸµ';
                    headerToggleBtn.title = 'å¼€å§‹èŠ‚æ‹å™¨';
                }
            }
        }

        // ç›‘å¬headerä¸­BPMè¾“å…¥æ¡†çš„å˜åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            const headerSpeedInput = document.getElementById('headerMetronomeBpm');
            
            if (headerSpeedInput) {
                // å®æ—¶è¾“å…¥éªŒè¯
                headerSpeedInput.addEventListener('input', function() {
                    let value = parseInt(this.value);
                    
                    // é™åˆ¶èŒƒå›´
                    if (value < 1) {
                        this.value = 1;
                        value = 1;
                    } else if (value > 999) {
                        this.value = 999;
                        value = 999;
                    }
                    
                    if (!isNaN(value)) {
                        setMetronomeTempo(value);
                    }
                });
                
                // Enteré”®ç¡®è®¤
                headerSpeedInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter') {
                        this.blur(); // å¤±å»ç„¦ç‚¹ï¼Œè§¦å‘éªŒè¯
                    }
                });
                
                // å¤±å»ç„¦ç‚¹æ—¶éªŒè¯
                headerSpeedInput.addEventListener('blur', function() {
                    let value = parseInt(this.value);
                    
                    if (isNaN(value) || value < 1) {
                        this.value = 1;
                        value = 1;
                    } else if (value > 999) {
                        this.value = 999;
                        value = 999;
                    }
                    
                    setMetronomeTempo(value);
                });

                // BPMæ‹–åŠ¨åŠŸèƒ½å®ç°
                let isDragging = false;
                let startY = 0;
                let startValue = 0;
                let dragTimeout = null;
                let hasStartedDrag = false;
                
                // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
                headerSpeedInput.addEventListener('mousedown', function(event) {
                    // åªå¤„ç†å·¦é”®ç‚¹å‡»
                    if (event.button !== 0) return;
                    
                    startY = event.clientY;
                    startValue = parseInt(this.value) || 60;
                    hasStartedDrag = false;
                    
                    console.log('BPMæ‹–åŠ¨: é¼ æ ‡æŒ‰ä¸‹', startValue);
                    
                    // é•¿æŒ‰80msåå¯åŠ¨æ‹–åŠ¨æ¨¡å¼
                    dragTimeout = setTimeout(() => {
                        isDragging = true;
                        hasStartedDrag = true;
                        
                        console.log('BPMæ‹–åŠ¨: å¯åŠ¨æ‹–åŠ¨æ¨¡å¼');
                        
                        // é˜²æ­¢æ–‡æœ¬é€‰æ‹©å’Œé»˜è®¤è¡Œä¸º
                        event.preventDefault();
                        document.body.style.userSelect = 'none';
                        document.body.style.webkitUserSelect = 'none';
                        document.body.style.mozUserSelect = 'none';
                        document.body.style.msUserSelect = 'none';
                        
                        // æ·»åŠ æ‹–åŠ¨ä¸­çš„è§†è§‰åé¦ˆ
                        this.style.cursor = 'ns-resize';
                        this.classList.add('dragging');
                        this.blur(); // å¤±å»ç„¦ç‚¹ï¼Œé¿å…é”®ç›˜è¾“å…¥å¹²æ‰°
                    }, 80);
                });
                
                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ - ç»‘å®šåˆ°å…¨å±€
                const handleMouseMove = function(event) {
                    if (!isDragging || !hasStartedDrag) return;
                    
                    const deltaY = startY - event.clientY; // å‘ä¸Šä¸ºæ­£ï¼Œå‘ä¸‹ä¸ºè´Ÿ
                    const sensitivity = 1; // æ‹–åŠ¨çµæ•åº¦ï¼Œæ¯1åƒç´ æ”¹å˜1ä¸ªBPM
                    const newValue = Math.max(1, Math.min(999, startValue + Math.round(deltaY / sensitivity)));
                    
                    console.log('BPMæ‹–åŠ¨: ç§»åŠ¨ä¸­', deltaY, newValue);
                    
                    headerSpeedInput.value = newValue;
                    setMetronomeTempo(newValue);
                    
                    // é˜»æ­¢é»˜è®¤è¡Œä¸º
                    event.preventDefault();
                    event.stopPropagation();
                };
                
                // é¼ æ ‡é‡Šæ”¾äº‹ä»¶ - ç»‘å®šåˆ°å…¨å±€
                const handleMouseUp = function(event) {
                    console.log('BPMæ‹–åŠ¨: é¼ æ ‡é‡Šæ”¾', isDragging);
                    
                    // æ¸…é™¤é•¿æŒ‰è®¡æ—¶å™¨
                    if (dragTimeout) {
                        clearTimeout(dragTimeout);
                        dragTimeout = null;
                    }
                    
                    if (isDragging && hasStartedDrag) {
                        isDragging = false;
                        hasStartedDrag = false;
                        
                        // æ¢å¤æ–‡æœ¬é€‰æ‹©
                        document.body.style.userSelect = '';
                        document.body.style.webkitUserSelect = '';
                        document.body.style.mozUserSelect = '';
                        document.body.style.msUserSelect = '';
                        
                        // ç§»é™¤è§†è§‰åé¦ˆ
                        headerSpeedInput.style.cursor = '';
                        headerSpeedInput.classList.remove('dragging');
                        
                        console.log('BPMæ‹–åŠ¨: ç»“æŸæ‹–åŠ¨æ¨¡å¼');
                    }
                };
                
                // ç»‘å®šå…¨å±€äº‹ä»¶
                document.addEventListener('mousemove', handleMouseMove, true);
                document.addEventListener('mouseup', handleMouseUp, true);
                
                // é¼ æ ‡ç¦»å¼€è¾“å…¥æ¡†æ—¶å–æ¶ˆé•¿æŒ‰
                headerSpeedInput.addEventListener('mouseleave', function(event) {
                    if (dragTimeout && !isDragging) {
                        clearTimeout(dragTimeout);
                        dragTimeout = null;
                        console.log('BPMæ‹–åŠ¨: é¼ æ ‡ç¦»å¼€ï¼Œå–æ¶ˆé•¿æŒ‰');
                    }
                });
                
                // é˜²æ­¢å³é”®èœå•å¹²æ‰°
                headerSpeedInput.addEventListener('contextmenu', function(event) {
                    if (isDragging) {
                        event.preventDefault();
                    }
                });
            }
            initializeMetronomePatternUI();
        });
        
        // åˆå§‹åŒ–ä¸»é¢˜
        function initializeTheme() {
            switchTheme(currentTheme);
        }
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ä¸»é¢˜
        document.addEventListener('DOMContentLoaded', function() {
            initializeTheme();
        });
    </script>

    <!-- å¤šè¯­è¨€ç³»ç»Ÿ -->
    <script>
        // å¤šè¯­è¨€ç¿»è¯‘å¯¹è±¡
        const translations = {
            'zh-CN': {
                'app.title': 'Cognote - ç®€è°±è§†å¥ç”Ÿæˆå™¨',
                'app.subtitle': 'ä¸“ä¸šçº§ç®€è°±è§†å¥ä¸éŸ³ä¹ç†è®ºå·¥å…·',
                'app.jianpuMode': 'ç®€è°±è§†å¥',
                'app.melodyMode': 'æ—‹å¾‹è§†å¥',
                'app.intervalMode': 'éŸ³ç¨‹è§†å¥',
                'app.chordMode': 'å’Œå¼¦è§†å¥',
                'app.rhythmMode': 'èŠ‚å¥è§†å¥',
                'controls.interval': 'éŸ³ç¨‹è·¨åº¦',
                'controls.intervalSettings': 'éŸ³ç¨‹è®¾ç½®',
                'controls.measures': 'å°èŠ‚æ•°',
                'controls.measures2': '2å°èŠ‚',
                'controls.measures4': '4å°èŠ‚',
                'controls.measures8': '8å°èŠ‚',
                'controls.key': 'è°ƒå·',
                'controls.keySettings': 'è°ƒå·è®¾ç½®',
                'controls.time': 'æ‹å·',
                'controls.timeSettings': 'æ‹å·è®¾ç½®',
                'controls.clef': 'è°±å·',
                'controls.clefSettings': 'è°±å·è®¾ç½®',
                'controls.mode': 'æ¨¡å¼',
                'mode.free': 'è‡ªç”±',
                'mode.challenge': 'æŒ‘æˆ˜',
                'controls.rangeMin': 'æœ€ä½éŸ³',
                'controls.rangeMax': 'æœ€é«˜éŸ³',
                'controls.jianpu': 'ç®€è°±',
                'controls.englishNames': 'éŸ³å',
                'controls.accidental': 'ä¸´æ—¶è®°å·',
                'controls.metronome': 'èŠ‚æ‹å™¨',
                'controls.metronomePattern': 'èŠ‚æ‹å™¨èŠ‚å¥å‹',
                'controls.generate': 'ç”Ÿæˆæ—‹å¾‹',
                'controls.previous': 'ä¸Šä¸€æ¡',
                'controls.next': 'ä¸‹ä¸€æ¡',
                'controls.play': 'æ’­æ”¾',
                'controls.stop': 'åœæ­¢',
                'controls.tempo': 'é€Ÿåº¦',
                'controls.playbackNote': 'æ’­æ”¾é€Ÿåº¦è·ŸéšèŠ‚æ‹å™¨è®¾ç½®',
                'controls.rhythm': 'èŠ‚å¥è®¾ç½®',
                'controls.articulation': 'æ¼”å¥æŠ€å·§',
                'controls.practiceCounter': 'ç»ƒä¹ è®¡æ•°',
                'controls.practiceAdd': '+',
                'controls.practiceReset': '-',
                'score.empty': 'ç‚¹å‡»ç”Ÿæˆç®€è°±å¼€å§‹ç»ƒä¹ ',
                'settings.title': 'è®¾ç½®',
                'settings.theme': 'ä¸»é¢˜',
                'settings.language': 'è¯­è¨€',
                'settings.lightMode': 'æµ…è‰²æ¨¡å¼',
                'settings.darkMode': 'æ·±è‰²æ¨¡å¼',
                'settings.midi': 'MIDI è¾“å…¥',
                'midi.enable': 'å¯ç”¨',
                'midi.device': 'è®¾å¤‡',
                'midi.status.unsupported': 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ MIDI',
                'midi.status.permission': 'æœªæˆæƒ MIDI è®¿é—®',
                'midi.status.nodevice': 'æœªæ£€æµ‹åˆ° MIDI è®¾å¤‡',
                'midi.status.connected': 'å·²è¿æ¥: {device}',
                'midi.status.disconnected': 'è®¾å¤‡å·²æ–­å¼€',
                'midi.status.disabled': 'MIDI å·²å…³é—­',
                'settings.mic': 'éº¦å…‹é£è¾“å…¥',
                'mic.enable': 'å¯ç”¨',
                'mic.device': 'è®¾å¤‡',
                'mic.device.unknown': 'éº¦å…‹é£ {index}',
                'mic.status.unsupported': 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£è¾“å…¥',
                'mic.status.permission': 'æœªæˆæƒéº¦å…‹é£è®¿é—®',
                'mic.status.permissionNeeded': 'è¯·å…è®¸éº¦å…‹é£æƒé™ä»¥æ˜¾ç¤ºè®¾å¤‡åç§°',
                'mic.status.error': 'éº¦å…‹é£å¯åŠ¨å¤±è´¥',
                'mic.status.nodevice': 'æœªæ£€æµ‹åˆ°éº¦å…‹é£è®¾å¤‡',
                'mic.status.ready': 'éº¦å…‹é£å·²å°±ç»ª',
                'mic.status.readyDevice': 'éº¦å…‹é£å·²å°±ç»ª: {device}',
                'mic.status.listening': 'éº¦å…‹é£ç›‘å¬ä¸­',
                'mic.status.listeningDevice': 'éº¦å…‹é£ç›‘å¬ä¸­: {device}',
                'mic.status.disabled': 'éº¦å…‹é£å·²å…³é—­',
                'settings.metronome': 'èŠ‚æ‹å™¨',
                'settings.tempo': 'é€Ÿåº¦ (BPM)',
                'settings.startMetronome': 'å¼€å§‹èŠ‚æ‹å™¨',
                'settings.stopMetronome': 'åœæ­¢èŠ‚æ‹å™¨',
                // Modal titles
                'modal.rhythm.title': 'èŠ‚å¥è®¾ç½®',
                'modal.keySignature.title': 'è°ƒå·è®¾ç½®',
                'modal.timeSignature.title': 'æ‹å·è®¾ç½®',
                'modal.interval.title': 'éŸ³ç¨‹è·¨åº¦è®¾ç½®',
                'modal.clef.title': 'è°±å·è®¾ç½®',
                'modal.articulation.title': 'Articulations',
                'modal.challenge.title': 'æŒ‘æˆ˜æ¨¡å¼',
                'modal.metronomePattern.title': 'èŠ‚æ‹å™¨èŠ‚å¥å‹',
                'metronomePattern.enable': 'å¯ç”¨è‡ªå®šä¹‰èŠ‚å¥',
                'metronomePattern.subdivision': 'ç»†åˆ†',
                'metronomePattern.subdivision.beat': 'æ¯æ‹1ä¸‹',
                'metronomePattern.subdivision.eighth': 'æ¯æ‹2åˆ† (å…«åˆ†)',
                'metronomePattern.subdivision.triplet': 'æ¯æ‹3åˆ† (ä¸‰è¿)',
                'metronomePattern.subdivision.sixteenth': 'æ¯æ‹4åˆ† (åå…­åˆ†)',
                'metronomePattern.bars': 'å°èŠ‚æ•°',
                'metronomePattern.bars.1': '1å°èŠ‚',
                'metronomePattern.bars.2': '2å°èŠ‚',
                'metronomePattern.bars.4': '4å°èŠ‚',
                'metronomePattern.timeSig': 'å½“å‰æ‹å·',
                'metronomePattern.hint': 'ç‚¹å‡»æ–¹æ ¼å¯ç”¨/é™éŸ³èŠ‚æ‹',
                'metronomePattern.resetBeats': 'é‡ç½®ä¸ºæ¯æ‹',
                'metronomePattern.clear': 'å…¨éƒ¨é™éŸ³',
                // Modal content
                'modal.rhythm.basicUnit': 'åŸºæœ¬èŠ‚å¥å•ä½',
                'modal.keySignature.major': 'å¤§è°ƒ (Major)',
                'modal.keySignature.minor': 'å°è°ƒ (Minor)',
                'modal.timeSignature.selection': 'æ‹å·é€‰é¡¹',
                'modal.interval.selection': 'æœ€å¤§éŸ³ç¨‹è·¨åº¦é€‰é¡¹',
                'modal.clef.selection': 'è°±å·é€‰é¡¹',
                'challenge.prepTime': 'å‡†å¤‡æ—¶é—´ï¼ˆç§’ï¼‰',
                'challenge.bpm': 'BPM',
                'challenge.cursor': 'å…‰æ ‡',
                'challenge.metronome': 'èŠ‚æ‹å™¨',
                'challenge.hide': 'éšè—',
                'challenge.modeToggle': 'æŒ‘æˆ˜æ¨¡å¼',
                'challenge.calibration': 'è¾“å…¥æ ¡å‡†',
                'challenge.cursorHint': 'å…‰æ ‡å¼€å…³ï¼šå…‰æ ‡ç”¨äºæç¤ºå½“å‰åº”æ¼”å¥çš„ä½ç½®ï¼Œcount-inç»“æŸåå‡ºç°å¹¶éšæ—‹å¾‹è·³åŠ¨ã€‚',
                'challenge.hideHint': 'éšè—å¼€å…³ï¼šå¼€å¯åï¼Œç³»ç»Ÿåœ¨è¿›å…¥ä¸‹ä¸€å°èŠ‚æ—¶ä¼šè‡ªåŠ¨é®æŒ¡ä¸Šä¸€å°èŠ‚ï¼Œä»…ä¿ç•™å½“å‰é˜…è¯»åŒºã€‚',
                'challenge.preparingLabel': 'å‡†å¤‡',
                'challenge.seconds': 'ç§’',
                'button.start': 'å¼€å§‹',
                'button.cancel': 'å–æ¶ˆ',
                // Clef types
                'clef.options': 'è°±å·é€‰é¡¹',
                'clef.treble': 'é«˜éŸ³è°±å· (Gè°±å·)',
                'clef.bass': 'ä½éŸ³è°±å· (Fè°±å·)',
                'clef.alto': 'ä¸­éŸ³è°±å· (Cè°±å·)',
                // Articulation types
                'articulation.basic.title': 'åŸºæœ¬æ¼”å¥æ³• (Basic Articulations)',
                'articulation.guitar.title': 'å‰ä»–æŠ€å·§ (Guitar Techniques)',
                'articulation.staccato': 'Staccato (æ–­å¥) â€¢',
                'articulation.accent': 'Accent (é‡éŸ³) >',
                'articulation.acciaccatura': 'Acciaccatura (çŸ­å€šéŸ³)',
                'articulation.hammer': 'Hammer-on (å‡»å¼¦) H',
                'articulation.pulloff': 'Pull-off (å‹¾å¼¦) P',
                'articulation.advancedFreq': 'é«˜çº§é¢‘ç‡è®¾ç½®',
                'rhythm.advancedFreq': 'é«˜çº§é¢‘ç‡è®¾ç½®',
                'rhythm.freqDesc': 'è°ƒæ•´å„èŠ‚å¥å•ä½åœ¨æ—‹å¾‹ä¸­çš„å‡ºç°é¢‘ç‡ (0% = ä¸ä½¿ç”¨, 100% = ä¼˜å…ˆä½¿ç”¨)',
                'articulation.freqDesc': 'è°ƒæ•´å„æ¼”å¥æ³•åœ¨æ—‹å¾‹ä¸­çš„å‡ºç°é¢‘ç‡ (0% = ä¸ä½¿ç”¨, 100% = ç»å¸¸ä½¿ç”¨)',
                'articulation.basicFreq': 'åŸºæœ¬æ¼”å¥æ³•é¢‘ç‡',
                'articulation.guitarFreq': 'å‰ä»–æŠ€å·§é¢‘ç‡',
                'articulation.freq.staccato': 'Staccato (æ–­å¥) é¢‘ç‡:',
                'articulation.freq.accent': 'Accent (é‡éŸ³) é¢‘ç‡:',
                'articulation.freq.acciaccatura': 'Acciaccatura (çŸ­å€šéŸ³) é¢‘ç‡:',
                'articulation.freq.slur': 'å‡»å‹¾å¼¦é¢‘ç‡:',
                // Interval types
                'interval.singleSelect': 'åªèƒ½é€‰æ‹©ä¸€ä¸ªéŸ³ç¨‹ä½œä¸ºæœ€å¤§è·¨åº¦',
                'interval.minor2nd': 'å°äºŒåº¦',
                'interval.major2nd': 'å¤§äºŒåº¦',
                'interval.minor3rd': 'å°ä¸‰åº¦',
                'interval.major3rd': 'å¤§ä¸‰åº¦',
                'interval.perfect4th': 'å®Œå…¨å››åº¦',
                'interval.tritone': 'å¢å››åº¦/å‡äº”åº¦',
                'interval.perfect5th': 'å®Œå…¨äº”åº¦',
                'interval.minor6th': 'å°å…­åº¦',
                'interval.major6th': 'å¤§å…­åº¦',
                'interval.minor7th': 'å°ä¸ƒåº¦',
                'interval.major7th': 'å¤§ä¸ƒåº¦',
                'interval.perfect8th': 'å®Œå…¨å…«åº¦',
                // Rhythm types
                'rhythm.whole': 'å…¨éŸ³ç¬¦',
                'rhythm.dottedHalf': 'é™„ç‚¹äºŒåˆ†éŸ³ç¬¦',
                'rhythm.half': 'äºŒåˆ†éŸ³ç¬¦',
                'rhythm.dottedQuarter': 'é™„ç‚¹å››åˆ†éŸ³ç¬¦',
                'rhythm.quarter': 'å››åˆ†éŸ³ç¬¦',
                'rhythm.eighth': 'å…«åˆ†éŸ³ç¬¦',
                'rhythm.sixteenth': 'åå…­åˆ†éŸ³ç¬¦',
                'rhythm.triplet': 'ä¸‰è¿éŸ³',
                'rhythm.duplet': 'äºŒè¿éŸ³',
                'rhythm.quadruplet': 'å››è¿éŸ³',
                'rhythm.dottedOptions': 'é™„ç‚¹éŸ³ç¬¦é€‰é¡¹',
                'rhythm.allowDotted': 'å…è®¸é™„ç‚¹éŸ³ç¬¦ (æ ¹æ®å·²é€‰èŠ‚å¥è‡ªåŠ¨ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬)',
                'rhythm.freq.dottedOverall': 'é™„ç‚¹éŸ³ç¬¦æ€»ä½“é¢‘ç‡:',
                'rhythm.freq.whole': 'å…¨éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.dottedHalf': 'é™„ç‚¹äºŒåˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.half': 'äºŒåˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.dottedQuarter': 'é™„ç‚¹å››åˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.quarter': 'å››åˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.dottedEighth': 'é™„ç‚¹å…«åˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.eighth': 'å…«åˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.sixteenth': 'åå…­åˆ†éŸ³ç¬¦é¢‘ç‡:',
                'rhythm.freq.triplet': 'ä¸‰è¿éŸ³é¢‘ç‡:',
                'rhythm.dottedDesc': 'å‹¾é€‰åå°†è‡ªåŠ¨ä¸ºå·²é€‰æ‹©çš„èŠ‚å¥ç±»å‹ç”Ÿæˆé™„ç‚¹ç‰ˆæœ¬',
                'rhythm.dottedExample': 'ä¾‹å¦‚ï¼šå‹¾é€‰å››åˆ†éŸ³ç¬¦+é™„ç‚¹éŸ³ç¬¦ â†’ å¯ç”Ÿæˆå››åˆ†éŸ³ç¬¦å’Œé™„ç‚¹å››åˆ†éŸ³ç¬¦',
                'time.2-4': '2/4 æ‹',
                'time.3-4': '3/4 æ‹',
                'time.4-4': '4/4 æ‹',
                'time.6-8': '6/8 æ‹',
                'time.custom': 'è‡ªå®šä¹‰',
                'time.custom.beats': 'æ‹æ•°',
                'time.custom.denominator': 'å•ä½',
                'time.custom.hint': 'ç¤ºä¾‹ï¼š5/4ã€7/4ã€5/8ã€7/8',
                'button.selectAll': 'å…¨é€‰',
                'button.selectAllMajor': 'å…¨é€‰',
                'button.selectAllMinor': 'å…¨é€‰',
                'button.save': 'ä¿å­˜è®¾ç½®',
                'button.saveOnly': 'ä¿å­˜',
                'button.cancel': 'å–æ¶ˆ',
                'button.advanced': 'é«˜çº§è®¾ç½®',
                'button.hideAdvanced': 'éšè—é«˜çº§è®¾ç½®',
                'button.resetDefault': 'è¿”å›é»˜è®¤',
            },
            'zh-TW': {
                'app.title': 'Cognote - ç°¡è­œè¦–å¥ç”Ÿæˆå™¨',
                'app.subtitle': 'å°ˆæ¥­ç´šç°¡è­œè¦–å¥èˆ‡éŸ³æ¨‚ç†è«–å·¥å…·',
                'app.jianpuMode': 'ç°¡è­œè¦–å¥',
                'app.melodyMode': 'æ—‹å¾‹è¦–å¥',
                'app.intervalMode': 'éŸ³ç¨‹è¦–å¥',
                'app.chordMode': 'å’Œå¼¦è¦–å¥',
                'app.rhythmMode': 'ç¯€å¥è¦–å¥',
                'controls.interval': 'éŸ³ç¨‹è·¨åº¦',
                'controls.intervalSettings': 'éŸ³ç¨‹è¨­ç½®',
                'controls.measures': 'å°ç¯€æ•¸',
                'controls.measures2': '2å°ç¯€',
                'controls.measures4': '4å°ç¯€',
                'controls.measures8': '8å°ç¯€',
                'controls.key': 'èª¿è™Ÿ',
                'controls.keySettings': 'èª¿è™Ÿè¨­ç½®',
                'controls.time': 'æ‹è™Ÿ',
                'controls.timeSettings': 'æ‹è™Ÿè¨­ç½®',
                'controls.clef': 'è­œè™Ÿ',
                'controls.clefSettings': 'è­œè™Ÿè¨­ç½®',
                'controls.mode': 'æ¨¡å¼',
                'mode.free': 'è‡ªç”±',
                'mode.challenge': 'æŒ‘æˆ°',
                'controls.rangeMin': 'æœ€ä½éŸ³',
                'controls.rangeMax': 'æœ€é«˜éŸ³',
                'controls.jianpu': 'ç°¡è­œ',
                'controls.englishNames': 'éŸ³å',
                'controls.accidental': 'è‡¨æ™‚è¨˜è™Ÿ',
                'controls.metronome': 'ç¯€æ‹å™¨',
                'controls.metronomePattern': 'ç¯€æ‹å™¨ç¯€å¥å‹',
                'controls.generate': 'ç”Ÿæˆæ—‹å¾‹',
                'controls.previous': 'ä¸Šä¸€æ¢',
                'controls.next': 'ä¸‹ä¸€æ¢',
                'controls.play': 'æ’­æ”¾',
                'controls.stop': 'åœæ­¢',
                'controls.tempo': 'é€Ÿåº¦',
                'controls.playbackNote': 'æ’­æ”¾é€Ÿåº¦è·Ÿéš¨ç¯€æ‹å™¨è¨­ç½®',
                'controls.rhythm': 'ç¯€å¥è¨­ç½®',
                'controls.articulation': 'æ¼”å¥æŠ€å·§',
                'controls.practiceCounter': 'ç·´ç¿’è¨ˆæ•¸',
                'controls.practiceAdd': '+',
                'controls.practiceReset': '-',
                'score.empty': 'é»æ“Šç”Ÿæˆç°¡è­œé–‹å§‹ç·´ç¿’',
                'settings.title': 'è¨­ç½®',
                'settings.theme': 'ä¸»é¡Œ',
                'settings.language': 'èªè¨€',
                'settings.lightMode': 'æ·ºè‰²æ¨¡å¼',
                'settings.darkMode': 'æ·±è‰²æ¨¡å¼',
                'settings.midi': 'MIDI è¼¸å…¥',
                'midi.enable': 'å•Ÿç”¨',
                'midi.device': 'è£ç½®',
                'midi.status.unsupported': 'ç›®å‰ç€è¦½å™¨ä¸æ”¯æ´ MIDI',
                'midi.status.permission': 'æœªæˆæ¬Š MIDI å­˜å–',
                'midi.status.nodevice': 'æœªåµæ¸¬åˆ° MIDI è£ç½®',
                'midi.status.connected': 'å·²é€£æ¥: {device}',
                'midi.status.disconnected': 'è£ç½®å·²æ–·é–‹',
                'midi.status.disabled': 'MIDI å·²é—œé–‰',
                'settings.mic': 'éº¥å…‹é¢¨è¼¸å…¥',
                'mic.enable': 'å•Ÿç”¨',
                'mic.device': 'è£ç½®',
                'mic.device.unknown': 'éº¥å…‹é¢¨ {index}',
                'mic.status.unsupported': 'ç›®å‰ç€è¦½å™¨ä¸æ”¯æ´éº¥å…‹é¢¨è¼¸å…¥',
                'mic.status.permission': 'æœªæˆæ¬Šéº¥å…‹é¢¨å­˜å–',
                'mic.status.permissionNeeded': 'è«‹å…è¨±éº¥å…‹é¢¨æ¬Šé™ä»¥é¡¯ç¤ºè£ç½®åç¨±',
                'mic.status.error': 'éº¥å…‹é¢¨å•Ÿå‹•å¤±æ•—',
                'mic.status.nodevice': 'æœªåµæ¸¬åˆ°éº¥å…‹é¢¨è£ç½®',
                'mic.status.ready': 'éº¥å…‹é¢¨å·²å°±ç·’',
                'mic.status.readyDevice': 'éº¥å…‹é¢¨å·²å°±ç·’: {device}',
                'mic.status.listening': 'éº¥å…‹é¢¨ç›£è½ä¸­',
                'mic.status.listeningDevice': 'éº¥å…‹é¢¨ç›£è½ä¸­: {device}',
                'mic.status.disabled': 'éº¥å…‹é¢¨å·²é—œé–‰',
                'settings.metronome': 'ç¯€æ‹å™¨',
                'settings.tempo': 'é€Ÿåº¦ (BPM)',
                'settings.startMetronome': 'é–‹å§‹ç¯€æ‹å™¨',
                'settings.stopMetronome': 'åœæ­¢ç¯€æ‹å™¨',
                // Modal titles
                'modal.rhythm.title': 'ç¯€å¥è¨­ç½®',
                'modal.keySignature.title': 'èª¿è™Ÿè¨­ç½®',
                'modal.timeSignature.title': 'æ‹è™Ÿè¨­ç½®',
                'modal.interval.title': 'éŸ³ç¨‹è·¨åº¦è¨­ç½®',
                'modal.clef.title': 'è­œè™Ÿè¨­ç½®',
                'modal.articulation.title': 'Articulations',
                'modal.challenge.title': 'æŒ‘æˆ°æ¨¡å¼',
                'modal.metronomePattern.title': 'ç¯€æ‹å™¨ç¯€å¥å‹',
                'metronomePattern.enable': 'å•Ÿç”¨è‡ªè¨‚ç¯€å¥',
                'metronomePattern.subdivision': 'ç´°åˆ†',
                'metronomePattern.subdivision.beat': 'æ¯æ‹1ä¸‹',
                'metronomePattern.subdivision.eighth': 'æ¯æ‹2åˆ† (å…«åˆ†)',
                'metronomePattern.subdivision.triplet': 'æ¯æ‹3åˆ† (ä¸‰é€£)',
                'metronomePattern.subdivision.sixteenth': 'æ¯æ‹4åˆ† (åå…­åˆ†)',
                'metronomePattern.bars': 'å°ç¯€æ•¸',
                'metronomePattern.bars.1': '1å°ç¯€',
                'metronomePattern.bars.2': '2å°ç¯€',
                'metronomePattern.bars.4': '4å°ç¯€',
                'metronomePattern.timeSig': 'ç›®å‰æ‹è™Ÿ',
                'metronomePattern.hint': 'é»æ“Šæ–¹æ ¼å•Ÿç”¨/éœéŸ³ç¯€æ‹',
                'metronomePattern.resetBeats': 'é‡ç½®ç‚ºæ¯æ‹',
                'metronomePattern.clear': 'å…¨éƒ¨éœéŸ³',
                // Modal content
                'modal.rhythm.basicUnit': 'åŸºæœ¬ç¯€å¥å–®ä½',
                'modal.keySignature.major': 'å¤§èª¿ (Major)',
                'modal.keySignature.minor': 'å°èª¿ (Minor)',
                'modal.timeSignature.selection': 'æ‹è™Ÿé¸é …',
                'modal.interval.selection': 'æœ€å¤§éŸ³ç¨‹è·¨åº¦é¸é …',
                'modal.clef.selection': 'è­œè™Ÿé¸é …',
                'challenge.prepTime': 'æº–å‚™æ™‚é–“ï¼ˆç§’ï¼‰',
                'challenge.bpm': 'BPM',
                'challenge.cursor': 'å…‰æ¨™',
                'challenge.metronome': 'ç¯€æ‹å™¨',
                'challenge.hide': 'éš±è—',
                'challenge.modeToggle': 'æŒ‘æˆ°æ¨¡å¼',
                'challenge.calibration': 'è¼¸å…¥æ ¡æº–',
                'challenge.cursorHint': 'å…‰æ¨™é–‹é—œï¼šå…‰æ¨™ç”¨æ–¼æç¤ºç›®å‰æ‡‰æ¼”å¥çš„ä½ç½®ï¼Œcount-inçµæŸå¾Œå‡ºç¾ä¸¦éš¨æ—‹å¾‹è·³å‹•ã€‚',
                'challenge.hideHint': 'éš±è—é–‹é—œï¼šé–‹å•Ÿå¾Œï¼Œç³»çµ±åœ¨é€²å…¥ä¸‹ä¸€å°ç¯€æ™‚æœƒè‡ªå‹•é®æ“‹ä¸Šä¸€å°ç¯€ï¼Œåƒ…ä¿ç•™ç•¶å‰é–±è®€å€ã€‚',
                'challenge.preparingLabel': 'æº–å‚™',
                'challenge.seconds': 'ç§’',
                'button.start': 'é–‹å§‹',
                'button.cancel': 'å–æ¶ˆ',
                // Clef types
                'clef.options': 'è­œè™Ÿé¸é …',
                'clef.treble': 'é«˜éŸ³è­œè™Ÿ (Gè­œè™Ÿ)',
                'clef.bass': 'ä½éŸ³è­œè™Ÿ (Fè­œè™Ÿ)',
                'clef.alto': 'ä¸­éŸ³è­œè™Ÿ (Cè­œè™Ÿ)',
                // Articulation types
                'articulation.basic.title': 'åŸºæœ¬æ¼”å¥æ³• (Basic Articulations)',
                'articulation.guitar.title': 'å‰ä»–æŠ€å·§ (Guitar Techniques)',
                'articulation.staccato': 'Staccato (æ–·å¥) â€¢',
                'articulation.accent': 'Accent (é‡éŸ³) >',
                'articulation.acciaccatura': 'Acciaccatura (çŸ­å€šéŸ³)',
                'articulation.hammer': 'Hammer-on (æ“Šå¼¦) H',
                'articulation.pulloff': 'Pull-off (å‹¾å¼¦) P',
                'articulation.advancedFreq': 'é«˜ç´šé »ç‡è¨­ç½®',
                'rhythm.advancedFreq': 'é«˜ç´šé »ç‡è¨­ç½®',
                'rhythm.freqDesc': 'èª¿æ•´å„ç¯€å¥å–®ä½åœ¨æ—‹å¾‹ä¸­çš„å‡ºç¾é »ç‡ (0% = ä¸ä½¿ç”¨, 100% = å„ªå…ˆä½¿ç”¨)',
                'articulation.freqDesc': 'èª¿æ•´å„æ¼”å¥æ³•åœ¨æ—‹å¾‹ä¸­çš„å‡ºç¾é »ç‡ (0% = ä¸ä½¿ç”¨, 100% = ç¶“å¸¸ä½¿ç”¨)',
                'articulation.basicFreq': 'åŸºæœ¬æ¼”å¥æ³•é »ç‡',
                'articulation.guitarFreq': 'å‰ä»–æŠ€å·§é »ç‡',
                'articulation.freq.staccato': 'Staccato (æ–·å¥) é »ç‡:',
                'articulation.freq.accent': 'Accent (é‡éŸ³) é »ç‡:',
                'articulation.freq.acciaccatura': 'Acciaccatura (çŸ­å€šéŸ³) é »ç‡:',
                'articulation.freq.slur': 'æ“Šå‹¾å¼¦é »ç‡:',
                // Interval types
                'interval.singleSelect': 'åªèƒ½é¸æ“‡ä¸€å€‹éŸ³ç¨‹ä½œç‚ºæœ€å¤§è·¨åº¦',
                'interval.minor2nd': 'å°äºŒåº¦',
                'interval.major2nd': 'å¤§äºŒåº¦',
                'interval.minor3rd': 'å°ä¸‰åº¦',
                'interval.major3rd': 'å¤§ä¸‰åº¦',
                'interval.perfect4th': 'å®Œå…¨å››åº¦',
                'interval.tritone': 'å¢å››åº¦/æ¸›äº”åº¦',
                'interval.perfect5th': 'å®Œå…¨äº”åº¦',
                'interval.minor6th': 'å°å…­åº¦',
                'interval.major6th': 'å¤§å…­åº¦',
                'interval.minor7th': 'å°ä¸ƒåº¦',
                'interval.major7th': 'å¤§ä¸ƒåº¦',
                'interval.perfect8th': 'å®Œå…¨å…«åº¦',
                // Rhythm types
                'rhythm.whole': 'å…¨éŸ³ç¬¦',
                'rhythm.dottedHalf': 'é™„é»äºŒåˆ†éŸ³ç¬¦',
                'rhythm.half': 'äºŒåˆ†éŸ³ç¬¦',
                'rhythm.dottedQuarter': 'é™„é»å››åˆ†éŸ³ç¬¦',
                'rhythm.quarter': 'å››åˆ†éŸ³ç¬¦',
                'rhythm.eighth': 'å…«åˆ†éŸ³ç¬¦',
                'rhythm.sixteenth': 'åå…­åˆ†éŸ³ç¬¦',
                'rhythm.triplet': 'ä¸‰é€£éŸ³',
                'rhythm.duplet': 'äºŒé€£éŸ³',
                'rhythm.quadruplet': 'å››é€£éŸ³',
                'rhythm.dottedOptions': 'é™„é»éŸ³ç¬¦é¸é …',
                'rhythm.allowDotted': 'å…è¨±é™„é»éŸ³ç¬¦ (æ ¹æ“šå·²é¸ç¯€å¥è‡ªå‹•ç”Ÿæˆé™„é»ç‰ˆæœ¬)',
                'rhythm.freq.dottedOverall': 'é™„é»éŸ³ç¬¦ç¸½é«”é »ç‡:',
                'rhythm.freq.whole': 'å…¨éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.dottedHalf': 'é™„é»äºŒåˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.half': 'äºŒåˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.dottedQuarter': 'é™„é»å››åˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.quarter': 'å››åˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.dottedEighth': 'é™„é»å…«åˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.eighth': 'å…«åˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.sixteenth': 'åå…­åˆ†éŸ³ç¬¦é »ç‡:',
                'rhythm.freq.triplet': 'ä¸‰é€£éŸ³é »ç‡:',
                'rhythm.dottedDesc': 'å‹¾é¸å¾Œå°‡è‡ªå‹•ç‚ºå·²é¸æ“‡çš„ç¯€å¥é¡å‹ç”Ÿæˆé™„é»ç‰ˆæœ¬',
                'rhythm.dottedExample': 'ä¾‹å¦‚ï¼šå‹¾é¸å››åˆ†éŸ³ç¬¦+é™„é»éŸ³ç¬¦ â†’ å¯ç”Ÿæˆå››åˆ†éŸ³ç¬¦å’Œé™„é»å››åˆ†éŸ³ç¬¦',
                'time.2-4': '2/4 æ‹',
                'time.3-4': '3/4 æ‹',
                'time.4-4': '4/4 æ‹',
                'time.6-8': '6/8 æ‹',
                'time.custom': 'è‡ªè¨‚',
                'time.custom.beats': 'æ‹æ•¸',
                'time.custom.denominator': 'å–®ä½',
                'time.custom.hint': 'ä¾‹ï¼š5/4ã€7/4ã€5/8ã€7/8',
                'button.selectAll': 'å…¨é¸',
                'button.selectAllMajor': 'å…¨é¸å¤§èª¿',
                'button.selectAllMinor': 'å…¨é¸å°èª¿',
                'button.save': 'ä¿å­˜è¨­ç½®',
                'button.saveOnly': 'ä¿å­˜',
                'button.cancel': 'å–æ¶ˆ',
                'button.advanced': 'é«˜ç´šè¨­ç½®',
                'button.hideAdvanced': 'éš±è—é«˜ç´šè¨­ç½®',
                'button.resetDefault': 'è¿”å›é»˜èª',
            },
            'en': {
                'app.title': 'Cognote - Jianpu Sight-Reading Generator',
                'app.subtitle': 'Professional Jianpu Rendering & Music Theory Tool',
                'app.jianpuMode': 'Jianpu Sight-Reading',
                'app.melodyMode': 'Melody Sight-Reading',
                'app.intervalMode': 'Interval Sight-Reading',
                'app.chordMode': 'Chord Sight-Reading',
                'app.rhythmMode': 'Rhythm Sight-Reading',
                'controls.interval': 'Interval Range',
                'controls.intervalSettings': 'Interval Settings',
                'controls.measures': 'Measures',
                'controls.measures2': '2 Measures',
                'controls.measures4': '4 Measures',
                'controls.measures8': '8 Measures',
                'controls.key': 'Key Signature',
                'controls.keySettings': 'Key Settings',
                'controls.time': 'Time Signature',
                'controls.timeSettings': 'Time Settings',
                'controls.clef': 'Clef',
                'controls.clefSettings': 'Clef Settings',
                'controls.mode': 'Mode',
                'mode.free': 'Free',
                'mode.challenge': 'Challenge',
                'controls.rangeMin': 'Lowest Note',
                'controls.rangeMax': 'Highest Note',
                'controls.jianpu': 'Numbered Notation',
                'controls.englishNames': 'Note Names',
                'controls.accidental': 'Accidentals',
                'controls.metronome': 'Metronome',
                'controls.metronomePattern': 'Metronome Pattern',
                'controls.generate': 'Generate Melody',
                'controls.previous': 'Previous',
                'controls.next': 'Next',
                'controls.play': 'Play',
                'controls.stop': 'Stop',
                'controls.tempo': 'Tempo',
                'controls.playbackNote': 'Playback follows metronome tempo',
                'controls.rhythm': 'Rhythm Settings',
                'controls.articulation': 'Articulations',
                'controls.practiceCounter': 'Practice',
                'controls.practiceAdd': '+',
                'controls.practiceReset': '-',
                'score.empty': 'Click Generate to Start Jianpu Practice',
                'settings.title': 'Settings',
                'settings.theme': 'Theme',
                'settings.language': 'Language',
                'settings.lightMode': 'Light Mode',
                'settings.darkMode': 'Dark Mode',
                'settings.midi': 'MIDI Input',
                'midi.enable': 'Enable',
                'midi.device': 'Device',
                'midi.status.unsupported': 'MIDI is not supported in this browser',
                'midi.status.permission': 'MIDI access not authorized',
                'midi.status.nodevice': 'No MIDI devices detected',
                'midi.status.connected': 'Connected: {device}',
                'midi.status.disconnected': 'Device disconnected',
                'midi.status.disabled': 'MIDI is off',
                'settings.mic': 'Microphone Input',
                'mic.enable': 'Enable',
                'mic.device': 'Device',
                'mic.device.unknown': 'Microphone {index}',
                'mic.status.unsupported': 'Microphone input is not supported in this browser',
                'mic.status.permission': 'Microphone access not authorized',
                'mic.status.permissionNeeded': 'Allow microphone access to show device names',
                'mic.status.error': 'Failed to start microphone',
                'mic.status.nodevice': 'No microphone devices detected',
                'mic.status.ready': 'Microphone is ready',
                'mic.status.readyDevice': 'Microphone is ready: {device}',
                'mic.status.listening': 'Microphone listening',
                'mic.status.listeningDevice': 'Microphone listening: {device}',
                'mic.status.disabled': 'Microphone is off',
                'settings.metronome': 'Metronome',
                'settings.tempo': 'Tempo (BPM)',
                'settings.startMetronome': 'Start Metronome',
                'settings.stopMetronome': 'Stop Metronome',
                // Modal titles
                'modal.rhythm.title': 'Rhythm Settings',
                'modal.keySignature.title': 'Key Signature Settings',
                'modal.timeSignature.title': 'Time Signature Settings',
                'modal.interval.title': 'Interval Range Settings',
                'modal.clef.title': 'Clef Settings',
                'modal.articulation.title': 'Articulations',
                'modal.challenge.title': 'Challenge Mode',
                'modal.metronomePattern.title': 'Metronome Pattern',
                'metronomePattern.enable': 'Enable custom pattern',
                'metronomePattern.subdivision': 'Subdivision',
                'metronomePattern.subdivision.beat': '1 per beat',
                'metronomePattern.subdivision.eighth': '2 per beat (eighths)',
                'metronomePattern.subdivision.triplet': '3 per beat (triplets)',
                'metronomePattern.subdivision.sixteenth': '4 per beat (sixteenths)',
                'metronomePattern.bars': 'Bars',
                'metronomePattern.bars.1': '1 bar',
                'metronomePattern.bars.2': '2 bars',
                'metronomePattern.bars.4': '4 bars',
                'metronomePattern.timeSig': 'Time signature',
                'metronomePattern.hint': 'Click squares to enable/mute beats',
                'metronomePattern.resetBeats': 'Reset to beats',
                'metronomePattern.clear': 'Mute all',
                // Modal content
                'modal.rhythm.basicUnit': 'Basic Rhythm Unit',
                'modal.keySignature.major': 'Major',
                'modal.keySignature.minor': 'Minor',
                'modal.timeSignature.selection': 'Time Signature Options',
                'modal.interval.selection': 'Maximum Interval Range Options',
                'modal.clef.selection': 'Clef Options',
                'challenge.prepTime': 'Preparation Time (sec)',
                'challenge.bpm': 'BPM',
                'challenge.cursor': 'Cursor',
                'challenge.metronome': 'Metronome',
                'challenge.hide': 'Hide',
                'challenge.modeToggle': 'Challenge Mode',
                'challenge.calibration': 'Input Calibration',
                'challenge.cursorHint': 'Cursor toggle: The cursor indicates the exact playing position and appears after the count-in, following the melody.',
                'challenge.hideHint': 'Hide toggle: When enabled, the previous measure is masked as you enter the next, leaving only the current reading area.',
                'challenge.preparingLabel': 'Prep',
                'challenge.seconds': 'sec',
                'button.start': 'Start',
                'button.cancel': 'Cancel',
                // Clef types
                'clef.options': 'Clef Options',
                'clef.treble': 'Treble Clef (G Clef)',
                'clef.bass': 'Bass Clef (F Clef)',
                'clef.alto': 'Alto Clef (C Clef)',
                // Articulation types
                'articulation.basic.title': 'Basic Articulations',
                'articulation.guitar.title': 'Guitar Techniques',
                'articulation.staccato': 'Staccato â€¢',
                'articulation.accent': 'Accent >',
                'articulation.acciaccatura': 'Acciaccatura',
                'articulation.hammer': 'Hammer-on H',
                'articulation.pulloff': 'Pull-off P',
                'articulation.advancedFreq': 'Advanced Frequency Settings',
                'rhythm.advancedFreq': 'Advanced Frequency Settings',
                'rhythm.freqDesc': 'Adjust the frequency of each rhythm unit in melody generation (0% = not used, 100% = preferred)',
                'articulation.freqDesc': 'Adjust frequency of each articulation in melody (0% = not used, 100% = frequently used)',
                'articulation.basicFreq': 'Basic Articulation Frequency',
                'articulation.guitarFreq': 'Guitar Technique Frequency',
                'articulation.freq.staccato': 'Staccato Frequency:',
                'articulation.freq.accent': 'Accent Frequency:',
                'articulation.freq.acciaccatura': 'Acciaccatura Frequency:',
                'articulation.freq.slur': 'Hammer-on/Pull-off Frequency:',
                // Interval types
                'interval.singleSelect': 'Can only select one interval as maximum span',
                'interval.minor2nd': 'Minor 2nd',
                'interval.major2nd': 'Major 2nd',
                'interval.minor3rd': 'Minor 3rd',
                'interval.major3rd': 'Major 3rd',
                'interval.perfect4th': 'Perfect 4th',
                'interval.tritone': 'Tritone (Aug 4th/Dim 5th)',
                'interval.perfect5th': 'Perfect 5th',
                'interval.minor6th': 'Minor 6th',
                'interval.major6th': 'Major 6th',
                'interval.minor7th': 'Minor 7th',
                'interval.major7th': 'Major 7th',
                'interval.perfect8th': 'Perfect 8th (Octave)',
                // Rhythm types
                'rhythm.whole': 'Whole Note',
                'rhythm.dottedHalf': 'Dotted Half Note',
                'rhythm.half': 'Half Note',
                'rhythm.dottedQuarter': 'Dotted Quarter Note',
                'rhythm.quarter': 'Quarter Note',
                'rhythm.eighth': 'Eighth Note',
                'rhythm.sixteenth': 'Sixteenth Note',
                'rhythm.triplet': 'Triplet',
                'rhythm.duplet': 'Duplet',
                'rhythm.quadruplet': 'Quadruplet',
                'rhythm.dottedOptions': 'Dotted Note Options',
                'rhythm.allowDotted': 'Allow Dotted Notes (Auto-generate dotted versions based on selected rhythms)',
                'rhythm.freq.dottedOverall': 'Overall Dotted Note Frequency:',
                'rhythm.freq.whole': 'Whole Note Frequency:',
                'rhythm.freq.dottedHalf': 'Dotted Half Note Frequency:',
                'rhythm.freq.half': 'Half Note Frequency:',
                'rhythm.freq.dottedQuarter': 'Dotted Quarter Note Frequency:',
                'rhythm.freq.quarter': 'Quarter Note Frequency:',
                'rhythm.freq.dottedEighth': 'Dotted Eighth Note Frequency:',
                'rhythm.freq.eighth': 'Eighth Note Frequency:',
                'rhythm.freq.sixteenth': 'Sixteenth Note Frequency:',
                'rhythm.freq.triplet': 'Triplet Frequency:',
                'rhythm.dottedDesc': 'Auto-generate dotted versions for selected rhythm types when checked',
                'rhythm.dottedExample': 'Example: Select quarter note + dotted notes â†’ generates both quarter notes and dotted quarter notes',
                'time.2-4': '2/4 Time',
                'time.3-4': '3/4 Time',
                'time.4-4': '4/4 Time',
                'time.6-8': '6/8 Time',
                'time.custom': 'Custom',
                'time.custom.beats': 'Beats',
                'time.custom.denominator': 'Unit',
                'time.custom.hint': 'Examples: 5/4, 7/4, 5/8, 7/8',
                'button.selectAll': 'Select All',
                'button.selectAllMajor': 'Select All Major',
                'button.selectAllMinor': 'Select All Minor',
                'button.save': 'Save Settings',
                'button.saveOnly': 'Save',
                'button.cancel': 'Cancel',
                'button.advanced': 'Advanced Settings',
                'button.hideAdvanced': 'Hide Advanced Settings',
                'button.resetDefault': 'Reset to Default',
            }
        };

        // è¯­è¨€åˆ‡æ¢ç›¸å…³å˜é‡
        let currentLanguage = 'zh-CN'; // é»˜è®¤å€¼ï¼Œç¨ååœ¨DOMContentLoadedä¸­æ­£ç¡®åˆå§‹åŒ–
        
        // è¯­è¨€æŒ‰é’®æ˜¾ç¤ºæ–‡æœ¬
        const languageLabels = {
            'zh-CN': 'ğŸŒ ç®€ä½“ä¸­æ–‡',
            'zh-TW': 'ğŸŒ ç¹é«”ä¸­æ–‡',
            'en': 'ğŸŒ English'
        };


        // åˆ‡æ¢è¯­è¨€
        function switchLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('preferredLanguage', lang);

            // æ›´æ–°æŒ‰é’®æ–‡æœ¬ (å¦‚æœå­˜åœ¨æ—§çš„è¯­è¨€æŒ‰é’®)
            const languageBtn = document.getElementById('languageBtn');
            if (languageBtn) {
                languageBtn.textContent = languageLabels[lang];
            }

            // åº”ç”¨ç¿»è¯‘
            applyTranslations();

            // è§¦å‘ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ (åŒæ ‡ç­¾é¡µå†…å®æ—¶åŒæ­¥)
            if (window.ICStudioSync) {
                window.ICStudioSync.syncLanguage(lang, 'jianpu-tool');
            }

            // å…³é—­è®¾ç½®èœå•
            closeSettings();
            
            console.log(`ğŸŒ è¯­è¨€å·²åˆ‡æ¢åˆ°: ${lang}`);
        }

        // åº”ç”¨ç¿»è¯‘
        function applyTranslations() {
            const elements = document.querySelectorAll('[data-i18n]');
            const currentTranslations = translations[currentLanguage] || translations['zh-CN'];

            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (currentTranslations[key]) {
                    // æ£€æŸ¥å…ƒç´ æ˜¯å¦åªåŒ…å«æ–‡æœ¬å†…å®¹ï¼ˆæ²¡æœ‰å­å…ƒç´ ï¼‰
                    if (element.children.length === 0) {
                        // åªæœ‰æ–‡æœ¬å†…å®¹ï¼Œç›´æ¥æ›¿æ¢
                        element.textContent = currentTranslations[key];
                    } else {
                        // æœ‰å­å…ƒç´ ï¼Œéœ€è¦ä¿ç•™ç»“æ„ï¼Œåªæ›¿æ¢æ–‡æœ¬èŠ‚ç‚¹
                        const textNodes = [];
                        const walker = document.createTreeWalker(
                            element,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        let node;
                        while (node = walker.nextNode()) {
                            if (node.nodeValue.trim()) {
                                textNodes.push(node);
                            }
                        }

                        // å¦‚æœåªæœ‰ä¸€ä¸ªä¸»è¦æ–‡æœ¬èŠ‚ç‚¹ï¼Œæ›¿æ¢å®ƒ
                        if (textNodes.length === 1) {
                            textNodes[0].nodeValue = currentTranslations[key];
                        } else {
                            // å¤æ‚ç»“æ„ï¼Œä½¿ç”¨textContentä½œä¸ºåå¤‡
                            element.textContent = currentTranslations[key];
                        }
                    }
                }
            });
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–è¯­è¨€
        document.addEventListener('DOMContentLoaded', function() {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„è¯­è¨€åå¥½
            const savedLanguage = localStorage.getItem('preferredLanguage') || localStorage.getItem('jianpuPreferredLanguage');
            if (!localStorage.getItem('preferredLanguage') && savedLanguage) {
                localStorage.setItem('preferredLanguage', savedLanguage);
            }

            if (savedLanguage) {
                // å¦‚æœæœ‰ä¿å­˜çš„è¯­è¨€åå¥½ï¼Œè®¾ç½®å½“å‰è¯­è¨€å¹¶æ˜¾ç¤ºå¯¹åº”è¯­è¨€åç§°
                currentLanguage = savedLanguage;
                const languageBtn = document.getElementById('languageBtn');
                if (languageBtn) {
                    languageBtn.textContent = languageLabels[currentLanguage];
                }
                console.log(`ğŸ’¾ ä½¿ç”¨ä¿å­˜çš„è¯­è¨€: ${savedLanguage}`);
            } else {
                // å¦‚æœæ²¡æœ‰ä¿å­˜çš„è¯­è¨€åå¥½ï¼Œè‡ªåŠ¨æ£€æµ‹æµè§ˆå™¨è¯­è¨€
                const browserLang = navigator.language || navigator.userLanguage;
                // æ£€æµ‹æ˜¯å¦ä¸ºä¸­æ–‡ç¯å¢ƒï¼ˆæ”¯æŒ zh, zh-CN, zh-TW, zh-HKï¼‰
                const isChinese = browserLang && browserLang.toLowerCase().startsWith('zh');
                currentLanguage = isChinese ? 'zh-CN' : 'en';
                const languageBtn = document.getElementById('languageBtn');
                if (languageBtn) {
                    languageBtn.textContent = 'ğŸŒ æ–‡/A';
                }
                console.log(`ğŸŒ æµè§ˆå™¨è¯­è¨€æ£€æµ‹: ${browserLang} â†’ ${currentLanguage}`);
            }

            // åº”ç”¨ç¿»è¯‘
            applyTranslations();

            console.log(`ğŸŒ ç®€è°±å·¥å…·åˆå§‹åŒ–è¯­è¨€: ${currentLanguage}`);

            // ============ é™„ç‚¹éŸ³ç¬¦è®¾ç½®ä¿å­˜/æ¢å¤ ============
            const allowDottedNotesCheckbox = document.getElementById('allowDottedNotes');
            if (allowDottedNotesCheckbox) {
                // ç‰ˆæœ¬æ§åˆ¶ï¼šå¼ºåˆ¶æ–°ç”¨æˆ·å’Œå‡çº§ç”¨æˆ·ä½¿ç”¨æ–°é»˜è®¤å€¼
                const settingsVersion = localStorage.getItem('jianpuSettingsVersion');
                const currentVersion = '2.0'; // ç‰ˆæœ¬ 2.0ï¼šé™„ç‚¹éŸ³ç¬¦é»˜è®¤å‹¾é€‰

                if (settingsVersion !== currentVersion) {
                    // ç‰ˆæœ¬å‡çº§æˆ–é¦–æ¬¡è®¿é—®ï¼Œä½¿ç”¨æ–°çš„é»˜è®¤å€¼
                    allowDottedNotesCheckbox.checked = true;
                    localStorage.setItem('jianpuAllowDottedNotes', 'true');
                    localStorage.setItem('jianpuSettingsVersion', currentVersion);
                    console.log(`ğŸ”„ è®¾ç½®ç‰ˆæœ¬å‡çº§åˆ° ${currentVersion}ï¼Œä½¿ç”¨æ–°é»˜è®¤å€¼`);
                } else {
                    // æ¢å¤ä¿å­˜çš„çŠ¶æ€
                    const savedDottedState = localStorage.getItem('jianpuAllowDottedNotes');
                    allowDottedNotesCheckbox.checked = (savedDottedState === 'true');
                }

                // ç›‘å¬å˜åŒ–å¹¶ä¿å­˜
                allowDottedNotesCheckbox.addEventListener('change', function() {
                    localStorage.setItem('jianpuAllowDottedNotes', this.checked);
                    console.log(`ğŸ’¾ é™„ç‚¹éŸ³ç¬¦è®¾ç½®å·²ä¿å­˜: ${this.checked}`);
                });

                console.log(`âœ… é™„ç‚¹éŸ³ç¬¦è®¾ç½®åˆå§‹åŒ–: ${allowDottedNotesCheckbox.checked}`);
            }

            // ============ åŒå·¥å…·åŒæ­¥ç›‘å¬æœºåˆ¶ ============
            // ç›‘å¬æœ¬å·¥å…·å¯¹localStorageçš„ä¿®æ”¹
            window.addEventListener('storage', function(e) {
                if (e.key === 'preferredTheme' && e.newValue !== currentTheme) {
                    console.log(`ğŸ”„ ç®€è°±è§†å¥å·¥å…·æ£€æµ‹åˆ°ä¸»é¢˜å˜åŒ–: ${currentTheme} â†’ ${e.newValue}`);
                    currentTheme = e.newValue;
                    document.documentElement.setAttribute('data-theme', currentTheme);
                    console.log(`ğŸ¨ ç®€è°±è§†å¥å·¥å…·ä¸»é¢˜å·²åŒæ­¥ä¸º: ${currentTheme}`);
                }

                if (e.key === 'preferredLanguage' && e.newValue !== currentLanguage) {
                    console.log(`ğŸ”„ ç®€è°±è§†å¥å·¥å…·æ£€æµ‹åˆ°è¯­è¨€å˜åŒ–: ${currentLanguage} â†’ ${e.newValue}`);
                    currentLanguage = e.newValue;
                    applyTranslations();
                    console.log(`ğŸŒ ç®€è°±è§†å¥å·¥å…·è¯­è¨€å·²åŒæ­¥ä¸º: ${currentLanguage}`);
                }
            });

            console.log('ğŸ”— ç®€è°±è§†å¥å·¥å…·localStorageåŒæ­¥ç›‘å¬å·²å¯ç”¨');

            // ============ ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ ============
            // åˆ›å»ºå…¨å±€åŒæ­¥å‡½æ•°ï¼Œæ”¯æŒåŒæ ‡ç­¾é¡µå†…å®æ—¶åŒæ­¥
            window.ICStudioSync = window.ICStudioSync || {
                tools: new Set(),

                // æ³¨å†Œå·¥å…·
                registerTool: function(toolName, callbacks) {
                    this.tools.add({
                        name: toolName,
                        onThemeChange: callbacks.onThemeChange,
                        onLanguageChange: callbacks.onLanguageChange
                    });
                    console.log(`ğŸ”— ${toolName} å·²æ³¨å†Œåˆ°ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ`);
                },

                // åŒæ­¥ä¸»é¢˜åˆ°æ‰€æœ‰å·¥å…·
                syncTheme: function(newTheme, fromTool) {
                    console.log(`ğŸ”„ ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ: åŒæ­¥ä¸»é¢˜ ${newTheme} (æ¥æº: ${fromTool})`);
                    this.tools.forEach(tool => {
                        if (tool.name !== fromTool && tool.onThemeChange) {
                            try {
                                tool.onThemeChange(newTheme);
                            } catch (error) {
                                console.warn(`âš ï¸ ${tool.name} ä¸»é¢˜åŒæ­¥å¤±è´¥:`, error);
                            }
                        }
                    });
                },

                // åŒæ­¥è¯­è¨€åˆ°æ‰€æœ‰å·¥å…·
                syncLanguage: function(newLanguage, fromTool) {
                    console.log(`ğŸ”„ ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ: åŒæ­¥è¯­è¨€ ${newLanguage} (æ¥æº: ${fromTool})`);
                    this.tools.forEach(tool => {
                        if (tool.name !== fromTool && tool.onLanguageChange) {
                            try {
                                tool.onLanguageChange(newLanguage);
                            } catch (error) {
                                console.warn(`âš ï¸ ${tool.name} è¯­è¨€åŒæ­¥å¤±è´¥:`, error);
                            }
                        }
                    });
                }
            };

            // æ³¨å†Œç®€è°±å·¥å…·åˆ°ç»Ÿä¸€åŒæ­¥ç³»ç»Ÿ
            window.ICStudioSync.registerTool('jianpu-tool', {
                onThemeChange: function(newTheme) {
                    if (currentTheme !== newTheme) {
                        console.log(`ğŸ¨ ç®€è°±å·¥å…·æ¥æ”¶ä¸»é¢˜åŒæ­¥: ${currentTheme} â†’ ${newTheme}`);
                        currentTheme = newTheme;
                        document.documentElement.setAttribute('data-theme', currentTheme);
                    }
                },
                onLanguageChange: function(newLanguage) {
                    if (currentLanguage !== newLanguage) {
                        console.log(`ğŸŒ ç®€è°±å·¥å…·æ¥æ”¶è¯­è¨€åŒæ­¥: ${currentLanguage} â†’ ${newLanguage}`);
                        currentLanguage = newLanguage;
                        applyTranslations();
                    }
                }
            });
        });
    </script>

    <script>
        // é‡å†™æ¨¡æ€æ¡†å…³é—­å‡½æ•°ä»¥é‡ç½®å…¨é€‰çŠ¶æ€
        const originalCloseRhythmSettings = window.closeRhythmSettings;
        const originalCloseArticulationSettings = window.closeArticulationSettings;
        const originalCloseKeySettings = window.closeKeySettings;
        const originalCloseTimeSignatureSettings = window.closeTimeSignatureSettings;
        const originalCloseIntervalSettings = window.closeIntervalSettings;
        const originalCloseClefSettings = window.closeClefSettings;

        if (typeof originalCloseRhythmSettings === 'function') {
            window.closeRhythmSettings = function() {
                originalCloseRhythmSettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        if (typeof originalCloseArticulationSettings === 'function') {
            window.closeArticulationSettings = function() {
                originalCloseArticulationSettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        if (typeof originalCloseKeySettings === 'function') {
            window.closeKeySettings = function() {
                originalCloseKeySettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        if (typeof originalCloseTimeSignatureSettings === 'function') {
            window.closeTimeSignatureSettings = function() {
                originalCloseTimeSignatureSettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        if (typeof originalCloseIntervalSettings === 'function') {
            window.closeIntervalSettings = function() {
                originalCloseIntervalSettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        if (typeof originalCloseClefSettings === 'function') {
            window.closeClefSettings = function() {
                originalCloseClefSettings();
                if (typeof resetSelectAllStates === 'function') resetSelectAllStates();
            };
        }

        // ğŸŒ ç®€åŒ–çš„æ ‡ç­¾ç¿»è¯‘ç³»ç»Ÿï¼ˆç§»é™¤å…·ä½“é€‰æ‹©å†…å®¹æ˜¾ç¤ºï¼‰
        // ä¸»é¡µé¢æŒ‰é’®åªæ˜¾ç¤ºåŸºç¡€æ ‡ç­¾ï¼Œä¸æ˜¾ç¤ºå…·ä½“é€‰æ‹©çš„å†…å®¹
        console.log('ğŸŒ ä½¿ç”¨ç®€åŒ–çš„æ ‡ç­¾ç¿»è¯‘ç³»ç»Ÿ - ä¸»é¡µé¢æŒ‰é’®åªæ˜¾ç¤ºåŸºç¡€æ ‡ç­¾');

        // åŠ¨æ€éšè—åŒ…å«ç‰¹å®šæ–‡æœ¬çš„SVGå…ƒç´ 
        function hideTitleAndInstrumentElements() {
            // ç­‰å¾…ä¸€ä¼šå„¿è®©OSMDæ¸²æŸ“å®Œæˆ
            setTimeout(() => {
                const scoreDiv = document.getElementById('score');
                if (scoreDiv) {
                    // æŸ¥æ‰¾æ‰€æœ‰SVG textå…ƒç´ 
                    const textElements = scoreDiv.querySelectorAll('svg text');
                    textElements.forEach(element => {
                        const text = element.textContent || element.innerText;
                        if (text && (
                            text.includes('Piano') || 
                            text.includes('Untitled') || 
                            text.includes('Untitled Score') ||
                            text.trim() === 'Piano' ||
                            text.trim() === 'Untitled Score'
                        )) {
                            element.style.display = 'none';
                            element.style.visibility = 'hidden';
                            console.log('éšè—æ–‡æœ¬å…ƒç´ :', text);
                        }
                    });
                    
                    // ä¹Ÿæ£€æŸ¥å…¶ä»–å¯èƒ½çš„å…ƒç´ 
                    const allElements = scoreDiv.querySelectorAll('*');
                    allElements.forEach(element => {
                        const text = element.textContent || element.innerText;
                        if (text && element.tagName !== 'SCRIPT' && (
                            text.trim() === 'Piano' ||
                            text.trim() === 'Untitled Score'
                        )) {
                            element.style.display = 'none';
                            element.style.visibility = 'hidden';
                            console.log('éšè—å…ƒç´ :', element.tagName, text);
                        }
                    });

                    // ğŸ”§ ä¿®å¤ï¼šç§»é™¤å¤šä½™çš„æ–­å¥ç‚¹ï¼ˆstaccato dotsï¼‰
                    removeExtraStaccatoDots();
                }
            }, 500);
        }

        // ğŸ”§ ä¿®å¤MusicXMLä¸­çš„å¤šä½™é™„ç‚¹
        function cleanupExcessiveDots(musicXML) {
            console.log('ğŸ”§ å¼€å§‹æ¸…ç†MusicXMLä¸­çš„å¤šä½™é™„ç‚¹...');

            // æ–¹æ³•1ï¼šå®Œå…¨ç§»é™¤æ‰€æœ‰ <dot/> å…ƒç´ 
            let cleanedXML = musicXML.replace(/<dot\s*\/?>|<dot><\/dot>/g, '');

            // æ–¹æ³•2ï¼šå¦‚æœéœ€è¦ä¿ç•™åˆç†çš„é™„ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨æ›´ç²¾ç¡®çš„æ¸…ç†
            // è¿™é‡Œæˆ‘ä»¬å…ˆç®€å•åœ°ç§»é™¤æ‰€æœ‰é™„ç‚¹ï¼Œå› ä¸ºç”Ÿæˆçš„éŸ³ç¬¦åº”è¯¥éƒ½æ˜¯åŸºç¡€æ—¶å€¼

            console.log('ğŸ”§ å·²ç§»é™¤æ‰€æœ‰ <dot> å…ƒç´ ');

            return cleanedXML;
        }

        // ğŸ”§ ä¿®å¤é™„ç‚¹é—®é¢˜ï¼šç§»é™¤å¤šä½™çš„æ–­å¥ç‚¹
        function removeExtraStaccatoDots() {
            // ç®€è°±æ¨¡å¼ä½¿ç”¨ simple-notationï¼Œåœ†ç‚¹ä»£è¡¨é«˜å…«åº¦ï¼Œä¸èƒ½ç§»é™¤
            if (window.currentJianpuRenderer) return;
            const scoreDiv = document.getElementById('score');
            if (!scoreDiv) return;

            // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„æ–­å¥ç‚¹å…ƒç´ 
            const svgElements = scoreDiv.querySelectorAll('svg circle, svg ellipse, svg use, svg path');

            let removedCount = 0;

            svgElements.forEach((element, index) => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯å°åœ†ç‚¹ï¼ˆæ–­å¥è®°å·ï¼‰
                if (element.tagName === 'circle') {
                    const radius = parseFloat(element.getAttribute('r')) || 0;
                    const cx = parseFloat(element.getAttribute('cx')) || 0;
                    const cy = parseFloat(element.getAttribute('cy')) || 0;

                    // å¦‚æœæ˜¯å°åœ†ç‚¹ï¼ˆåŠå¾„å°äº3ï¼‰ï¼Œå¾ˆå¯èƒ½æ˜¯æ–­å¥è®°å·
                    if (radius > 0 && radius < 3) {
                        // éšè—è¿™ä¸ªå…ƒç´ 
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                        removedCount++;
                    }
                }

                // æ£€æŸ¥useå…ƒç´ ï¼ˆå¯èƒ½æ˜¯ç¬¦å·å¼•ç”¨ï¼‰
                if (element.tagName === 'use') {
                    const href = element.getAttribute('href') || element.getAttribute('xlink:href') || '';
                    if (href.includes('staccato') || href.includes('dot') || href.includes('articulation')) {
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                        removedCount++;
                    }
                }

                // æ£€æŸ¥pathå…ƒç´ ä¸­å¯èƒ½çš„æ–­å¥ç‚¹
                if (element.tagName === 'path') {
                    const d = element.getAttribute('d') || '';
                    // å¦‚æœè·¯å¾„å¾ˆçŸ­ä¸”åŒ…å«åœ†å¼§ï¼Œå¯èƒ½æ˜¯æ–­å¥ç‚¹
                    if (d.length < 50 && (d.includes('C') || d.includes('A'))) {
                        const bbox = element.getBBox ? element.getBBox() : { width: 0, height: 0 };
                        if (bbox.width < 10 && bbox.height < 10) {
                            element.style.display = 'none';
                            element.style.visibility = 'hidden';
                            removedCount++;
                        }
                    }
                }
            });
        }
        
        // æ¸…é™¤ç©ºè°±å­æç¤ºä¿¡æ¯
        function clearEmptyScoreMessage() {
            const scoreDiv = document.getElementById('score');
            if (scoreDiv) {
                const emptyMessage = scoreDiv.querySelector('.empty-score-message');
                if (emptyMessage) {
                    emptyMessage.remove();
                }
            }
        }

        // ç›‘å¬OSMDæ¸²æŸ“å®Œæˆ
        const originalGenerateMelody = window.generateMelody;
        if (originalGenerateMelody) {
            window.generateMelody = function(...args) {
                // è‡ªåŠ¨åœæ­¢å½“å‰æ’­æ”¾
                if (window.isPlayingMelody) {
                    window.isPlayingMelody = false;
                    // åœæ­¢æ‰€æœ‰è°ƒåº¦çš„æ’­æ”¾
                    if (window.melodyScheduledSounds) {
                        window.melodyScheduledSounds.forEach(sound => {
                            try {
                                if (sound.oscillator) {
                                    sound.oscillator.stop();
                                }
                                if (sound.source) {
                                    sound.source.stop();
                                }
                                if (sound.element) {
                                    sound.element.pause();
                                    sound.element.src = '';
                                }
                            } catch (e) {
                                // èŠ‚ç‚¹å¯èƒ½å·²ç»åœæ­¢ï¼Œå¿½ç•¥é”™è¯¯
                            }
                        });
                        window.melodyScheduledSounds = [];
                    }
                    // æ›´æ–°æ’­æ”¾æŒ‰é’®çŠ¶æ€
                    if (typeof updatePlayButton === 'function') {
                        updatePlayButton();
                    }
                }

                // æ¸…é™¤ç©ºè°±å­æç¤ºä¿¡æ¯
                clearEmptyScoreMessage();

                // ğŸ”’ é¢„éšè—å®¹å™¨ï¼ˆå‚è€ƒéŸ³ç¨‹è§†å¥å·¥å…·çš„å®ç°ï¼‰
                if (typeof isMelodyHidden !== 'undefined' && isMelodyHidden) {
                    const scoreEl = document.getElementById('score');
                    if (scoreEl) {
                        scoreEl.style.opacity = '0';
                        scoreEl.style.filter = 'blur(10px)';
                        console.log('ğŸ”’ æ¸²æŸ“å‰é¢„éšè—å®¹å™¨ï¼ˆé¿å…é—ªç°ï¼‰');
                    }
                }

                const result = originalGenerateMelody.apply(this, args);
                hideTitleAndInstrumentElements();
                // ğŸ”’ éšè—çŠ¶æ€ç°åœ¨åœ¨ renderScore ä¸­ç«‹å³åº”ç”¨ï¼Œæ— éœ€å»¶è¿Ÿ
                return result;
            };
        }

        // åŒ…è£… previousMelody å’Œ nextMelodyï¼Œæ·»åŠ åœæ­¢æ’­æ”¾é€»è¾‘
        const originalPreviousMelody = window.previousMelody;
        if (originalPreviousMelody) {
            window.previousMelody = function(...args) {
                // åˆ‡æ¢æ—¶è‡ªåŠ¨åœæ­¢æ’­æ”¾
                if (window.isPlayingMelody) {
                    window.isPlayingMelody = false;
                    if (window.melodyScheduledSounds) {
                        window.melodyScheduledSounds.forEach(sound => {
                            try {
                                if (sound.oscillator) sound.oscillator.stop();
                                if (sound.source) sound.source.stop();
                                if (sound.element) {
                                    sound.element.pause();
                                    sound.element.src = '';
                                }
                            } catch (e) {}
                        });
                        window.melodyScheduledSounds = [];
                    }
                    if (typeof updatePlayButton === 'function') {
                        updatePlayButton();
                    }
                }
                return originalPreviousMelody.apply(this, args);
            };
        }

        const originalNextMelody = window.nextMelody;
        if (originalNextMelody) {
            window.nextMelody = function(...args) {
                // åˆ‡æ¢æ—¶è‡ªåŠ¨åœæ­¢æ’­æ”¾
                if (window.isPlayingMelody) {
                    window.isPlayingMelody = false;
                    if (window.melodyScheduledSounds) {
                        window.melodyScheduledSounds.forEach(sound => {
                            try {
                                if (sound.oscillator) sound.oscillator.stop();
                                if (sound.source) sound.source.stop();
                                if (sound.element) {
                                    sound.element.pause();
                                    sound.element.src = '';
                                }
                            } catch (e) {}
                        });
                        window.melodyScheduledSounds = [];
                    }
                    if (typeof updatePlayButton === 'function') {
                        updatePlayButton();
                    }
                }
                return originalNextMelody.apply(this, args);
            };
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåä¹Ÿæ‰§è¡Œä¸€æ¬¡
        document.addEventListener('DOMContentLoaded', () => {
            hideTitleAndInstrumentElements();
            // å®šæœŸæ£€æŸ¥
            setInterval(hideTitleAndInstrumentElements, 2000);

            // ğŸµ æ·»åŠ ä¹è°±å®¹å™¨ç‚¹å‡»äº‹ä»¶ï¼Œè§¦å‘ç”Ÿæˆæ—‹å¾‹
            const scoreContainer = document.getElementById('score');
            if (scoreContainer) {
                scoreContainer.addEventListener('click', function(event) {
                    console.log('ğŸµ ç”¨æˆ·ç‚¹å‡»ä¹è°±å®¹å™¨ï¼Œè§¦å‘ç”Ÿæˆæ—‹å¾‹');
                    // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»çš„æ˜¯ä¹è°±å†…å®¹è€Œä¸æ˜¯æ§åˆ¶æŒ‰é’®
                    if (!event.target.closest('button') && !event.target.closest('.control')) {
                        generateMelody();
                    }
                });
                // æ·»åŠ æ ·å¼æç¤ºï¼Œè®©ç”¨æˆ·çŸ¥é“å®¹å™¨å¯ä»¥ç‚¹å‡»
                scoreContainer.style.cursor = 'pointer';
                scoreContainer.title = 'ç‚¹å‡»ç”Ÿæˆæ–°æ—‹å¾‹';
            }
        });

        // ====== ç›´æ¥åœ¨HTMLä¸­å®šä¹‰çš„ç®€å•æ’­æ”¾å™¨ ======
        console.log('ğŸ¹ ç›´æ¥åœ¨HTMLä¸­åˆ›å»ºæ’­æ”¾å™¨...');

        window.isPlayingMelody = false;
        window.melodyAudioCtx = null;
        window.melodyMetronomeSyncTimeout = null; // èŠ‚æ‹å™¨åŒæ­¥çš„ setTimeout ID

        function directPlayTest() {
            console.log('ğŸµ ç›´æ¥æ’­æ”¾è¢«è°ƒç”¨');

            if (window.isPlayingMelody) {
                // åœæ­¢æ’­æ”¾
                window.isPlayingMelody = false;

                // ğŸ”§ æ¸…é™¤èŠ‚æ‹å™¨åŒæ­¥çš„ setTimeoutï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (window.melodyMetronomeSyncTimeout) {
                    clearTimeout(window.melodyMetronomeSyncTimeout);
                    window.melodyMetronomeSyncTimeout = null;
                    console.log('â¹ï¸ å·²æ¸…é™¤èŠ‚æ‹å™¨åŒæ­¥å®šæ—¶å™¨');
                }

                // åœæ­¢æ‰€æœ‰è°ƒåº¦çš„æ’­æ”¾
                if (window.melodyScheduledSounds) {
                    window.melodyScheduledSounds.forEach(sound => {
                        try {
                            // å¤„ç†æŒ¯è¡å™¨èŠ‚ç‚¹ï¼ˆåˆæˆå™¨å›é€€ï¼‰
                            if (sound.oscillator) {
                                sound.oscillator.stop();
                            }
                            // å¤„ç†é‡‡æ ·å™¨çš„ BufferSource èŠ‚ç‚¹
                            if (sound.source) {
                                sound.source.stop();
                            }
                            // å¤„ç† HTMLAudioElementï¼ˆfile:// åè®®ä¸‹çš„å›é€€ï¼‰
                            if (sound.element) {
                                sound.element.pause();
                                sound.element.src = '';
                            }
                        } catch (e) {
                            // èŠ‚ç‚¹å¯èƒ½å·²ç»åœæ­¢ï¼Œå¿½ç•¥é”™è¯¯
                        }
                    });
                    window.melodyScheduledSounds = [];
                }
                updatePlayButton();
                console.log('â¹ï¸ åœæ­¢é’¢ç´æ’­æ”¾');
                return;
            }

            try {
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                if (!window.melodyAudioCtx) {
                    window.melodyAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('ğŸ¹ åˆ›å»ºäº†æ–°çš„AudioContext');
                }

                // æ£€æŸ¥çŠ¶æ€
                if (window.melodyAudioCtx.state === 'suspended') {
                    window.melodyAudioCtx.resume().then(() => {
                        console.log('ğŸ”„ AudioContextå·²æ¢å¤');
                        // ğŸ”§ ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦åœ¨resumeæœŸé—´ç”¨æˆ·ç‚¹å‡»äº†åœæ­¢
                        if (!window.isPlayingMelody) {
                            console.log('â¹ï¸ Resumeå®Œæˆå‰ç”¨æˆ·å·²åœæ­¢ï¼Œå–æ¶ˆæ’­æ”¾');
                            return;
                        }
                        startMelodyPlayback();
                    });
                } else {
                    startMelodyPlayback();
                }

            } catch (error) {
                console.error('âŒ æ’­æ”¾é”™è¯¯:', error);
                alert('æ’­æ”¾å‡ºé”™: ' + error.message);
            }
        }

        function startMelodyPlayback() {
            console.log('ğŸµ å¼€å§‹æ—‹å¾‹æ’­æ”¾');

            // è·å–å½“å‰æ—‹å¾‹æ•°æ®
            let melodyData = null;
            if (typeof getCurrentMelodyData === 'function') {
                melodyData = getCurrentMelodyData();
            } else {
                // å¦‚æœå‡½æ•°ä¸å­˜åœ¨ï¼Œå°è¯•ä»å…¨å±€å˜é‡è·å–
                if (typeof melodyHistory !== 'undefined' && typeof currentHistoryIndex !== 'undefined' &&
                    melodyHistory && melodyHistory.length > 0 && currentHistoryIndex >= 0 &&
                    currentHistoryIndex < melodyHistory.length) {
                    melodyData = melodyHistory[currentHistoryIndex];
                    console.log('ğŸ“‹ ä»å…¨å±€å˜é‡è·å–æ—‹å¾‹æ•°æ®:', melodyData);
                }
            }

            if (!melodyData) {
                console.log('âš ï¸ æ²¡æœ‰æ—‹å¾‹æ•°æ®ï¼Œæ’­æ”¾æµ‹è¯•éŸ³ç¬¦');
                // åˆå§‹åŒ–é‡‡æ ·å™¨ï¼ˆæ‡’åŠ è½½ï¼‰
                if (!window.__icSamplePlayer && window.ICSamplePlayer) {
                    window.__icSamplePlayer = new ICSamplePlayer({ rootPath: 'assets/samples/piano-ogg-full' });
                    window.__icSamplePlayer.load();
                }
                playTestNote();
                return;
            }

            // æ£€æŸ¥æ˜¯å¦ä¸ºéšè—æ¨¡å¼
            const isHiddenMode = checkIfMelodyHidden();

            if (isHiddenMode) {
                console.log('ğŸ¼ éšè—æ¨¡å¼æ¿€æ´»ï¼Œå¯åŠ¨count-in + èŠ‚æ‹å™¨');
                playCountInThenMelody(melodyData);
            } else {
                // ğŸ”§ æ™ºèƒ½æ’­æ”¾æ—¶é—´ï¼šèŠ‚æ‹å™¨å¼€å¯æ—¶å¯¹é½ç½‘æ ¼ï¼Œå…³é—­æ—¶ç«‹å³å“åº”

                // è·å–å½“å‰é€Ÿåº¦
                let tempo = 60;
                if (typeof getCurrentTempo === 'function') {
                    tempo = getCurrentTempo();
                } else if (typeof metronomeTempo !== 'undefined') {
                    tempo = metronomeTempo;
                }

                const beatDuration = 60.0 / tempo;
                const now = window.melodyAudioCtx.currentTime;
                let startTime;

                if (typeof isMetronomeRunning !== 'undefined' && isMetronomeRunning) {
                    // ğŸµ èŠ‚æ‹å™¨å¼€å¯ - å¯¹é½å…¨å±€ç½‘æ ¼ç¡®ä¿åŒæ­¥
                    const currentBeatNumber = Math.floor(now / beatDuration);
                    let nextBeatNumber = currentBeatNumber + 1;
                    startTime = nextBeatNumber * beatDuration;

                    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿ startTime è‡³å°‘åœ¨æœªæ¥ 50ms
                    const minLookahead = 0.05;
                    if (startTime < now + minLookahead) {
                        nextBeatNumber++;
                        startTime = nextBeatNumber * beatDuration;
                        console.log(`âš ï¸ æ—¶é—´å¤ªè¿‘ï¼Œè·³åˆ°ä¸‹ä¸€æ‹ (ç¬¬${nextBeatNumber}æ‹)`);
                    }

                    console.log(`ğŸµ èŠ‚æ‹å™¨å¼€å¯ - åŒæ­¥åˆ°å…¨å±€ç½‘æ ¼: BPM=${tempo}, å½“å‰=${now.toFixed(3)}s, æ’­æ”¾=${startTime.toFixed(3)}s (ç¬¬${nextBeatNumber}æ‹)`);
                } else {
                    // ğŸš€ èŠ‚æ‹å™¨å…³é—­ - ç«‹å³æ’­æ”¾ï¼Œå“åº”è¿…é€Ÿ
                    startTime = now + 0.1;
                    console.log(`ğŸš€ èŠ‚æ‹å™¨æœªå¼€å¯ - ç«‹å³æ’­æ”¾: BPM=${tempo}, å½“å‰=${now.toFixed(3)}s, æ’­æ”¾=${startTime.toFixed(3)}s`);
                }

                playFullMelody(melodyData, startTime);
            }
        }

        // æ£€æŸ¥æ—‹å¾‹æ˜¯å¦éšè—
        function checkIfMelodyHidden() {
            // æ£€æŸ¥å…¨å±€å˜é‡isMelodyHidden
            if (typeof isMelodyHidden !== 'undefined' && isMelodyHidden) {
                return true;
            }

            // æ£€æŸ¥SVGæ˜¯å¦æœ‰hidden class
            const scoreElement = document.getElementById('score');
            if (scoreElement) {
                const svgElements = scoreElement.querySelectorAll('svg');
                for (let svg of svgElements) {
                    if (svg.classList.contains('melody-hidden')) {
                        return true;
                    }
                }
            }

            return false;
        }

        function playTestNote() {
            try {
                console.log('ğŸ¹ æ’­æ”¾440Hzé’¢ç´æµ‹è¯•éŸ³ç¬¦');

                window.isPlayingMelody = true;
                updatePlayButton();

                // ä½¿ç”¨æ–°çš„é’¢ç´éŸ³è‰²æ’­æ”¾æµ‹è¯•éŸ³ç¬¦
                const now = window.melodyAudioCtx.currentTime;
                const testDuration = 1.0;
                const pianoTestNote = createPianoNote(440, now, testDuration);

                console.log('âœ… é’¢ç´æµ‹è¯•éŸ³ç¬¦å¼€å§‹æ’­æ”¾');

                // 1.5ç§’ååœæ­¢çŠ¶æ€
                setTimeout(() => {
                    window.isPlayingMelody = false;
                    updatePlayButton();
                    console.log('âœ… é’¢ç´éŸ³è‰²æ’­æ”¾å®Œæˆ - éŸ³é¢‘ç³»ç»Ÿå·¥ä½œæ­£å¸¸');

                    // æ’­æ”¾æˆåŠŸåå¯ä»¥æ‰©å±•åˆ°å®Œæ•´æ—‹å¾‹æ’­æ”¾
                    if (typeof getCurrentMelodyData === 'function') {
                        console.log('ğŸµ é’¢ç´éŸ³è‰²æµ‹è¯•æˆåŠŸï¼Œç³»ç»Ÿå‡†å¤‡å°±ç»ª');
                    }
                }, 1500);

            } catch (error) {
                console.error('âŒ é’¢ç´æµ‹è¯•éŸ³ç¬¦æ’­æ”¾å¤±è´¥:', error);
                window.isPlayingMelody = false;
                updatePlayButton();
            }
        }

        function updatePlayButton() {
            const playBtn = document.getElementById('playMelodyBtn');
            if (playBtn) {
                if (window.isPlayingMelody) {
                    playBtn.innerHTML = 'åœæ­¢';
                } else {
                    playBtn.innerHTML = 'æ’­æ”¾';
                }
                console.log('ğŸ”„ æŒ‰é’®çŠ¶æ€å·²æ›´æ–°:', window.isPlayingMelody ? 'æ’­æ”¾ä¸­' : 'å·²åœæ­¢');
            }
        }

        // åˆ‡æ¢æ—‹å¾‹æ˜¾ç¤º/éšè—
        var isMelodyHidden = false;
        function toggleMelodyVisibility() {
            isMelodyHidden = !isMelodyHidden;
            const visibilityBtn = document.getElementById('melodyVisibilityBtn');
            const scoreElement = document.getElementById('score');

            if (isMelodyHidden) {
                // éšè—æ—‹å¾‹ï¼ˆåŒæ­¥éšè—å®¹å™¨ä¸SVGï¼Œé¿å…æ¸²æŸ“å‰åçŠ¶æ€ä¸ä¸€è‡´ï¼‰
                if (scoreElement) {
                    // éšè—å®¹å™¨
                    scoreElement.style.opacity = '0';
                    scoreElement.style.filter = 'blur(10px)';

                    // éšè—SVGå…ƒç´ 
                    const svgElements = scoreElement.querySelectorAll('svg');
                    svgElements.forEach(svg => {
                        svg.classList.add('melody-hidden');
                        svg.style.opacity = '0';
                        svg.style.filter = 'blur(10px)';
                    });
                }
                if (visibilityBtn) {
                    visibilityBtn.innerHTML = 'ğŸ‘‚';
                    visibilityBtn.title = 'æ˜¾ç¤ºæ—‹å¾‹';
                    visibilityBtn.classList.add('hidden-state');
                }
                console.log('ğŸ‘‚ æ—‹å¾‹å·²éšè—ï¼ˆå®¹å™¨+SVGï¼‰');
            } else {
                // æ˜¾ç¤ºæ—‹å¾‹ï¼ˆæ¸…é™¤å®¹å™¨ä¸SVGä¸Šçš„éšè—æ ·å¼ï¼Œç¡®ä¿å¯è§ï¼‰
                if (scoreElement) {
                    // æ˜¾ç¤ºå®¹å™¨
                    scoreElement.style.opacity = '1';
                    scoreElement.style.filter = 'none';

                    // æ˜¾ç¤ºSVGå…ƒç´ 
                    const svgElements = scoreElement.querySelectorAll('svg');
                    svgElements.forEach(svg => {
                        svg.classList.remove('melody-hidden');
                        svg.style.opacity = '1';
                        svg.style.filter = 'none';
                    });
                }
                if (visibilityBtn) {
                    visibilityBtn.innerHTML = 'ğŸ‘€';
                    visibilityBtn.title = 'éšè—æ—‹å¾‹';
                    visibilityBtn.classList.remove('hidden-state');
                }
                console.log('ğŸ‘€ æ—‹å¾‹å·²æ˜¾ç¤º');
            }
        }

        // MIDIè½¬é¢‘ç‡çš„è¾…åŠ©å‡½æ•°
        function midiToFrequency(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }

        // éŸ³ç¬¦æ—¶å€¼è½¬ç§’æ•°çš„è¾…åŠ©å‡½æ•°
        function durationToSeconds(duration, tempo = 60) {
            const beatsPerSecond = tempo / 60;

            // æ”¯æŒä¸¤ç§é™„ç‚¹æ ¼å¼ï¼š
            // 1. ç‚¹åç¼€æ ¼å¼: 'quarter.' (æ¥è‡ª jianpu-sight-reading-final.js çš„æŸäº›è·¯å¾„)
            // 2. ç ´æŠ˜å·å‰ç¼€æ ¼å¼: 'dotted-quarter' (æ¥è‡ª MusicXML è§£æ)
            let normalizedDuration = duration;
            if (duration && duration.endsWith('.')) {
                const baseDuration = duration.slice(0, -1);  // ç§»é™¤ç‚¹å·
                normalizedDuration = `dotted-${baseDuration}`;
            }

            const durationMap = {
                'whole': 4,
                'half': 2,
                'quarter': 1,
                'eighth': 0.5,
                '16th': 0.25,
                '32nd': 0.125,
                'dotted-whole': 6,          // é™„ç‚¹å…¨éŸ³ç¬¦ = 6æ‹
                'dotted-half': 3,           // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦ = 3æ‹
                'dotted-quarter': 1.5,      // é™„ç‚¹å››åˆ†éŸ³ç¬¦ = 1.5æ‹
                'dotted-eighth': 0.75,      // é™„ç‚¹å…«åˆ†éŸ³ç¬¦ = 0.75æ‹
                'dotted-16th': 0.375        // é™„ç‚¹åå…­åˆ†éŸ³ç¬¦ = 0.375æ‹
            };
            const beats = durationMap[normalizedDuration] || 1;
            return beats / beatsPerSecond;
        }


        // å®‰æ’å•ä¸ªéŸ³ç¬¦æ’­æ”¾ï¼šä¼˜å…ˆä½¿ç”¨é‡‡æ ·å™¨ï¼Œå¤±è´¥å›é€€åˆ°åˆæˆå™¨
        function scheduleNotePlay(frequency, startTime, duration) {
            try {
                if (window.__icSamplePlayer && window.__icSamplePlayer.ready && window.melodyAudioCtx) {
                    const midi = Math.round(69 + 12 * Math.log2(frequency / 440));
                    const playResult = window.__icSamplePlayer.scheduleAtExternalContext(
                        window.melodyAudioCtx, startTime, midi, duration, 0.85
                    );
                    // ä¿å­˜è¿”å›å€¼ä»¥ä¾¿åœæ­¢æ—¶ä½¿ç”¨
                    if (playResult && window.melodyScheduledSounds) {
                        window.melodyScheduledSounds.push(playResult);
                    }
                    return;
                }
            } catch (e) {
                console.warn('é‡‡æ ·å™¨æ’­æ”¾å¤±è´¥ï¼Œå›é€€æŒ¯è¡å™¨:', e);
            }
            try {
                const pianoSound = createPianoNote(frequency, startTime, duration);
                window.melodyScheduledSounds.push(...pianoSound.components);
            } catch (error) {
                console.error('âŒ éŸ³ç¬¦æ’­æ”¾å®‰æ’å¤±è´¥:', error);
            }
        }

        // ä¼˜åŒ–ç‰ˆæœ¬ï¼šç›´æ¥ä½¿ç”¨ MIDI ç¼–å·ï¼Œé¿å…é¢‘ç‡â†”MIDI çš„å†—ä½™è½¬æ¢
        function scheduleNotePlayDirect(midi, startTime, duration) {
            try {
                if (window.__icSamplePlayer && window.__icSamplePlayer.ready && window.melodyAudioCtx) {
                    const playResult = window.__icSamplePlayer.scheduleAtExternalContext(
                        window.melodyAudioCtx, startTime, midi, duration, 0.85
                    );
                    // ä¿å­˜è¿”å›å€¼ä»¥ä¾¿åœæ­¢æ—¶ä½¿ç”¨
                    if (playResult && window.melodyScheduledSounds) {
                        window.melodyScheduledSounds.push(playResult);
                    }
                    return;
                }
            } catch (e) {
                console.warn('é‡‡æ ·å™¨æ’­æ”¾å¤±è´¥ï¼Œå›é€€æŒ¯è¡å™¨:', e);
            }
            // å›é€€åˆ°åˆæˆå™¨
            try {
                const frequency = 440 * Math.pow(2, (midi - 69) / 12);
                const pianoSound = createPianoNote(frequency, startTime, duration);
                window.melodyScheduledSounds.push(...pianoSound.components);
            } catch (error) {
                console.error('âŒ éŸ³ç¬¦æ’­æ”¾å®‰æ’å¤±è´¥:', error);
            }
        }

        // åˆ›å»ºé«˜å“è´¨é’¢ç´éŸ³è‰²
        function createPianoNote(frequency, startTime, duration) {
            const components = [];

            // ğŸ¹ æ ¹æ®éŸ³é«˜è°ƒæ•´å‚æ•°
            const isLowNote = frequency < 130; // C3ä»¥ä¸‹
            const isMidNote = frequency >= 130 && frequency < 520; // C3-C5
            const isHighNote = frequency >= 520; // C5ä»¥ä¸Š

            // ğŸ“Š éŸ³é«˜ç›¸å…³çš„éŸ³è‰²å‚æ•°
            const harmonicWeights = getHarmonicWeights(frequency);
            const envelopeParams = getEnvelopeParams(frequency, duration);

            // ğŸ¼ ä¸»éŸ³é¢‘é“¾ï¼šåŸºé¢‘ + æ»¤æ³¢å™¨ + å‹ç¼©å™¨
            const fundamental = window.melodyAudioCtx.createOscillator();
            const fundamentalGain = window.melodyAudioCtx.createGain();
            const mainFilter = window.melodyAudioCtx.createBiquadFilter();
            const compressor = window.melodyAudioCtx.createDynamicsCompressor();
            const outputGain = window.melodyAudioCtx.createGain();

            // åŸºé¢‘è®¾ç½®
            fundamental.frequency.value = frequency;
            fundamental.type = isMidNote ? 'triangle' : 'sawtooth';

            // ä¸»æ»¤æ³¢å™¨ - æ¨¡æ‹Ÿé’¢ç´çš„æœ¨è´¨å…±é¸£ï¼Œé™ä½æˆªæ­¢é¢‘ç‡å‰Šå¼±é«˜é¢‘
            mainFilter.type = 'lowpass';
            mainFilter.frequency.value = frequency * (isLowNote ? 2.5 : isHighNote ? 6 : 4);
            mainFilter.Q.value = isLowNote ? 0.7 : 1.0;

            // å‹ç¼©å™¨è®¾ç½® - æ¨¡æ‹Ÿé’¢ç´çš„åŠ¨æ€å“åº”
            compressor.threshold.value = -18;
            compressor.knee.value = 12;
            compressor.ratio.value = isLowNote ? 3 : 6;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.1;

            // è¿æ¥ä¸»éŸ³é¢‘é“¾
            fundamental.connect(mainFilter);
            mainFilter.connect(fundamentalGain);
            fundamentalGain.connect(compressor);
            outputGain.gain.value = 2;
            compressor.connect(outputGain);
            outputGain.connect(window.melodyAudioCtx.destination);

            // ğŸµ è°æ³¢ç³»åˆ— - æ¨¡æ‹ŸçœŸå®é’¢ç´çš„è°æ³¢ç»“æ„
            const harmonics = [];
            const harmonicRatios = [2, 3, 4, 5, 6, 7, 8]; // å…«åº¦ã€åäºŒåº¦ã€ä¸¤å…«åº¦ç­‰

            harmonicRatios.forEach((ratio, index) => {
                const weight = harmonicWeights[index] || 0;
                if (weight > 0.01) {
                    const harmonic = window.melodyAudioCtx.createOscillator();
                    const harmonicGain = window.melodyAudioCtx.createGain();
                    const harmonicFilter = window.melodyAudioCtx.createBiquadFilter();

                    harmonic.frequency.value = frequency * ratio;
                    harmonic.type = ratio % 2 === 0 ? 'triangle' : 'sine';

                    // è°æ³¢æ»¤æ³¢å™¨ - è¿›ä¸€æ­¥å‰Šå¼±é«˜é¢‘
                    harmonicFilter.type = 'lowpass';
                    harmonicFilter.frequency.value = frequency * ratio * 1.2;
                    harmonicFilter.Q.value = 0.6;

                    harmonic.connect(harmonicFilter);
                    harmonicFilter.connect(harmonicGain);
                    harmonicGain.connect(compressor);

                    harmonics.push({ oscillator: harmonic, gainNode: harmonicGain, filter: harmonicFilter, weight });
                }
            });

            // ğŸ­ å™ªéŸ³æˆåˆ†å·²ç§»é™¤ - æä¾›æ›´çº¯å‡€çš„éŸ³è‰²

            // ğŸ¼ é«˜çº§ADSRåŒ…ç»œ
            const now = startTime;
            const { attack, decay, sustain, release } = envelopeParams;

            // ä¸»éŸ³åŒ…ç»œ
            fundamentalGain.gain.setValueAtTime(0, now);
            fundamentalGain.gain.linearRampToValueAtTime(0.5, now + attack);
            fundamentalGain.gain.exponentialRampToValueAtTime(0.5 * sustain, now + attack + decay);
            fundamentalGain.gain.setValueAtTime(0.5 * sustain, now + duration - release);
            fundamentalGain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // è°æ³¢åŒ…ç»œ - æ¯ä¸ªè°æ³¢æœ‰ä¸åŒçš„è¡°å‡ç‰¹æ€§
            harmonics.forEach(({ gainNode, weight }, index) => {
                const harmonicAttack = attack * (0.8 + index * 0.1);
                const harmonicDecay = decay * (0.5 + index * 0.2);
                const harmonicSustain = sustain * (0.6 - index * 0.1);
                const harmonicRelease = release * (0.8 + index * 0.15);

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(weight, now + harmonicAttack);
                gainNode.gain.exponentialRampToValueAtTime(weight * harmonicSustain, now + harmonicAttack + harmonicDecay);
                gainNode.gain.setValueAtTime(weight * harmonicSustain, now + duration - harmonicRelease);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
            });

            // å™ªéŸ³åŒ…ç»œå·²ç§»é™¤

            // ğŸ¹ åŠ¨æ€æ»¤æ³¢å™¨åŒ…ç»œ - æ›´ä¿å®ˆçš„é«˜é¢‘æ§åˆ¶
            mainFilter.frequency.setValueAtTime(frequency * 5, now);
            mainFilter.frequency.exponentialRampToValueAtTime(frequency * 2.5, now + attack + decay);
            mainFilter.frequency.setValueAtTime(frequency * 2.5, now + duration - release);
            mainFilter.frequency.exponentialRampToValueAtTime(frequency * 1.8, now + duration);

            // å¯åŠ¨æ‰€æœ‰æŒ¯è¡å™¨
            fundamental.start(now);
            harmonics.forEach(({ oscillator }) => oscillator.start(now));

            // åœæ­¢æ‰€æœ‰æŒ¯è¡å™¨
            fundamental.stop(now + duration);
            harmonics.forEach(({ oscillator }) => oscillator.stop(now + duration));

            // è®°å½•ç»„ä»¶
            components.push({ oscillator: fundamental, gainNode: fundamentalGain, filter: mainFilter });
            components.push(...harmonics);

            console.log(`ğŸ¹ åˆ›å»ºçº¯å‡€é’¢ç´éŸ³è‰²: ${frequency.toFixed(1)}Hz (åŸºé¢‘ + ${harmonics.length}ä¸ªè°æ³¢)`);

            return { components };
        }

        // æ ¹æ®éŸ³é«˜è·å–è°æ³¢æƒé‡
        function getHarmonicWeights(frequency) {
            const isLowNote = frequency < 130;
            const isMidNote = frequency >= 130 && frequency < 520;
            const isHighNote = frequency >= 520;

            if (isLowNote) {
                // ä½éŸ³ï¼šæ›´å¤šä½æ¬¡è°æ³¢ï¼Œåšé‡æ„Ÿï¼Œå¤§å¹…å‰Šå¼±ç¬¬4ä¸ªæ³›éŸ³åˆ—
                return [0.25, 0.12, 0.025, 0.015, 0.01, 0.003, 0.001];
            } else if (isHighNote) {
                // é«˜éŸ³ï¼šä¿æŒæ˜äº®ä½†å¤§å¹…å‰Šå¼±é«˜é¢‘æˆåˆ†ï¼Œç‰¹åˆ«æ˜¯ç¬¬4ä¸ªæ³›éŸ³åˆ—
                return [0.18, 0.18, 0.06, 0.04, 0.02, 0.008, 0.002];
            } else {
                // ä¸­éŸ³ï¼šå¹³è¡¡ç»“æ„ï¼Œå¤§å¹…å‰Šå¼±ç¬¬4ä¸ªæ³›éŸ³åˆ—
                return [0.22, 0.15, 0.04, 0.03, 0.018, 0.01, 0.003];
            }
        }

        // æ ¹æ®éŸ³é«˜å’Œæ—¶é•¿è·å–åŒ…ç»œå‚æ•°
        function getEnvelopeParams(frequency, duration) {
            const isLowNote = frequency < 130;
            const isMidNote = frequency >= 130 && frequency < 520;
            const isHighNote = frequency >= 520;

            let attack, decay, sustain, release;

            if (isLowNote) {
                // ä½éŸ³ï¼šè¾ƒæ…¢çš„èµ·éŸ³ï¼Œé•¿çš„è¡°å‡
                attack = Math.max(0.008, 0.03 - (frequency / 200) * 0.01);
                decay = 0.5;
                sustain = 0.3;
                release = Math.min(1.5, duration * 0.3);
            } else if (isHighNote) {
                // é«˜éŸ³ï¼šå¿«èµ·éŸ³ï¼ŒçŸ­è¡°å‡
                attack = 0.003;
                decay = 0.15;
                sustain = 0.2;
                release = Math.min(0.3, duration * 0.2);
            } else {
                // ä¸­éŸ³ï¼šå¹³è¡¡çš„å‚æ•°
                attack = 0.005;
                decay = 0.3;
                sustain = 0.25;
                release = Math.min(0.8, duration * 0.25);
            }

            return {
                attack,
                decay,
                sustain,
                release
            };
        }

        // æ”¹è¿›çš„MusicXMLéŸ³ç¬¦è§£æå‡½æ•°
        function parseNotesFromMusicXML(musicXML) {
            const notes = [];

            try {
                console.log('ğŸ¼ å¼€å§‹è¯¦ç»†è§£æMusicXML...');

                // ğŸ” è°ƒè¯•ï¼šè¾“å‡ºåŸå§‹MusicXMLä»¥åˆ†æé™„ç‚¹é—®é¢˜
                console.log('ğŸ“‹ åŸå§‹MusicXMLå†…å®¹:', musicXML);

                // ğŸ” æ£€æŸ¥MusicXMLä¸­çš„ <dot> å…ƒç´ ï¼ˆè°ƒè¯•ç”¨ï¼‰
                const dotCount = (musicXML.match(/<dot/g) || []).length;
                console.log(`ğŸ” æ£€æµ‹åˆ° ${dotCount} ä¸ª <dot> å…ƒç´ `);

                // âš ï¸ å·²ç¦ç”¨ï¼šä¹‹å‰è¿™é‡Œä¼šé”™è¯¯åœ°åˆ é™¤æ‰€æœ‰é™„ç‚¹å…ƒç´ 
                // å½“ç”¨æˆ·å¯ç”¨é™„ç‚¹éŸ³ç¬¦åŠŸèƒ½æ—¶ï¼Œè¿™äº›<dot>å…ƒç´ æ˜¯åˆæ³•ä¸”å¿…éœ€çš„
                // if (dotCount > 0) {
                //     console.log(`âš ï¸ å‘ç° ${dotCount} ä¸ªé™„ç‚¹å…ƒç´ ï¼Œå¼€å§‹æ¸…ç†å¤šä½™é™„ç‚¹...`);
                //     musicXML = cleanupExcessiveDots(musicXML);
                //     const cleanedDotCount = (musicXML.match(/<dot/g) || []).length;
                //     console.log(`âœ… æ¸…ç†å®Œæˆï¼Œå‰©ä½™ ${cleanedDotCount} ä¸ªé™„ç‚¹å…ƒç´ `);
                // }

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(musicXML, 'text/xml');

                // æŸ¥æ‰¾æ‰€æœ‰noteå…ƒç´ 
                const noteElements = xmlDoc.getElementsByTagName('note');
                console.log(`ğŸ” XMLä¸­æ‰¾åˆ° ${noteElements.length} ä¸ªnoteå…ƒç´ `);

                for (let i = 0; i < noteElements.length; i++) {
                    const noteElement = noteElements[i];

                    // è·å–åŸºæœ¬çš„durationä¿¡æ¯ï¼ˆMusicXML durationå•ä½ï¼‰
                    const durationElement = noteElement.getElementsByTagName('duration')[0];
                    const xmlDuration = durationElement ? parseInt(durationElement.textContent) : 4;

                    // è·å–æ—¶å€¼ç±»å‹
                    const typeElement = noteElement.getElementsByTagName('type')[0];
                    const noteType = typeElement ? typeElement.textContent : 'quarter';

                    // æ£€æŸ¥æ˜¯å¦æœ‰é™„ç‚¹
                    const dotElements = noteElement.getElementsByTagName('dot');
                    const hasDot = dotElements.length > 0;

                    // ğŸ” è°ƒè¯•ï¼šæ˜¾ç¤ºæ¯ä¸ªéŸ³ç¬¦çš„é™„ç‚¹æƒ…å†µ
                    console.log(`ğŸ” éŸ³ç¬¦ ${i+1}: ç±»å‹=${noteType}, é™„ç‚¹æ•°é‡=${dotElements.length}`);
                    if (dotElements.length > 0) {
                        console.log(`âš ï¸ æ£€æµ‹åˆ°å¼‚å¸¸ï¼éŸ³ç¬¦æœ‰ ${dotElements.length} ä¸ªé™„ç‚¹`);
                    }

                    // è®¡ç®—å®é™…çš„durationå­—ç¬¦ä¸²
                    let actualDuration = noteType;
                    if (hasDot) {
                        actualDuration = `dotted-${noteType}`;
                    }

                    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¼‘æ­¢ç¬¦
                    const restElement = noteElement.getElementsByTagName('rest')[0];
                    if (restElement) {
                        const restObj = {
                            type: 'rest',
                            duration: actualDuration,
                            xmlDuration: xmlDuration,
                            beats: calculateBeatsFromDuration(actualDuration)
                        };
                        console.log(`ğŸµ è§£æä¼‘æ­¢ç¬¦: ${actualDuration} (${restObj.beats}æ‹)`);
                        notes.push(restObj);
                        continue;
                    }

                    // è·å–éŸ³é«˜ä¿¡æ¯
                    const pitchElement = noteElement.getElementsByTagName('pitch')[0];
                    if (pitchElement) {
                        const step = pitchElement.getElementsByTagName('step')[0]?.textContent;
                        const octave = parseInt(pitchElement.getElementsByTagName('octave')[0]?.textContent);
                        const alterElement = pitchElement.getElementsByTagName('alter')[0];
                        const alter = alterElement ? parseInt(alterElement.textContent) : 0;

                        // æ£€æŸ¥è¿çº¿ä¿¡æ¯
                        const tieElements = noteElement.getElementsByTagName('tie');
                        let tieInfo = null;
                        if (tieElements.length > 0) {
                            const tieTypes = Array.from(tieElements).map(tie => tie.getAttribute('type'));
                            tieInfo = {
                                isStart: tieTypes.includes('start'),
                                isStop: tieTypes.includes('stop'),
                                types: tieTypes
                            };
                        }

                        // è®¡ç®—MIDIéŸ³ç¬¦å·
                        if (step && !isNaN(octave)) {
                            const midi = stepOctaveToMidi(step, octave, alter);

                            const noteObj = {
                                type: 'note',
                                step: step,
                                octave: octave,
                                alter: alter,
                                midi: midi,
                                duration: actualDuration,
                                xmlDuration: xmlDuration,
                                beats: calculateBeatsFromDuration(actualDuration),
                                tied: tieInfo ? true : false,
                                tieInfo: tieInfo
                            };

                            const tieStr = tieInfo ? ` [è¿çº¿:${tieInfo.types.join(',')}]` : '';
                            console.log(`ğŸµ è§£æéŸ³ç¬¦: ${step}${alter > 0 ? '#' : alter < 0 ? 'b' : ''}${octave} (MIDI: ${midi}) ${actualDuration} (${noteObj.beats}æ‹)${tieStr}`);
                            notes.push(noteObj);
                        }
                    }
                }

                console.log(`ğŸ¼ XMLè§£æå®Œæˆï¼Œå…±${notes.length}ä¸ªéŸ³ç¬¦/ä¼‘æ­¢ç¬¦`);

            } catch (error) {
                console.error('âŒ MusicXMLè§£æé”™è¯¯:', error);
            }

            return notes;
        }

        // è®¡ç®—éŸ³ç¬¦æ—¶å€¼å¯¹åº”çš„æ‹æ•°
        function calculateBeatsFromDuration(duration) {
            const baseDurations = {
                'whole': 4,
                'half': 2,
                'quarter': 1,
                'eighth': 0.5,
                '16th': 0.25,
                '32nd': 0.125
            };

            // å¤„ç†é™„ç‚¹éŸ³ç¬¦ï¼ˆç”¨äºè§£æç°æœ‰MusicXMLï¼‰
            if (duration.startsWith('dotted-')) {
                const baseDuration = duration.replace('dotted-', '');
                const baseBeats = baseDurations[baseDuration] || 1;
                return baseBeats * 1.5; // é™„ç‚¹å¢åŠ 50%æ—¶å€¼
            }

            return baseDurations[duration] || 1;
        }

        // å°†éŸ³åå’Œå…«åº¦è½¬æ¢ä¸ºMIDIéŸ³ç¬¦å·
        function stepOctaveToMidi(step, octave, alter = 0) {
            const stepToSemitone = {
                'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11
            };

            const baseMidi = stepToSemitone[step];
            if (baseMidi === undefined) return 60; // é»˜è®¤C4

            return (octave + 1) * 12 + baseMidi + alter;
        }



        // è·å–æ‹å·ä¿¡æ¯
        function getTimeSignature(melodyData) {
            // é»˜è®¤å€¼
            let timeSignature = { numerator: 4, denominator: 4 };

            try {
                // ä»configä¸­è·å–
                if (melodyData.config && melodyData.config.timeSignature) {
                    const ts = melodyData.config.timeSignature;
                    if (ts.includes('/')) {
                        const parts = ts.split('/');
                        timeSignature.numerator = parseInt(parts[0]) || 4;
                        timeSignature.denominator = parseInt(parts[1]) || 4;
                    }
                }

                // ä»musicXMLä¸­è·å–
                if (melodyData.musicXML && timeSignature.numerator === 4) {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(melodyData.musicXML, 'text/xml');
                    const timeElements = xmlDoc.getElementsByTagName('time');

                    if (timeElements.length > 0) {
                        const beats = timeElements[0].getElementsByTagName('beats')[0]?.textContent;
                        const beatType = timeElements[0].getElementsByTagName('beat-type')[0]?.textContent;

                        if (beats && beatType) {
                            timeSignature.numerator = parseInt(beats) || 4;
                            timeSignature.denominator = parseInt(beatType) || 4;
                        }
                    }
                }
            } catch (error) {
                console.warn('âš ï¸ æ— æ³•è§£ææ‹å·ï¼Œä½¿ç”¨é»˜è®¤4/4æ‹:', error);
            }

            console.log(`ğŸ¼ æ£€æµ‹åˆ°æ‹å·: ${timeSignature.numerator}/${timeSignature.denominator}`);
            return timeSignature;
        }

        // æ’­æ”¾å®Œæ•´æ—‹å¾‹ï¼ˆçº¯æ—‹å¾‹ï¼Œä¸å¸¦èŠ‚æ‹å™¨ï¼‰
        function playFullMelody(melodyData, customStartTime = null) {
            console.log('ğŸ¶ å¼€å§‹æ—‹å¾‹æ’­æ”¾');

            // åªåœ¨é¦–æ¬¡è°ƒç”¨æ—¶è®¾ç½®æ’­æ”¾çŠ¶æ€ï¼Œcount-inè°ƒç”¨æ—¶å·²ç»è®¾ç½®è¿‡äº†
            if (!window.isPlayingMelody) {
                window.isPlayingMelody = true;
                updatePlayButton();
                window.melodyScheduledSounds = [];
            }

            // è·å–èŠ‚æ‹å™¨é€Ÿåº¦
            let tempo = 60;
            if (typeof getCurrentTempo === 'function') {
                tempo = getCurrentTempo();
            }
            console.log('ğŸ•°ï¸ æ’­æ”¾é€Ÿåº¦:', tempo, 'BPM');

            // è§£æéŸ³ç¬¦æ•°æ®
            let notes = extractNotesFromMelodyData(melodyData);

            if (notes.length === 0) {
                console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°éŸ³ç¬¦ï¼Œæ’­æ”¾é’¢ç´æµ‹è¯•éŸ³ç¬¦');
                playTestNote();
                return;
            }

            console.log(`ğŸµ æ‰¾åˆ° ${notes.length} ä¸ªéŸ³ç¬¦ï¼Œå¼€å§‹å®‰æ’æ’­æ”¾`);

            // å¤„ç†è¿çº¿éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦
            const processedNotes = processNotesForPlayback(notes);
            console.log(`ğŸµ å¤„ç†åçš„éŸ³ç¬¦: ${processedNotes.length}ä¸ªäº‹ä»¶`);

            // è®¡ç®—æ€»æ—¶é•¿å¹¶å®‰æ’æ’­æ”¾
            const startTime = customStartTime || window.melodyAudioCtx.currentTime;
            let totalDuration = 0;
            let currentTime = 0;

            // å®‰æ’éŸ³ç¬¦æ’­æ”¾
            processedNotes.forEach((event, index) => {
                const eventStartTime = startTime + currentTime;
                const eventDuration = durationToSeconds(event.duration || 'quarter', tempo);

                if (event.type === 'note' && event.midi && !event.isTiedContinuation) {
                    // æ’­æ”¾éŸ³ç¬¦ï¼ˆè·³è¿‡è¿çº¿çš„å»¶ç»­éƒ¨åˆ†ï¼‰
                    // ä¼˜åŒ–ï¼šç›´æ¥ä½¿ç”¨ MIDIï¼Œé¿å… MIDIâ†’é¢‘ç‡â†’MIDI çš„å†—ä½™è½¬æ¢
                    scheduleNotePlayDirect(event.midi, eventStartTime, eventDuration);
                    console.log(`ğŸ¹ å®‰æ’æ’­æ”¾: MIDI ${event.midi} @ ${eventStartTime.toFixed(2)}s, æ—¶é•¿ ${eventDuration.toFixed(2)}s`);
                } else if (event.type === 'rest') {
                    // ä¼‘æ­¢ç¬¦ - åªè®¡æ—¶ï¼Œä¸æ’­æ”¾
                    console.log(`ğŸ”‡ ä¼‘æ­¢ç¬¦: ${eventDuration.toFixed(2)}s @ ${eventStartTime.toFixed(2)}s`);
                }

                totalDuration = Math.max(totalDuration, currentTime + eventDuration);
                currentTime += eventDuration;
            });

            // è®¾ç½®æ’­æ”¾å®Œæˆå›è°ƒ
            setTimeout(() => {
                if (window.isPlayingMelody) {
                    window.isPlayingMelody = false;
                    updatePlayButton();
                    window.melodyScheduledSounds = [];
                    console.log('âœ… æ—‹å¾‹æ’­æ”¾å®Œæˆ');
                }
            }, (totalDuration + 0.5) * 1000);

            console.log(`ğŸ¼ æ’­æ”¾å®‰æ’å®Œæˆ: ${totalDuration.toFixed(2)}ç§’`);
        }

        // æå–éŸ³ç¬¦æ•°æ®çš„è¾…åŠ©å‡½æ•°
        function extractNotesFromMelodyData(melodyData) {
            let notes = [];

            // æ–¹æ³•1ï¼šæ£€æŸ¥measuresç»“æ„
            if (melodyData.measures && Array.isArray(melodyData.measures)) {
                melodyData.measures.forEach((measure, measureIndex) => {
                    if (measure.notes && Array.isArray(measure.notes)) {
                        measure.notes.forEach(note => {
                            notes.push(note);
                        });
                    }
                });
            }

            // æ–¹æ³•2ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç›´æ¥çš„notesæ•°ç»„
            if (notes.length === 0 && melodyData.notes && Array.isArray(melodyData.notes)) {
                notes = melodyData.notes;
            }

            // æ–¹æ³•3ï¼šæ£€æŸ¥musicXMLä¸­æ˜¯å¦èƒ½è§£æå‡ºéŸ³ç¬¦
            if (notes.length === 0 && melodyData.musicXML) {
                notes = parseNotesFromMusicXML(melodyData.musicXML);
            }

            return notes;
        }

        // å¤„ç†è¿çº¿éŸ³ç¬¦å’Œä¼‘æ­¢ç¬¦
        function processNotesForPlayback(notes) {
            const processedNotes = [];
            let i = 0;

            while (i < notes.length) {
                const currentNote = notes[i];

                if (currentNote.type === 'rest') {
                    // ä¼‘æ­¢ç¬¦ç›´æ¥æ·»åŠ 
                    processedNotes.push(currentNote);
                    i++;
                } else if (currentNote.type === 'note') {
                    if (currentNote.tied && currentNote.tieInfo && currentNote.tieInfo.isStart) {
                        // è¿™æ˜¯è¿çº¿çš„å¼€å§‹ï¼Œéœ€è¦åˆå¹¶åç»­çš„è¿çº¿éŸ³ç¬¦
                        const mergedNote = mergeTiedNotes(notes, i);
                        processedNotes.push(mergedNote.note);
                        i = mergedNote.nextIndex;
                    } else if (currentNote.tied && currentNote.tieInfo && currentNote.tieInfo.isStop && !currentNote.tieInfo.isStart) {
                        // è¿™æ˜¯è¿çº¿çš„ç»“æŸï¼Œä½†ä¸æ˜¯å¼€å§‹ï¼Œæ ‡è®°ä¸ºå»¶ç»­ï¼ˆä¸æ’­æ”¾ï¼‰
                        const continuationNote = {
                            ...currentNote,
                            isTiedContinuation: true
                        };
                        processedNotes.push(continuationNote);
                        i++;
                    } else {
                        // æ™®é€šéŸ³ç¬¦ï¼Œç›´æ¥æ·»åŠ 
                        processedNotes.push(currentNote);
                        i++;
                    }
                } else {
                    // å…¶ä»–ç±»å‹ï¼Œç›´æ¥æ·»åŠ 
                    processedNotes.push(currentNote);
                    i++;
                }
            }

            return processedNotes;
        }

        // åˆå¹¶è¿çº¿éŸ³ç¬¦
        function mergeTiedNotes(notes, startIndex) {
            const startNote = notes[startIndex];
            let totalBeats = startNote.beats || calculateBeatsFromDuration(startNote.duration);
            let nextIndex = startIndex + 1;

            console.log(`ğŸ”— å¼€å§‹å¤„ç†è¿çº¿: ${startNote.step}${startNote.octave} (å¼€å§‹éŸ³ç¬¦: ${startNote.beats}æ‹)`);

            // æŸ¥æ‰¾åç»­çš„è¿çº¿éŸ³ç¬¦
            while (nextIndex < notes.length) {
                const nextNote = notes[nextIndex];

                // æ£€æŸ¥æ˜¯å¦æ˜¯åŒéŸ³é«˜çš„è¿çº¿éŸ³ç¬¦
                if (nextNote.type === 'note' &&
                    nextNote.tied &&
                    nextNote.midi === startNote.midi &&
                    nextNote.tieInfo) {

                    const noteBeats = nextNote.beats || calculateBeatsFromDuration(nextNote.duration);
                    totalBeats += noteBeats;
                    console.log(`ğŸ”— åˆå¹¶è¿çº¿éŸ³ç¬¦: +${noteBeats}æ‹, æ€»è®¡: ${totalBeats}æ‹`);

                    nextIndex++;

                    // å¦‚æœè¿™æ˜¯è¿çº¿çš„ç»“æŸï¼Œåœæ­¢åˆå¹¶
                    if (nextNote.tieInfo.isStop && !nextNote.tieInfo.isStart) {
                        break;
                    }
                } else {
                    // é‡åˆ°éè¿çº¿éŸ³ç¬¦ï¼Œåœæ­¢
                    break;
                }
            }

            // è®¡ç®—åˆå¹¶åçš„duration
            const mergedDuration = beatsToClosestDuration(totalBeats);

            const mergedNote = {
                ...startNote,
                duration: mergedDuration,
                beats: totalBeats,
                isMergedTie: true,
                originalDuration: startNote.duration
            };

            console.log(`ğŸ”— è¿çº¿åˆå¹¶å®Œæˆ: ${startNote.step}${startNote.octave}, æ€»æ—¶é•¿: ${totalBeats}æ‹ (${mergedDuration})`);

            return {
                note: mergedNote,
                nextIndex: nextIndex
            };
        }

        // å°†æ‹æ•°è½¬æ¢ä¸ºæœ€æ¥è¿‘çš„durationå­—ç¬¦ä¸²
        function beatsToClosestDuration(beats) {
            // å®Œæ•´çš„éŸ³ç¬¦æ—¶å€¼æ˜ å°„ï¼ˆåŒ…å«é™„ç‚¹éŸ³ç¬¦ï¼‰
            const durationMap = [
                { beats: 4, duration: 'whole' },
                { beats: 3, duration: 'dotted-half' },      // é™„ç‚¹äºŒåˆ†éŸ³ç¬¦
                { beats: 2, duration: 'half' },
                { beats: 1.5, duration: 'dotted-quarter' }, // é™„ç‚¹å››åˆ†éŸ³ç¬¦
                { beats: 1, duration: 'quarter' },
                { beats: 0.75, duration: 'dotted-eighth' }, // é™„ç‚¹å…«åˆ†éŸ³ç¬¦
                { beats: 0.5, duration: 'eighth' },
                { beats: 0.25, duration: '16th' },
                { beats: 0.125, duration: '32nd' }
            ];

            // ç²¾ç¡®åŒ¹é…ä¼˜å…ˆï¼ˆå®¹å·®0.01æ‹ï¼‰
            for (const { beats: targetBeats, duration } of durationMap) {
                if (Math.abs(beats - targetBeats) < 0.01) {
                    return duration;
                }
            }

            // æ— ç²¾ç¡®åŒ¹é…æ—¶ï¼Œæ‰¾æœ€æ¥è¿‘çš„
            let closestDuration = 'quarter';
            let minDifference = Infinity;

            for (const { beats: targetBeats, duration } of durationMap) {
                const difference = Math.abs(beats - targetBeats);
                if (difference < minDifference) {
                    minDifference = difference;
                    closestDuration = duration;
                }
            }

            return closestDuration;
        }

        // ====== éšè—æ¨¡å¼ä¸‹çš„èŠ‚æ‹å™¨åŠŸèƒ½ ======

        // åˆ›å»ºèŠ‚æ‹å™¨å£°éŸ³
        function createMetronomeClick(frequency = 523.25, isDownbeat = false) {
            try {
                const oscillator = window.melodyAudioCtx.createOscillator();
                const gainNode = window.melodyAudioCtx.createGain();

                // ä½¿ç”¨æ–¹æ³¢å’Œè‡ªç„¶éŸ³é«˜ (ä¸ä¸»èŠ‚æ‹å™¨ä¿æŒä¸€è‡´)
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(
                    isDownbeat ? frequency * 1.2 : frequency,
                    window.melodyAudioCtx.currentTime
                );

                oscillator.connect(gainNode);
                gainNode.connect(window.melodyAudioCtx.destination);

                return { oscillator, gainNode };
            } catch (error) {
                console.error('âŒ åˆ›å»ºèŠ‚æ‹å™¨å£°éŸ³å¤±è´¥:', error);
                return null;
            }
        }

        // æ’­æ”¾èŠ‚æ‹å™¨ç‚¹å‡»å£°
        function playMetronomeClick(startTime, isDownbeat = false) {
            const metronome = createMetronomeClick(523.25, isDownbeat);
            if (!metronome) return;

            const { oscillator, gainNode } = metronome;

            // ä½¿ç”¨ä¸NiceChordèŠ‚æ‹å™¨ä¸€è‡´çš„åŒ…ç»œ
            const clickDuration = 0.05;
            const volume = 0.5; // ç»Ÿä¸€éŸ³é‡

            gainNode.gain.setValueAtTime(volume, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + clickDuration);

            oscillator.start(startTime);
            oscillator.stop(startTime + clickDuration);

            // è®°å½•ä»¥ä¾¿åœæ­¢æ—¶æ¸…ç†
            window.melodyScheduledSounds.push({ oscillator, gainNode });

            console.log(`ğŸ¥ èŠ‚æ‹å™¨: ${isDownbeat ? 'å¼ºæ‹' : 'å¼±æ‹'} @ ${startTime.toFixed(2)}s`);
        }

        // å¯åŠ¨é¡µé¢ä¸Šçš„èŠ‚æ‹å™¨
        function startPageMetronome() {
            // æŸ¥æ‰¾é¡µé¢ä¸Šçš„èŠ‚æ‹å™¨æŒ‰é’®å¹¶å¯åŠ¨
            const metronomeBtn = document.querySelector('#headerMetronomePlay, .metronome-play-btn');
            if (metronomeBtn && !metronomeBtn.classList.contains('playing')) {
                console.log('ğŸ¼ å¯åŠ¨é¡µé¢èŠ‚æ‹å™¨');
                metronomeBtn.click();
                return true;
            }
            return false;
        }

        // åœæ­¢é¡µé¢ä¸Šçš„èŠ‚æ‹å™¨
        function stopPageMetronome() {
            const metronomeBtn = document.querySelector('#headerMetronomePlay, .metronome-play-btn');
            if (metronomeBtn && metronomeBtn.classList.contains('playing')) {
                console.log('â¹ï¸ åœæ­¢é¡µé¢èŠ‚æ‹å™¨');
                metronomeBtn.click();
                return true;
            }
            return false;
        }

        // Count-inç„¶åæ’­æ”¾æ—‹å¾‹ï¼ˆéšè—æ¨¡å¼ä¸“ç”¨ï¼‰
        function playCountInThenMelody(melodyData) {
            console.log('ğŸ¼ éšè—æ¨¡å¼ï¼šå¼€å§‹count-inï¼ˆä»…count-inï¼Œä¸å¯åŠ¨é¡µé¢èŠ‚æ‹å™¨ï¼‰');

            window.isPlayingMelody = true;
            updatePlayButton();
            window.melodyScheduledSounds = [];

            // è·å–èŠ‚æ‹å™¨é€Ÿåº¦å’Œæ‹å·
            let tempo = 60;
            if (typeof getCurrentTempo === 'function') {
                tempo = getCurrentTempo();
            }

            // è·å–æ‹å·ä¿¡æ¯
            const timeSignature = getTimeSignature(melodyData);
            const countInBeats = timeSignature.numerator; // ä½¿ç”¨æ‹å·åˆ†å­ä½œä¸ºcount-inæ¬¡æ•°

            console.log(`ğŸ¼ Count-inè®¾ç½®: ${tempo} BPM, æ‹å· ${timeSignature.numerator}/${timeSignature.denominator}, count-in ${countInBeats}ä¸‹`);

            const beatDuration = 60 / tempo; // æ¯æ‹çš„ç§’æ•°
            const now = window.melodyAudioCtx.currentTime;

            // æ³¨é‡Šæ‰å¯åŠ¨é¡µé¢èŠ‚æ‹å™¨çš„ä»£ç 
            // startPageMetronome();

            // æ’­æ”¾count-inï¼ˆæ ¹æ®æ‹å·åˆ†å­å†³å®šæ¬¡æ•°ï¼‰
            for (let beat = 0; beat < countInBeats; beat++) {
                const beatTime = now + beat * beatDuration;
                const isDownbeat = beat === 0;
                playMetronomeClick(beatTime, isDownbeat);
            }

            // count-inå®Œæˆåçš„å¤„ç†
            const countInEndTime = now + countInBeats * beatDuration;
            console.log(`ğŸµ Count-inå°†åœ¨${countInEndTime.toFixed(3)}sç»“æŸï¼Œç„¶åç²¾ç¡®å¼€å§‹æ—‹å¾‹æ’­æ”¾`);

            // ğŸ”§ å…³é”®ä¿®å¤ï¼šä¸ä½¿ç”¨setTimeoutï¼Œç«‹å³è°ƒç”¨æ’­æ”¾å‡½æ•°ï¼Œä¼ å…¥count-inç»“æŸçš„ç²¾ç¡®æ—¶é—´
            // Web Audio API ä¼šç²¾ç¡®åœ°åœ¨count-inç»“æŸæ—¶å¼€å§‹æ’­æ”¾æ—‹å¾‹
            playFullMelody(melodyData, countInEndTime);
        }

        // ğŸ¹ ä¸´æ—¶æ ·æœ¬ç”Ÿæˆå™¨ - æµ‹è¯•ç”¨
        function generateTestSample(frequency, name, audioContext) {
            console.log(`ğŸµ ç”Ÿæˆæµ‹è¯•æ ·æœ¬: ${name} (${frequency}Hz)`);

            const duration = 2.5;
            const sampleRate = 22050;
            const length = duration * sampleRate;

            // åˆ›å»ºAudioBuffer
            const buffer = audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            // æ ¹æ®å…·ä½“éŸ³ç¬¦è°ƒæ•´è°æ³¢ç»“æ„
            let harmonics, decay, brightness;

            switch(name) {
                case 'C4':
                    harmonics = [1.0, 0.5, 0.3, 0.2, 0.12, 0.08, 0.05]; // æ¸©æš–çš„ä¸­éŸ³
                    decay = 0.7;
                    brightness = 0.8;
                    break;
                case 'E4':
                    harmonics = [1.0, 0.45, 0.35, 0.22, 0.15, 0.09, 0.04]; // ç•¥å¸¦æ˜äº®
                    decay = 0.65;
                    brightness = 0.9;
                    break;
                case 'G4':
                    harmonics = [1.0, 0.4, 0.4, 0.25, 0.18, 0.1, 0.03]; // å¹³è¡¡çš„é«˜ä¸­éŸ³
                    decay = 0.6;
                    brightness = 1.0;
                    break;
                case 'A4':
                    harmonics = [1.0, 0.35, 0.45, 0.28, 0.2, 0.12, 0.02]; // æ˜äº®çš„A4
                    decay = 0.58;
                    brightness = 1.1;
                    break;
                default:
                    harmonics = [1.0, 0.4, 0.3, 0.2, 0.1, 0.05];
                    decay = 0.7;
                    brightness = 1.0;
            }

            // ç”Ÿæˆæ ·æœ¬æ•°æ®
            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                let sample = 0;

                // æ·»åŠ è°æ³¢ç³»åˆ—
                harmonics.forEach((amplitude, index) => {
                    const harmonic = index + 1;
                    const freq = frequency * harmonic;

                    // é«˜æ¬¡è°æ³¢éšæ—¶é—´è¡°å‡æ›´å¿«
                    const harmonicDecay = decay * (1 + index * 0.3);
                    const envelope = Math.exp(-harmonicDecay * t);

                    sample += amplitude * Math.sin(2 * Math.PI * freq * t) * envelope;
                });

                // æ·»åŠ è½»å¾®çš„ç´å¼¦å…±é¸£å™ªå£°
                const noiseLevel = 0.015 * Math.exp(-t * 3);
                sample += (Math.random() - 0.5) * noiseLevel;

                // æ€»ä½“éŸ³é‡åŒ…ç»œï¼ˆæ¨¡æ‹Ÿé’¢ç´è§¦é”®ï¼‰
                const attack = Math.min(1, t * 50); // å¿«é€Ÿæ”»å‡»
                const sustain = Math.exp(-t * 0.8); // è‡ªç„¶è¡°å‡
                const totalEnvelope = attack * sustain;

                data[i] = sample * totalEnvelope * 0.25; // æ§åˆ¶æ€»éŸ³é‡
            }

            console.log(`âœ… ${name} æ ·æœ¬ç”Ÿæˆå®Œæˆï¼Œæ—¶é•¿ ${duration}s`);
            return buffer;
        }

        // ğŸ¹ æµ‹è¯•æ ·æœ¬æ’­æ”¾å™¨
        window.testSamplePlayback = function(sampleName) {
            console.log(`ğŸµ æµ‹è¯•æ’­æ”¾æ ·æœ¬: ${sampleName}`);

            // ç¡®ä¿AudioContextå·²åˆå§‹åŒ–
            if (!window.melodyAudioCtx) {
                console.log('ğŸ”§ åˆå§‹åŒ–AudioContext...');
                try {
                    window.melodyAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('âœ… AudioContextåˆå§‹åŒ–æˆåŠŸ');
                } catch (error) {
                    console.error('âŒ AudioContextåˆå§‹åŒ–å¤±è´¥:', error);
                    return;
                }
            }

            // ç¡®ä¿AudioContextæœªè¢«æš‚åœ
            if (window.melodyAudioCtx.state === 'suspended') {
                window.melodyAudioCtx.resume();
            }

            const frequencies = {
                'C4': 261.63,
                'E4': 329.63,
                'G4': 392.00,
                'A4': 440.00
            };

            const frequency = frequencies[sampleName];
            if (!frequency) {
                console.error(`âŒ æœªçŸ¥æ ·æœ¬: ${sampleName}`);
                return;
            }

            try {
                // ç”Ÿæˆæµ‹è¯•æ ·æœ¬
                const buffer = generateTestSample(frequency, sampleName, window.melodyAudioCtx);

                // æ’­æ”¾æ ·æœ¬
                const source = window.melodyAudioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(window.melodyAudioCtx.destination);

                const now = window.melodyAudioCtx.currentTime;
                source.start(now);

                console.log(`ğŸ”Š ${sampleName} æ ·æœ¬å¼€å§‹æ’­æ”¾`);

                // è®°å½•æ’­æ”¾çŠ¶æ€
                setTimeout(() => {
                    console.log(`âœ… ${sampleName} æ ·æœ¬æ’­æ”¾å®Œæˆ`);
                }, 3000);

            } catch (error) {
                console.error(`âŒ ${sampleName} æ ·æœ¬æ’­æ”¾å¤±è´¥:`, error);
            }
        };

        // ğŸ¹ æ’­æ”¾æ‰€æœ‰æµ‹è¯•æ ·æœ¬ï¼ˆæŒ‰é¡ºåºï¼‰
        window.testAllSamples = function() {
            console.log('ğŸµ === å¼€å§‹æµ‹è¯•æ‰€æœ‰ä¸­é«˜éŸ³æ ·æœ¬ ===');

            const samples = ['C4', 'E4', 'G4', 'A4'];
            let currentIndex = 0;

            function playNext() {
                if (currentIndex >= samples.length) {
                    console.log('âœ… === æ‰€æœ‰æ ·æœ¬æµ‹è¯•å®Œæˆ ===');
                    return;
                }

                const sample = samples[currentIndex];
                console.log(`\nğŸµ ç¬¬${currentIndex + 1}ä¸ªæ ·æœ¬: ${sample}`);
                window.testSamplePlayback(sample);

                currentIndex++;
                setTimeout(playNext, 3500); // 3.5ç§’é—´éš”
            }

            playNext();
        };

        // ğŸ¹ æµ‹è¯•pitch shiftingæ•ˆæœ
        window.testPitchShifting = function() {
            console.log('ğŸµ === Pitch Shifting æµ‹è¯• ===');

            // ä½¿ç”¨A4æ ·æœ¬ç”Ÿæˆä¸åŒéŸ³é«˜
            const baseFreq = 440; // A4
            const baseSample = generateTestSample(baseFreq, 'A4');

            // æµ‹è¯•ä¸åŒçš„pitch shiftingæ¯”ä¾‹
            const testNotes = [
                { name: 'C3', freq: 130.81, ratio: 130.81/440 },  // å‘ä¸‹shift
                { name: 'F3', freq: 174.61, ratio: 174.61/440 },  // ä¸­ç­‰å‘ä¸‹
                { name: 'A4', freq: 440, ratio: 1.0 },            // åŸéŸ³
                { name: 'C5', freq: 523.25, ratio: 523.25/440 },  // å‘ä¸Šshift
                { name: 'F5', freq: 698.46, ratio: 698.46/440 }   // å¤§å¹…å‘ä¸Š
            ];

            let index = 0;
            function playNextShifted() {
                if (index >= testNotes.length) {
                    console.log('âœ… Pitch Shifting æµ‹è¯•å®Œæˆ');
                    return;
                }

                const note = testNotes[index];
                console.log(`ğŸµ æµ‹è¯• ${note.name}: æ¯”ä¾‹ ${note.ratio.toFixed(2)}x`);

                const source = window.melodyAudioCtx.createBufferSource();
                source.buffer = baseSample;
                source.playbackRate.value = note.ratio;
                source.connect(window.melodyAudioCtx.destination);

                source.start(window.melodyAudioCtx.currentTime);

                index++;
                setTimeout(playNextShifted, 2500);
            }

            playNextShifted();
        };

        console.log('âœ… HTMLå†…æ’­æ”¾å™¨åˆ›å»ºå®Œæˆï¼ˆå«éšè—æ¨¡å¼èŠ‚æ‹å™¨ + æ ·æœ¬æµ‹è¯•åŠŸèƒ½ï¼‰');

        // ğŸ¯ é€šç”¨å¼¹çª—å¤–éƒ¨ç‚¹å‡»å…³é—­åŠŸèƒ½
        function initializeModalClickOutsideToClose() {
            const modalIds = [
                'settingsModal',
                'rhythmModal',
                'articulationModal',
                'keySignatureModal',
                'timeSignatureModal',
                'intervalModal',
                'clefModal',
                'challengeModal',
                'metronomePatternModal'
            ];

            modalIds.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.addEventListener('click', function(event) {
                        // åªæœ‰å½“ç‚¹å‡»çš„æ˜¯å¼¹çª—èƒŒæ™¯ï¼ˆmodalå®¹å™¨æœ¬èº«ï¼‰æ—¶æ‰å…³é—­
                        if (event.target === modal) {
                            console.log(`ğŸ¯ ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—: ${modalId}`);

                            // æ ¹æ®å¼¹çª—ç±»å‹è°ƒç”¨ç›¸åº”çš„å…³é—­å‡½æ•°
                switch(modalId) {
                                case 'settingsModal':
                                    if (typeof closeSettingsModal === 'function') {
                                        closeSettingsModal();
                                    }
                                    break;
                                case 'rhythmModal':
                                    if (typeof closeRhythmSettings === 'function') {
                                        closeRhythmSettings();
                                    }
                                    break;
                                case 'articulationModal':
                                    if (typeof closeArticulationSettings === 'function') {
                                        closeArticulationSettings();
                                    }
                                    break;
                                case 'keySignatureModal':
                                    if (typeof closeKeySettings === 'function') {
                                        closeKeySettings();
                                    }
                                    break;
                                case 'timeSignatureModal':
                                    if (typeof closeTimeSignatureSettings === 'function') {
                                        closeTimeSignatureSettings();
                                    }
                                    break;
                                case 'intervalModal':
                                    if (typeof closeIntervalSettings === 'function') {
                                        closeIntervalSettings();
                                    }
                                    break;
                        case 'clefModal':
                            if (typeof closeClefSettings === 'function') {
                                closeClefSettings();
                            }
                            break;
                        case 'challengeModal':
                            if (typeof cancelChallengeSetup === 'function') {
                                cancelChallengeSetup();
                            }
                            break;
                        case 'metronomePatternModal':
                            if (typeof closeMetronomePatternSettings === 'function') {
                                closeMetronomePatternSettings();
                            }
                            break;
                                default:
                                    // é€šç”¨å…³é—­æ–¹æ³•
                                    modal.style.display = 'none';
                            }
                        }
                    });
                    console.log(`âœ… å·²ä¸º ${modalId} æ·»åŠ å¤–éƒ¨ç‚¹å‡»å…³é—­åŠŸèƒ½`);
                }
            });
        }

        // åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeModalClickOutsideToClose();
            console.log('ğŸ¯ å¼¹çª—å¤–éƒ¨ç‚¹å‡»å…³é—­åŠŸèƒ½å·²åˆå§‹åŒ–');
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('settingsModal');
                if (modal && modal.style.display !== 'none') {
                    closeSettingsModal();
                }
            }
        });

        // ç»ƒä¹ è®¡æ•°å™¨ï¼ˆä¼šè¯å†…è®¡æ•°ï¼Œåˆ·æ–°æ¸…é›¶ï¼‰
        function loadPracticeCount(){
            const el = document.getElementById('practiceCountValue');
            if (!el) return 0;
            const v = parseInt(el.textContent || '0', 10);
            return isFinite(v) ? Math.max(0, v) : 0;
        }

        function updatePracticeCountDisplay(val){
            const el = document.getElementById('practiceCountValue');
            if (el) el.textContent = String(Math.max(0, val));
        }

        window.incrementPracticeCount = function(){
            const next = loadPracticeCount() + 1;
            updatePracticeCountDisplay(next);
        };

        window.decrementPracticeCount = function(){
            const next = Math.max(0, loadPracticeCount() - 1);
            updatePracticeCountDisplay(next);
        };

        document.addEventListener('DOMContentLoaded', function(){
            updatePracticeCountDisplay(0);
        });

        // ç›‘å¬ç®€è°±/è‹±åå¼€å…³
        document.addEventListener('DOMContentLoaded', function() {
            ['jianpuToggle', 'englishNameToggle'].forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    toggle.addEventListener('change', () => {
                        if (typeof updateNotationPanel === 'function') {
                            updateNotationPanel();
                        }
                        if (typeof rerenderLatestScore === 'function') {
                            rerenderLatestScore();
                        }
                    });
                }
            });
        });

        // é«˜çº§è®¾ç½®è¡Œä¸ºç”±å¤–éƒ¨è„šæœ¬ jianpu-sight-reading-final.js æä¾›

        // âŒ¨ï¸ å…¨å±€é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            // å¦‚æœåœ¨è¾“å…¥æ¡†ã€æ–‡æœ¬æ¡†æˆ–æ¨¡æ€æ¡†è¾“å…¥ä¸­ï¼Œä¸è§¦å‘å¿«æ·é”®
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰æ¨¡æ€æ¡†æ‰“å¼€ï¼ˆé¿å…åœ¨è®¾ç½®ä¸­è§¦å‘ï¼‰
            const hasOpenModal = document.querySelector('.modal:not([style*="display: none"])');
            if (hasOpenModal) {
                return;
            }

            const key = e.key.toLowerCase();

            switch(key) {
                case 'p':
                    // æ’­æ”¾/æš‚åœæ’­æ”¾
                    e.preventDefault();
                    if (typeof directPlayTest === 'function') {
                        directPlayTest();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: P - æ’­æ”¾/æš‚åœ');
                    }
                    break;

                case 'arrowleft':
                    // ä¸Šä¸€æ¡
                    e.preventDefault();
                    if (typeof previousMelody === 'function') {
                        previousMelody();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: â† - ä¸Šä¸€æ¡');
                    }
                    break;

                case 'arrowright':
                    // ä¸‹ä¸€æ¡
                    e.preventDefault();
                    if (typeof nextMelody === 'function') {
                        nextMelody();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: â†’ - ä¸‹ä¸€æ¡');
                    }
                    break;

                case ' ':
                    // ç”Ÿæˆï¼ˆç©ºæ ¼é”®ï¼‰
                    e.preventDefault();
                    if (typeof generateMelody === 'function') {
                        generateMelody();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: Space - ç”Ÿæˆæ—‹å¾‹');
                    }
                    break;

                case 'h':
                    // éšè—/æ˜¾ç¤º
                    e.preventDefault();
                    if (typeof toggleMelodyVisibility === 'function') {
                        toggleMelodyVisibility();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: H - éšè—/æ˜¾ç¤º');
                    }
                    break;

                case 'c':
                    // èŠ‚æ‹å™¨å¼€å…³
                    e.preventDefault();
                    if (typeof toggleMetronome === 'function') {
                        toggleMetronome();
                        console.log('âŒ¨ï¸ å¿«æ·é”®: C - èŠ‚æ‹å™¨å¼€å…³');
                    }
                    break;
            }
        });

        console.log('âŒ¨ï¸ ç®€è°±è§†å¥å·¥å…·å¿«æ·é”®å·²å¯ç”¨: P=æ’­æ”¾ â†â†’=å¯¼èˆª Space=ç”Ÿæˆ H=éšè— C=èŠ‚æ‹å™¨');
    </script>

    <!-- ğŸ›¡ï¸ è¯•ç”¨ä¿æŠ¤ç³»ç»Ÿè„šæœ¬ -->

    <!-- æŒ‘æˆ˜æ¨¡å¼é€»è¾‘ï¼ˆå¤–é“¾ï¼‰ -->
    <script src="./IC ç®€è°±è§†å¥å·¥å…·_files/challenge-mode.js"></script>
    <!-- æ—§çš„å†…è”æŒ‘æˆ˜æ¨¡å¼é€»è¾‘ï¼ˆå·²è¿ç§»è‡³å¤–é“¾ï¼‰ï¼›ä»¥ä¸‹å—è¢«æ³¨é‡Šä»¥é¿å…é‡å¤æ‰§è¡Œ -->
    <script>
        /* moved to ./IC ç®€è°±è§†å¥å·¥å…·_files/challenge-mode.js
        (function(){
            const scoreEl = document.getElementById('score');
            const toggleEl = document.getElementById('challengeModeToggle');

            // æŒ‘æˆ˜è¿è¡Œæ—¶çŠ¶æ€
            const state = {
                active: false,
                rafId: null,
                countdownTimerId: null,
                countInTimerId: null,
                observer: null,
                startTs: 0,
                measureRects: [],
                measureDuration: 0,
                cursorEl: null,
                overlayEl: null,
                masked: new Set(),
                lastIndex: -1,
                resizeHandler: null,
                activeSvg: null,
                audioCtx: null,
            };

            function $(id){ return document.getElementById(id); }

            function openChallengeModal(){
                const modal = $('challengeModal');
                const prep = $('challengePrepTime');
                const bpm = $('challengeBPM');
                // æ¢å¤ä¸Šæ¬¡è®¾ç½®
                try{
                    const saved = JSON.parse(localStorage.getItem('ic_jianpu_challenge_settings')||'{}');
                    if (typeof saved.prep === 'number') prep.value = saved.prep;
                    if (typeof saved.bpm === 'number') bpm.value = saved.bpm;
                }catch(e){}
                modal.style.display = 'flex';
            }

            window.closeChallengeModal = function(){
                const modal = $('challengeModal');
                modal.style.display = 'none';
            }

            window.cancelChallengeSetup = function(){
                // å…³é—­å¹¶å¤ä½åˆ‡æ¢ä¸ºè‡ªç”±
                closeChallengeModal();
                if (toggleEl) {
                    toggleEl.checked = false;
                    updateSwitcherVisual();
                }
            }

            window.confirmChallengeSetup = async function(){
                const prep = Math.max(0, parseInt(($('challengePrepTime').value||'0'), 10));
                const bpm = Math.max(40, Math.min(240, parseInt(($('challengeBPM').value||'80'), 10)));
                // ä¿å­˜è®¾ç½®
                try{ localStorage.setItem('ic_jianpu_challenge_settings', JSON.stringify({ prep, bpm })); }catch(e){}
                closeChallengeModal();
                // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡åœ¨ç”¨æˆ·æ‰‹åŠ¿ä¸‹å°±ç»ª
                try { ensureClickAudio(); } catch(_) {}
                await startChallenge(prep, bpm);
            }

            function updateSwitcherVisual(){
                // å‚ç…§å’Œå¼¦é¡µçš„æ»‘å—æŒ‰é’®ä½ç§»
                const slider = toggleEl?.parentElement?.querySelector('.slider');
                const knob = slider ? slider.querySelector('.slider-button') : null;
                if (!slider || !knob) return;
                if (toggleEl.checked){
                    slider.style.backgroundColor = 'var(--primary-orange, #ff9500)';
                    knob.style.transform = 'translateX(26px)';
                } else {
                    slider.style.backgroundColor = '#ccc';
                    knob.style.transform = 'translateX(0px)';
                }
            }

            function ensureOverlay(){
                if (state.overlayEl && state.overlayEl.parentNode) return state.overlayEl;
                const overlay = document.createElement('div');
                overlay.id = 'challengeOverlay';
                overlay.style.position = 'absolute';
                overlay.style.inset = '0';
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '5';
                scoreEl.appendChild(overlay);

                // cursor
                const cursor = document.createElement('div');
                cursor.id = 'challengeCursor';
                cursor.style.position = 'absolute';
                cursor.style.top = '0';
                cursor.style.width = '2px';
                cursor.style.height = '100%';
                cursor.style.left = '0';
                cursor.style.background = 'var(--primary-blue, #007aff)';
                cursor.style.boxShadow = '0 0 0 0 rgba(0,122,255,0.6)';
                cursor.style.transition = 'box-shadow 0.12s ease';
                overlay.appendChild(cursor);

                state.overlayEl = overlay;
                state.cursorEl = cursor;
                return overlay;
            }

            function clearOverlay(){
                if (state.rafId) cancelAnimationFrame(state.rafId);
                if (state.prepTimerId) clearTimeout(state.prepTimerId);
                if (state.prepBeatTimerId) clearInterval(state.prepBeatTimerId);
                state.rafId = null;
                state.prepTimerId = null;
                state.prepBeatTimerId = null;
                state.masked.clear();
                state.lastIndex = -1;
                if (state.overlayEl && state.overlayEl.parentNode){
                    state.overlayEl.parentNode.removeChild(state.overlayEl);
                }
                state.overlayEl = null;
                state.cursorEl = null;
            }

async function ensureScoreReady(){
                // å¦‚æœä¸å­˜åœ¨SVGåˆ™å°è¯•ç”Ÿæˆæ—‹å¾‹
                let svg = scoreEl.querySelector('svg');
                if (!svg && typeof window.generateMelody === 'function') {
                    try { window.generateMelody(); } catch(e) {}
                }
                const t0 = Date.now();
                while (!svg && Date.now() - t0 < 6000){
                    await new Promise(r => setTimeout(r, 100));
                    svg = scoreEl.querySelector('svg');
                }
    // åŒæ—¶ç­‰å¾…OSMDå›¾å½¢å±‚ï¼ˆè‹¥å¯ç”¨ï¼‰
    if (typeof osmd !== 'undefined' && osmd){
        const t1 = Date.now();
        while (Date.now() - t1 < 2000){
            try{
                if (osmd.GraphicSheet && Array.isArray(osmd.GraphicSheet.MeasureList) && osmd.GraphicSheet.MeasureList.length > 0) break;
            }catch(_){}
            await new Promise(r => setTimeout(r, 80));
        }
    }
    return !!svg;
}

            function getCurrentTimeSignature(){
                let timeSig = '4/4';
                try{
                    if (typeof melodyHistory !== 'undefined' && typeof currentHistoryIndex !== 'undefined'){
                        const md = melodyHistory[currentHistoryIndex];
                        if (md && md.config && md.config.timeSignature){ timeSig = md.config.timeSignature; }
                    }
                }catch(e){}
                return String(timeSig);
            }

            function collectMeasureRects(){
                const svg = scoreEl.querySelector('svg');
                if (!svg) return [];
                const containerRect = scoreEl.getBoundingClientRect();

                function getScreenRectForElement(el){
                    try {
                        if (typeof el.getBBox === 'function') {
                            const bbox = el.getBBox();
                            if (bbox && bbox.width > 0 && bbox.height > 0 && typeof el.getScreenCTM === 'function') {
                                const ctm = el.getScreenCTM();
                                if (ctm) {
                                    const pt = svg.createSVGPoint();
                                    const corners = [
                                        [bbox.x, bbox.y],
                                        [bbox.x + bbox.width, bbox.y],
                                        [bbox.x, bbox.y + bbox.height],
                                        [bbox.x + bbox.width, bbox.y + bbox.height]
                                    ];
                                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                    for (const [x, y] of corners) {
                                        pt.x = x; pt.y = y;
                                        const res = pt.matrixTransform(ctm);
                                        if (!isNaN(res.x) && !isNaN(res.y)) {
                                            minX = Math.min(minX, res.x);
                                            minY = Math.min(minY, res.y);
                                            maxX = Math.max(maxX, res.x);
                                            maxY = Math.max(maxY, res.y);
                                        }
                                    }
                                    if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
                                        return { left: minX, top: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
                                    }
                                }
                            }
                        }
                    } catch(e) { /* ignore and fallback */ }
                    // Fallback: use getBoundingClientRect
                    if (typeof el.getBoundingClientRect === 'function') {
                        const r = el.getBoundingClientRect();
                        if (r && r.width > 0 && r.height > 0) {
                            return { left: r.left, top: r.top, width: r.width, height: r.height };
                        }
                    }
                    return null;
                }

                const allG = svg.querySelectorAll('g');
                const list = [];
                allG.forEach(g => {
                    const id = (g.getAttribute('id') || '').toLowerCase();
                    const cls = (g.getAttribute('class') || '').toLowerCase();
                    const looksLikeMeasure = id.includes('measure') || cls.includes('measure');
                    if (!looksLikeMeasure) return;
                    const screenRect = getScreenRectForElement(g);
                    if (!screenRect) return;
                    // è¿‡æ»¤æå°å…ƒç´ 
                    if (screenRect.width <= 2 || screenRect.height <= 2) return;
                    list.push({
                        el: g,
                        x: screenRect.left - containerRect.left + scoreEl.scrollLeft,
                        y: screenRect.top - containerRect.top + scoreEl.scrollTop,
                        width: screenRect.width,
                        height: screenRect.height
                    });
                });

                // ä»¥topå†leftæ’åºï¼Œç¡®ä¿é¡ºåºæ­£ç¡®
                list.sort((a,b)=> a.y === b.y ? a.x - b.x : a.y - b.y);
                // ç®€å•å»é‡ï¼šå»æ‰åæ ‡/å°ºå¯¸å‡ ä¹ä¸€è‡´çš„é‡å¤åˆ†ç»„
                const dedup = [];
                const eps = 3; // px å®¹å·®
                for (const m of list) {
                    const last = dedup[dedup.length - 1];
                    if (!last) { dedup.push(m); continue; }
                    const almostSame = Math.abs(m.x - last.x) < eps && Math.abs(m.y - last.y) < eps && Math.abs(m.width - last.width) < eps && Math.abs(m.height - last.height) < eps;
                    if (!almostSame) dedup.push(m);
                }
                return dedup;
            }

            async function waitForMeasuresReady(maxWaitMs){
                const t0 = Date.now();
                let rects = [];
                // ä¼˜å…ˆ: OSMDå›¾å½¢å±‚
                if (typeof window.getOSMDMeasureRects === 'function'){
                    try { const r = window.getOSMDMeasureRects(); if (Array.isArray(r) && r.length>0) rects = r; } catch(_) {}
                }
                if (rects.length === 0){ rects = collectMeasureRects(); }
                while ((rects.length === 0 || rects.every(r => r.width === 0 || r.height === 0)) && Date.now() - t0 < maxWaitMs){
                    await new Promise(r => setTimeout(r, 120));
                    rects = [];
                    if (typeof window.getOSMDMeasureRects === 'function'){
                        try { const r = window.getOSMDMeasureRects(); if (Array.isArray(r) && r.length>0) rects = r; } catch(_) {}
                    }
                    if (rects.length === 0) rects = collectMeasureRects();
                }

                // å¦‚æœä¾ç„¶æ‹¿ä¸åˆ°ï¼Œå°è¯•åŸºäºç«–çº¿(barline)æ¨æ–­çœŸå®å°èŠ‚åˆ†éš”
                if (rects.length === 0 || rects.every(r => r.width === 0 || r.height === 0)) {
                    const byBars = collectMeasureRectsByBarlines();
                    if (byBars.length > 0) return byBars;
                }

                // å¦‚æœä¾ç„¶æ‹¿ä¸åˆ°ï¼Œå°è¯•æŒ‰ç³»ç»Ÿåˆ†å‰²ï¼ˆå…œåº•æ–¹æ¡ˆï¼‰
                if (rects.length === 0 || rects.every(r => r.width === 0 || r.height === 0)) {
                    const bySystem = collectMeasureRectsBySystemSubdivision();
                    if (bySystem.length > 0) return bySystem;
                }

                // é¢å¤–çŸ­æš‚å…œåº•ç­‰å¾…ï¼Œå†è¯•ä¸€æ¬¡
                if (rects.length === 0) {
                    const t1 = Date.now();
                    while (rects.length === 0 && Date.now() - t1 < 1200){
                        await new Promise(r => setTimeout(r, 120));
                        rects = collectMeasureRects();
                    }
                    if (rects.length === 0) {
                        const bySystem2 = collectMeasureRectsBySystemSubdivision();
                        if (bySystem2.length > 0) return bySystem2;
                        // æœ€åå…œåº•ï¼šåŸºäºsvgå…¨å±€bboxæŒ‰é¢„æœŸå°èŠ‚æ•°ç­‰åˆ†
                        const equalSplit = collectMeasureRectsByGlobalEqualSplit();
                        if (equalSplit.length > 0) return equalSplit;
                    }
                }
                // éªŒè¯ç¨³å®šæ€§ï¼šè¿ç»­ä¸¤æ¬¡é‡‡æ ·å‡ ä½•å·®å¼‚å¾ˆå°
                rects = await waitForStableMeasures(rects, 400);
                // è‹¥æ•°é‡ä¸XMLé¢„æœŸä¸ç¬¦ï¼Œå°è¯•å›é€€/æ ¡æ­£
                const expected = getExpectedMeasureCountFromXML();
                if (expected > 0 && rects.length !== expected){
                    const bars = collectMeasureRectsByBarlines();
                    if (bars.length === expected) return bars;
                    const sys = collectMeasureRectsBySystemSubdivision();
                    if (sys.length === expected) return sys;
                }
                return rects;
            }

            async function waitForStableMeasures(initialRects, maxWaitMs){
                const eps = 2; // px å®¹å·®
                const start = Date.now();
                let prev = initialRects || collectMeasureRects();
                while (Date.now() - start < maxWaitMs){
                    await new Promise(r => requestAnimationFrame(()=>r()));
                    const nowRects = collectMeasureRects();
                    if (prev.length === nowRects.length){
                        let stable = true;
                        for (let i=0;i<prev.length;i++){
                            const a = prev[i], b = nowRects[i];
                            if (!b || Math.abs(a.x-b.x)>eps || Math.abs(a.y-b.y)>eps || Math.abs(a.width-b.width)>eps || Math.abs(a.height-b.height)>eps){
                                stable = false; break;
                            }
                        }
                        if (stable) return nowRects;
                    }
                    prev = nowRects;
                }
                return prev;
            }

function getExpectedMeasureCountFromXML(){
    try{
        // 1) ä¼˜å…ˆï¼šOSMDå›¾å½¢å±‚
        if (typeof osmd !== 'undefined' && osmd && osmd.GraphicSheet && Array.isArray(osmd.GraphicSheet.MeasureList)){
            const n = osmd.GraphicSheet.MeasureList.length;
            if (n && n > 0) return n;
        }
        // 2) æ—‹å¾‹é…ç½®
        if (typeof melodyHistory !== 'undefined' && typeof currentHistoryIndex !== 'undefined'){
            const md = melodyHistory[currentHistoryIndex];
            if (md && md.config && typeof md.config.measures === 'number' && md.config.measures > 0) return md.config.measures;
        }
        // 3) è§£æMusicXML
        const xml = getCurrentMelodyXML();
        if (!xml) return 0;
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const measures = doc.querySelectorAll('part measure');
            if (measures && measures.length > 0) return measures.length;
        } catch(_) {}
        // æ­£åˆ™å…œåº•ç»Ÿè®¡ <measure çš„å‡ºç°æ¬¡æ•°
        const m = xml.match(/<measure\b/gi);
        return m ? m.length : 0;
    }catch(e){ return 0; }
}

function collectMeasureRectsByGlobalEqualSplit(){
    try{
        const svg = scoreEl.querySelector('svg');
        if (!svg) return [];
        let expected = getExpectedMeasureCountFromXML();
        if (!expected || expected <= 0) expected = 4; // æœ€åå…œåº•ï¼Œå‡è®¾4å°èŠ‚
        const bbox = svg.getBBox ? svg.getBBox() : null;
        const containerRect = scoreEl.getBoundingClientRect();
        const totalMeasures = expected;
        const perLine = totalMeasures <= 4 ? totalMeasures : 4; // å‡å®š4/è¡Œ
        const lines = Math.ceil(totalMeasures / perLine);
        // å½“bboxä¸å¯ç”¨æ—¶ï¼Œé€€å›å®¹å™¨å°ºå¯¸
        const useWidth = (bbox && bbox.width > 0) ? bbox.width : Math.max(10, scoreEl.clientWidth - 20);
        const useHeight = (bbox && bbox.height > 0) ? bbox.height : Math.max(40, scoreEl.clientHeight || 120);
        const bx = (bbox ? bbox.x : containerRect.left - containerRect.left + scoreEl.scrollLeft);
        const by = (bbox ? bbox.y : containerRect.top - containerRect.top + scoreEl.scrollTop);
        const lineHeight = useHeight / Math.max(1, lines);
        const leftMargin = Math.min(40, useWidth * 0.06); // é¢„ç•™clef/keyåŒº
        const usableW = Math.max(10, useWidth - leftMargin);
        const out = [];
        let remain = totalMeasures;
        for (let row=0; row<lines; row++){
            const thisCount = Math.min(perLine, remain);
            const segW = usableW / thisCount;
            for (let i=0;i<thisCount;i++){
                const x = (bx - containerRect.left + scoreEl.scrollLeft) + leftMargin + i*segW;
                const y = (by - containerRect.top + scoreEl.scrollTop) + row*lineHeight;
                out.push({ x, y, width: segW, height: lineHeight });
            }
            remain -= thisCount;
        }
        return out;
    }catch(e){ return []; }
}

            function collectSystemRects(){
                const svg = scoreEl.querySelector('svg');
                if (!svg) return [];
                const containerRect = scoreEl.getBoundingClientRect();
                // é¦–é€‰ï¼šé€šè¿‡äº”çº¿è°±æ°´å¹³çº¿(path)ç›´æ¥è¯†åˆ«ç³»ç»Ÿ
                const systemsByStaff = collectSystemRectsFromStaffLines();
                if (systemsByStaff.length) return systemsByStaff;

                const allG = svg.querySelectorAll('g');
                const systemRectsById = [];
                const rects = [];
                // 1) é¦–å…ˆå°è¯•é€šè¿‡ id/class åŒ…å« system çš„ group
                allG.forEach(g => {
                    const id = (g.getAttribute('id') || '').toLowerCase();
                    const cls = (g.getAttribute('class') || '').toLowerCase();
                    const looksLikeSystem = id.includes('system') || cls.includes('system');
                    if (!looksLikeSystem) return;
                    const screenRect = (function(){
                        try {
                            if (typeof g.getBBox === 'function') {
                                const bbox = g.getBBox();
                                if (bbox && bbox.width > 0 && bbox.height > 0 && typeof g.getScreenCTM === 'function') {
                                    const ctm = g.getScreenCTM();
                                    if (ctm) {
                                        const pt = svg.createSVGPoint();
                                        const corners = [[bbox.x, bbox.y],[bbox.x + bbox.width, bbox.y],[bbox.x, bbox.y + bbox.height],[bbox.x + bbox.width, bbox.y + bbox.height]];
                                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                        for (const [x, y] of corners) {
                                            pt.x = x; pt.y = y;
                                            const res = pt.matrixTransform(ctm);
                                            if (!isNaN(res.x) && !isNaN(res.y)) {
                                                minX = Math.min(minX, res.x);
                                                minY = Math.min(minY, res.y);
                                                maxX = Math.max(maxX, res.x);
                                                maxY = Math.max(maxY, res.y);
                                            }
                                        }
                                        if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
                                            return { left: minX, top: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
                                        }
                                    }
                                }
                            }
                        } catch(e) {}
                        if (typeof g.getBoundingClientRect === 'function') {
                            const r = g.getBoundingClientRect();
                            if (r && r.width > 0 && r.height > 0) return { left: r.left, top: r.top, width: r.width, height: r.height };
                        }
                        return null;
                    })();
                    if (!screenRect) return;
                    if (screenRect.width <= 10 || screenRect.height <= 10) return;
                    systemRectsById.push({
                        x: screenRect.left - containerRect.left + scoreEl.scrollLeft,
                        y: screenRect.top - containerRect.top + scoreEl.scrollTop,
                        width: screenRect.width,
                        height: screenRect.height
                    });
                });
                if (systemRectsById.length) {
                    systemRectsById.sort((a,b)=> a.y === b.y ? a.x - b.x : a.y - b.y);
                    return systemRectsById;
                }

                // 2) å…œåº•ï¼šæŒ‰ y èšç±»æ‰€æœ‰è¾ƒå¤§ g è¿‘ä¼¼å¾—åˆ°æ¯ä¸€è¡Œç³»ç»Ÿ
                const largeGroups = [];
                allG.forEach(g => {
                    const screenRect = (function(){
                        try {
                            if (typeof g.getBBox === 'function') {
                                const bbox = g.getBBox();
                                if (bbox && bbox.width > 0 && bbox.height > 0 && typeof g.getScreenCTM === 'function') {
                                    const ctm = g.getScreenCTM();
                                    if (ctm) {
                                        const pt = svg.createSVGPoint();
                                        const corners = [[bbox.x, bbox.y],[bbox.x + bbox.width, bbox.y],[bbox.x, bbox.y + bbox.height],[bbox.x + bbox.width, bbox.y + bbox.height]];
                                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                                        for (const [x, y] of corners) {
                                            pt.x = x; pt.y = y;
                                            const res = pt.matrixTransform(ctm);
                                            if (!isNaN(res.x) && !isNaN(res.y)) {
                                                minX = Math.min(minX, res.x);
                                                minY = Math.min(minY, res.y);
                                                maxX = Math.max(maxX, res.x);
                                                maxY = Math.max(maxY, res.y);
                                            }
                                        }
                                        if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
                                            return { left: minX, top: minY, width: Math.max(0, maxX - minX), height: Math.max(0, maxY - minY) };
                                        }
                                    }
                                }
                            }
                        } catch(e) {}
                        if (typeof g.getBoundingClientRect === 'function') {
                            const r = g.getBoundingClientRect();
                            if (r && r.width > 50 && r.height > 30) return { left: r.left, top: r.top, width: r.width, height: r.height };
                        }
                        return null;
                    })();
                    if (!screenRect) return;
                    largeGroups.push({
                        x: screenRect.left - containerRect.left + scoreEl.scrollLeft,
                        y: screenRect.top - containerRect.top + scoreEl.scrollTop,
                        width: screenRect.width,
                        height: screenRect.height
                    });
                });
                // y èšç±»ï¼ˆå®¹å·® 20pxï¼‰
                const rows = [];
                const tol = 20;
                largeGroups.forEach(r => {
                    let bucket = rows.find(b => Math.abs(b.y - r.y) < tol);
                    if (!bucket) { rows.push({ y: r.y, x1: r.x, y1: r.y, x2: r.x + r.width, y2: r.y + r.height }); }
                    else {
                        bucket.x1 = Math.min(bucket.x1, r.x);
                        bucket.y1 = Math.min(bucket.y1, r.y);
                        bucket.x2 = Math.max(bucket.x2, r.x + r.width);
                        bucket.y2 = Math.max(bucket.y2, r.y + r.height);
                    }
                });
                rows.sort((a,b)=> a.y - b.y);
                rows.forEach(b => rects.push({ x: b.x1, y: b.y1, width: b.x2 - b.x1, height: b.y2 - b.y1 }));
                return rects;
            }

            function collectSystemRectsFromStaffLines(){
                const svg = scoreEl.querySelector('svg');
                if (!svg) return [];
                const containerRect = scoreEl.getBoundingClientRect();
                const svgBBox = svg.getBoundingClientRect();
                // è§£æviewBoxæ¯”ä¾‹ï¼Œå°†è·¯å¾„åæ ‡æ˜ å°„åˆ°åƒç´ 
                let vb = { x:0, y:0, width: svgBBox.width, height: svgBBox.height };
                if (svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width > 0){
                    vb = svg.viewBox.baseVal;
                }
                const scaleX = svgBBox.width / (vb.width || 1);
                const scaleY = svgBBox.height / (vb.height || 1);

                // æ”¶é›†æ°´å¹³pathï¼ˆäº”çº¿è°±çº¿ï¼‰
                const paths = Array.from(svg.querySelectorAll('path'));
                const lines = [];
                for (const p of paths){
                    const d = p.getAttribute('d') || '';
                    const nums = d.match(/-?\d+\.?\d*/g);
                    if (!nums || nums.length < 4) continue;
                    const x1 = parseFloat(nums[0]);
                    const y1 = parseFloat(nums[1]);
                    const x2 = parseFloat(nums[2]);
                    const y2 = parseFloat(nums[3]);
                    if (!isFinite(x1)||!isFinite(y1)||!isFinite(x2)||!isFinite(y2)) continue;
                    if (Math.abs(y1 - y2) > 0.2) continue; // è¿‘ä¼¼æ°´å¹³
                    const pxY = (y1 - vb.y) * scaleY;
                    const pxX1 = (x1 - vb.x) * scaleX;
                    const pxX2 = (x2 - vb.x) * scaleX;
                    const relY = svgBBox.top - containerRect.top + scoreEl.scrollTop + pxY;
                    const relX1 = svgBBox.left - containerRect.left + scoreEl.scrollLeft + Math.min(pxX1, pxX2);
                    const relX2 = svgBBox.left - containerRect.left + scoreEl.scrollLeft + Math.max(pxX1, pxX2);
                    // è¿‡æ»¤è¿‡çŸ­çº¿æ®µ
                    if (relX2 - relX1 < 20) continue;
                    lines.push({ y: relY, x1: relX1, x2: relX2 });
                }
                if (lines.length < 5) return [];
                lines.sort((a,b)=> a.y - b.y);
                // å»é‡yï¼ˆåŒä¸€æ¡äº”çº¿è°±çº¿ä¼šåˆ†æ®µå‡ºç°ï¼Œå–yè¿‘ä¼¼ç›¸ç­‰çš„åˆå¹¶xèŒƒå›´ï¼‰
                const yLevels = [];
                const epsY = 2;
                for (const ln of lines){
                    let found = yLevels.find(l => Math.abs(l.y - ln.y) < epsY);
                    if (!found){
                        yLevels.push({ y: ln.y, minX: Math.min(ln.x1, ln.x2), maxX: Math.max(ln.x1, ln.x2) });
                    } else {
                        found.minX = Math.min(found.minX, ln.x1, ln.x2);
                        found.maxX = Math.max(found.maxX, ln.x1, ln.x2);
                    }
                }
                yLevels.sort((a,b)=> a.y - b.y);
                if (yLevels.length < 5) return [];
                // å°†yLevelsæŒ‰æ¯5æ¡åˆ†ä¸ºä¸€ä¸ªç³»ç»Ÿï¼ˆå¸¸è§æƒ…å†µï¼‰
                const rects = [];
                for (let i=0; i+4 < yLevels.length; i+=5){
                    const group = yLevels.slice(i, i+5);
                    const minY = group[0].y;
                    const maxY = group[4].y;
                    const spacing = (maxY - minY) / 4;
                    const sysY = minY - Math.max(1, spacing*0.4);
                    const sysH = (maxY - minY) + Math.max(2, spacing*0.8);
                    const minX = Math.min(...group.map(g => g.minX));
                    const maxX = Math.max(...group.map(g => g.maxX));
                    rects.push({ x: minX, y: sysY, width: Math.max(10, maxX - minX), height: sysH });
                }
                return rects;
            }

            function collectMeasureRectsByBarlines(){
                const svg = scoreEl.querySelector('svg');
                if (!svg) return [];
                const systems = collectSystemRects();
                if (!systems.length) return [];
                const containerRect = scoreEl.getBoundingClientRect();

                function screenRect(el){
                    try {
                        if (typeof el.getBBox === 'function' && typeof el.getScreenCTM === 'function'){
                            const bbox = el.getBBox();
                            const ctm = el.getScreenCTM();
                            if (bbox && ctm) {
                                const pt = svg.createSVGPoint();
                                const corners = [[bbox.x,bbox.y],[bbox.x+bbox.width,bbox.y],[bbox.x,bbox.y+bbox.height],[bbox.x+bbox.width,bbox.y+bbox.height]];
                                let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
                                for (const [x,y] of corners){ pt.x=x; pt.y=y; const r=pt.matrixTransform(ctm); minX=Math.min(minX,r.x); minY=Math.min(minY,r.y); maxX=Math.max(maxX,r.x); maxY=Math.max(maxY,r.y);} 
                                return { left:minX, top:minY, width:Math.max(0,maxX-minX), height:Math.max(0,maxY-minY) };
                            }
                        }
                    }catch(e){}
                    const r = el.getBoundingClientRect ? el.getBoundingClientRect() : null;
                    if (r && r.width>0 && r.height>0) return { left:r.left, top:r.top, width:r.width, height:r.height };
                    return null;
                }

                const lines = Array.from(svg.querySelectorAll('line, path, rect'));
                const measures = [];
                systems.forEach(sys => {
                    // æ”¶é›†è¯¥ç³»ç»Ÿå†…çš„ç«–ç›´åˆ†éš”æ¡ï¼ˆé«˜ä¸”çª„ï¼Œè½åœ¨ç³»ç»Ÿæ¨ªå‘èŒƒå›´å†…ï¼‰
                    const barXsRaw = [];
                    const left = sys.x, right = sys.x + sys.width, top = sys.y, bottom = sys.y + sys.height;
                    lines.forEach(el => {
                        const r = screenRect(el);
                        if (!r) return;
                        const xCenter = r.left - containerRect.left + scoreEl.scrollLeft + r.width/2;
                        const yTop = r.top - containerRect.top + scoreEl.scrollTop;
                        const yBottom = yTop + r.height;
                        // éœ€è¦è½åœ¨ç³»ç»Ÿæ°´å¹³èŒƒå›´å†…ï¼Œå¹¶ä¸”çºµå‘è¦†ç›–ç³»ç»Ÿâ€œç»å¤§éƒ¨åˆ†â€é«˜åº¦ï¼Œä¸”è¶³å¤Ÿç»†
                        const tallEnough = r.height >= sys.height * 0.9;
                        const thinEnough = r.width <= 3;
                        const insideX = xCenter >= left && xCenter <= right;
                        const overlappingY = (yTop <= bottom) && (yBottom >= top);
                        if (tallEnough && thinEnough && insideX && overlappingY){
                            barXsRaw.push(xCenter);
                        }
                    });
                    // å»é‡å¹¶æ’åº
                    const eps = Math.max(2, sys.width * 0.002);
                    const barXs = [];
                    barXsRaw.sort((a,b)=>a-b).forEach(x => {
                        if (barXs.length === 0 || Math.abs(x - barXs[barXs.length-1]) > eps) barXs.push(x);
                    });

                    // å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ªå†…éƒ¨barlineæ‰é‡‡ç”¨barlineæ–¹æ¡ˆ
                    if (barXs.length < 1) return; // è¯¥ç³»ç»Ÿæ²¡æœ‰å¯ç”¨barline

                    // è¡¥ä¸Šç³»ç»Ÿå·¦å³è¾¹ç•Œä½œä¸ºå¤–ä¾§åˆ†éš”
                    barXs.unshift(left);
                    barXs.push(right);

                    // å»é™¤å¯èƒ½ä¸å·¦å³è¾¹ç•Œé‡å çš„barline
                    const uniq = [];
                    barXs.sort((a,b)=>a-b).forEach(x => {
                        if (uniq.length === 0 || Math.abs(x - uniq[uniq.length-1]) > eps) uniq.push(x);
                    });
                    if (uniq.length < 3) return; // åªæœ‰å·¦å³è¾¹ç•Œï¼Œæ²¡æœ‰å†…éƒ¨barï¼Œæ”¾å¼ƒæ­¤ç³»ç»Ÿçš„barlineæ–¹æ¡ˆ

                    // ç›¸é‚»åˆ†éš”å½¢æˆå°èŠ‚
                    for (let i=0;i<uniq.length-1;i++){
                        const x1 = uniq[i];
                        const x2 = uniq[i+1];
                        const w = x2 - x1;
                        if (w <= 8) continue; // è¿‡æ»¤æçª„æ®µ
                        measures.push({ x:x1, y: top, width: w, height: sys.height });
                    }
                });
                return measures;
            }

            function findFirstBeatXWithinFirstMeasure(){
                const svg = scoreEl.querySelector('svg');
                if (!svg || !state.measureRects || state.measureRects.length === 0) return null;
                const m0 = state.measureRects[0];
                const containerRect = scoreEl.getBoundingClientRect();
                const candidates = svg.querySelectorAll('[class*="stavenote"], [class*="notehead"], [class*="StaveNote"], [class*="NoteHead"]');
                let bestX = null;
                candidates.forEach(el => {
                    const r = el.getBoundingClientRect ? el.getBoundingClientRect() : null;
                    if (!r || r.width<=0 || r.height<=0) return;
                    const cx = r.left - containerRect.left + scoreEl.scrollLeft + r.width/2;
                    const cy = r.top - containerRect.top + scoreEl.scrollTop + r.height/2;
                    // å¿…é¡»è½åœ¨ç¬¬1å°èŠ‚çš„å‚ç›´èŒƒå›´å†…ï¼Œä¸”åœ¨å°èŠ‚å†…éƒ¨ï¼ˆé¢„ç•™å·¦è¾¹è·ï¼‰
                    const withinY = cy >= m0.y && cy <= (m0.y + m0.height);
                    const withinX = cx >= (m0.x + Math.min(20, m0.width*0.05)) && cx <= (m0.x + m0.width);
                    if (withinY && withinX){
                        if (bestX === null || cx < bestX) bestX = cx;
                    }
                });
                return bestX;
            }

            function collectMeasureRectsBySystemSubdivision(){
                try {
                    const systems = collectSystemRects();
                    // è¯»å–æ€»å°èŠ‚æ•°ï¼šä¼˜å…ˆ OSMDï¼Œå…¶æ¬¡ä»å½“å‰æ—‹å¾‹é…ç½®
                    let totalMeasures = 0;
                    if (typeof osmd !== 'undefined' && osmd && osmd.GraphicSheet && Array.isArray(osmd.GraphicSheet.MeasureList)) {
                        totalMeasures = osmd.GraphicSheet.MeasureList.length;
                    } else if (typeof melodyHistory !== 'undefined' && typeof currentHistoryIndex !== 'undefined') {
                        const md = melodyHistory[currentHistoryIndex];
                        if (md && md.config && typeof md.config.measures === 'number') totalMeasures = md.config.measures;
                    }
                    if (!systems.length || !totalMeasures) return [];
                    // ä¼°ç®—æ¯è¡Œå°èŠ‚æ•°ï¼ˆæ ¹æ®æ¸²æŸ“ç­–ç•¥ï¼š>4 åˆ™ 4/è¡Œï¼Œå¦åˆ™æ€»æ•°/è¡Œï¼‰
                    let perLine = 4;
                    try {
                        if (typeof osmd !== 'undefined' && osmd && osmd.EngravingRules && typeof osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem === 'number' && osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem > 0) {
                            perLine = osmd.EngravingRules.RenderXMeasuresPerLineAkaSystem;
                        }
                    } catch(_) {}
                    if (totalMeasures <= 4) {
                        perLine = totalMeasures;
                    }
                    const out = [];
                    let remain = totalMeasures;
                    systems.forEach((sys, idx) => {
                        const thisCount = Math.min(perLine, remain);
                        if (thisCount <= 0) return;
                        const leftMarginFix = Math.max(0, Math.min(sys.width*0.05, 20)); // é¿å… clef/key åŒºåŸŸï¼Œç•¥å¾®å³ç§»
                        const usableX = sys.x + leftMarginFix;
                        const usableW = Math.max(10, sys.width - leftMarginFix);
                        const segW = usableW / thisCount;
                        for (let i=0;i<thisCount;i++){
                            out.push({ x: usableX + i*segW, y: sys.y, width: segW, height: sys.height });
                        }
                        remain -= thisCount;
                    });
                    // è‹¥æ•°é‡ä¸æ€»å°èŠ‚ä¸ç¬¦ï¼Œæˆªæ–­æˆ–ä¿ç•™å‰ totalMeasures ä¸ª
                    if (out.length > totalMeasures) return out.slice(0, totalMeasures);
                    return out;
                } catch(e){ return []; }
            }

            function getCurrentMelodyXML(){
                try{
                    if (typeof melodyHistory !== 'undefined' && typeof currentHistoryIndex !== 'undefined'){
                        const md = melodyHistory[currentHistoryIndex];
                        if (md && typeof md.musicXML === 'string' && md.musicXML.length > 0) return md.musicXML;
                    }
                }catch(e){}
                return null;
            }

            function parseTimeSigFromXML(xml){
                try{
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xml, 'text/xml');
                    // ä¼˜å…ˆå–ç¬¬ä¸€å°èŠ‚ <attributes><time>
                    const timeEl = doc.querySelector('measure attributes time');
                    if (timeEl){
                        const b = timeEl.querySelector('beats');
                        const bt = timeEl.querySelector('beat-type');
                        const num = parseInt((b && b.textContent)||'4',10);
                        const den = parseInt((bt && bt.textContent)||'4',10);
                        if (!isNaN(num) && !isNaN(den) && num>0 && den>0){ return { num, den }; }
                    }
                }catch(e){}
                return null;
            }

            function parseMeasureDurationSec(bpm){
                // ä¼˜å…ˆä»å½“å‰æ—‹å¾‹çš„ MusicXML è¯»å–æ‹å·
                const xml = getCurrentMelodyXML();
                let num, den;
                const ts = xml ? parseTimeSigFromXML(xml) : null;
                if (ts){ num = ts.num; den = ts.den; }
                else {
                    const timeSig = getCurrentTimeSignature();
                    const parts = String(timeSig||'4/4').split('/');
                    num = parseInt(parts[0]||'4',10);
                    den = parseInt(parts[1]||'4',10);
                    if (!isFinite(num) || !isFinite(den)) { num = 4; den = 4; }
                }
                const secPerQuarter = 60 / Math.max(1, bpm);
                const secPerMeasure = (num * (4/den)) * secPerQuarter;
                // åˆç†åŒºé—´ä¿æŠ¤ï¼šè‹¥å¼‚å¸¸è¿‡å°ï¼Œå›é€€ä¸º4/4è®¡ç®—
                if (!isFinite(secPerMeasure) || secPerMeasure < 0.25){
                    return 4 * secPerQuarter; // 4/4 å…œåº•
                }
                return secPerMeasure;
            }

            function maskMeasure(index){
                if (!state.overlayEl || !state.measureRects[index] || state.masked.has(index)) return;
                const theme = document.documentElement.getAttribute('data-theme') || 'light';
                const m = state.measureRects[index];
                const mask = document.createElement('div');
                mask.className = 'measure-mask';
                mask.style.position = 'absolute';
                mask.style.left = m.x + 'px';
                mask.style.top = m.y + 'px';
                mask.style.width = Math.max(1, m.width) + 'px';
                mask.style.height = Math.max(1, m.height) + 'px';
                mask.style.background = theme === 'dark' ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.92)';
                mask.style.backdropFilter = 'blur(1px)';
                mask.style.borderRadius = '2px';
                state.overlayEl.appendChild(mask);
                state.masked.add(index);
            }

            function animateCursor(startTs){
                const now = performance.now();
                const elapsedSec = (now - startTs) / 1000;
                const totalMeasures = state.measureRects.length;
                const md = state.measureDuration || 1e-6;
                let idx = Math.floor(elapsedSec / md);
                if (idx >= totalMeasures){
                    // ç»“æŸ
                    maskMeasure(totalMeasures-1);
                    stopChallenge();
                    return;
                }
                const within = elapsedSec - idx * md;
                const frac = Math.max(0, Math.min(1, within / md));

                // å»¶è¿Ÿé®ç›–ä¸Šä¸€å°èŠ‚ï¼šè¿›å…¥æ–°å°èŠ‚åï¼Œç­‰å‰è¿›ä¸€å®šæ¯”ä¾‹å†é®ç›–ä¸Šä¸€å°èŠ‚
                const prev = idx - 1;
                if (prev >= 0 && !state.masked.has(prev) && frac >= 0.06) {
                    maskMeasure(prev);
                }

                // æ›´æ–°è“çº¿ä½ç½®ä¸å°ºå¯¸ï¼ˆä»…è¦†ç›–å½“å‰å°èŠ‚é«˜åº¦èŒƒå›´å†…ï¼‰
                const m = state.measureRects[idx];
                const x = m.x + m.width * frac;
                if (state.cursorEl){
                    const top = m.y + m.height * 0.05;
                    const height = Math.max(2, m.height * 0.9);
                    state.cursorEl.style.transform = `translateX(${x}px)`;
                    state.cursorEl.style.top = `${top}px`;
                    state.cursorEl.style.height = `${height}px`;
                }
                state.lastIndex = idx;
                state.rafId = requestAnimationFrame(()=>animateCursor(startTs));
            }

            function startCountIn(bpm){
                // ä¾æ®å½“å‰æ‹å·ï¼Œ4/4â†’4æ‹ï¼Œ3/4â†’3æ‹ï¼Œ2/4â†’2æ‹ï¼Œ6/8â†’6æ‹
                let beats = 4, denVal = 4;
                const xml = getCurrentMelodyXML();
                const ts = xml ? parseTimeSigFromXML(xml) : null;
                if (ts){ beats = ts.num; denVal = ts.den; }
                else {
                    const tsStr = getCurrentTimeSignature();
                    const parts = String(tsStr||'4/4').split('/');
                    beats = parseInt(parts[0]||'4',10);
                    denVal = parseInt(parts[1]||'4',10);
                    if (!isFinite(beats) || !isFinite(denVal)) { beats = 4; denVal = 4; }
                }
                const beatSec = (60/Math.max(1,bpm)) * (4/denVal); // ä»¥åˆ†æ¯ä¸ºæ‹å•ä½

                // å…‰æ ‡åˆ°ç¬¬1å°èŠ‚å·¦ç¼˜
                const first = state.measureRects[0];
                if (first && state.cursorEl){
                    let startX = first.x;
                    const fbX = findFirstBeatXWithinFirstMeasure();
                    if (typeof fbX === 'number' && isFinite(fbX)) startX = fbX;
                    state.cursorEl.style.transform = `translateX(${startX}px)`;
                    const top = first.y + first.height * 0.05;
                    const height = Math.max(2, first.height * 0.9);
                    state.cursorEl.style.top = `${top}px`;
                    state.cursorEl.style.height = `${height}px`;
                }

                // count-in æ–‡æœ¬
                const overlay = ensureOverlay();
                const label = document.createElement('div');
                label.id = 'challengeCountInLabel';
                label.style.position = 'absolute';
                label.style.top = '8px';
                label.style.left = '50%';
                label.style.transform = 'translateX(-50%)';
                label.style.fontSize = '18px';
                label.style.fontWeight = '700';
                label.style.color = 'var(--text-color)';
                label.style.background = 'rgba(0,0,0,0.05)';
                label.style.padding = '4px 10px';
                label.style.borderRadius = '999px';
                label.style.backdropFilter = 'blur(2px)';
                overlay.appendChild(label);

                let i = 0;
                const timeSigStr = getCurrentTimeSignature();
                function strongBeat(n){
                    // 6/8 å¼ºåœ¨1ä¸4ï¼Œå…¶ä½™æ‹å¼±ï¼›å…¶å®ƒæ‹å·ä»…1å¼º
                    const is68 = (ts && ts.num===6 && ts.den===8) || timeSigStr === '6/8';
                    if (is68) return n===1 || n===4;
                    return n===1;
                }

                function tick(){
                    i++;
                    const n = i > beats ? beats : i;
                    // ç‚¹å‡»éŸ³ï¼ˆå¼ºå¼±åŒºåˆ†ï¼‰
                    ensureClickAudio();
                    try { playClick(strongBeat(n)); } catch(e) {}
                    label.textContent = String(n);
                    // å¼ºå¼±è§†è§‰ï¼šå¼ºæ‹æ›´è“æ›´å¤§å…‰æ™•ï¼Œå¼±æ‹è½»å¾®ï¼›ä¿æŒè“çº¿å°ºå¯¸åŒ¹é…ç¬¬1å°èŠ‚
                    if (state.cursorEl){
                        if (first){
                            const top = first.y + first.height * 0.05;
                            const height = Math.max(2, first.height * 0.9);
                            state.cursorEl.style.top = `${top}px`;
                            state.cursorEl.style.height = `${height}px`;
                        }
                        if (strongBeat(n)){
                            state.cursorEl.style.boxShadow = '0 0 0 8px rgba(0,122,255,0.20)';
                            label.style.color = 'var(--primary-blue, #007aff)';
                            label.style.opacity = '1';
                        } else {
                            state.cursorEl.style.boxShadow = '0 0 0 4px rgba(0,122,255,0.10)';
                            label.style.color = 'var(--text-color)';
                            label.style.opacity = '0.75';
                        }
                        setTimeout(()=>{ if(state.cursorEl) state.cursorEl.style.boxShadow = '0 0 0 0 rgba(0,122,255,0)'; }, Math.min(220, beatSec*800));
                    }

                    if (i >= beats){
                        // ç»“æŸcount-inï¼Œç§»é™¤æ–‡æœ¬ï¼Œå¼€å§‹åŠ¨ç”»
                        if (label && label.parentNode) label.parentNode.removeChild(label);
                        state.startTs = performance.now();
                        state.rafId = requestAnimationFrame(()=>animateCursor(state.startTs));
                        if (state.countInTimerId) { clearInterval(state.countInTimerId); state.countInTimerId = null; }
                    }
                }

                tick();
                state.countInTimerId = setInterval(tick, beatSec*1000);
            }

            function ensureClickAudio(){
                try {
                    if (!state.audioCtx) {
                        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    if (state.audioCtx && state.audioCtx.state === 'suspended') {
                        state.audioCtx.resume().catch(()=>{});
                    }
                } catch(_) {}
            }

            function playClick(isStrong){
                if (!state.audioCtx) return;
                try {
                    const ctx = state.audioCtx;
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = isStrong ? 880 : 660;
                    const now = ctx.currentTime;
                    const dur = isStrong ? 0.09 : 0.06;
                    const peak = isStrong ? 0.5 : 0.35;
                    g.gain.setValueAtTime(0.0001, now);
                    g.gain.exponentialRampToValueAtTime(peak, now + 0.005);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
                    osc.connect(g).connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + dur + 0.02);
                } catch(_) {}
            }

            function showCountdownUI(totalSec){
                const wrap = document.getElementById('challengeCountdownUI');
                const val = document.getElementById('challengeCountdownValue');
                if (wrap && val){
                    wrap.style.display = 'inline-flex';
                    val.textContent = String(Math.max(0, Math.ceil(totalSec)));
                }
            }
            function updateCountdownUI(remainSec){
                const val = document.getElementById('challengeCountdownValue');
                if (val){ val.textContent = String(Math.max(0, Math.ceil(remainSec))); }
            }
            function hideCountdownUI(){
                const wrap = document.getElementById('challengeCountdownUI');
                if (wrap){ wrap.style.display = 'none'; }
            }

            async function startChallenge(prepSec, bpm){
                if (state.active) stopChallenge();
                state.active = true;

                // å€’è®¡æ—¶UI
                showCountdownUI(prepSec);
                const tStart = Date.now();
                if (state.countdownTimerId) { clearInterval(state.countdownTimerId); }
                state.countdownTimerId = setInterval(()=>{
                    const elapsed = (Date.now() - tStart)/1000;
                    updateCountdownUI(Math.max(0, prepSec - elapsed));
                }, 200);

                // æ— æ¡ä»¶ç”Ÿæˆä¸€æ¬¡æ—‹å¾‹ï¼Œç¡®ä¿â€œç¬¦åˆå½“å‰è®¾ç½®â€çš„æ–°å†…å®¹
                if (typeof window.generateMelody === 'function') {
                    try { window.generateMelody(); } catch(e) {}
                }
                await ensureScoreReady();
                // åœ¨å‡†å¤‡é˜¶æ®µå†…ç­‰å¾…å°èŠ‚å°±ç»ªï¼ˆå¹¶æ ¡éªŒç¨³å®šæ€§ä¸é¢„æœŸæ•°é‡ï¼‰
                const rects = await waitForMeasuresReady(Math.max(1000, prepSec*1000));
                state.measureRects = rects;

                // åœ¨Count-Inå¯åŠ¨å‰ï¼Œå†æ¬¡ç”¨åŒå¸§å¤æ ¸ä¸€æ¬¡ï¼Œé¿å…OSMDæœ€åé˜¶æ®µçš„ç»†å¾®é‡æ’
                state.measureRects = await waitForStableMeasures(state.measureRects, 300);

                // å€’è®¡æ—¶èµ°å®Œ
                const nowMs = Date.now();
                const remainMs = Math.max(0, prepSec*1000 - (nowMs - tStart));
                await new Promise(r => setTimeout(r, remainMs));
                if (state.countdownTimerId) { clearInterval(state.countdownTimerId); state.countdownTimerId = null; }
                hideCountdownUI();

                if (!state.measureRects || !state.measureRects.length){
                    alert('æœªæ£€æµ‹åˆ°å°èŠ‚ï¼Œæ— æ³•å¯åŠ¨æŒ‘æˆ˜');
                    stopChallenge();
                    return;
                }

                // è®¡ç®—æ¯å°èŠ‚æ—¶é•¿ï¼ˆåŸºäºXMLæ‹å·ï¼Œç»Ÿä¸€äºcount-inèŠ‚æ‹ï¼‰
                state.measureDuration = parseMeasureDurationSec(bpm);
                
                // åˆ›å»ºè¦†ç›–å±‚å’Œå…‰æ ‡ï¼ˆæ”¾åœ¨measureRectså°±ç»ªåï¼‰
                ensureOverlay();

                // è§‚å¯Ÿè°±é¢å˜åŒ–ï¼ˆä¾‹å¦‚ç”¨æˆ·ç”Ÿæˆæ–°æ—‹å¾‹ã€SVGè¢«æ›¿æ¢ï¼‰ï¼Œä»…åœ¨é¡¶å±‚ svg è¢«æ›¿æ¢æ—¶åœæ­¢æŒ‘æˆ˜
                if (state.observer) { try { state.observer.disconnect(); } catch(_){} }
                state.activeSvg = scoreEl.querySelector('svg');
                state.observer = new MutationObserver(() => {
                    const currentSvg = scoreEl.querySelector('svg');
                    if (currentSvg !== state.activeSvg) {
                        stopChallenge();
                    }
                });
                state.observer.observe(scoreEl, { childList: true, subtree: false });

                // çª—å£å°ºå¯¸å˜åŒ–æ—¶ï¼Œç»“æŸæŒ‘æˆ˜ä»¥é¿å…é”™ä½
                state.resizeHandler = ()=> stopChallenge();
                window.addEventListener('resize', state.resizeHandler, { passive: true });

                // Count-Inï¼ˆå«å¼ºå¼±ï¼‰
                startCountIn(bpm);
            }

            function stopChallenge(){
                if (state.observer) { try { state.observer.disconnect(); } catch(_){} state.observer = null; }
                if (state.resizeHandler) { window.removeEventListener('resize', state.resizeHandler); state.resizeHandler = null; }
                if (state.countdownTimerId) { clearInterval(state.countdownTimerId); state.countdownTimerId = null; }
                if (state.countInTimerId) { clearInterval(state.countInTimerId); state.countInTimerId = null; }
                clearOverlay();
                hideCountdownUI();
                state.active = false;
                if (toggleEl){ toggleEl.checked = false; updateSwitcherVisual(); }
            }

            window.stopChallenge = stopChallenge;

            function onToggleChanged(){
                if (!toggleEl) return;
                updateSwitcherVisual();
                if (toggleEl.checked){
                    openChallengeModal();
                } else {
                    stopChallenge();
                }
            }

            if (toggleEl){
                toggleEl.addEventListener('change', onToggleChanged);
                // åˆå§‹åŒ–è§†è§‰
                updateSwitcherVisual();
            }

        })();
        */
    </script>

    <script>
        window.IC_MIDI_CONFIG = {
            getAudioContext: () => {
                if (!window.melodyAudioCtx) {
                    window.melodyAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (window.melodyAudioCtx && window.melodyAudioCtx.state === 'suspended') {
                    window.melodyAudioCtx.resume().catch(()=>{});
                }
                return window.melodyAudioCtx;
            },
            sampleRoot: 'assets/samples/piano-ogg-full',
            useSamplePlayer: true
        };
    </script>
    <script src="assets/js/midi-input.js?v=1"></script>

    <script defer src="/js/tool-access-loader.js?v=1.0.2"></script>
</body></html>
